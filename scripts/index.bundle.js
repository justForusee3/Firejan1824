/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@firebolt-js/sdk/dist/firebolt.js":
/*!********************************************************!*\
  !*** ./node_modules/@firebolt-js/sdk/dist/firebolt.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Accessibility: () => (/* binding */ __webpack_exports__Accessibility),
/* harmony export */   Account: () => (/* binding */ __webpack_exports__Account),
/* harmony export */   Advertising: () => (/* binding */ __webpack_exports__Advertising),
/* harmony export */   Authentication: () => (/* binding */ __webpack_exports__Authentication),
/* harmony export */   Device: () => (/* binding */ __webpack_exports__Device),
/* harmony export */   Discovery: () => (/* binding */ __webpack_exports__Discovery),
/* harmony export */   Events: () => (/* binding */ __webpack_exports__Events),
/* harmony export */   Keyboard: () => (/* binding */ __webpack_exports__Keyboard),
/* harmony export */   Lifecycle: () => (/* binding */ __webpack_exports__Lifecycle),
/* harmony export */   Localization: () => (/* binding */ __webpack_exports__Localization),
/* harmony export */   Log: () => (/* binding */ __webpack_exports__Log),
/* harmony export */   Metrics: () => (/* binding */ __webpack_exports__Metrics),
/* harmony export */   Parameters: () => (/* binding */ __webpack_exports__Parameters),
/* harmony export */   Platform: () => (/* binding */ __webpack_exports__Platform),
/* harmony export */   Profile: () => (/* binding */ __webpack_exports__Profile),
/* harmony export */   SecondScreen: () => (/* binding */ __webpack_exports__SecondScreen),
/* harmony export */   Settings: () => (/* binding */ __webpack_exports__Settings)
/* harmony export */ });
/******/ // The require scope
/******/ var __nested_webpack_require_43__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nested_webpack_require_43__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__nested_webpack_require_43__.o(definition, key) && !__nested_webpack_require_43__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nested_webpack_require_43__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/************************************************************************/
var __nested_webpack_exports__ = {};

// EXPORTS
__nested_webpack_require_43__.d(__nested_webpack_exports__, {
  "yq": () => (/* reexport */ Accessibility),
  "mR": () => (/* reexport */ Account),
  "ZL": () => (/* reexport */ Advertising),
  "Vy": () => (/* reexport */ Authentication),
  "AS": () => (/* reexport */ Device),
  "PG": () => (/* reexport */ Discovery),
  "zW": () => (/* reexport */ Events),
  "N1": () => (/* reexport */ Keyboard),
  "Fw": () => (/* reexport */ Lifecycle),
  "WH": () => (/* reexport */ Localization),
  "Zb": () => (/* reexport */ Log),
  "C3": () => (/* reexport */ Metrics),
  "aE": () => (/* reexport */ Parameters),
  "t4": () => (/* reexport */ Platform),
  "NZ": () => (/* reexport */ Profile),
  "_F": () => (/* reexport */ SecondScreen),
  "Zr": () => (/* reexport */ Settings)
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Prop/MockProps.js


const mocks = {}

function mock(module, method, args, def) {
  const fullMethod = `${module}.${method}`
  if ((args == null) || (args.length === 0)) {
    // get
    const rv = mocks[fullMethod] && mocks[fullMethod].value ? mocks[fullMethod].value : def
    return rv
  } else {
    // set
    let mockMethod = mocks[fullMethod]
    if (mockMethod == null) {
      mockMethod = {
        subscribers: []
      }
    }
    mocks[fullMethod] = mockMethod
    mockMethod.value = args[0].value
    Transport_mock.event(module, method + 'Changed', {
      value: args[0].value
    })
    return {}
  }
}

/* harmony default export */ const MockProps = ({
  mock: mock
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Accessibility/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const defaults = ({

    closedCaptions: {
  "enabled": true,
  "styles": {
    "fontFamily": "Monospace sans-serif",
    "fontSize": 1,
    "fontColor": "#ffffff",
    "fontEdge": "none",
    "fontEdgeColor": "#7F7F7F",
    "fontOpacity": 100,
    "backgroundColor": "#000000",
    "backgroundOpacity": 100,
    "textAlign": "center",
    "textAlignVertical": "middle"
  }
},

    closedCaptionsSettings: function () { return MockProps.mock('accessibility', 'closedCaptionsSettings', arguments, {
  "enabled": true,
  "styles": {
    "fontFamily": "Monospace sans-serif",
    "fontSize": 1,
    "fontColor": "#ffffff",
    "fontEdge": "none",
    "fontEdgeColor": "#7F7F7F",
    "fontOpacity": 100,
    "backgroundColor": "#000000",
    "backgroundOpacity": 100,
    "textAlign": "center",
    "textAlignVertical": "middle"
  }
}) },

    voiceGuidance: {
  "enabled": true,
  "speed": 5
},

    voiceGuidanceSettings: function () { return MockProps.mock('accessibility', 'voiceGuidanceSettings', arguments, {
  "enabled": true,
  "speed": 5
}) }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Account/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Account_defaults = ({

    id: function () { return MockProps.mock('account', 'id', arguments, "123") },

    uid: function () { return MockProps.mock('account', 'uid', arguments, "ee6723b8-7ab3-462c-8d93-dbf61227998e") }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Advertising/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Advertising_defaults = ({

    config: {
  "adServerUrl": "http://demo.v.fwmrm.net/ad/p/1",
  "adServerUrlTemplate": "http://demo.v.fwmrm.net/ad/p/1?flag=+sltp+exvt+slcb+emcr+amcb+aeti&prof=12345:caf_allinone_profile &nw=12345&mode=live&vdur=123&caid=a110523018&asnw=372464&csid=gmott_ios_tablet_watch_live_ESPNU&ssnw=372464&vip=198.205.92.1&resp=vmap1&metr=1031&pvrn=12345&vprn=12345&vcid=1X0Ce7L3xRWlTeNhc7br8Q%3D%3D",
  "adNetworkId": "519178",
  "adProfileId": "12345:caf_allinone_profile",
  "adSiteSectionId": "caf_allinone_profile_section",
  "adOptOut": true,
  "privacyData": "ew0KICAicGR0IjogImdkcDp2MSIsDQogICJ1c19wcml2YWN5IjogIjEtTi0iLA0KICAibG10IjogIjEiIA0KfQ0K",
  "ifaValue": "01234567-89AB-CDEF-GH01-23456789ABCD",
  "ifa": "ewogICJ2YWx1ZSI6ICIwMTIzNDU2Ny04OUFCLUNERUYtR0gwMS0yMzQ1Njc4OUFCQ0QiLAogICJpZmFfdHlwZSI6ICJzc3BpZCIsCiAgImxtdCI6ICIwIgp9Cg==",
  "appName": "FutureToday",
  "appBundleId": "FutureToday.comcast",
  "distributorAppId": "1001",
  "deviceAdAttributes": "ewogICJib0F0dHJpYnV0ZXNGb3JSZXZTaGFyZUlkIjogIjEyMzQiCn0=",
  "coppa": 0,
  "authenticationEntity": "60f72475281cfba3852413bd53e957f6"
},

    policy: function () { return MockProps.mock('advertising', 'policy', arguments, {
  "skipRestriction": "adsUnwatched",
  "limitAdTracking": false
}) },

    advertisingId: {
  "ifa": "01234567-89AB-CDEF-GH01-23456789ABCD",
  "ifa_type": "idfa",
  "lmt": "0"
},

    deviceAttributes: {},

    appBundleId: "operator.app"
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Authentication/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Authentication_defaults = ({

    token: {
  "value": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
  "expires": "2022-04-23T18:25:43.511Z",
  "type": "platform"
}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Device/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Device_defaults = ({

    id: function () { return MockProps.mock('device', 'id', arguments, "123") },

    distributor: function () { return MockProps.mock('device', 'distributor', arguments, "Company") },

    platform: function () { return MockProps.mock('device', 'platform', arguments, "WPE") },

    uid: function () { return MockProps.mock('device', 'uid', arguments, "ee6723b8-7ab3-462c-8d93-dbf61227998e") },

    type: function () { return MockProps.mock('device', 'type', arguments, "STB") },

    model: function () { return MockProps.mock('device', 'model', arguments, "xi6") },

    sku: function () { return MockProps.mock('device', 'sku', arguments, "AX061AEI") },

    make: function () { return MockProps.mock('device', 'make', arguments, "Arris") },

    version: function () { return MockProps.mock('device', 'version', arguments, {
  "sdk": {
    "major": 0,
    "minor": 5,
    "patch": 0,
    "readable": "Firebolt JS SDK v0.5.0"
  },
  "os": {
    "major": 0,
    "minor": 1,
    "patch": 0,
    "readable": "Firebolt OS v0.1.0"
  },
  "debug": ""
}) },

    hdcp: function () { return MockProps.mock('device', 'hdcp', arguments, {
  "hdcp1.4": true,
  "hdcp2.2": true
}) },

    hdr: function () { return MockProps.mock('device', 'hdr', arguments, {
  "hdr10": true,
  "hdr10Plus": true,
  "dolbyVision": true,
  "hlg": true
}) },

    audio: function () { return MockProps.mock('device', 'audio', arguments, {
  "stereo": true,
  "dolbyDigital5.1": true,
  "dolbyDigital5.1+": true,
  "dolbyAtmos": true
}) },

    screenResolution: function () { return MockProps.mock('device', 'screenResolution', arguments, [
  1920,
  1080
]) },

    videoResolution: function () { return MockProps.mock('device', 'videoResolution', arguments, [
  1920,
  1080
]) },

    name: function () { return MockProps.mock('device', 'name', arguments, "Living Room") },

    network: function () { return MockProps.mock('device', 'network', arguments, {
  "state": "connected",
  "type": "wifi"
}) }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Discovery/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Discovery_defaults = ({

    policy: function () { return MockProps.mock('discovery', 'policy', arguments, {
  "enableRecommendations": true,
  "shareWatchHistory": true,
  "rememberWatchedPrograms": true
}) },

    entityInfo: true,

    purchasedContent: true,

    watched: true,

    watchNext: true,

    entitlements: true,

    launch: true,

    signIn: true,

    signOut: true
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Keyboard/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Keyboard_defaults = ({

    email: "user@domain.com",

    password: "abc123",

    standard: "Living Room"
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/global.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

let g

if (typeof self !== 'undefined') {
	g = self;
} else if (typeof window !== 'undefined') {
	g = window;
} else {
	g = Function('return this')();
} 

const global = g

/* harmony default export */ const Transport_global = (global);
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Lifecycle/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */





let inactive = {"state":"inactive","previous":"initializing"}
let foreground = {"state":"foreground","previous":"inactive"}
let background = {"state":"background","previous":"foreground"}
let suspended = {"state":"suspended","previous":"inactive"}
let unloading = {"state":"unloading","previous":"inactive"}

const emit = (value) => {
  value.previous = Lifecycle.state()
  Transport_mock.event('Lifecycle', value.state, value)
}

const automation = Transport_global && Transport_global.__firebolt ? !!Transport_global.__firebolt.automation : false

/* harmony default export */ const Lifecycle_defaults = ({
  ready: function() {
    inactive.previous = 'initializing'
    setTimeout(() => emit(inactive), automation ? 1 : 500)
    foreground.previous = 'inactive'
    setTimeout(() => emit(foreground), automation ? 2 : 1000)
  },

  close: function(params) {
    let reason = params.reason
    if (reason === Lifecycle.CloseReason.REMOTE_BUTTON) {
      setTimeout(() => emit(inactive), automation ? 1 : 500)
    }
    else if (Object.values(Lifecycle.CloseReason).includes(reason)) {
      setTimeout(() => emit(inactive), automation ? 1 : 500)
      setTimeout(() => emit(unloading), automation ? 2 : 1000)
      setTimeout(() => Lifecycle.finished(), automation ? 3: 3000)
    }
    else {
      throw "Invalid close reason"
    }
  },

  finished: function() {
    if (Transport_global.location)
      Transport_global.location.href = "about:blank"
  },
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Localization/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Localization_defaults = ({

    locality: "Philadelphia",

    postalCode: "19103",

    countryCode: "US",

    language: function () { return MockProps.mock('localization', 'language', arguments, "en") },

    locale: "en-US",

    latlon: [
  39.9549,
  75.1699
],

    additionalInfo: {}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Metrics/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Metrics_defaults = ({

    ready: true,

    signIn: true,

    signOut: true,

    startContent: true,

    stopContent: true,

    page: true,

    action: true,

    error: true,

    mediaLoadStart: true,

    mediaPlay: true,

    mediaPlaying: true,

    mediaPause: true,

    mediaWaiting: true,

    mediaProgress: true,

    mediaSeeking: true,

    mediaSeeked: true,

    mediaRateChange: true,

    mediaRenditionChange: true,

    mediaEnded: true
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Parameters/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Parameters_defaults = ({

    initialization: {
  "lmt": 0,
  "us_privacy": "1-Y-",
  "discovery": {
    "navigateTo": {
      "action": "entity",
      "data": {
        "entityId": "abc",
        "entityType": "program",
        "programType": "movie"
      },
      "context": {
        "source": "voice"
      }
    }
  }
}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Profile/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Profile_defaults = ({

    approveContentRating: false,

    approvePurchase: false,

    flags: {
  "userExperience": "1000"
}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/SecondScreen/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const SecondScreen_defaults = ({

    protocols: {
  "dial1.7": true
},

    device: "device-id",

    friendlyName: function () { return MockProps.mock('secondscreen', 'friendlyName', arguments, "Living Room") }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Platform/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */





/* harmony default export */ const Platform_defaults = ({
  localization: Localization_defaults,
  device: Device_defaults,
  accessibility: defaults,
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/mock.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



















let listener
const setMockListener = func => { listener = func }

let mock_mock = {
  accessibility: defaults,
  account: Account_defaults,
  advertising: Advertising_defaults,
  authentication: Authentication_defaults,
  device: Device_defaults,
  discovery: Discovery_defaults,
  keyboard: Keyboard_defaults,
  lifecycle: Lifecycle_defaults,
  localization: Localization_defaults,
  metrics: Metrics_defaults,
  parameters: Parameters_defaults,
  profile: Profile_defaults,
  secondscreen: SecondScreen_defaults,
  platform: Platform_defaults,
}

let callback
let testHarness

if (Transport_global.__firebolt && Transport_global.__firebolt.testHarness) {
  testHarness = Transport_global.__firebolt.testHarness
}

function send(message) {
  let json = JSON.parse(message)
  let [module, method] = json.method.split('.')

  if (testHarness && testHarness.onSend) {
    testHarness.onSend(module, method, json.params, json.id)
  }

  // store the ID of the first listen for each event
  // TODO: what about wild cards?
  let result
  try {
    result = getResult(json.method, json.params)
  }
  catch (error) {
    setTimeout(() => callback(JSON.stringify({ 
      jsonrpc: '2.0',
      error: {
        code: -32602,
        message: "Invalid params (this is a mock error from the mock transport layer)"
      },
      id: json.id
    })))
  }

  setTimeout(() => callback(JSON.stringify({ 
    jsonrpc: '2.0',
    result: result,
    id: json.id
  })))
}

function receive(_callback) {
  callback = _callback

  if (testHarness && (typeof testHarness.initialize === 'function')) {
    testHarness.initialize({
      emit: mock_event,
      listen: function(...args) { listener(...args) },
    })
  }
}

function mock_event(module, event, value) {
  const listener = Object.entries(Transport.getEventMap()).find(([k, v]) => v.toLowerCase() === module.toLowerCase() + '.' + event.toLowerCase())
  if (listener) {
    let message = JSON.stringify({
      jsonrpc: '2.0',
      id: listener[0],
      result: value
    })
    callback(message)
  }
}

function dotGrab(obj = {}, key) {
  const keys = key.split('.')
  let ref = obj
  for (let i = 0; i < keys.length; i++) {
    ref = ref[keys[i]] || {}
  }
  return ref
}

function getResult(method, params) {
  let api = dotGrab(mock_mock, method)

  if (method.match(/^[a-zA-Z]+\.on[A-Za-z]+$/)) {
    api = {
      event: method,
      listening: true
    }
  }

  if (typeof api === 'function') {
    return params == null ? api() : api(params)
  } else return api
}

/* harmony default export */ const Transport_mock = ({
  send: send,
  receive: receive,
  event: mock_event
});


;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/queue.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

class Queue {
  constructor () {
    this._callback = null
    this._queue = []
  }

  send (json) {
    this._queue.push(json)
  }

  receive (_callback) {
    this._callback = _callback
  }

  flush (transport) {
    transport.receive(this._callback)
    this._queue.forEach(item => transport.send(item))
  }
}

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Settings/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

const settings = {}
const subscribers = {}

const initSettings = (appSettings, platformSettings) => {
  settings['app'] = appSettings
  settings['platform'] = {
    logLevel: 'WARN',
    ...platformSettings
  }
  settings['user'] = {}
}

const publish = (key, value) => {
  subscribers[key] && subscribers[key].forEach(subscriber => subscriber(value))
}

const Settings_dotGrab = (obj = {}, key) => {
  const keys = key.split('.')
  for (let i = 0; i < keys.length; i++) {
    obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {}
  }
  return typeof obj === 'object' ? (Object.keys(obj).length ? obj : undefined) : obj
}

/* harmony default export */ const Settings = ({
  get(type, key, fallback = undefined) {
    const val = Settings_dotGrab(settings[type], key)
    return val !== undefined ? val : fallback
  },
  has(type, key) {
    return !!this.get(type, key)
  },
  set(key, value) {
    settings['user'][key] = value
    publish(key, value)
  },
  subscribe(key, callback) {
    subscribers[key] = subscribers[key] || []
    subscribers[key].push(callback)
  },
  unsubscribe(key, callback) {
    if (callback) {
      const index = subscribers[key] && subscribers[key].findIndex(cb => cb === callback)
      index > -1 && subscribers[key].splice(index, 1)
    } else {
      if (key in subscribers) {
        subscribers[key] = []
      }
    }
  },
  clearSubscribers() {
    for (const key of Object.getOwnPropertyNames(subscribers)) {
      delete subscribers[key]
    }
  },
  setLogLevel (logLevel) {
    settings.platform.logLevel = logLevel
  },
  getLogLevel () {
    return settings.platform.logLevel
  }
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/LegacyTransport.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

class LegacyTransport {
  constructor (bridge) {
    this.bridge = bridge
  }

  send (msg) {
    this.bridge.JSMessageChanged(msg, () => {})
  }

  receive (callback) {
    window.$badger = window.$badger || {}
    /** Hold on to real $badger callback and event methods so they can be called for non-jsonrpc messages */
    const badgerCallback = window.$badger.callback ? window.$badger.callback.bind(window.$badger) : null
    const badgerEvent = window.$badger.event ? window.$badger.event.bind(window.$badger) : null
    window.$badger.callback = (pid, success, json) => {
      if (json.jsonrpc) {
        callback(JSON.stringify(json))
      } else if (badgerCallback) {
        badgerCallback(pid, success, json)
      }
    }
    window.$badger.event = (handlerId, json) => {
      if (json.jsonrpc) {
        callback(JSON.stringify(json))
      } else if (badgerEvent) {
        badgerEvent(handlerId, json)
      }
    }
  }

  static isLegacy (transport) {
    return LegacyTransport.isXREProxy(transport) || ((transport.send === undefined) && (transport.JSMessageChanged))
  }

  static isXREProxy (transport) {
    /** Set top boxes running XRE has a "Proxy" transport
     * native object that intercepts ALL method calls, so we
     * cannot test for transport.send existence because it will return true
     * even though it actually is not supported. Check if some obscure method
     * name like "proxyObjectTest" is defined. If it is then we know we are using a
     * Proxy object and thus is legacy transport.
     */
    return transport.proxyObjectTest !== undefined
  }
}

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/WebsocketTransport.js
const MAX_QUEUED_MESSAGES = 100

class WebsocketTransport {
  constructor (endpoint) {
    this._endpoint = endpoint
    this._ws = null
    this._connected = false
    this._queue = []
    this._callbacks = []
  }

  send (msg) {
    this._connect()

    if (this._connected) {
      this._ws.send(msg)
    } else {
      if (this._queue.length < MAX_QUEUED_MESSAGES) {
        this._queue.push(msg)
      }
    }
  }

  receive (callback) {
    if (!callback) return
    this._connect()
    this._callbacks.push(callback)
  }

  _notifyCallbacks (message) {
    for (let i = 0; i < this._callbacks.length; i++) {
      setTimeout(() => this._callbacks[i](message), 1)
    }
  }

  _connect () {
    if (this._ws) return
    this._ws = new WebSocket(this._endpoint)
    this._ws.addEventListener('message', message => {
      this._notifyCallbacks(message.data)
    })
    this._ws.addEventListener('error', message => {
    })
    this._ws.addEventListener('close', message => {
      this._ws = null
      this._connected = false
    })
    this._ws.addEventListener('open', message => {
      this._connected = true
      for (let i = 0; i < this._queue.length; i++) {
        this._ws.send(this._queue[i])
      }
      this._queue = []
    })
  }
}
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */








const LEGACY_TRANSPORT_SERVICE_NAME = 'com.comcast.BridgeObject_1'
let moduleInstance = null

const isEventSuccess = x => x && (typeof x.event === 'string') && (typeof x.listening === 'boolean')

class Transport {
  constructor () {
    this._promises = []
    this._transport = null
    this._id = 1
    this._eventEmitters = []
    this._eventMap = {}
    this._queue = new Queue()
    this._deprecated = {}
    this.isMock = false
  }

  static addEventEmitter (emitter) {
    Transport.get()._eventEmitters.push(emitter)
  }

  static registerDeprecatedMethod (module, method, alternative) {
    Transport.get()._deprecated[module.toLowerCase() + '.' + method.toLowerCase()] = {
      alternative: alternative || ''
    }
  }

  _endpoint () {
    if (Transport_global.__firebolt && Transport_global.__firebolt.endpoint) {
      return Transport_global.__firebolt.endpoint
    }
    return null
  }

  constructTransportLayer () {
    let transport
    const endpoint = this._endpoint()
    if (endpoint && (endpoint.startsWith('ws://') || endpoint.startsWith('wss://'))) {
      transport = new WebsocketTransport(endpoint)
      transport.receive(this.receiveHandler.bind(this))
    } else if (
      typeof Transport_global.ServiceManager !== 'undefined' &&
      Transport_global.ServiceManager &&
      Transport_global.ServiceManager.version
    ) {
      // Wire up the queue
      transport = this._queue
      // get the default bridge service, and flush the queue
      Transport_global.ServiceManager.getServiceForJavaScript(LEGACY_TRANSPORT_SERVICE_NAME, service => {
        if (LegacyTransport.isLegacy(service)) {
          transport = new LegacyTransport(service)
        } else {
          transport = service
        }
        this.setTransportLayer(transport)
      })
    } else {
      this.isMock = true
      transport = Transport_mock
      transport.receive(this.receiveHandler.bind(this))
    }
    return transport
  }

  setTransportLayer (tl) {
    this._transport = tl
    this._queue.flush(tl)
  }

  static send (module, method, params) {
    /** Transport singleton across all SDKs to keep single id map */
    return Transport.get()._send(module, method, params)
  }

  _send (module, method, params) {
    const p = new Promise((resolve, reject) => {
      this._promises[this._id] = {}
      this._promises[this._id].promise = this
      this._promises[this._id].resolve = resolve
      this._promises[this._id].reject = reject

      const deprecated = this._deprecated[module.toLowerCase() + '.' + method.toLowerCase()]
      if (deprecated) {
        console.warn(`WARNING: ${module}.${method}() is deprecated. ` + deprecated.alternative)
      }

      // store the ID of the first listen for each event
      // TODO: what about wild cards?
      if (method.match(/^on[A-Z]/)) {
        if (params.listen) {
          this._eventMap[this._id] = module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3)
        } else {
          Object.keys(this._eventMap).forEach(key => {
            if (this._eventMap[key] === module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3)) {
              delete this._eventMap[key]
            }
          })
        }
      }
    })

    const json = { jsonrpc: '2.0', method: module + '.' + method, params: params, id: this._id }
    this._id++

    const msg = JSON.stringify(json)
    if (Settings.getLogLevel() === 'DEBUG') {
      console.debug('Sending message to transport: ' + msg)
    }
    this._transport.send(msg)

    return p
  }

  static getEventMap () {
    return Transport.get()._eventMap
  }

  /**
   * If we have a global transport, use that. Otherwise, use the module-scoped transport instance.
   * @returns {Transport}
   */
  static get () {
    return Transport_global.__firebolt.transport ? Transport_global.__firebolt.transport : moduleInstance
  }

  receiveHandler (message) {
    if (Settings.getLogLevel() === 'DEBUG') {
      console.debug('Received message from transport: ' + message)
    }
    const json = JSON.parse(message)
    const p = this._promises[json.id]

    if (p) {
      if (json.error) p.reject(json.error)
      else {
        p.resolve(json.result)
      }
      delete this._promises[json.id]
    }

    // event responses need to be emitted, even after the listen call is resolved
    if (this._eventMap[json.id] && !isEventSuccess(json.result)) {
      const moduleevent = this._eventMap[json.id]
      if (moduleevent) {
        this._eventEmitters.forEach(emit => {
          emit(moduleevent.split('.')[0], moduleevent.split('.')[1], json.result)
        })
      }
    }
  }

  init () {
    initSettings({}, { log: true })
    this._queue.receive(this.receiveHandler.bind(this))
    if (Transport_global.__firebolt) {
      if (Transport_global.__firebolt.mockTransportLayer === true) {
        this.isMock = true
        this.setTransportLayer(Transport_mock)
      } else if (Transport_global.__firebolt.getTransportLayer) {
        this.setTransportLayer(Transport_global.__firebolt.getTransportLayer())
      }
    }
    if (this._transport == null) {
      this._transport = this.constructTransportLayer()
    }
  }
}

/** Set up singleton and initialize it */
Transport_global.__firebolt = Transport_global.__firebolt || {}
if ((Transport_global.__firebolt.transport == null) && (moduleInstance == null)) {
  const transport = new Transport()
  transport.init()
  if (transport.isMock) {
    /** We should use the mock transport built with the SDK, not a global */
    moduleInstance = transport
  } else {
    Transport_global.__firebolt = Transport_global.__firebolt || {}
    Transport_global.__firebolt.transport = transport
  }
  Transport_global.__firebolt.setTransportLayer = transport.setTransportLayer.bind(transport)
}

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Events/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */




let listenerId = 0

// holds a map of ${module}.${event} => listenerId, e.g. callback method id
// note that one callback can listen to multiple events, e.g. 'discovery.*'
const listeners = {}

// holds a map of ${module}.${event} => Transport.send calls (only called once per event)
// note that the keys here MUST NOT contain wild cards
const enabledEvents = {}

const oncers = []
const validEvents = {}
let transportInitialized = false

const Events_emit = (module, event, value) => {
  callCallbacks(listeners[module + '.*'], [event, value])
  callCallbacks(listeners[module + '.' + event], [value])
}

const registerEvents = (module, events) => {
  validEvents[module.toLowerCase()] = events.concat()
}

const callCallbacks = (cbs, args) => {
  cbs &&
    Object.keys(cbs).forEach(listenerId => {
      let callback = cbs[listenerId]
      if (oncers.indexOf(parseInt(listenerId)) >= 0) {
        oncers.splice(oncers.indexOf(parseInt(listenerId)), 1)
        delete cbs[listenerId]
      }
      callback.apply(null, args)
    })
}

const doListen = function(module, event, callback, once) {
  if (typeof callback !== 'function') {
    return Promise.reject('No valid callback function provided.')
  } else {
    if (module === '*') {
      return Promise.reject('No valid module name provided')
    }

    let events = (event === '*' ? validEvents[module] : [event]) // explodes wildcards into an array
    let promises = []
    const key = module + '.' + event // this might be a wildcard, e.g. 'lifecycle.*'
    listenerId++
    listeners[key] = listeners[key] || {}
    listeners[key][''+listenerId] = callback

    if (once) {
      oncers.push(listenerId)
    }

    events.forEach(event => {
      // Check each event, and only turn on events (not wildcards) that are off
      if (!enabledEvents[module + '.' + event]) {
        promises.push(
          Transport.send(module, 'on' + event[0].toUpperCase() + event.substr(1), { listen: true })
        )
        enabledEvents[module + '.' + event] = true
      }
    })

    let resolve, reject
    let p = new Promise((res, rej) => {
      resolve = res
      reject = rej
    })

    if (promises.length) {
      Promise.all(promises).then(responses => {
        resolve(listenerId)
      }).catch(error => {
        // Promise.all rejects if at least one promise rejects... we don't want that behavior here
        // TODO: Do something better than fail silently
        if (event === '*') {
          resolve(listenerId)
        }
        else {
          reject(error)
        }
      })
    }
    else {
      resolve(listenerId)
    }

    return p
  }
}

const getListenArgs = function(...args) {
  const callback = args.pop()
  const module = args[0].toLowerCase() || '*'
  const event = args[1] || '*'
  return [module, event, callback]
}

const once = function(...args) {
  const [module, event, callback] = getListenArgs(...args)
  return doListen(module, event, callback, true)
}

const listen = function(...args) {
  init()
  const [module, event, callback] = getListenArgs(...args)
  return doListen(module, event, callback, false)
}

const init = () => {
  if (!transportInitialized) {
    Transport.addEventEmitter(Events_emit)
    setMockListener(listen)
    transportInitialized = true
  }
}

/* harmony default export */ const Events = ({
  listen: listen,
  once: once,
  // TODO: clear needs to go through Transport Layer
  clear(moduleOrId = false, event = false) {
    if (typeof moduleOrId === 'number') {
      const searchId = moduleOrId.toString()
      Object.keys(listeners).every(key => {
        if (listeners[key][searchId]) {
          // delete callback
          delete listeners[key][searchId]
          // delete the whole namespace if it was the only callback
          if (Object.keys(listeners[key]).length === 0) {
            delete listeners[key]
          }
          return false
        }
        return true
      })
    } else {
      if (!moduleOrId && !event) {
        Object.keys(listeners).forEach(key => {
          delete listeners[key]
        })
      } else if (!event) {
        Object.keys(listeners).forEach(key => {
          if (key.indexOf(moduleOrId.toLowerCase()) === 0) {
            delete listeners[key]
          }
        })
      } else {
        delete listeners[moduleOrId + '.' + event]
      }
    }
  },
  broadcast(event, value) {
    Events_emit('app', event, value)
  },
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Prop/index.js



function prop(moduleName, key, args, immutable, readonly) {
  if (args.length === 0) {
    // getter
    return Transport.send(moduleName, key)
  } else if (args.length === 1 && typeof args[0] === 'function') {
    // subscribe
    if (immutable) {
      throw new Error('Cannot subscribe to an immutable property')
    }
    return Events.listen(moduleName, key + 'Changed', args[0])
  } else {
    // setter
    if (immutable) {
      throw new Error('Cannot set a value to an immutable property')
    }
    if (readonly) {
      throw new Error('Cannot set a value to a readonly property')
    }
    return Transport.send(moduleName, key, {
      value: args[0]
    })
  }
}

/* harmony default export */ const Prop = ({
  prop: prop
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Accessibility/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Accessibility', Object.values(["closedCaptionsSettingsChanged","voiceGuidanceSettingsChanged"]))

Transport.registerDeprecatedMethod('Accessibility', 'closedCaptions', 'Use Accessibility.closedCaptionsSettings() instead.')
Transport.registerDeprecatedMethod('Accessibility', 'voiceGuidance', 'Use Accessibility.voiceGuidanceSettings() instead.')


function closedCaptions() {
  return Transport.send('accessibility', 'closedCaptions', {  })
}
function closedCaptionsSettings() {
  return Prop.prop('accessibility',  'closedCaptionsSettings', arguments, false, true)
}

function voiceGuidance() {
  return Transport.send('accessibility', 'voiceGuidance', {  })
}
function voiceGuidanceSettings() {
  return Prop.prop('accessibility',  'voiceGuidanceSettings', arguments, false, true)
}

function Accessibility_listen(...args) {
  return Events.listen('accessibility', ...args)
} 

function Accessibility_once(...args) {
  return Events.once('accessibility', ...args)
}

function clear(...args) {
  return Events.clear('accessibility', ...args)
}

/* harmony default export */ const Accessibility = ({

  events: {
    closedCaptionsSettingsChanged:'closedCaptionsSettingsChanged',
    voiceGuidanceSettingsChanged:'voiceGuidanceSettingsChanged'
  },
closedCaptions,
  closedCaptionsSettings,
  voiceGuidance,
  voiceGuidanceSettings,
  listen: Accessibility_listen,
  once: Accessibility_once,
  clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Account/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function id() {
  return Prop.prop('account',  'id', arguments, true, true)
}
function uid() {
  return Prop.prop('account',  'uid', arguments, true, true)
}

/* harmony default export */ const Account = ({

id,
  uid
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Advertising/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Advertising', Object.values(["policyChanged"]))



function config(options) {
  return Transport.send('advertising', 'config', { options })
}
function policy() {
  return Prop.prop('advertising',  'policy', arguments, false, true)
}

function advertisingId() {
  return Transport.send('advertising', 'advertisingId', {  })
}

function deviceAttributes() {
  return Transport.send('advertising', 'deviceAttributes', {  })
}

function appBundleId() {
  return Transport.send('advertising', 'appBundleId', {  })
}

function Advertising_listen(...args) {
  return Events.listen('advertising', ...args)
} 

function Advertising_once(...args) {
  return Events.once('advertising', ...args)
}

function Advertising_clear(...args) {
  return Events.clear('advertising', ...args)
}

/* harmony default export */ const Advertising = ({

  events: {
    policyChanged:'policyChanged'
  },

  SkipRestriction: {
    NONE: 'none',
    ADS_UNWATCHED: 'adsUnwatched',
    ADS_ALL: 'adsAll',
    ALL: 'all'
  },

config,
  policy,
  advertisingId,
  deviceAttributes,
  appBundleId,
  listen: Advertising_listen,
  once: Advertising_once,
  clear: Advertising_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Authentication/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function token(type, options) {
  return Transport.send('authentication', 'token', { type, options })
}

/* harmony default export */ const Authentication = ({


  TokenType: {
    PLATFORM: 'platform',
    DEVICE: 'device',
    DISTRIBUTOR: 'distributor'
  },

token
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Device/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Device', Object.values(["deviceNameChanged","hdcpChanged","hdrChanged","audioChanged","screenResolutionChanged","videoResolutionChanged","nameChanged","networkChanged"]))

Transport.registerDeprecatedMethod('Device', 'onDeviceNameChanged', 'Use Device.name() instead.')

function version() {
  return new Promise( (resolve, reject) => {
      Transport.send('device', 'version').then( v => {
          v = v || {}
          v.sdk = v.sdk || {}
          v.sdk.major = parseInt('0')
          v.sdk.minor = parseInt('6')
          v.sdk.patch = parseInt('0')
          v.sdk.readable = 'The Firebolt JS SDK'
          resolve(v)    
      }).catch(error => {
          reject(error)
      })
  })
}

function Device_id() {
  return Prop.prop('device',  'id', arguments, true, true)
}
function distributor() {
  return Prop.prop('device',  'distributor', arguments, true, true)
}
function platform() {
  return Prop.prop('device',  'platform', arguments, true, true)
}
function Device_uid() {
  return Prop.prop('device',  'uid', arguments, true, true)
}
function type() {
  return Prop.prop('device',  'type', arguments, true, true)
}
function model() {
  return Prop.prop('device',  'model', arguments, true, true)
}
function sku() {
  return Prop.prop('device',  'sku', arguments, true, true)
}
function make() {
  return Prop.prop('device',  'make', arguments, true, true)
}
function hdcp() {
  return Prop.prop('device',  'hdcp', arguments, false, true)
}
function hdr() {
  return Prop.prop('device',  'hdr', arguments, false, true)
}
function audio() {
  return Prop.prop('device',  'audio', arguments, false, true)
}
function screenResolution() {
  return Prop.prop('device',  'screenResolution', arguments, false, true)
}
function videoResolution() {
  return Prop.prop('device',  'videoResolution', arguments, false, true)
}
function Device_name() {
  return Prop.prop('device',  'name', arguments, false, true)
}
function network() {
  return Prop.prop('device',  'network', arguments, false, true)
}

function Device_listen(...args) {
  return Events.listen('device', ...args)
} 

function Device_once(...args) {
  return Events.once('device', ...args)
}

function Device_clear(...args) {
  return Events.clear('device', ...args)
}

/* harmony default export */ const Device = ({

  events: {
    deviceNameChanged:'deviceNameChanged',
    hdcpChanged:'hdcpChanged',
    hdrChanged:'hdrChanged',
    audioChanged:'audioChanged',
    screenResolutionChanged:'screenResolutionChanged',
    videoResolutionChanged:'videoResolutionChanged',
    nameChanged:'nameChanged',
    networkChanged:'networkChanged'
  },

  NetworkType: {
    WIFI: 'wifi',
    ETHERNET: 'ethernet',
    HYBRID: 'hybrid'
  },


  NetworkState: {
    CONNECTED: 'connected',
    DISCONNECTED: 'disconnected'
  },


  AudioProfile: {
    STEREO: 'stereo',
    DOLBY_DIGITAL_5_1: 'dolbyDigital5.1',
    DOLBY_DIGITAL_7_1: 'dolbyDigital7.1',
    DOLBY_DIGITAL_5_1_PLUS: 'dolbyDigital5.1+',
    DOLBY_DIGITAL_7_1_PLUS: 'dolbyDigital7.1+',
    DOLBY_ATMOS: 'dolbyAtmos'
  },


  version,
id: Device_id,
  distributor,
  platform,
  uid: Device_uid,
  type,
  model,
  sku,
  make,
  hdcp,
  hdr,
  audio,
  screenResolution,
  videoResolution,
  name: Device_name,
  network,
  listen: Device_listen,
  once: Device_once,
  clear: Device_clear
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Metrics/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function ready() {
  return Transport.send('metrics', 'ready', {})
}

function signIn() {
  return Transport.send('metrics', 'signIn', {})
}

function signOut() {
  return Transport.send('metrics', 'signOut', {})
}



function startContent(entityId) {
  return Transport.send('metrics', 'startContent', { entityId })
}

function stopContent(entityId) {
  return Transport.send('metrics', 'stopContent', { entityId })
}

function page(pageId) {
  return Transport.send('metrics', 'page', { pageId })
}

function action(category, type, parameters) {
  return Transport.send('metrics', 'action', { category, type, parameters })
}

function error(type, code, description, visible, parameters) {
  return Transport.send('metrics', 'error', { type, code, description, visible, parameters })
}

function mediaLoadStart(entityId) {
  return Transport.send('metrics', 'mediaLoadStart', { entityId })
}

function mediaPlay(entityId) {
  return Transport.send('metrics', 'mediaPlay', { entityId })
}

function mediaPlaying(entityId) {
  return Transport.send('metrics', 'mediaPlaying', { entityId })
}

function mediaPause(entityId) {
  return Transport.send('metrics', 'mediaPause', { entityId })
}

function mediaWaiting(entityId) {
  return Transport.send('metrics', 'mediaWaiting', { entityId })
}

function mediaProgress(entityId, progress) {
  return Transport.send('metrics', 'mediaProgress', { entityId, progress })
}

function mediaSeeking(entityId, target) {
  return Transport.send('metrics', 'mediaSeeking', { entityId, target })
}

function mediaSeeked(entityId, position) {
  return Transport.send('metrics', 'mediaSeeked', { entityId, position })
}

function mediaRateChange(entityId, rate) {
  return Transport.send('metrics', 'mediaRateChange', { entityId, rate })
}

function mediaRenditionChange(entityId, bitrate, width, height, profile) {
  return Transport.send('metrics', 'mediaRenditionChange', { entityId, bitrate, width, height, profile })
}

function mediaEnded(entityId) {
  return Transport.send('metrics', 'mediaEnded', { entityId })
}

/* harmony default export */ const Metrics = ({


  ErrorType: {
    NETWORK: 'network',
    MEDIA: 'media',
    RESTRICTION: 'restriction',
    ENTITLEMENT: 'entitlement',
    OTHER: 'other'
  },

startContent,
  stopContent,
  page,
  action,
  error,
  mediaLoadStart,
  mediaPlay,
  mediaPlaying,
  mediaPause,
  mediaWaiting,
  mediaProgress,
  mediaSeeking,
  mediaSeeked,
  mediaRateChange,
  mediaRenditionChange,
  mediaEnded
});


;// CONCATENATED MODULE: ./build/sdk/javascript/src/Discovery/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Discovery', Object.values(["navigateTo","policyChanged"]))


function Discovery_policy() {
  return Prop.prop('discovery',  'policy', arguments, false, true)
}

let entityInfoHasCallback = false

function entityInfo (data) {
  if (arguments.length === 1 && typeof arguments[0] === 'function') {
    if (entityInfoHasCallback) {
      return Promise.reject('Cannot register more than one entityInfo handler.')
    }

    const callback = arguments[0]
    entityInfoHasCallback = true
    return Events.listen('discovery', 'pullEntityInfo', (request) => {
      if (typeof request === 'boolean') return

      try {
        const result = callback(request.parameters).then(result => {
          const params = {
            correlationId: request.correlationId,
            result: result
          }
          Transport.send('discovery', 'entityInfo', params).catch(error => {
            const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
            InternalMetrics.sdk.error(`Failed to send entityInfo pull response through Transport Layer: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
          })
        }).catch(error => {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
          InternalMetrics.sdk.error(`App 'entityInfo' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
        })
      }
      catch (error) {
        const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
        InternalMetrics.sdk.error(`App 'entityInfo' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
    }
    })
  }
  else {
    return Transport.send('discovery', 'entityInfo', { data })
  }
}

let purchasedContentHasCallback = false

function purchasedContent (data) {
  if (arguments.length === 1 && typeof arguments[0] === 'function') {
    if (purchasedContentHasCallback) {
      return Promise.reject('Cannot register more than one purchasedContent handler.')
    }

    const callback = arguments[0]
    purchasedContentHasCallback = true
    return Events.listen('discovery', 'pullPurchasedContent', (request) => {
      if (typeof request === 'boolean') return

      try {
        const result = callback(request.parameters).then(result => {
          const params = {
            correlationId: request.correlationId,
            result: result
          }
          Transport.send('discovery', 'purchasedContent', params).catch(error => {
            const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
            InternalMetrics.sdk.error(`Failed to send purchasedContent pull response through Transport Layer: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
          })
        }).catch(error => {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
          InternalMetrics.sdk.error(`App 'purchasedContent' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
        })
      }
      catch (error) {
        const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
        InternalMetrics.sdk.error(`App 'purchasedContent' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
    }
    })
  }
  else {
    return Transport.send('discovery', 'purchasedContent', { data })
  }
}

function watched(entityId, progress, completed, watchedOn) {
  if (arguments.length === 1 && Array.isArray(arguments[0])) {
    return Transport.send('discovery', 'watched', arguments[0])
  }
  else {
    return Transport.send('discovery', 'watched', { entityId, progress, completed, watchedOn })
  }
}

function watchNext(title, identifiers, expires, images) {
  return Transport.send('discovery', 'watchNext', { title, identifiers, expires, images })
}

function entitlements(entitlements) {
  return Transport.send('discovery', 'entitlements', { entitlements })
}

function launch(appId, intent) {
  return Transport.send('discovery', 'launch', { appId, intent })
}



function Discovery_signIn(entitlements) {
    const p = Transport.send('discovery', 'signIn', { entitlements })
    
    p.then(_ => {
        setTimeout(_ => {
            signIn(entitlements)
        })    
    })

    return p
}



function Discovery_signOut() {
    const p = Transport.send('discovery', 'signOut', {  })
    
    p.then(_ => {
        setTimeout(_ => {
            signOut()
        })    
    })

    return p
}

function Discovery_listen(...args) {
  return Events.listen('discovery', ...args)
} 

function Discovery_once(...args) {
  return Events.once('discovery', ...args)
}

function Discovery_clear(...args) {
  return Events.clear('discovery', ...args)
}

/* harmony default export */ const Discovery = ({

  events: {
    navigateTo:'navigateTo',
    policyChanged:'policyChanged'
  },
policy: Discovery_policy,
  entityInfo,
  purchasedContent,
  watched,
  watchNext,
  entitlements,
  launch,
  signIn: Discovery_signIn,
  signOut: Discovery_signOut,
  listen: Discovery_listen,
  once: Discovery_once,
  clear: Discovery_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Keyboard/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function email(type, message) {
  return Transport.send('keyboard', 'email', { type, message })
}

function Keyboard_password(message) {
  return Transport.send('keyboard', 'password', { message })
}

function standard(message) {
  return Transport.send('keyboard', 'standard', { message })
}

/* harmony default export */ const Keyboard = ({


  EmailUsage: {
    SIGN_IN: 'signIn',
    SIGN_UP: 'signUp'
  },

email,
  password: Keyboard_password,
  standard
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Lifecycle/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






registerEvents('Lifecycle', Object.values(["inactive","foreground","background","suspended","unloading"]))


const store = {
  _current: 'initializing',
  get current() {
    return this._current
  }
}

Events.listen('Lifecycle', (event, value) => {
  store._current = event
})


;

function Lifecycle_ready() {
    const p = Transport.send('lifecycle', 'ready', {  })
    
    p.then(_ => {
        setTimeout(_ => {
            ready()
        })    
    })

    return p
}

function Lifecycle_close(reason) {
  return Transport.send('lifecycle', 'close', { reason })
}

function Lifecycle_listen(...args) {
  return Events.listen('lifecycle', ...args)
} 

function Lifecycle_once(...args) {
  return Events.once('lifecycle', ...args)
}

function Lifecycle_clear(...args) {
  return Events.clear('lifecycle', ...args)
}

function state() {
  return store.current
}

function finished() {
  if (store.current === 'unloading') {
    return Transport.send('lifecycle', 'finished')
  } else {
    throw 'Cannot call finished() except when in the unloading transition'
  }
}

// public API
/* harmony default export */ const Lifecycle = ({

  events: {
    inactive:'inactive',
    foreground:'foreground',
    background:'background',
    suspended:'suspended',
    unloading:'unloading'
  },


  LifecycleState: {
    INITIALIZING: 'initializing',
    INACTIVE: 'inactive',
    BACKGROUND: 'background',
    FOREGROUND: 'foreground',
    SUSPENDED: 'suspended',
    UNLOADING: 'unloading'
  },


  CloseReason: {
    REMOTE_BUTTON: 'remoteButton',
    USER_EXIT: 'userExit',
    ERROR: 'error'
  },


  state,
  finished,

ready: Lifecycle_ready,
  close: Lifecycle_close,
  listen: Lifecycle_listen,
  once: Lifecycle_once,
  clear: Lifecycle_clear  
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Localization/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Localization', Object.values(["languageChanged"]))



function locality() {
  return Transport.send('localization', 'locality', {  })
}

function postalCode() {
  return Transport.send('localization', 'postalCode', {  })
}

function countryCode() {
  return Transport.send('localization', 'countryCode', {  })
}
function language() {
  return Prop.prop('localization',  'language', arguments, false, true)
}

function locale() {
  return Transport.send('localization', 'locale', {  })
}

function latlon() {
  return Transport.send('localization', 'latlon', {  })
}

function additionalInfo() {
  return Transport.send('localization', 'additionalInfo', {  })
}

function Localization_listen(...args) {
  return Events.listen('localization', ...args)
} 

function Localization_once(...args) {
  return Events.once('localization', ...args)
}

function Localization_clear(...args) {
  return Events.clear('localization', ...args)
}

/* harmony default export */ const Localization = ({

  events: {
    languageChanged:'languageChanged'
  },
locality,
  postalCode,
  countryCode,
  language,
  locale,
  latlon,
  additionalInfo,
  listen: Localization_listen,
  once: Localization_once,
  clear: Localization_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Parameters/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function initialization() {
  return Transport.send('parameters', 'initialization', {  })
}

/* harmony default export */ const Parameters = ({

initialization
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Profile/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function approveContentRating() {
  return Transport.send('profile', 'approveContentRating', {  })
}

function approvePurchase() {
  return Transport.send('profile', 'approvePurchase', {  })
}

function flags() {
  return Transport.send('profile', 'flags', {  })
}

/* harmony default export */ const Profile = ({

approveContentRating,
  approvePurchase,
  flags
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/SecondScreen/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('SecondScreen', Object.values(["launchRequest","closeRequest","friendlyNameChanged"]))



function protocols() {
  return Transport.send('secondscreen', 'protocols', {  })
}

function device(type) {
  return Transport.send('secondscreen', 'device', { type })
}
function friendlyName() {
  return Prop.prop('secondscreen',  'friendlyName', arguments, false, true)
}

function SecondScreen_listen(...args) {
  return Events.listen('secondscreen', ...args)
} 

function SecondScreen_once(...args) {
  return Events.once('secondscreen', ...args)
}

function SecondScreen_clear(...args) {
  return Events.clear('secondscreen', ...args)
}

/* harmony default export */ const SecondScreen = ({

  events: {
    launchRequest:'launchRequest',
    closeRequest:'closeRequest',
    friendlyNameChanged:'friendlyNameChanged'
  },
protocols,
  device,
  friendlyName,
  listen: SecondScreen_listen,
  once: SecondScreen_once,
  clear: SecondScreen_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Platform/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






// public API
/* harmony default export */ const Platform = ({
  Localization: Localization,
  Device: Device,
  Accessibility: Accessibility,
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Log/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



const prepLog = (type, args) => {
  const colors = {
    Info: 'green',
    Debug: 'gray',
    Warn: 'orange',
    Error: 'red',
  }

  args = Array.from(args)
  return [
    '%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type),
    'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px',
    args,
  ]
}

/* harmony default export */ const Log = ({
  info() {
    Settings.get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments))
  },
  debug() {
    Settings.get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments))
  },
  error() {
    Settings.get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments))
  },
  warn() {
    Settings.get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments))
  },
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



















var __webpack_exports__Accessibility = __nested_webpack_exports__.yq;
var __webpack_exports__Account = __nested_webpack_exports__.mR;
var __webpack_exports__Advertising = __nested_webpack_exports__.ZL;
var __webpack_exports__Authentication = __nested_webpack_exports__.Vy;
var __webpack_exports__Device = __nested_webpack_exports__.AS;
var __webpack_exports__Discovery = __nested_webpack_exports__.PG;
var __webpack_exports__Events = __nested_webpack_exports__.zW;
var __webpack_exports__Keyboard = __nested_webpack_exports__.N1;
var __webpack_exports__Lifecycle = __nested_webpack_exports__.Fw;
var __webpack_exports__Localization = __nested_webpack_exports__.WH;
var __webpack_exports__Log = __nested_webpack_exports__.Zb;
var __webpack_exports__Metrics = __nested_webpack_exports__.C3;
var __webpack_exports__Parameters = __nested_webpack_exports__.aE;
var __webpack_exports__Platform = __nested_webpack_exports__.t4;
var __webpack_exports__Profile = __nested_webpack_exports__.NZ;
var __webpack_exports__SecondScreen = __nested_webpack_exports__._F;
var __webpack_exports__Settings = __nested_webpack_exports__.Zr;


//# sourceMappingURL=firebolt.js.map

/***/ }),

/***/ "./node_modules/@lightningjs/core/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@lightningjs/core/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_lightning_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/lightning.mjs */ "./node_modules/@lightningjs/core/src/lightning.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_src_lightning_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/index.js":
/*!************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ads: () => (/* reexport safe */ _src_Ads__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   AppData: () => (/* reexport safe */ _src_Application__WEBPACK_IMPORTED_MODULE_1__.AppData),
/* harmony export */   Application: () => (/* reexport safe */ _src_Application__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   AudioPlayer: () => (/* reexport safe */ _src_AudioPlayer__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   Colors: () => (/* reexport safe */ _src_Colors__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   Img: () => (/* reexport safe */ _src_Img__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   Keyboard: () => (/* reexport safe */ _src_Keyboard__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   Language: () => (/* reexport safe */ _src_Language__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   Launch: () => (/* reexport safe */ _src_Launch__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   Lightning: () => (/* reexport safe */ _src_Lightning__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   Locale: () => (/* reexport safe */ _src_Locale__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   Log: () => (/* reexport safe */ _src_Log__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   MediaPlayer: () => (/* reexport safe */ _src_MediaPlayer__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   Metadata: () => (/* reexport safe */ _src_Metadata__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   Metrics: () => (/* reexport safe */ _src_Metrics__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   Pin: () => (/* reexport safe */ _src_Pin__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   Profile: () => (/* reexport safe */ _src_Profile__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   Purchase: () => (/* reexport safe */ _src_Purchase__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   Registry: () => (/* reexport safe */ _src_Registry__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   Router: () => (/* reexport safe */ _src_Router__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   Settings: () => (/* reexport safe */ _src_Settings__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   Storage: () => (/* reexport safe */ _src_Storage__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   TV: () => (/* reexport safe */ _src_TV__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   Utils: () => (/* reexport safe */ _src_Utils__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   VideoPlayer: () => (/* reexport safe */ _src_VideoPlayer__WEBPACK_IMPORTED_MODULE_22__["default"])
/* harmony export */ });
/* harmony import */ var _src_Ads__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/Ads */ "./node_modules/@lightningjs/sdk/src/Ads/index.js");
/* harmony import */ var _src_Application__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Application */ "./node_modules/@lightningjs/sdk/src/Application/index.js");
/* harmony import */ var _src_AudioPlayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/AudioPlayer */ "./node_modules/@lightningjs/sdk/src/AudioPlayer/index.js");
/* harmony import */ var _src_Colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/Colors */ "./node_modules/@lightningjs/sdk/src/Colors/index.js");
/* harmony import */ var _src_Img__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/Img */ "./node_modules/@lightningjs/sdk/src/Img/index.js");
/* harmony import */ var _src_Keyboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/Keyboard */ "./node_modules/@lightningjs/sdk/src/Keyboard/index.js");
/* harmony import */ var _src_Launch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/Launch */ "./node_modules/@lightningjs/sdk/src/Launch/index.js");
/* harmony import */ var _src_Lightning__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _src_Locale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/Locale */ "./node_modules/@lightningjs/sdk/src/Locale/index.js");
/* harmony import */ var _src_Language__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/Language */ "./node_modules/@lightningjs/sdk/src/Language/index.js");
/* harmony import */ var _src_Log__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _src_MediaPlayer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/MediaPlayer */ "./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js");
/* harmony import */ var _src_Metrics__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _src_Pin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/Pin */ "./node_modules/@lightningjs/sdk/src/Pin/index.js");
/* harmony import */ var _src_Profile__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/Profile */ "./node_modules/@lightningjs/sdk/src/Profile/index.js");
/* harmony import */ var _src_Purchase__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/Purchase */ "./node_modules/@lightningjs/sdk/src/Purchase/index.js");
/* harmony import */ var _src_Registry__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/Registry */ "./node_modules/@lightningjs/sdk/src/Registry/index.js");
/* harmony import */ var _src_Router__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/Router */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _src_Settings__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _src_Storage__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/Storage */ "./node_modules/@lightningjs/sdk/src/Storage/index.js");
/* harmony import */ var _src_TV__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/TV */ "./node_modules/@lightningjs/sdk/src/TV/index.js");
/* harmony import */ var _src_Utils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _src_VideoPlayer__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/VideoPlayer */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js");
/* harmony import */ var _src_Metadata__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/Metadata */ "./node_modules/@lightningjs/sdk/src/Metadata/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




























/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Ads/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Ads/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initAds: () => (/* binding */ initAds)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _VideoPlayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VideoPlayer */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let consumer

let getAds = () => {
  // todo: enable some default ads during development, maybe from the settings.json
  return Promise.resolve({
    prerolls: [],
    midrolls: [],
    postrolls: [],
  })
}

const initAds = config => {
  if (config.getAds) {
    getAds = config.getAds
  }
}

const state = {
  active: false,
}

const playSlot = (slot = []) => {
  return slot.reduce((promise, ad) => {
    return promise.then(() => {
      return playAd(ad)
    })
  }, Promise.resolve(null))
}

const playAd = ad => {
  return new Promise(resolve => {
    if (state.active === false) {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Skipping add due to inactive state')
      return resolve()
    }
    // is it safe to rely on videoplayer plugin already created the video tag?
    const videoEl = document.getElementsByTagName('video')[0]
    videoEl.style.display = 'block'
    videoEl.style.visibility = 'visible'
    videoEl.src = (0,_VideoPlayer__WEBPACK_IMPORTED_MODULE_1__.mediaUrl)(ad.url)
    videoEl.load()

    let timeEvents = null
    let timeout

    const cleanup = () => {
      // remove all listeners
      Object.keys(handlers).forEach(handler =>
        videoEl.removeEventListener(handler, handlers[handler])
      )
      resolve()
    }
    const handlers = {
      play() {
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Play ad', ad.url)
        fireOnConsumer('Play', ad)
        sendBeacon(ad.callbacks, 'defaultImpression')
      },
      ended() {
        fireOnConsumer('Ended', ad)
        sendBeacon(ad.callbacks, 'complete')
        cleanup()
      },
      timeupdate() {
        if (!timeEvents && videoEl.duration) {
          // calculate when to fire the time based events (now that duration is known)
          timeEvents = {
            firstQuartile: videoEl.duration / 4,
            midPoint: videoEl.duration / 2,
            thirdQuartile: (videoEl.duration / 4) * 3,
          }
          _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Calculated quartiles times', { timeEvents })
        }
        if (
          timeEvents &&
          timeEvents.firstQuartile &&
          videoEl.currentTime >= timeEvents.firstQuartile
        ) {
          fireOnConsumer('FirstQuartile', ad)
          delete timeEvents.firstQuartile
          sendBeacon(ad.callbacks, 'firstQuartile')
        }
        if (timeEvents && timeEvents.midPoint && videoEl.currentTime >= timeEvents.midPoint) {
          fireOnConsumer('MidPoint', ad)
          delete timeEvents.midPoint
          sendBeacon(ad.callbacks, 'midPoint')
        }
        if (
          timeEvents &&
          timeEvents.thirdQuartile &&
          videoEl.currentTime >= timeEvents.thirdQuartile
        ) {
          fireOnConsumer('ThirdQuartile', ad)
          delete timeEvents.thirdQuartile
          sendBeacon(ad.callbacks, 'thirdQuartile')
        }
      },
      stalled() {
        fireOnConsumer('Stalled', ad)
        timeout = setTimeout(() => {
          cleanup()
        }, 5000) // make timeout configurable
      },
      canplay() {
        timeout && clearTimeout(timeout)
      },
      error() {
        fireOnConsumer('Error', ad)
        cleanup()
      },
      // this doesn't work reliably on sky box, moved logic to timeUpdate event
      // loadedmetadata() {
      //   // calculate when to fire the time based events (now that duration is known)
      //   timeEvents = {
      //     firstQuartile: videoEl.duration / 4,
      //     midPoint: videoEl.duration / 2,
      //     thirdQuartile: (videoEl.duration / 4) * 3,
      //   }
      // },
      abort() {
        cleanup()
      },
      // todo: pause, resume, mute, unmute beacons
    }
    // add all listeners
    Object.keys(handlers).forEach(handler => videoEl.addEventListener(handler, handlers[handler]))

    videoEl.play()
  })
}

const sendBeacon = (callbacks, event) => {
  if (callbacks && callbacks[event]) {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Sending beacon', event, callbacks[event])
    return callbacks[event].reduce((promise, url) => {
      return promise.then(() =>
        fetch(url)
          // always resolve, also in case of a fetch error (so we don't block firing the rest of the beacons for this event)
          // note: for fetch failed http responses don't throw an Error :)
          .then(response => {
            if (response.status === 200) {
              fireOnConsumer('Beacon' + event + 'Sent')
            } else {
              fireOnConsumer('Beacon' + event + 'Failed' + response.status)
            }
            Promise.resolve(null)
          })
          .catch(() => {
            Promise.resolve(null)
          })
      )
    }, Promise.resolve(null))
  } else {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'No callback found for ' + event)
  }
}

const fireOnConsumer = (event, args) => {
  if (consumer) {
    consumer.fire('$ad' + event, args)
    consumer.fire('$adEvent', event, args)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(config, videoPlayerConsumer) {
    if (config.enabled === false) {
      return Promise.resolve({
        prerolls() {
          return Promise.resolve()
        },
      })
    }
    consumer = videoPlayerConsumer

    return new Promise(resolve => {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Starting session')
      getAds(config).then(ads => {
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'API result', ads)
        resolve({
          prerolls() {
            if (ads.preroll) {
              state.active = true
              fireOnConsumer('PrerollSlotImpression', ads)
              sendBeacon(ads.preroll.callbacks, 'slotImpression')
              return playSlot(ads.preroll.ads).then(() => {
                fireOnConsumer('PrerollSlotEnd', ads)
                sendBeacon(ads.preroll.callbacks, 'slotEnd')
                state.active = false
              })
            }
            return Promise.resolve()
          },
          midrolls() {
            return Promise.resolve()
          },
          postrolls() {
            return Promise.resolve()
          },
        })
      })
    })
  },
  cancel() {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Cancel Ad')
    state.active = false
  },
  stop() {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Stop Ad')
    state.active = false
    // fixme: duplication
    const videoEl = document.getElementsByTagName('video')[0]
    videoEl.pause()
    videoEl.removeAttribute('src')
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Application/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Application/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AppData: () => (/* binding */ AppData),
/* harmony export */   AppInstance: () => (/* binding */ AppInstance),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepmerge */ "./node_modules/deepmerge/dist/cjs.js");
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Locale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Locale */ "./node_modules/@lightningjs/sdk/src/Locale/index.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _VersionLabel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VersionLabel */ "./node_modules/@lightningjs/sdk/src/VersionLabel/index.js");
/* harmony import */ var _FpsCounter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../FpsCounter */ "./node_modules/@lightningjs/sdk/src/FpsCounter/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _Language__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Language */ "./node_modules/@lightningjs/sdk/src/Language/index.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _Registry__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Registry */ "./node_modules/@lightningjs/sdk/src/Registry/index.js");
/* harmony import */ var _Colors__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Colors */ "./node_modules/@lightningjs/sdk/src/Colors/index.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../package.json */ "./node_modules/@lightningjs/sdk/package.json");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















let AppInstance
let AppData

const defaultOptions = {
  stage: { w: 1920, h: 1080, clearColor: 0x00000000, canvas2d: false },
  debug: false,
  defaultFontFace: 'RobotoRegular',
  keys: {
    8: 'Back',
    13: 'Enter',
    27: 'Menu',
    37: 'Left',
    38: 'Up',
    39: 'Right',
    40: 'Down',
    174: 'ChannelDown',
    175: 'ChannelUp',
    178: 'Stop',
    250: 'PlayPause',
    191: 'Search', // Use "/" for keyboard
    409: 'Search',
  },
}

const customFontFaces = []

const fontLoader = (fonts, store) =>
  new Promise((resolve, reject) => {
    fonts
      .map(({ family, url, urls, descriptors }) => () => {
        const src = urls
          ? urls.map(url => {
              return 'url(' + url + ')'
            })
          : 'url(' + url + ')'
        const fontFace = new FontFace(family, src, descriptors || {})
        store.push(fontFace)
        _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Loading font', family)
        document.fonts.add(fontFace)
        return fontFace.load()
      })
      .reduce((promise, method) => {
        return promise.then(() => method())
      }, Promise.resolve(null))
      .then(resolve)
      .catch(reject)
  })

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(App, appData, platformSettings) {
  const { width, height } = platformSettings

  if (width && height) {
    defaultOptions.stage['w'] = width
    defaultOptions.stage['h'] = height
    defaultOptions.stage['precision'] = width / 1920
  }

  // support for 720p browser
  if (!width && !height && window.innerHeight === 720) {
    defaultOptions.stage['w'] = 1280
    defaultOptions.stage['h'] = 720
    defaultOptions.stage['precision'] = 1280 / 1920
  }

  return class Application extends _Lightning__WEBPACK_IMPORTED_MODULE_1__["default"].Application {
    constructor(options) {
      const config = deepmerge__WEBPACK_IMPORTED_MODULE_0___default()(defaultOptions, options)
      // Deepmerge breaks HTMLCanvasElement, so restore the passed in canvas.
      if (options.stage.canvas) {
        config.stage.canvas = options.stage.canvas
      }
      super(config)
      this.config = config
    }

    static _template() {
      return {
        w: 1920,
        h: 1080,
      }
    }

    _setup() {
      Promise.all([
        this.loadFonts((App.config && App.config.fonts) || (App.getFonts && App.getFonts()) || []),
        // to be deprecated
        _Locale__WEBPACK_IMPORTED_MODULE_2__["default"].load((App.config && App.config.locale) || (App.getLocale && App.getLocale())),
        App.language && this.loadLanguage(App.language()),
        App.colors && this.loadColors(App.colors()),
      ])
        .then(() => {
          _Metrics__WEBPACK_IMPORTED_MODULE_3__["default"].app.loaded()

          AppData = appData

          AppInstance = this.stage.c({
            ref: 'App',
            type: App,
            zIndex: 1,
            forceZIndexContext: !!platformSettings.showVersion || !!platformSettings.showFps,
          })

          this.childList.a(AppInstance)

          this._refocus()

          _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('App version', this.config.version)
          _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('SDK version', _package_json__WEBPACK_IMPORTED_MODULE_12__.version)

          if (platformSettings.showVersion) {
            this.childList.a({
              ref: 'VersionLabel',
              type: _VersionLabel__WEBPACK_IMPORTED_MODULE_4__["default"],
              version: this.config.version,
              sdkVersion: _package_json__WEBPACK_IMPORTED_MODULE_12__.version,
              zIndex: 1,
            })
          }

          if (platformSettings.showFps) {
            this.childList.a({
              ref: 'FpsCounter',
              type: _FpsCounter__WEBPACK_IMPORTED_MODULE_5__["default"],
              zIndex: 1,
            })
          }

          super._setup()
        })
        .catch(console.error)
    }

    _handleBack() {
      this.closeApp()
    }

    _handleExit() {
      this.closeApp()
    }

    closeApp() {
      _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Signaling App Close')

      if (platformSettings.onClose && typeof platformSettings.onClose === 'function') {
        platformSettings.onClose(...arguments)
      } else {
        this.close()
      }
    }

    close() {
      _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Closing App')

      _Settings__WEBPACK_IMPORTED_MODULE_7__["default"].clearSubscribers()
      _Registry__WEBPACK_IMPORTED_MODULE_10__["default"].clear()

      this.childList.remove(this.tag('App'))
      this.cleanupFonts()
      // force texture garbage collect
      this.stage.gc()
      this.destroy()
    }

    loadFonts(fonts) {
      return platformSettings.fontLoader && typeof platformSettings.fontLoader === 'function'
        ? platformSettings.fontLoader(fonts, customFontFaces)
        : fontLoader(fonts, customFontFaces)
    }

    cleanupFonts() {
      if ('delete' in document.fonts) {
        customFontFaces.forEach(fontFace => {
          _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Removing font', fontFace.family)
          document.fonts.delete(fontFace)
        })
      } else {
        _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('No support for removing manually-added fonts')
      }
    }

    loadLanguage(config) {
      let file = _Utils__WEBPACK_IMPORTED_MODULE_9__["default"].asset('translations.json')
      let language = config

      if (typeof language === 'object') {
        language = config.language || null
        file = config.file || file
      }

      return (0,_Language__WEBPACK_IMPORTED_MODULE_8__.initLanguage)(file, language)
    }

    loadColors(config) {
      let file = _Utils__WEBPACK_IMPORTED_MODULE_9__["default"].asset('colors.json')
      if (config && (typeof config === 'string' || typeof config === 'object')) {
        file = config
      }
      return (0,_Colors__WEBPACK_IMPORTED_MODULE_11__.initColors)(file)
    }

    set focus(v) {
      this._focussed = v
      this._refocus()
    }

    _getFocused() {
      return this._focussed || this.tag('App')
    }
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/AudioPlayer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/AudioPlayer/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioPlayer)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class AudioPlayer {}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Colors/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Colors/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initColors: () => (/* binding */ initColors)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@lightningjs/sdk/src/Colors/utils.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let colors = {
  white: '#ffffff',
  black: '#000000',
  red: '#ff0000',
  green: '#00ff00',
  blue: '#0000ff',
  yellow: '#feff00',
  cyan: '#00feff',
  magenta: '#ff00ff',
}

const normalizedColors = {
  //store for normalized colors
}

const addColors = (colorsToAdd, value) => {
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(colorsToAdd)) {
    // clean up normalizedColors if they exist in the to be added colors
    Object.keys(colorsToAdd).forEach(color => cleanUpNormalizedColors(color))
    colors = Object.assign({}, colors, colorsToAdd)
  } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(colorsToAdd) && value) {
    cleanUpNormalizedColors(colorsToAdd)
    colors[colorsToAdd] = value
  }
}

const cleanUpNormalizedColors = color => {
  for (let c in normalizedColors) {
    if (c.indexOf(color) > -1) {
      delete normalizedColors[c]
    }
  }
}

const initColors = file => {
  return new Promise((resolve, reject) => {
    if (typeof file === 'object') {
      addColors(file)
      resolve()
    }
    fetch(file)
      .then(response => response.json())
      .then(json => {
        addColors(json)
        resolve()
      })
      .catch(() => {
        const error = 'Colors file ' + file + ' not found'
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        reject(error)
      })
  })
}

const normalizeColorToARGB = color => {
  let targetColor = normalizedColors[color] || colors[color] || color
  if (!targetColor) {
    targetColor = color
  }
  const check = /^#([0-9A-F]{3}|[0-9A-F]{6})$/i
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(targetColor) && check.test(targetColor)) {
    let hex = check.exec(targetColor)[1]
    if (hex.length === 3) {
      hex = hex
        .split('')
        .map(value => {
          return value + value
        })
        .join('')
    }
    targetColor = `0xff${hex}` * 1
  }
  if (!normalizedColors[color]) {
    normalizedColors[color] = targetColor
  }
  return targetColor || 0xffffffff
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (color => {
  return Color.generate(color)
});

const Color = {
  color: null,
  generate: function(value = this.color) {
    if (normalizedColors[value]) {
      this.color = normalizedColors[value]
    } else {
      this.color = normalizeColorToARGB(value)
    }
    return this
  },
  get() {
    return this.color
  },
  alpha: function(percentage) {
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateAlpha)(this.color, Math.abs(percentage))
    return this
  },
  darker(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.l = hsl.l * (1 - percentage)
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  lighter(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.l = hsl.l + (1 - hsl.l) * percentage
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  saturation(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.s = percentage
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  lightness(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.l = percentage
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  hue(degrees) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.h = degrees
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  mix(argb, p) {
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeColors)(this.color, argb, p)
    return this
  },
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Colors/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Colors/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   argbToHSLA: () => (/* binding */ argbToHSLA),
/* harmony export */   argbToHsva: () => (/* binding */ argbToHsva),
/* harmony export */   calculateAlpha: () => (/* binding */ calculateAlpha),
/* harmony export */   getRgbaComponents: () => (/* binding */ getRgbaComponents),
/* harmony export */   hslaToARGB: () => (/* binding */ hslaToARGB),
/* harmony export */   hsvaToArgb: () => (/* binding */ hsvaToArgb),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   limitWithinRange: () => (/* binding */ limitWithinRange),
/* harmony export */   mergeColorAlpha: () => (/* binding */ mergeColorAlpha),
/* harmony export */   mergeColors: () => (/* binding */ mergeColors)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const isObject = v => {
  return typeof v === 'object' && v !== null
}

const isString = v => {
  return typeof v === 'string'
}

const getRgbaComponents = argb => {
  return {
    r: ((argb / 65536) | 0) % 256,
    g: ((argb / 256) | 0) % 256,
    b: (argb * 1) % 256,
    a: (argb / 16777216) | 0,
  }
}

const limitWithinRange = (num, min, max) => {
  return Math.min(Math.max(num, min), max)
}

const mergeColors = (c1, c2, p) => {
  let r1 = ((c1 / 65536) | 0) % 256
  let g1 = ((c1 / 256) | 0) % 256
  let b1 = c1 % 256
  let a1 = (c1 / 16777216) | 0
  let r2 = ((c2 / 65536) | 0) % 256
  let g2 = ((c2 / 256) | 0) % 256
  let b2 = c2 % 256
  let a2 = (c2 / 16777216) | 0
  let r = r1 * p + r2 * (1 - p)
  let g = g1 * p + g2 * (1 - p)
  let b = b1 * p + b2 * (1 - p)
  let a = a1 * p + a2 * (1 - p)
  return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b)
}

const calculateAlpha = (argb, p) => {
  if (p > 1) {
    p /= 100
  } else if (p < 0) {
    p = 0
  }
  let r = ((argb / 65536) | 0) % 256
  let g = ((argb / 256) | 0) % 256
  let b = argb % 256
  return (r << 16) + (g << 8) + b + ((p * 255) | 0) * 16777216
}

const mergeColorAlpha = (c, alpha) => {
  let a = (((c / 16777216) | 0) * alpha) | 0
  return (
    (((((c >> 16) & 0xff) * a) / 255) & 0xff) +
    ((((c & 0xff00) * a) / 255) & 0xff00) +
    (((((c & 0xff) << 16) * a) / 255) & 0xff0000) +
    (a << 24)
  )
}

const getArgbNumber = rgba => {
  rgba[0] = Math.max(0, Math.min(255, rgba[0]))
  rgba[1] = Math.max(0, Math.min(255, rgba[1]))
  rgba[2] = Math.max(0, Math.min(255, rgba[2]))
  rgba[3] = Math.max(0, Math.min(255, rgba[3]))
  let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0)
  if (v < 0) {
    v = 0xffffffff + v + 1
  }
  return v
}

const argbToHsva = argb => {
  const color = getRgbaComponents(argb)
  let r = color.r / 255
  let g = color.g / 255
  let b = color.b / 255
  let h = 0
  let s = 0

  const cMax = Math.max(r, g, b)
  const cMin = Math.min(r, g, b)
  const delta = cMax - cMin

  //calculate hue
  if (delta < 0.00001) {
    h = 0
  } else if (cMax !== 0 || cMin !== 0) {
    if (r === cMax) {
      h = (60 * ((g - b) / delta) + 360) % 360
    } else if (g === cMax) {
      h = (60 * ((b - r) / delta) + 120) % 360
    } else if (b === cMax) {
      h = (60 * ((r - g) / delta) + 240) % 360
    }
  }

  //calc saturation
  if (cMax > 0) {
    s = delta / cMax
  }
  return {
    h,
    s,
    v: cMax,
    a: color.a / 255,
  }
}

const hsvaToArgb = color => {
  const h = color.h
  const c = color.v * color.s
  const m = color.v - c
  const x = c * (1.0 - Math.abs(((h / 60) % 2) - 1))
  let r = 0
  let g = 0
  let b = 0

  if (0 <= h && h < 60) {
    r = c
    g = x
  } else if (60 <= h && h < 120) {
    r = x
    g = c
  } else if (120 <= h && h < 180) {
    g = c
    b = x
  } else if (180 <= h && h < 240) {
    g = x
    b = c
  } else if (240 <= h && h < 300) {
    r = x
    b = c
  } else if (300 <= h && h < 360) {
    r = c
    b = x
  }

  r = Math.round((r + m) * 255.0)
  g = Math.round((g + m) * 255.0)
  b = Math.round((b + m) * 255.0)
  return getArgbNumber([r, g, b, color.a * 255])
}

const argbToHSLA = argb => {
  const col = getRgbaComponents(argb)
  const r = col.r / 255
  const g = col.g / 255
  const b = col.b / 255

  const max = Math.max(r, g, b)
  const min = Math.min(r, g, b)

  let h = 0
  let s = 0
  const l = (min + max) * 0.5
  if (l > 0) {
    const maxMin = max - min
    if (maxMin > 0) {
      const r2 = (max - r) / maxMin
      const g2 = (max - g) / maxMin
      const b2 = (max - b) / maxMin
      if (l < 0.5) {
        s = max + min
      } else {
        s = 2 - max - min
      }

      if (r === max && g === min) {
        h = 5.0 + b2
      } else if (r === max) {
        h = 1.0 - g2
      } else if (g === max && b === min) {
        h = 1.0 + r2
      } else if (g === max) {
        h = 3.0 - b2
      } else if (b === max) {
        h = 3.0 + g2
      } else {
        h = 5.0 - r2
      }
      h = h / 6
    }
  }
  return { h: h % 1, s, l, a: col.a }
}

const hslaToARGB = hsla => {
  let r = 1
  let g = 1
  let b = 1

  let h = hsla.h
  let s = hsla.s
  let l = hsla.l

  if (h < 0) {
    h += 1
  }
  let max = 0
  if (l <= 0.5) {
    max = l * (1.0 + s)
  } else {
    max = l + s - l * s
  }

  if (max > 0) {
    h *= 6.0
    const min = l + l - max
    const minMax = (max - min) / max
    const sextant = Math.floor(h)
    const fract = h - sextant
    const minMaxFract = max * minMax * fract
    const mid1 = min + minMaxFract
    const mid2 = max - minMaxFract

    if (sextant === 0) {
      r = max
      g = mid1
      b = min
    }
    if (sextant === 1) {
      r = mid2
      g = max
      b = min
    }
    if (sextant === 2) {
      r = min
      g = max
      b = mid1
    }
    if (sextant === 3) {
      r = min
      g = mid2
      b = max
    }
    if (sextant === 4) {
      r = mid1
      g = min
      b = max
    }
    if (sextant === 5) {
      r = max
      g = min
      b = mid2
    }
  }
  return getArgbNumber([Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255), hsla.a])
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/FpsCounter/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/FpsCounter/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FpsIndicator)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class FpsIndicator extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      rect: true,
      color: 0xffffffff,
      texture: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Tools.getRoundRect(80, 80, 40),
      h: 80,
      w: 80,
      x: 100,
      y: 100,
      mount: 1,
      Background: {
        x: 3,
        y: 3,
        texture: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Tools.getRoundRect(72, 72, 36),
        color: 0xff008000,
      },
      Counter: {
        w: w => w,
        h: h => h,
        y: 10,
        text: {
          fontSize: 32,
          textAlign: 'center',
        },
      },
      Text: {
        w: w => w,
        h: h => h,
        y: 48,
        text: {
          fontSize: 15,
          textAlign: 'center',
          text: 'FPS',
        },
      },
    }
  }

  _setup() {
    this.config = {
      ...{
        log: false,
        interval: 500,
        threshold: 1,
      },
      ..._Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'showFps'),
    }

    this.fps = 0
    this.lastFps = this.fps - this.config.threshold

    const fpsCalculator = () => {
      this.fps = ~~(1 / this.stage.dt)
    }
    this.stage.on('frameStart', fpsCalculator)
    this.stage.off('framestart', fpsCalculator)
    this.interval = setInterval(this.showFps.bind(this), this.config.interval)
  }

  _firstActive() {
    this.showFps()
  }

  _detach() {
    clearInterval(this.interval)
  }

  showFps() {
    if (Math.abs(this.lastFps - this.fps) <= this.config.threshold) return
    this.lastFps = this.fps
    // green
    let bgColor = 0xff008000
    // orange
    if (this.fps <= 40 && this.fps > 20) bgColor = 0xffffa500
    // red
    else if (this.fps <= 20) bgColor = 0xffff0000

    this.tag('Background').setSmooth('color', bgColor)
    this.tag('Counter').text = `${this.fps}`

    this.config.log && _Log__WEBPACK_IMPORTED_MODULE_2__["default"].info('FPS', this.fps)
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Img/ScaledImageTexture.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Img/ScaledImageTexture.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScaledImageTexture)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ScaledImageTexture extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].textures.ImageTexture {
  constructor(stage) {
    super(stage)
    this._scalingOptions = undefined
  }

  set options(options) {
    this.resizeMode = this._scalingOptions = options
  }

  _getLookupId() {
    return `${this._src}-${this._scalingOptions.type}-${this._scalingOptions.w}-${this._scalingOptions.h}`
  }

  getNonDefaults() {
    const obj = super.getNonDefaults()
    if (this._src) {
      obj.src = this._src
    }
    return obj
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Img/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Img/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _ScaledImageTexture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ScaledImageTexture */ "./node_modules/@lightningjs/sdk/src/Img/ScaledImageTexture.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((imageUrl, options) => {
  const imageServerUrl = _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'imageServerUrl')

  // make and return ScaledImageTexture
  const make = options => {
    // local asset, wrap it in Utils.asset()
    if (!/^(?:https?:)?\/\//i.test(imageUrl)) {
      imageUrl = _Utils__WEBPACK_IMPORTED_MODULE_0__["default"].asset(imageUrl)
    }

    // only pass to image server if imageServerUrl is configured
    // and if the asset isn't local to the app (i.e. has same origin)
    if (imageServerUrl && imageUrl.indexOf(window.location.origin) === -1) {
      imageUrl = _Utils__WEBPACK_IMPORTED_MODULE_0__["default"].ensureUrlWithProtocol(
        imageServerUrl + '?' + _Utils__WEBPACK_IMPORTED_MODULE_0__["default"].makeQueryString(imageUrl, options)
      )
    } else {
      // Lightning will handle the resizing and has only 2 flavours (cover and contain)
      if (options.type === 'crop') options.type = 'cover'
      else options.type = 'contain'
    }

    return {
      type: _ScaledImageTexture__WEBPACK_IMPORTED_MODULE_2__["default"],
      src: imageUrl,
      options: options,
    }
  }

  // merge options with default
  const setOptions = options => {
    options = {
      ...{
        type: 'contain',
        w: 0,
        h: 0,
      },
      ...options,
    }
    const imageQuality = Math.max(
      0.1,
      Math.min(1, (parseFloat(_Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'image.quality')) || 100) / 100)
    )

    options.w = options.w * imageQuality
    options.h = options.h * imageQuality
    return options
  }

  // if options are passed, return scaled image right away
  if (options) {
    return make(setOptions(options))
  }

  // otherwise return 'chained' functions
  return {
    // official api
    exact: (w, h) => make(setOptions({ type: 'exact', w, h })),
    landscape: w => make(setOptions({ type: 'landscape', w })),
    portrait: h => make(setOptions({ type: 'portrait', h })),
    cover: (w, h) => make(setOptions({ type: 'cover', w, h })),
    contain: (w, h) => make(setOptions({ type: 'contain', w, h })),
    original: () => make(setOptions({ type: 'contain' })),

    // todo: add positioning - i.e. top, bottom, center, left etc.
  }
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Keyboard/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Keyboard/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Language/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Language/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initLanguage: () => (/* binding */ initLanguage)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let meta = {}
let translations = {}
let language = null
let dictionary = null

const initLanguage = (file, language = null) => {
  return new Promise((resolve, reject) => {
    fetch(file)
      .then(response => response.json())
      .then(json => {
        setTranslations(json)
        // set language (directly or in a promise)
        typeof language === 'object' && 'then' in language && typeof language.then === 'function'
          ? language
              .then(lang =>
                setLanguage(lang)
                  .then(resolve)
                  .catch(reject)
              )
              .catch(e => {
                _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(e)
                reject(e)
              })
          : setLanguage(language)
              .then(resolve)
              .catch(reject)
      })
      .catch(() => {
        const error = 'Language file ' + file + ' not found'
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        reject(error)
      })
  })
}

const setTranslations = obj => {
  if ('meta' in obj) {
    meta = { ...obj.meta }
    delete obj.meta
  }
  translations = obj
}

const getLanguage = () => {
  return language
}

const setLanguage = lng => {
  language = null
  dictionary = null

  return new Promise((resolve, reject) => {
    if (lng in translations) {
      language = lng
    } else {
      if ('map' in meta && lng in meta.map && meta.map[lng] in translations) {
        language = meta.map[lng]
      } else if ('default' in meta && meta.default in translations) {
        const error =
          'Translations for Language ' +
          language +
          ' not found. Using default language ' +
          meta.default
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].warn(error)
        language = meta.default
      } else {
        const error = 'Translations for Language ' + language + ' not found.'
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        reject(error)
      }
    }

    if (language) {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Setting language to', language)

      const translationsObj = translations[language]
      if (typeof translationsObj === 'object') {
        dictionary = translationsObj
        resolve()
      } else if (typeof translationsObj === 'string') {
        const url = _Utils__WEBPACK_IMPORTED_MODULE_1__["default"].asset(translationsObj)

        fetch(url)
          .then(response => response.json())
          .then(json => {
            // save the translations for this language (to prevent loading twice)
            translations[language] = json
            dictionary = json
            resolve()
          })
          .catch(e => {
            const error = 'Error while fetching ' + url
            _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error, e)
            reject(error)
          })
      }
    }
  })
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  translate(key) {
    let replacements = [...arguments].slice(1)

    // no replacements so just translated string
    if (replacements.length === 0) {
      return (dictionary && dictionary[key]) || key
    } else {
      if (replacements.length === 1 && typeof replacements[0] === 'object') {
        replacements = replacements.pop()
      }

      return Object.keys(
        // maps array input to an object {0: 'item1', 1: 'item2'}
        Array.isArray(replacements) ? Object.assign({}, replacements) : replacements
      ).reduce((text, replacementKey) => {
        return text.replace(
          new RegExp('{\\s?' + replacementKey + '\\s?}', 'g'),
          replacements[replacementKey]
        )
      }, (dictionary && dictionary[key]) || key)
    }
  },

  translations(obj) {
    setTranslations(obj)
  },

  set(language) {
    return setLanguage(language)
  },

  get() {
    return getLanguage()
  },

  available() {
    const languageKeys = Object.keys(translations)
    return languageKeys.map(key => ({ code: key, name: (meta.names && meta.names[key]) || key }))
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Launch/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Launch/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApplicationInstance: () => (/* binding */ ApplicationInstance),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _Profile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Profile */ "./node_modules/@lightningjs/sdk/src/Profile/index.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _MediaPlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MediaPlayer */ "./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js");
/* harmony import */ var _VideoPlayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VideoPlayer */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js");
/* harmony import */ var _Storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Storage */ "./node_modules/@lightningjs/sdk/src/Storage/index.js");
/* harmony import */ var _Ads__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Ads */ "./node_modules/@lightningjs/sdk/src/Ads/index.js");
/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Router */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _TV__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../TV */ "./node_modules/@lightningjs/sdk/src/TV/index.js");
/* harmony import */ var _Purchase__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Purchase */ "./node_modules/@lightningjs/sdk/src/Purchase/index.js");
/* harmony import */ var _Pin__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Pin */ "./node_modules/@lightningjs/sdk/src/Pin/index.js");
/* harmony import */ var _Metadata__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../Metadata */ "./node_modules/@lightningjs/sdk/src/Metadata/index.js");
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Application */ "./node_modules/@lightningjs/sdk/src/Application/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















let ApplicationInstance

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((App, appSettings, platformSettings, appData) => {
  ;(0,_Settings__WEBPACK_IMPORTED_MODULE_3__.initSettings)(appSettings, platformSettings)
  ;(0,_Metadata__WEBPACK_IMPORTED_MODULE_12__.initMetadata)(appSettings)

  ;(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.initUtils)(platformSettings)
  ;(0,_Storage__WEBPACK_IMPORTED_MODULE_6__.initStorage)()
  // Initialize plugins
  if (platformSettings.plugins) {
    platformSettings.plugins.profile && (0,_Profile__WEBPACK_IMPORTED_MODULE_1__.initProfile)(platformSettings.plugins.profile)
    platformSettings.plugins.metrics && (0,_Metrics__WEBPACK_IMPORTED_MODULE_2__.initMetrics)(platformSettings.plugins.metrics)
    platformSettings.plugins.mediaPlayer && (0,_MediaPlayer__WEBPACK_IMPORTED_MODULE_4__.initMediaPlayer)(platformSettings.plugins.mediaPlayer)
    platformSettings.plugins.mediaPlayer && (0,_VideoPlayer__WEBPACK_IMPORTED_MODULE_5__.initVideoPlayer)(platformSettings.plugins.mediaPlayer)
    platformSettings.plugins.ads && (0,_Ads__WEBPACK_IMPORTED_MODULE_7__.initAds)(platformSettings.plugins.ads)
    platformSettings.plugins.router && (0,_Router__WEBPACK_IMPORTED_MODULE_8__.initRouter)(platformSettings.plugins.router)
    platformSettings.plugins.tv && (0,_TV__WEBPACK_IMPORTED_MODULE_9__.initTV)(platformSettings.plugins.tv)
    platformSettings.plugins.purchase && (0,_Purchase__WEBPACK_IMPORTED_MODULE_10__.initPurchase)(platformSettings.plugins.purchase)
    platformSettings.plugins.pin && (0,_Pin__WEBPACK_IMPORTED_MODULE_11__.initPin)(platformSettings.plugins.pin)
  }

  const app = (0,_Application__WEBPACK_IMPORTED_MODULE_13__["default"])(App, appData, platformSettings)
  ApplicationInstance = new app(appSettings)
  return ApplicationInstance
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Lightning/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Lightning/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lightningjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/core */ "./node_modules/@lightningjs/core/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lightningjs_core__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Locale/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Locale/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple module for localization of strings.
 *
 * How to use:
 * 1. Create localization file with following JSON format:
 * {
 *   "en" :{
 *     "how": "How do you want your egg today?",
 *     "boiledEgg": "Boiled egg",
 *     "softBoiledEgg": "Soft-boiled egg",
 *     "choice": "How to choose the egg",
 *     "buyQuestion": "I'd like to buy {0} eggs, {1} dollars each."
 *   },
 *
 *   "it": {
 *     "how": "Come vuoi il tuo uovo oggi?",
 *     "boiledEgg": "Uovo sodo",
 *     "softBoiledEgg": "Uovo alla coque",
 *     "choice": "Come scegliere l'uovo",
 *     "buyQuestion": "Mi piacerebbe comprare {0} uova, {1} dollari ciascuna."
 *   }
 * }
 *
 * 2. Use Locale's module load method, specifying path to your localization file and set chosen language, e.g.:
 *    > Locale.load('static/locale/locale.json');
 *    > Locale.setLanguage('en');
 *
 * 3. Use localization strings:
 *    > console.log(Locale.tr.how);
 *    How do you want your egg today?
 *    > console.log(Locale.tr.boiledEgg);
 *    Boiled egg
 *
 * 4. String formatting
 *    > console.log(Locale.tr.buyQuestion.format(10, 0.5));
 *    I'd like to buy 10 eggs, 0.5 dollars each.
 */



let warned = false
const deprecated = (force = false) => {
  if (force === true || warned === false) {
    console.warn(
      [
        "The 'Locale'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
        "Please consider using the new 'Language'-plugin instead.",
        'https://rdkcentral.github.io/Lightning-SDK/#/plugins/language',
      ].join('\n\n')
    )
  }
  warned = true
}
class Locale {
  constructor() {
    this.__enabled = false
  }

  /**
   * Loads translation object from external json file.
   *
   * @param {String} path Path to resource.
   * @return {Promise}
   */
  async load(path) {
    if (!this.__enabled) {
      return
    }

    await fetch(path)
      .then(resp => resp.json())
      .then(resp => {
        this.loadFromObject(resp)
      })
  }

  /**
   * Sets language used by module.
   *
   * @param {String} lang
   */
  setLanguage(lang) {
    deprecated()
    this.__enabled = true
    this.language = lang
  }

  /**
   * Returns reference to translation object for current language.
   *
   * @return {Object}
   */
  get tr() {
    deprecated(true)
    return this.__trObj[this.language]
  }

  /**
   * Loads translation object from existing object (binds existing object).
   *
   * @param {Object} trObj
   */
  loadFromObject(trObj) {
    deprecated()
    const fallbackLanguage = 'en'
    if (Object.keys(trObj).indexOf(this.language) === -1) {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].warn('No translations found for: ' + this.language)
      if (Object.keys(trObj).indexOf(fallbackLanguage) > -1) {
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].warn('Using fallback language: ' + fallbackLanguage)
        this.language = fallbackLanguage
      } else {
        const error = 'No translations found for fallback language: ' + fallbackLanguage
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        throw Error(error)
      }
    }

    this.__trObj = trObj
    for (const lang of Object.values(this.__trObj)) {
      for (const str of Object.keys(lang)) {
        lang[str] = new LocalizedString(lang[str])
      }
    }
  }
}

/**
 * Extended string class used for localization.
 */
class LocalizedString extends String {
  /**
   * Returns formatted LocalizedString.
   * Replaces each placeholder value (e.g. {0}, {1}) with corresponding argument.
   *
   * E.g.:
   * > new LocalizedString('{0} and {1} and {0}').format('A', 'B');
   * A and B and A
   *
   * @param  {...any} args List of arguments for placeholders.
   */
  format(...args) {
    const sub = args.reduce((string, arg, index) => string.split(`{${index}}`).join(arg), this)
    return new LocalizedString(sub)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Locale());


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Log/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Log/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const prepLog = (type, args) => {
  const colors = {
    Info: 'green',
    Debug: 'gray',
    Warn: 'orange',
    Error: 'red',
  }

  args = Array.from(args)
  return [
    '%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type),
    'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px',
    args,
  ]
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  info() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments))
  },
  debug() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments))
  },
  error() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments))
  },
  warn() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments))
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Mediaplayer),
/* harmony export */   initMediaPlayer: () => (/* binding */ initMediaPlayer)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const events = [
  'timeupdate',
  'error',
  'ended',
  'loadeddata',
  'canplay',
  'play',
  'playing',
  'pause',
  'loadstart',
  'seeking',
  'seeked',
  'encrypted',
]

let mediaUrl = url => url

const initMediaPlayer = config => {
  if (config.mediaUrl) {
    mediaUrl = config.mediaUrl
  }
}

class Mediaplayer extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  _construct() {
    this._skipRenderToTexture = false
    this._metrics = null
    this._textureMode = _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].get('platform', 'textureMode') || false
    _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('Texture mode: ' + this._textureMode)
    console.warn(
      [
        "The 'MediaPlayer'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
        "Please consider using the new 'VideoPlayer'-plugin instead.",
        'https://rdkcentral.github.io/Lightning-SDK/#/plugins/videoplayer',
      ].join('\n\n')
    )
  }

  static _template() {
    return {
      Video: {
        VideoWrap: {
          VideoTexture: {
            visible: false,
            pivot: 0.5,
            texture: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].textures.StaticTexture, options: {} },
          },
        },
      },
    }
  }

  set skipRenderToTexture(v) {
    this._skipRenderToTexture = v
  }

  get textureMode() {
    return this._textureMode
  }

  get videoView() {
    return this.tag('Video')
  }

  _init() {
    //re-use videotag if already there
    const videoEls = document.getElementsByTagName('video')
    if (videoEls && videoEls.length > 0) this.videoEl = videoEls[0]
    else {
      this.videoEl = document.createElement('video')
      this.videoEl.setAttribute('id', 'video-player')
      this.videoEl.style.position = 'absolute'
      this.videoEl.style.zIndex = '1'
      this.videoEl.style.display = 'none'
      this.videoEl.setAttribute('width', '100%')
      this.videoEl.setAttribute('height', '100%')

      this.videoEl.style.visibility = this.textureMode ? 'hidden' : 'visible'
      document.body.appendChild(this.videoEl)
    }
    if (this.textureMode && !this._skipRenderToTexture) {
      this._createVideoTexture()
    }

    this.eventHandlers = []
  }

  _registerListeners() {
    events.forEach(event => {
      const handler = e => {
        if (this._metrics && this._metrics[event] && typeof this._metrics[event] === 'function') {
          this._metrics[event]({ currentTime: this.videoEl.currentTime })
        }
        this.fire(event, { videoElement: this.videoEl, event: e })
      }
      this.eventHandlers.push(handler)
      this.videoEl.addEventListener(event, handler)
    })
  }

  _deregisterListeners() {
    _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('Deregistering event listeners MediaPlayer')
    events.forEach((event, index) => {
      this.videoEl.removeEventListener(event, this.eventHandlers[index])
    })
    this.eventHandlers = []
  }

  _attach() {
    this._registerListeners()
  }

  _detach() {
    this._deregisterListeners()
    this.close()
  }

  _createVideoTexture() {
    const stage = this.stage

    const gl = stage.gl
    const glTexture = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, glTexture)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

    this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height }
  }

  _startUpdatingVideoTexture() {
    if (this.textureMode && !this._skipRenderToTexture) {
      const stage = this.stage
      if (!this._updateVideoTexture) {
        this._updateVideoTexture = () => {
          if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
            const gl = stage.gl

            const currentTime = new Date().getTime()

            // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
            // We'll fallback to fixed 30fps in this case.
            const frameCount = this.videoEl.webkitDecodedFrameCount

            const mustUpdate = frameCount
              ? this._lastFrame !== frameCount
              : this._lastTime < currentTime - 30

            if (mustUpdate) {
              this._lastTime = currentTime
              this._lastFrame = frameCount
              try {
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false)
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl)
                this._lastFrame = this.videoEl.webkitDecodedFrameCount
                this.videoTextureView.visible = true

                this.videoTexture.options.w = this.videoEl.videoWidth
                this.videoTexture.options.h = this.videoEl.videoHeight
                const expectedAspectRatio = this.videoTextureView.w / this.videoTextureView.h
                const realAspectRatio = this.videoEl.videoWidth / this.videoEl.videoHeight
                if (expectedAspectRatio > realAspectRatio) {
                  this.videoTextureView.scaleX = realAspectRatio / expectedAspectRatio
                  this.videoTextureView.scaleY = 1
                } else {
                  this.videoTextureView.scaleY = expectedAspectRatio / realAspectRatio
                  this.videoTextureView.scaleX = 1
                }
              } catch (e) {
                _Log__WEBPACK_IMPORTED_MODULE_3__["default"].error('texImage2d video', e)
                this._stopUpdatingVideoTexture()
                this.videoTextureView.visible = false
              }
              this.videoTexture.source.forceRenderUpdate()
            }
          }
        }
      }
      if (!this._updatingVideoTexture) {
        stage.on('frameStart', this._updateVideoTexture)
        this._updatingVideoTexture = true
      }
    }
  }

  _stopUpdatingVideoTexture() {
    if (this.textureMode) {
      const stage = this.stage
      stage.removeListener('frameStart', this._updateVideoTexture)
      this._updatingVideoTexture = false
      this.videoTextureView.visible = false

      if (this.videoTexture.options.source) {
        const gl = stage.gl
        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
        gl.clearColor(0, 0, 0, 1)
        gl.clear(gl.COLOR_BUFFER_BIT)
      }
    }
  }

  updateSettings(settings = {}) {
    // The Component that 'consumes' the media player.
    this._consumer = settings.consumer

    if (this._consumer && this._consumer.getMediaplayerSettings) {
      // Allow consumer to add settings.
      settings = Object.assign(settings, this._consumer.getMediaplayerSettings())
    }

    if (!_Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Utils.equalValues(this._stream, settings.stream)) {
      if (settings.stream && settings.stream.keySystem) {
        navigator
          .requestMediaKeySystemAccess(
            settings.stream.keySystem.id,
            settings.stream.keySystem.config
          )
          .then(keySystemAccess => {
            return keySystemAccess.createMediaKeys()
          })
          .then(createdMediaKeys => {
            return this.videoEl.setMediaKeys(createdMediaKeys)
          })
          .then(() => {
            if (settings.stream && settings.stream.src) this.open(settings.stream.src)
          })
          .catch(() => {
            console.error('Failed to set up MediaKeys')
          })
      } else if (settings.stream && settings.stream.src) {
        // This is here to be backwards compatible, will be removed
        // in future sdk release
        if (_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].get('app', 'hls')) {
          if (!window.Hls) {
            window.Hls = class Hls {
              static isSupported() {
                console.warn('hls-light not included')
                return false
              }
            }
          }
          if (window.Hls.isSupported()) {
            if (!this._hls) this._hls = new window.Hls({ liveDurationInfinity: true })
            this._hls.loadSource(settings.stream.src)
            this._hls.attachMedia(this.videoEl)
            this.videoEl.style.display = 'block'
          }
        } else {
          this.open(settings.stream.src)
        }
      } else {
        this.close()
      }
      this._stream = settings.stream
    }

    this._setHide(settings.hide)
    this._setVideoArea(settings.videoPos)
  }

  _setHide(hide) {
    if (this.textureMode) {
      this.tag('Video').setSmooth('alpha', hide ? 0 : 1)
    } else {
      this.videoEl.style.visibility = hide ? 'hidden' : 'visible'
    }
  }

  open(url, settings = { hide: false, videoPosition: null }) {
    // prep the media url to play depending on platform (mediaPlayerplugin)
    url = mediaUrl(url)
    this._metrics = _Metrics__WEBPACK_IMPORTED_MODULE_1__["default"].media(url)
    _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('Playing stream', url)
    if (this.application.noVideo) {
      _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('noVideo option set, so ignoring: ' + url)
      return
    }
    // close the video when opening same url as current (effectively reloading)
    if (this.videoEl.getAttribute('src') === url) {
      this.close()
    }
    this.videoEl.setAttribute('src', url)

    // force hide, then force show (in next tick!)
    // (fixes comcast playback rollover issue)
    this.videoEl.style.visibility = 'hidden'
    this.videoEl.style.display = 'none'

    setTimeout(() => {
      this.videoEl.style.display = 'block'
      this.videoEl.style.visibility = 'visible'
    })

    this._setHide(settings.hide)
    this._setVideoArea(settings.videoPosition || [0, 0, 1920, 1080])
  }

  close() {
    // We need to pause first in order to stop sound.
    this.videoEl.pause()
    this.videoEl.removeAttribute('src')

    // force load to reset everything without errors
    this.videoEl.load()

    this._clearSrc()

    this.videoEl.style.display = 'none'
  }

  playPause() {
    if (this.isPlaying()) {
      this.doPause()
    } else {
      this.doPlay()
    }
  }

  get muted() {
    return this.videoEl.muted
  }

  set muted(v) {
    this.videoEl.muted = v
  }

  get loop() {
    return this.videoEl.loop
  }

  set loop(v) {
    this.videoEl.loop = v
  }

  isPlaying() {
    return this._getState() === 'Playing'
  }

  doPlay() {
    this.videoEl.play()
  }

  doPause() {
    this.videoEl.pause()
  }

  reload() {
    var url = this.videoEl.getAttribute('src')
    this.close()
    this.videoEl.src = url
  }

  getPosition() {
    return Promise.resolve(this.videoEl.currentTime)
  }

  setPosition(pos) {
    this.videoEl.currentTime = pos
  }

  getDuration() {
    return Promise.resolve(this.videoEl.duration)
  }

  seek(time, absolute = false) {
    if (absolute) {
      this.videoEl.currentTime = time
    } else {
      this.videoEl.currentTime += time
    }
  }

  get videoTextureView() {
    return this.tag('Video').tag('VideoTexture')
  }

  get videoTexture() {
    return this.videoTextureView.texture
  }

  _setVideoArea(videoPos) {
    if (_Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Utils.equalValues(this._videoPos, videoPos)) {
      return
    }

    this._videoPos = videoPos

    if (this.textureMode) {
      this.videoTextureView.patch({
        smooth: {
          x: videoPos[0],
          y: videoPos[1],
          w: videoPos[2] - videoPos[0],
          h: videoPos[3] - videoPos[1],
        },
      })
    } else {
      const precision = this.stage.getRenderPrecision()
      this.videoEl.style.left = Math.round(videoPos[0] * precision) + 'px'
      this.videoEl.style.top = Math.round(videoPos[1] * precision) + 'px'
      this.videoEl.style.width = Math.round((videoPos[2] - videoPos[0]) * precision) + 'px'
      this.videoEl.style.height = Math.round((videoPos[3] - videoPos[1]) * precision) + 'px'
    }
  }

  _fireConsumer(event, args) {
    if (this._consumer) {
      this._consumer.fire(event, args)
    }
  }

  _equalInitData(buf1, buf2) {
    if (!buf1 || !buf2) return false
    if (buf1.byteLength != buf2.byteLength) return false
    const dv1 = new Int8Array(buf1)
    const dv2 = new Int8Array(buf2)
    for (let i = 0; i != buf1.byteLength; i++) if (dv1[i] != dv2[i]) return false
    return true
  }

  error(args) {
    this._fireConsumer('$mediaplayerError', args)
    this._setState('')
    return ''
  }

  loadeddata(args) {
    this._fireConsumer('$mediaplayerLoadedData', args)
  }

  play(args) {
    this._fireConsumer('$mediaplayerPlay', args)
  }

  playing(args) {
    this._fireConsumer('$mediaplayerPlaying', args)
    this._setState('Playing')
  }

  canplay(args) {
    this.videoEl.play()
    this._fireConsumer('$mediaplayerStart', args)
  }

  loadstart(args) {
    this._fireConsumer('$mediaplayerLoad', args)
  }

  seeked() {
    this._fireConsumer('$mediaplayerSeeked', {
      currentTime: this.videoEl.currentTime,
      duration: this.videoEl.duration || 1,
    })
  }

  seeking() {
    this._fireConsumer('$mediaplayerSeeking', {
      currentTime: this.videoEl.currentTime,
      duration: this.videoEl.duration || 1,
    })
  }

  durationchange(args) {
    this._fireConsumer('$mediaplayerDurationChange', args)
  }

  encrypted(args) {
    const video = args.videoElement
    const event = args.event
    // FIXME: Double encrypted events need to be properly filtered by Gstreamer
    if (video.mediaKeys && !this._equalInitData(this._previousInitData, event.initData)) {
      this._previousInitData = event.initData
      this._fireConsumer('$mediaplayerEncrypted', args)
    }
  }

  static _states() {
    return [
      class Playing extends this {
        $enter() {
          this._startUpdatingVideoTexture()
        }
        $exit() {
          this._stopUpdatingVideoTexture()
        }
        timeupdate() {
          this._fireConsumer('$mediaplayerProgress', {
            currentTime: this.videoEl.currentTime,
            duration: this.videoEl.duration || 1,
          })
        }
        ended(args) {
          this._fireConsumer('$mediaplayerEnded', args)
          this._setState('')
        }
        pause(args) {
          this._fireConsumer('$mediaplayerPause', args)
          this._setState('Playing.Paused')
        }
        _clearSrc() {
          this._fireConsumer('$mediaplayerStop', {})
          this._setState('')
        }
        static _states() {
          return [class Paused extends this {}]
        }
      },
    ]
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Metadata/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Metadata/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initMetadata: () => (/* binding */ initMetadata)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let metadata = {}

const initMetadata = metadataObj => {
  metadata = metadataObj
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(key, fallback = undefined) {
    return key in metadata ? metadata[key] : fallback
  },
  appId() {
    return this.get('id')
  },
  safeAppId() {
    return this.get('id').replace(/[^0-9a-zA-Z_$]/g, '_')
  },
  appName() {
    return this.get('name')
  },
  appVersion() {
    return (this.get('version') || '').split('-').shift()
  },
  appIcon() {
    return this.get('icon')
  },
  // Version from app store (with commit hash)
  appFullVersion() {
    return this.get('version')
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Metrics/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Metrics/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initMetrics: () => (/* binding */ initMetrics)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



let sendMetric = (type, event, params) => {
  _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Sending metric', type, event, params)
}

const initMetrics = config => {
  sendMetric = config.sendMetric
}

// available metric per category
const metrics = {
  app: ['launch', 'loaded', 'ready', 'close'],
  page: ['view', 'leave'],
  user: ['click', 'input'],
  media: [
    'abort',
    'canplay',
    'ended',
    'pause',
    'play',
    // with some videos there occur almost constant suspend events ... should investigate
    // 'suspend',
    'volumechange',
    'waiting',
    'seeking',
    'seeked',
  ],
}

// error metric function (added to each category)
const errorMetric = (type, message, code, visible, params = {}) => {
  params = { params, ...{ message, code, visible } }
  sendMetric(type, 'error', params)
}

const Metric = (type, events, options = {}) => {
  return events.reduce(
    (obj, event) => {
      obj[event] = (name, params = {}) => {
        params = { ...options, ...(name ? { name } : {}), ...params }
        sendMetric(type, event, params)
      }
      return obj
    },
    {
      error(message, code, params) {
        errorMetric(type, message, code, params)
      },
      event(name, params) {
        sendMetric(type, name, params)
      },
    }
  )
}

const Metrics = types => {
  return Object.keys(types).reduce(
    (obj, type) => {
      // media metric works a bit different!
      // it's a function that accepts a url and returns an object with the available metrics
      // url is automatically passed as a param in every metric
      type === 'media'
        ? (obj[type] = url => Metric(type, types[type], { url }))
        : (obj[type] = Metric(type, types[type]))
      return obj
    },
    { error: errorMetric, event: sendMetric }
  )
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Metrics(metrics));


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Pin/dialog.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Pin/dialog.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PinDialog)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Pin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Pin */ "./node_modules/@lightningjs/sdk/src/Pin/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class PinInput extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      w: 120,
      h: 150,
      rect: true,
      color: 0xff949393,
      alpha: 0.5,
      shader: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].shaders.RoundedRectangle, radius: 10 },
      Nr: {
        w: w => w,
        y: 24,
        text: {
          text: '',
          textColor: 0xff333333,
          fontSize: 80,
          textAlign: 'center',
          verticalAlign: 'middle',
        },
      },
    }
  }

  set index(v) {
    this.x = v * (120 + 24)
  }

  set nr(v) {
    this._timeout && clearTimeout(this._timeout)

    if (v) {
      this.setSmooth('alpha', 1)
    } else {
      this.setSmooth('alpha', 0.5)
    }

    this.tag('Nr').patch({
      text: {
        text: (v && v.toString()) || '',
        fontSize: v === '*' ? 120 : 80,
      },
    })

    if (v && v !== '*') {
      this._timeout = setTimeout(() => {
        this._timeout = null
        this.nr = '*'
      }, 750)
    }
  }
}

class PinDialog extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      zIndex: 1,
      w: w => w,
      h: h => h,
      rect: true,
      color: 0xdd000000,
      alpha: 0.000001,
      Dialog: {
        w: 648,
        h: 320,
        y: h => (h - 320) / 2,
        x: w => (w - 648) / 2,
        rect: true,
        color: 0xdd333333,
        shader: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].shaders.RoundedRectangle, radius: 10 },
        Info: {
          y: 24,
          x: 48,
          text: { text: 'Please enter your PIN', fontSize: 32 },
        },
        Msg: {
          y: 260,
          x: 48,
          text: { text: '', fontSize: 28, textColor: 0xffffffff },
        },
        Code: {
          x: 48,
          y: 96,
        },
      },
    }
  }

  _init() {
    const children = []
    for (let i = 0; i < 4; i++) {
      children.push({
        type: PinInput,
        index: i,
      })
    }

    this.tag('Code').children = children
  }

  get pin() {
    if (!this._pin) this._pin = ''
    return this._pin
  }

  set pin(v) {
    if (v.length <= 4) {
      const maskedPin = new Array(Math.max(v.length - 1, 0)).fill('*', 0, v.length - 1)
      v.length && maskedPin.push(v.length > this._pin.length ? v.slice(-1) : '*')
      for (let i = 0; i < 4; i++) {
        this.tag('Code').children[i].nr = maskedPin[i] || ''
      }
      this._pin = v
    }
  }

  get msg() {
    if (!this._msg) this._msg = ''
    return this._msg
  }

  set msg(v) {
    this._timeout && clearTimeout(this._timeout)

    this._msg = v
    if (this._msg) {
      this.tag('Msg').text = this._msg
      this.tag('Info').setSmooth('alpha', 0.5)
      this.tag('Code').setSmooth('alpha', 0.5)
    } else {
      this.tag('Msg').text = ''
      this.tag('Info').setSmooth('alpha', 1)
      this.tag('Code').setSmooth('alpha', 1)
    }
    this._timeout = setTimeout(() => {
      this.msg = ''
    }, 2000)
  }

  _firstActive() {
    this.setSmooth('alpha', 1)
  }

  _handleKey(event) {
    if (this.msg) {
      this.msg = false
    } else {
      const val = parseInt(event.key)
      if (val > -1) {
        this.pin += val
      }
    }
  }

  _handleBack() {
    if (this.msg) {
      this.msg = false
    } else {
      if (this.pin.length) {
        this.pin = this.pin.slice(0, this.pin.length - 1)
      } else {
        _Pin__WEBPACK_IMPORTED_MODULE_1__["default"].hide()
        this.resolve(false)
      }
    }
  }

  _handleEnter() {
    if (this.msg) {
      this.msg = false
    } else {
      _Pin__WEBPACK_IMPORTED_MODULE_1__["default"].submit(this.pin)
        .then(val => {
          this.msg = 'Unlocking ...'
          setTimeout(() => {
            _Pin__WEBPACK_IMPORTED_MODULE_1__["default"].hide()
          }, 1000)
          this.resolve(val)
        })
        .catch(e => {
          this.msg = e
          this.reject(e)
        })
    }
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Pin/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Pin/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initPin: () => (/* binding */ initPin)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dialog */ "./node_modules/@lightningjs/sdk/src/Pin/dialog.js");
/* harmony import */ var _Launch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Launch */ "./node_modules/@lightningjs/sdk/src/Launch/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../index */ "./node_modules/@lightningjs/sdk/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






// only used during local development
let unlocked = false
const contextItems = ['purchase', 'parental']

let submit = (pin, context) => {
  return new Promise((resolve, reject) => {
    if (pin.toString() === _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'pin', '0000').toString()) {
      unlocked = true
      resolve(unlocked)
    } else {
      reject('Incorrect pin')
    }
  })
}

let check = context => {
  return new Promise(resolve => {
    resolve(unlocked)
  })
}

const initPin = config => {
  if (config.submit && typeof config.submit === 'function') {
    submit = config.submit
  }
  if (config.check && typeof config.check === 'function') {
    check = config.check
  }
}

let pinDialog = null

const contextCheck = context => {
  if (context === undefined) {
    _index__WEBPACK_IMPORTED_MODULE_3__.Log.info('Please provide context explicitly')
    return contextItems[0]
  } else if (!contextItems.includes(context)) {
    _index__WEBPACK_IMPORTED_MODULE_3__.Log.warn('Incorrect context provided')
    return false
  }
  return context
}

// Public API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  show() {
    return new Promise((resolve, reject) => {
      pinDialog = _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.stage.c({
        ref: 'PinDialog',
        type: _dialog__WEBPACK_IMPORTED_MODULE_1__["default"],
        resolve,
        reject,
      })
      _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.childList.a(pinDialog)
      _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.focus = pinDialog
    })
  },
  hide() {
    _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.focus = null
    _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.children = _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.children.map(
      child => child !== pinDialog && child
    )
    pinDialog = null
  },
  submit(pin, context) {
    return new Promise((resolve, reject) => {
      try {
        context = contextCheck(context)
        if (context) {
          submit(pin, context)
            .then(resolve)
            .catch(reject)
        } else {
          reject('Incorrect Context provided')
        }
      } catch (e) {
        reject(e)
      }
    })
  },
  unlocked(context) {
    return new Promise((resolve, reject) => {
      try {
        context = contextCheck(context)
        if (context) {
          check(context)
            .then(resolve)
            .catch(reject)
        } else {
          reject('Incorrect Context provided')
        }
      } catch (e) {
        reject(e)
      }
    })
  },
  locked(context) {
    return new Promise((resolve, reject) => {
      try {
        context = contextCheck(context)
        if (context) {
          check(context)
            .then(unlocked => resolve(!!!unlocked))
            .catch(reject)
        } else {
          reject('Incorrect Context provided')
        }
      } catch (e) {
        reject(e)
      }
    })
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Profile/defaults.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Profile/defaults.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultProfile: () => (/* binding */ defaultProfile)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Profile/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const defaultProfile = {
  ageRating: 'adult',
  city: 'New York',
  zipCode: '27505',
  countryCode: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getCountryCode)('US'),
  ip: '127.0.0.1',
  household: 'b2244e9d4c04826ccd5a7b2c2a50e7d4',
  language: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getLanguage)('en'),
  latlon: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getLatLon)([40.7128, 74.006]),
  locale: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getLocale)('en-US'),
  mac: '00:00:00:00:00:00',
  operator: 'metrological',
  platform: 'metrological',
  packages: [],
  uid: 'ee6723b8-7ab3-462c-8d93-dbf61227998e',
  stbType: 'metrological',
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Profile/helpers.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Profile/helpers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCountryCode: () => (/* binding */ getCountryCode),
/* harmony export */   getLanguage: () => (/* binding */ getLanguage),
/* harmony export */   getLatLon: () => (/* binding */ getLatLon),
/* harmony export */   getLocale: () => (/* binding */ getLocale)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const formatLocale = locale => {
  if (locale && locale.length === 2) {
    return `${locale.toLowerCase()}-${locale.toUpperCase()}`
  } else {
    return locale
  }
}

const getLocale = defaultValue => {
  if ('language' in navigator) {
    const locale = formatLocale(navigator.language)
    return Promise.resolve(locale)
  } else {
    return Promise.resolve(defaultValue)
  }
}

const getLanguage = defaultValue => {
  if ('language' in navigator) {
    const language = formatLocale(navigator.language).slice(0, 2)
    return Promise.resolve(language)
  } else {
    return Promise.resolve(defaultValue)
  }
}

const getCountryCode = defaultValue => {
  if ('language' in navigator) {
    const countryCode = formatLocale(navigator.language).slice(3, 5)
    return Promise.resolve(countryCode)
  } else {
    return Promise.resolve(defaultValue)
  }
}

const hasOrAskForGeoLocationPermission = () => {
  return new Promise(resolve => {
    // force to prompt for location permission
    if (_Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'forceBrowserGeolocation') === true) resolve(true)
    if ('permissions' in navigator && typeof navigator.permissions.query === 'function') {
      navigator.permissions.query({ name: 'geolocation' }).then(status => {
        resolve(status.state === 'granted' || status.status === 'granted')
      })
    } else {
      resolve(false)
    }
  })
}

const getLatLon = defaultValue => {
  return new Promise(resolve => {
    hasOrAskForGeoLocationPermission().then(granted => {
      if (granted === true) {
        if ('geolocation' in navigator) {
          navigator.geolocation.getCurrentPosition(
            // success
            result =>
              result && result.coords && resolve([result.coords.latitude, result.coords.longitude]),
            // error
            () => resolve(defaultValue),
            // options
            {
              enableHighAccuracy: true,
              timeout: 5000,
              maximumAge: 0,
            }
          )
        } else {
          return queryForLatLon().then(result => resolve(result || defaultValue))
        }
      } else {
        return queryForLatLon().then(result => resolve(result || defaultValue))
      }
    })
  })
}

const queryForLatLon = () => {
  return new Promise(resolve => {
    fetch('https://geolocation-db.com/json/')
      .then(response => response.json())
      .then(({ latitude, longitude }) =>
        latitude && longitude ? resolve([latitude, longitude]) : resolve(false)
      )
      .catch(() => resolve(false))
  })
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Profile/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Profile/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initProfile: () => (/* binding */ initProfile)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaults */ "./node_modules/@lightningjs/sdk/src/Profile/defaults.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let getInfo = key => {
  const profile = { ..._defaults__WEBPACK_IMPORTED_MODULE_1__.defaultProfile, ..._Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'profile') }
  return Promise.resolve(typeof profile[key] === 'function' ? profile[key]() : profile[key])
}

let setInfo = (key, params) => {
  if (key in _defaults__WEBPACK_IMPORTED_MODULE_1__.defaultProfile) _defaults__WEBPACK_IMPORTED_MODULE_1__.defaultProfile[key] = params
}

const initProfile = config => {
  getInfo = config.getInfo
  setInfo = config.setInfo
}

const getOrSet = (key, params) => (params ? setInfo(key, params) : getInfo(key))

// public API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ageRating(params) {
    return getOrSet('ageRating', params)
  },
  city(params) {
    return getOrSet('city', params)
  },
  zipCode(params) {
    return getOrSet('zipCode', params)
  },
  countryCode(params) {
    return getOrSet('countryCode', params)
  },
  ip(params) {
    return getOrSet('ip', params)
  },
  household(params) {
    return getOrSet('household', params)
  },
  language(params) {
    return getOrSet('language', params)
  },
  latlon(params) {
    return getOrSet('latlon', params)
  },
  locale(params) {
    return getOrSet('locale', params)
  },
  mac(params) {
    return getOrSet('mac', params)
  },
  operator(params) {
    return getOrSet('operator', params)
  },
  platform(params) {
    return getOrSet('platform', params)
  },
  packages(params) {
    return getOrSet('packages', params)
  },
  uid(params) {
    return getOrSet('uid', params)
  },
  stbType(params) {
    return getOrSet('stbType', params)
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Purchase/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Purchase/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initPurchase: () => (/* binding */ initPurchase)
/* harmony export */ });
/* harmony import */ var _Profile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Profile */ "./node_modules/@lightningjs/sdk/src/Profile/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _helpers_sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/sequence */ "./node_modules/@lightningjs/sdk/src/helpers/sequence.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





let cspUrl = 'http://payment-csp-example.metrological.com:8080/'
let billingUrl = 'https://payment-sdk.metrological.com/'

let cspEndpoints = {
  assets: {
    uri: '/assets',
    method: 'GET',
  },
  asset: {
    uri: '/assets/:id',
    method: 'GET',
  },
  signature: {
    uri: '/assets/:id/signature',
    method: 'POST',
  },
  subscribe: {
    uri: '/assets/:id/subscribe',
    method: 'POST',
  },
  unsubscribe: {
    uri: '/assets/:id/unsubscribe',
    method: 'POST',
  },
}

const initPurchase = config => {
  if (config.billingUrl) billingUrl = config.billingUrl
}

const createUrl = (uri, baseUrl, params = {}) => {
  return new URL(
    // sprinkle in the params
    Object.keys(params)
      .reduce((res, key) => res.replace(new RegExp(':' + key, 'g'), params[key]), uri)
      // remove any leading slash from uri
      .replace(/^\//, ''),
    // make sure baseUrl always has a trailing slash
    /\/$/.test(baseUrl) ? baseUrl : baseUrl.replace(/$/, '/')
  )
}

const request = (url, method = 'GET', data, headers = {}) => {
  if (method === 'GET' && data) {
    url.search = new URLSearchParams(data)
  }

  return new Promise((resolve, reject) => {
    fetch(url, {
      headers: {
        ...{
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        ...headers,
      },
      method: method,
      body: method !== 'GET' && data ? JSON.stringify(data) : null,
    })
      .then(response => (response.ok ? resolve(response.json()) : reject(response.statusText)))
      .catch(reject)
  })
}

const cspRequest = (type, data = null, params = {}) => {
  return new Promise((resolve, reject) => {
    const endpoint = cspEndpoints[type]

    if (!endpoint) {
      reject('No endpoint found for "' + type + '" call')
    } else {
      if (endpoint.callback && typeof endpoint.callback === 'function') {
        endpoint
          .callback(data, params)
          .then(resolve)
          .catch(reject)
      } else {
        request(
          createUrl(endpoint.uri, cspUrl, params),
          endpoint.method,
          {
            ...(endpoint.data || {}),
            ...data,
          },
          endpoint.headers || {}
        )
          .then(resolve)
          .catch(reject)
      }
    }
  })
}

const billingRequest = (uri, data, method = 'POST') => {
  return new Promise((resolve, reject) => {
    request(createUrl(uri, billingUrl), method, data)
      .then(resolve)
      .catch(reject)
  })
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setup(config) {
    if (config.cspUrl) cspUrl = config.cspUrl
    if (config.endpoints) cspEndpoints = { cspEndpoints, ...config.endpoints }
  },
  assets() {
    return new Promise((resolve, reject) => {
      _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household().then(household => {
        cspRequest('assets', { household })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  asset(id) {
    return new Promise((resolve, reject) => {
      _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household().then(household => {
        cspRequest('asset', { household }, { id })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  signature(id) {
    return new Promise((resolve, reject) => {
      Promise.all([_Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household()]).then(([household]) => {
        cspRequest('signature', { household }, { id })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  subscribe(id, transaction) {
    return new Promise((resolve, reject) => {
      cspRequest('subscribe', { ...transaction }, { id })
        .then(resolve)
        .catch(reject)
    })
  },
  unsubscribe(id) {
    return new Promise((resolve, reject) => {
      _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household().then(household => {
        cspRequest('unsubscribe', { household }, { id })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  payment(signature = {}, type = 'in-app') {
    return new Promise((resolve, reject) => {
      Promise.all([
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].countryCode(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].operator(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].mac(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].uid(),
      ])
        .then(([household, country, operator, mac, uid]) => {
          billingRequest('/', {
            purchase: signature,
            identifier: _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('app', 'id'),
            name: _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('app', 'id'),
            household,
            country,
            operator,
            mac,
            uid,
            type,
          })
            .then(resolve)
            .catch(reject)
        })
        .catch(reject)
    })
  },
  confirm(transactionId) {
    return new Promise((resolve, reject) => {
      billingRequest('/confirm', {
        transactionId,
      })
        .then(resolve)
        .catch(reject)
    })
  },
  buy(assetId, type) {
    return new Promise((resolve, reject) => {
      let transactionId
      ;(0,_helpers_sequence__WEBPACK_IMPORTED_MODULE_2__["default"])([
        () => this.signature(assetId),
        signature => this.payment(signature, type),
        transaction => {
          transactionId = transaction.transactionId
          return this.subscribe(assetId, transaction)
        },
        () => this.confirm(transactionId),
      ])
        .then(resolve)
        .catch(reject)
    })
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Registry/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Registry/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const registry = {
  eventListeners: [],
  timeouts: [],
  intervals: [],
  targets: [],
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  // Timeouts
  setTimeout(cb, timeout, ...params) {
    const timeoutId = setTimeout(
      () => {
        registry.timeouts = registry.timeouts.filter(id => id !== timeoutId)
        cb.apply(null, params)
      },
      timeout,
      params
    )
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Set Timeout', 'ID: ' + timeoutId)
    registry.timeouts.push(timeoutId)
    return timeoutId
  },

  clearTimeout(timeoutId) {
    if (registry.timeouts.indexOf(timeoutId) > -1) {
      registry.timeouts = registry.timeouts.filter(id => id !== timeoutId)
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Clear Timeout', 'ID: ' + timeoutId)
      clearTimeout(timeoutId)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Clear Timeout', 'ID ' + timeoutId + ' not found')
    }
  },

  clearTimeouts() {
    registry.timeouts.forEach(timeoutId => {
      this.clearTimeout(timeoutId)
    })
  },

  // Intervals
  setInterval(cb, interval, ...params) {
    const intervalId = setInterval(
      () => {
        registry.intervals.filter(id => id !== intervalId)
        cb.apply(null, params)
      },
      interval,
      params
    )
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Set Interval', 'ID: ' + intervalId)
    registry.intervals.push(intervalId)
    return intervalId
  },

  clearInterval(intervalId) {
    if (registry.intervals.indexOf(intervalId) > -1) {
      registry.intervals = registry.intervals.filter(id => id !== intervalId)
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Clear Interval', 'ID: ' + intervalId)
      clearInterval(intervalId)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Clear Interval', 'ID ' + intervalId + ' not found')
    }
  },

  clearIntervals() {
    registry.intervals.forEach(intervalId => {
      this.clearInterval(intervalId)
    })
  },

  // Event listeners
  addEventListener(target, event, handler) {
    target.addEventListener(event, handler)
    const targetIndex =
      registry.targets.indexOf(target) > -1
        ? registry.targets.indexOf(target)
        : registry.targets.push(target) - 1

    registry.eventListeners[targetIndex] = registry.eventListeners[targetIndex] || {}
    registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event] || []
    registry.eventListeners[targetIndex][event].push(handler)
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info(
      'Add eventListener',
      'Target:',
      target,
      'Event: ' + event,
      'Handler:',
      handler.toString()
    )
  },

  removeEventListener(target, event, handler) {
    const targetIndex = registry.targets.indexOf(target)
    if (
      targetIndex > -1 &&
      registry.eventListeners[targetIndex] &&
      registry.eventListeners[targetIndex][event] &&
      registry.eventListeners[targetIndex][event].indexOf(handler) > -1
    ) {
      registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][
        event
      ].filter(fn => fn !== handler)
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info(
        'Remove eventListener',
        'Target:',
        target,
        'Event: ' + event,
        'Handler:',
        handler.toString()
      )
      target.removeEventListener(event, handler)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(
        'Remove eventListener',
        'Not found',
        'Target',
        target,
        'Event: ' + event,
        'Handler',
        handler.toString()
      )
    }
  },

  // if `event` is omitted, removes all registered event listeners for target
  // if `target` is also omitted, removes all registered event listeners
  removeEventListeners(target, event) {
    if (target && event) {
      const targetIndex = registry.targets.indexOf(target)
      if (targetIndex > -1) {
        registry.eventListeners[targetIndex][event].forEach(handler => {
          this.removeEventListener(target, event, handler)
        })
      }
    } else if (target) {
      const targetIndex = registry.targets.indexOf(target)
      if (targetIndex > -1) {
        Object.keys(registry.eventListeners[targetIndex]).forEach(_event => {
          this.removeEventListeners(target, _event)
        })
      }
    } else {
      Object.keys(registry.eventListeners).forEach(targetIndex => {
        this.removeEventListeners(registry.targets[targetIndex])
      })
    }
  },

  // Clear everything (to be called upon app close for proper cleanup)
  clear() {
    this.clearTimeouts()
    this.clearIntervals()
    this.removeEventListeners()
    registry.eventListeners = []
    registry.timeouts = []
    registry.intervals = []
    registry.targets = []
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/base.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RoutedApp: () => (/* binding */ RoutedApp)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _utils_router_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/router.js */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class RoutedApp extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      Pages: {
        forceZIndexContext: true,
      },
      /**
       * This is a default Loading page that will be made visible
       * during data-provider on() you CAN override in child-class
       */
      Loading: {
        rect: true,
        w: 1920,
        h: 1080,
        color: 0xff000000,
        visible: false,
        zIndex: 99,
        Label: {
          mount: 0.5,
          x: 960,
          y: 540,
          text: {
            text: 'Loading..',
          },
        },
      },
    }
  }

  static _states() {
    return [
      class Loading extends this {
        $enter() {
          this.tag('Loading').visible = true
        }

        $exit() {
          this.tag('Loading').visible = false
        }
      },
      class Widgets extends this {
        $enter(args, widget) {
          // store widget reference
          this._widget = widget

          // since it's possible that this behaviour
          // is non-remote driven we force a recalculation
          // of the focuspath
          this._refocus()
        }

        _getFocused() {
          // we delegate focus to selected widget
          // so it can consume remotecontrol presses
          return this._widget
        }

        // if we want to widget to widget focus delegation
        reload(widget) {
          this._widget = widget
          this._refocus()
        }

        _handleKey() {
          const restoreFocus = _utils_router_js__WEBPACK_IMPORTED_MODULE_2__.routerConfig.get('autoRestoreRemote')
          /**
           * The Router used to delegate focus back to the page instance on
           * every unhandled key. This is barely usefull in any situation
           * so for now we offer the option to explicity turn that behaviour off
           * so we don't don't introduce a breaking change.
           */
          if (!(0,_utils_helpers__WEBPACK_IMPORTED_MODULE_3__.isBoolean)(restoreFocus) || restoreFocus === true) {
            _index__WEBPACK_IMPORTED_MODULE_1__["default"].focusPage()
          }
        }
      },
    ]
  }

  /**
   * Return location where pages need to be stored
   */
  get pages() {
    return this.tag('Pages')
  }

  /**
   * Tell router where widgets are stored
   */
  get widgets() {
    return this.tag('Widgets')
  }

  /**
   * we MUST register _handleBack method so the Router
   * can override it
   * @private
   */
  _handleBack() {}

  /**
   * We MUST return Router.activePage() so the new Page
   * can listen to the remote-control.
   */
  _getFocused() {
    return _index__WEBPACK_IMPORTED_MODULE_1__["default"].getActivePage()
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getResumeHash: () => (/* binding */ getResumeHash),
/* harmony export */   initRouter: () => (/* binding */ initRouter),
/* harmony export */   navigate: () => (/* binding */ navigate),
/* harmony export */   navigateQueue: () => (/* binding */ navigateQueue),
/* harmony export */   step: () => (/* binding */ step)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _utils_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _utils_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/* harmony import */ var _utils_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/history */ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js");
/* harmony import */ var _utils_route__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _utils_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/loader */ "./node_modules/@lightningjs/sdk/src/Router/utils/loader.js");
/* harmony import */ var _utils_regex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base */ "./node_modules/@lightningjs/sdk/src/Router/base.js");
/* harmony import */ var _Registry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Registry */ "./node_modules/@lightningjs/sdk/src/Registry/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













/*
rouThor ==[x]
 */
let navigateQueue = new Map()
let forcedHash = ''
let resumeHash = ''

/**
 * Start routing the app
 * @param config - route config object
 * @param instance - instance of the app
 */
const startRouter = (config, instance) => {
  ;(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.bootRouter)(config, instance)
  registerListener()
  start()
}

// start translating url
const start = () => {
  let hash = (getHash() || '').replace(/^#/, '')
  const bootKey = '$'
  const params = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.getQueryStringParams)(hash)
  const bootRequest = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getBootRequest)()
  const rootHash = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getRootHash)()
  const isDirectLoad = hash.indexOf(bootKey) !== -1

  // prevent direct reload of wildcard routes
  // expect bootComponent
  if (_utils_regex__WEBPACK_IMPORTED_MODULE_6__.isWildcard.test(hash) && hash !== bootKey) {
    hash = ''
  }

  // store resume point for manual resume
  resumeHash = isDirectLoad ? rootHash : hash || rootHash

  const ready = () => {
    if (!hash && rootHash) {
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(rootHash)) {
        navigate(rootHash)
      } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(rootHash)) {
        rootHash().then(res => {
          if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
            navigate(res.path, res.params)
          } else {
            navigate(res)
          }
        })
      }
    } else {
      queue(hash)
      handleHashChange()
        .then(() => {
          _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
        })
        .catch(e => {
          console.error(e)
        })
    }
  }

  if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(bootKey)) {
    if (hash && !isDirectLoad) {
      if (!(0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getRouteByHash)(hash)) {
        navigate('*', { failedHash: hash })
        return
      }
    }
    navigate(
      bootKey,
      {
        resume: resumeHash,
        reload: bootKey === hash,
      },
      false
    )
  } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(bootRequest)) {
    bootRequest(params)
      .then(() => {
        ready()
      })
      .catch(e => {
        handleBootError(e)
      })
  } else {
    ready()
  }
}

const handleBootError = e => {
  if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)('!')) {
    navigate('!', { request: { error: e } })
  } else {
    console.error(e)
  }
}

/**
 * start a new request
 * @param url
 * @param args
 * @param store
 */
const navigate = (url, args = {}, store) => {
  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(url)) {
    url = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getHashByName)(url)
    if (!url) {
      return
    }
  }

  let hash = getHash()
  if (!(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.mustUpdateLocationHash)() && forcedHash) {
    hash = forcedHash
  }
  if (hash.replace(/^#/, '') !== url) {
    // push request in the queue
    queue(url, args, store)

    setHash(url)
    if (!(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.mustUpdateLocationHash)()) {
      forcedHash = url
      handleHashChange(url)
        .then(() => {
          _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
        })
        .catch(e => {
          console.error(e)
        })
    }
  } else if (args.reload) {
    // push request in the queue
    queue(url, args, store)

    handleHashChange(url)
      .then(() => {
        _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
      })
      .catch(e => {
        console.error(e)
      })
  }
}

const queue = (hash, args = {}, store) => {
  hash = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.cleanHash)(hash)
  if (!navigateQueue.has(hash)) {
    for (let request of navigateQueue.values()) {
      request.cancel()
    }
    const request = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.createRequest)(hash, args, store)
    navigateQueue.set(decodeURIComponent(hash), request)

    return request
  }
  return false
}

/**
 * Handle change of hash
 * @param override
 * @returns {Promise<void>}
 */
const handleHashChange = async override => {
  const hash = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.cleanHash)(override || getHash())
  const queueId = decodeURIComponent(hash)
  let request = navigateQueue.get(queueId)

  // handle hash updated manually
  if (!request && !navigateQueue.size) {
    request = queue(hash)
  }

  const route = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getRouteByHash)(hash)

  if (!route) {
    if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)('*')) {
      navigate('*', { failedHash: hash })
    } else {
      console.error(`Unable to navigate to: ${hash}`)
    }
    return
  }

  // update current processed request
  request.hash = hash
  request.route = route

  let result = await (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.beforeEachRoute)((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash)(), request)

  // test if a local hook is configured for the route
  if (route.beforeNavigate) {
    result = await route.beforeNavigate((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash)(), request)
  }

  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(result)) {
    // only if resolve value is explicitly true
    // we continue the current route request
    if (result) {
      return resolveHashChange(request)
    }
  } else {
    // if navigation guard didn't return true
    // we cancel the current request
    request.cancel()
    navigateQueue.delete(queueId)

    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(result)) {
      navigate(result)
    } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(result)) {
      let store = true
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(result.store)) {
        store = result.store
      }
      navigate(result.path, result.params, store)
    }
  }
}

/**
 * Continue processing the hash change if not blocked
 * by global or local hook
 * @param request - {}
 */
const resolveHashChange = request => {
  const hash = request.hash
  const route = request.route
  const queueId = decodeURIComponent(hash)
  // store last requested hash so we can
  // prevent a route that resolved later
  // from displaying itself
  ;(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.setLastHash)(hash)

  if (route.path) {
    const component = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getComponent)(route.path)
    // if a hook is provided for the current route
    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(route.hook)) {
      const urlParams = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getValuesFromHash)(hash, route.path)
      const params = {}
      for (const key of urlParams.keys()) {
        params[key] = urlParams.get(key)
      }
      route.hook(_utils_router__WEBPACK_IMPORTED_MODULE_1__.app, { ...params })
    }
    // if there is a component attached to the route
    if (component) {
      // force page to root state to prevent shared state issues
      const activePage = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActivePage)()
      if (activePage) {
        const keepAlive = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.keepActivePageAlive)((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveRoute)(), request)
        if (activePage && route.path === (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveRoute)() && !keepAlive) {
          activePage._setState('')
        }
      }

      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isPage)(component, _utils_router__WEBPACK_IMPORTED_MODULE_1__.stage)) {
        (0,_utils_loader__WEBPACK_IMPORTED_MODULE_5__.load)(request).then(() => {
          _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
          navigateQueue.delete(queueId)
        })
      } else {
        // of the component is not a constructor
        // or a Component instance we can assume
        // that it's a dynamic import
        component()
          .then(contents => {
            return contents.default
          })
          .then(module => {
            (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.storeComponent)(route.path, module)
            return (0,_utils_loader__WEBPACK_IMPORTED_MODULE_5__.load)(request)
          })
          .then(() => {
            _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
            navigateQueue.delete(queueId)
          })
      }
    } else {
      navigateQueue.delete(queueId)
    }
  }
}

/**
 * Directional step in history
 * @param direction
 */
const step = (level = 0) => {
  if (!level || isNaN(level)) {
    return false
  }
  const history = (0,_utils_history__WEBPACK_IMPORTED_MODULE_3__.getHistory)()
  // for now we only support negative numbers
  level = Math.abs(level)

  // we can't step back past the amount
  // of history entries
  if (level > history.length) {
    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(_utils_router__WEBPACK_IMPORTED_MODULE_1__.app._handleAppClose)) {
      return _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._handleAppClose()
    }
    return false
  } else if (history.length) {
    // for now we only support history back
    const route = history.splice(history.length - level, level)[0]
    // store changed history
    ;(0,_utils_history__WEBPACK_IMPORTED_MODULE_3__.setHistory)(history)
    return navigate(
      route.hash,
      {
        [_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.backtrack]: true,
        [_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.historyState]: route.state,
      },
      false
    )
  } else if (_utils_router__WEBPACK_IMPORTED_MODULE_1__.routerConfig.get('backtrack')) {
    const hashLastPart = /(\/:?[\w%\s-]+)$/
    let hash = (0,_utils_regex__WEBPACK_IMPORTED_MODULE_6__.stripRegex)(getHash())
    let floor = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getFloor)(hash)

    // test if we got deep-linked
    if (floor > 1) {
      while (floor--) {
        // strip of last part
        hash = hash.replace(hashLastPart, '')
        // if we have a configured route
        // we navigate to it
        if ((0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getRouteByHash)(hash)) {
          return navigate(hash, { [_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.backtrack]: true }, false)
        }
      }
    }
  }
  return false
}

/**
 * Resume Router's page loading process after
 * the BootComponent became visible;
 */
const resume = () => {
  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(resumeHash)) {
    navigate(resumeHash, false)
    resumeHash = ''
  } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(resumeHash)) {
    resumeHash().then(res => {
      resumeHash = ''
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
        navigate(res.path, res.params)
      } else {
        navigate(res)
      }
    })
  } else {
    console.warn('[Router]: resume() called but no hash found')
  }
}

/**
 * Force reload active hash
 */
const reload = () => {
  if (!isNavigating()) {
    const hash = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash)()
    navigate(hash, { reload: true }, false)
  }
}

/**
 * Query if the Router is still processing a Request
 * @returns {boolean}
 */
const isNavigating = () => {
  if (navigateQueue.size) {
    let isProcessing = false
    for (let request of navigateQueue.values()) {
      if (!request.isCancelled) {
        isProcessing = true
      }
    }
    return isProcessing
  }
  return false
}

const getResumeHash = () => {
  return resumeHash
}

/**
 * By default we return the location hash
 * @returns {string}
 */
let getHash = () => {
  return document.location.hash
}

/**
 * Update location hash
 * @param url
 */
let setHash = url => {
  document.location.hash = url
}

/**
 * This can be called from the platform / bootstrapper to override
 * the default getting and setting of the hash
 * @param config
 */
const initRouter = config => {
  if (config.getHash) {
    getHash = config.getHash
  }
  if (config.setHash) {
    setHash = config.setHash
  }
}

/**
 * On hash change we start processing
 */
const registerListener = () => {
  _Registry__WEBPACK_IMPORTED_MODULE_8__["default"].addEventListener(window, 'hashchange', async () => {
    if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.mustUpdateLocationHash)()) {
      try {
        await handleHashChange()
      } catch (e) {
        console.error(e)
      }
    }
  })
}

/**
 * Navigate to root hash
 */
const root = () => {
  const rootHash = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getRootHash)()
  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(rootHash)) {
    navigate(rootHash)
  } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(rootHash)) {
    rootHash().then(res => {
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
        navigate(res.path, res.params)
      } else {
        navigate(res)
      }
    })
  }
}

// export API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  startRouter,
  navigate,
  resume,
  step,
  go: step,
  back: step.bind(null, -1),
  activePage: _utils_router__WEBPACK_IMPORTED_MODULE_1__.getActivePage,
  getActivePage() {
    // warning
    return (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActivePage)()
  },
  getActiveRoute: _utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveRoute,
  getActiveHash: _utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash,
  focusWidget: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.focusWidget,
  getActiveWidget: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.getActiveWidget,
  restoreFocus: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.restoreFocus,
  isNavigating,
  getHistory: _utils_history__WEBPACK_IMPORTED_MODULE_3__.getHistory,
  setHistory: _utils_history__WEBPACK_IMPORTED_MODULE_3__.setHistory,
  getHistoryState: _utils_history__WEBPACK_IMPORTED_MODULE_3__.getHistoryState,
  replaceHistoryState: _utils_history__WEBPACK_IMPORTED_MODULE_3__.replaceHistoryState,
  getQueryStringParams: _utils_helpers__WEBPACK_IMPORTED_MODULE_0__.getQueryStringParams,
  reload,
  symbols: _utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols,
  App: _base__WEBPACK_IMPORTED_MODULE_7__.RoutedApp,
  // keep backwards compatible
  focusPage: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.restoreFocus,
  root: root,
  /**
   * Deprecated api methods
   */
  setupRoutes() {
    console.warn('Router: setupRoutes is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
  on() {
    console.warn('Router.on() is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
  before() {
    console.warn('Router.before() is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
  after() {
    console.warn('Router.after() is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/model/Request.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/model/Request.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Request)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _utils_register__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/register */ "./node_modules/@lightningjs/sdk/src/Router/utils/register.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class Request {
  constructor(hash = '', navArgs, storeCaller) {
    /**
     * Hash we navigate to
     * @type {string}
     * @private
     */
    this._hash = hash

    /**
     * Do we store previous hash in history
     * @type {boolean}
     * @private
     */
    this._storeCaller = storeCaller

    /**
     * Request and navigate data
     * @type {Map}
     * @private
     */
    this._register = new Map()

    /**
     * Flag if the instance is created due to
     * this request
     * @type {boolean}
     * @private
     */
    this._isCreated = false

    /**
     * Flag if the instance is shared between
     * previous and current request
     * @type {boolean}
     * @private
     */
    this._isSharedInstance = false

    /**
     * Flag if the request has been cancelled
     * @type {boolean}
     * @private
     */
    this._cancelled = false

    /**
     * if instance is shared between requests we copy state object
     * from instance before the new request overrides state
     * @type {null}
     * @private
     */
    this._copiedHistoryState = null

    // if there are arguments attached to navigate()
    // we store them in new request
    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(navArgs)) {
      this._register = (0,_utils_register__WEBPACK_IMPORTED_MODULE_1__.createRegister)(navArgs)
    } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(navArgs)) {
      // if second navigate() argument is explicitly
      // set to false we prevent the calling page
      // from ending up in history
      this._storeCaller = navArgs
    }
    // @todo: remove because we can simply check
    // ._storeCaller property
    this._register.set(_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.store, this._storeCaller)
  }

  cancel() {
    _Log__WEBPACK_IMPORTED_MODULE_2__["default"].debug('[router]:', `cancelled ${this._hash}`)
    this._cancelled = true
  }

  get url() {
    return this._hash
  }

  get register() {
    return this._register
  }

  get hash() {
    return this._hash
  }

  set hash(args) {
    this._hash = args
  }

  get route() {
    return this._route
  }

  set route(args) {
    this._route = args
  }

  get provider() {
    return this._provider
  }

  set provider(args) {
    this._provider = args
  }

  get providerType() {
    return this._providerType
  }

  set providerType(args) {
    this._providerType = args
  }

  set page(args) {
    this._page = args
  }

  get page() {
    return this._page
  }

  set isCreated(args) {
    this._isCreated = args
  }

  get isCreated() {
    return this._isCreated
  }

  get isSharedInstance() {
    return this._isSharedInstance
  }

  set isSharedInstance(args) {
    this._isSharedInstance = args
  }

  get isCancelled() {
    return this._cancelled
  }

  set copiedHistoryState(v) {
    this._copiedHistoryState = v
  }

  get copiedHistoryState() {
    return this._copiedHistoryState
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/model/Route.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/model/Route.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Route)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Route {
  constructor(config = {}) {
    // keep backwards compatible
    let type = ['on', 'before', 'after'].reduce((acc, type) => {
      return (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config[type]) ? type : acc
    }, undefined)

    this._cfg = config
    if (type) {
      this._provider = {
        type,
        request: config[type],
      }
    }
  }

  get path() {
    return this._cfg.path
  }

  get component() {
    return this._cfg.component
  }

  get options() {
    return this._cfg.options
  }

  get widgets() {
    return this._cfg.widgets
  }

  get cache() {
    return this._cfg.cache
  }

  get hook() {
    return this._cfg.hook
  }

  get beforeNavigate() {
    return this._cfg.beforeNavigate
  }

  get provider() {
    return this._provider
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/transitions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/transitions.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const fade = (i, o) => {
  return new Promise(resolve => {
    i.patch({
      alpha: 0,
      visible: true,
      smooth: {
        alpha: [1, { duration: 0.5, delay: 0.1 }],
      },
    })
    // resolve on y finish
    i.transition('alpha').on('finish', () => {
      if (o) {
        o.visible = false
      }
      resolve()
    })
  })
}

const crossFade = (i, o) => {
  return new Promise(resolve => {
    i.patch({
      alpha: 0,
      visible: true,
      smooth: {
        alpha: [1, { duration: 0.5, delay: 0.1 }],
      },
    })
    if (o) {
      o.patch({
        smooth: {
          alpha: [0, { duration: 0.5, delay: 0.3 }],
        },
      })
    }
    // resolve on y finish
    i.transition('alpha').on('finish', () => {
      resolve()
    })
  })
}

const moveOnAxes = (axis, direction, i, o) => {
  const bounds = axis === 'x' ? 1920 : 1080
  return new Promise(resolve => {
    i.patch({
      [`${axis}`]: direction ? bounds * -1 : bounds,
      visible: true,
      smooth: {
        [`${axis}`]: [0, { duration: 0.4, delay: 0.2 }],
      },
    })
    // out is optional
    if (o) {
      o.patch({
        [`${axis}`]: 0,
        smooth: {
          [`${axis}`]: [direction ? bounds : bounds * -1, { duration: 0.4, delay: 0.2 }],
        },
      })
    }
    // resolve on y finish
    i.transition(axis).on('finish', () => {
      resolve()
    })
  })
}

const up = (i, o) => {
  return moveOnAxes('y', 0, i, o)
}

const down = (i, o) => {
  return moveOnAxes('y', 1, i, o)
}

const left = (i, o) => {
  return moveOnAxes('x', 0, i, o)
}

const right = (i, o) => {
  return moveOnAxes('x', 1, i, o)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  fade,
  crossFade,
  up,
  down,
  left,
  right,
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/components.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/components.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createComponent: () => (/* binding */ createComponent)
/* harmony export */ });
/* harmony import */ var _widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const createComponent = (stage, type) => {
  return stage.c({
    type,
    visible: false,
    widgets: (0,_widgets__WEBPACK_IMPORTED_MODULE_0__.getReferences)(),
  })
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/emit.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((page, events = [], params = {}) => {
  if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(events)) {
    events = [events]
  }
  events.forEach(e => {
    const event = `_on${(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.ucfirst)(e)}`
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(page[event])) {
      page[event](params)
    }
  })
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cleanHash: () => (/* binding */ cleanHash),
/* harmony export */   getConfigMap: () => (/* binding */ getConfigMap),
/* harmony export */   getQueryStringParams: () => (/* binding */ getQueryStringParams),
/* harmony export */   incorrectParams: () => (/* binding */ incorrectParams),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isComponentConstructor: () => (/* binding */ isComponentConstructor),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isPage: () => (/* binding */ isPage),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   objectToQueryString: () => (/* binding */ objectToQueryString),
/* harmony export */   symbols: () => (/* binding */ symbols),
/* harmony export */   ucfirst: () => (/* binding */ ucfirst)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const isFunction = v => {
  return typeof v === 'function'
}

const isObject = v => {
  return typeof v === 'object' && v !== null
}

const isBoolean = v => {
  return typeof v === 'boolean'
}

const isPage = v => {
  if (v instanceof _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Element || isComponentConstructor(v)) {
    return true
  }
  return false
}

const isComponentConstructor = type => {
  return type.prototype && 'isComponent' in type.prototype
}

const isArray = v => {
  return Array.isArray(v)
}

const ucfirst = v => {
  return `${v.charAt(0).toUpperCase()}${v.slice(1)}`
}

const isString = v => {
  return typeof v === 'string'
}

const isPromise = method => {
  let result
  if (isFunction(method)) {
    try {
      result = method.apply(null)
    } catch (e) {
      result = e
    }
  } else {
    result = method
  }
  return isObject(result) && isFunction(result.then)
}

const cleanHash = (hash = '') => {
  return hash.replace(/^#/, '').replace(/\/+$/, '')
}

const getConfigMap = () => {
  const routerSettings = _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'router')
  const isObj = isObject(routerSettings)
  return [
    'backtrack',
    'gcOnUnload',
    'destroyOnHistoryBack',
    'lazyCreate',
    'lazyDestroy',
    'reuseInstance',
    'autoRestoreRemote',
    'numberNavigation',
    'updateHash',
    'storeSameHash',
  ].reduce((config, key) => {
    config.set(key, isObj ? routerSettings[key] : _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', key))
    return config
  }, new Map())
}

const incorrectParams = (cb, route) => {
  const isIncorrect = /^\w*?\s?\(\s?\{.*?\}\s?\)/i
  if (isIncorrect.test(cb.toString())) {
    console.warn(
      [
        `DEPRECATION: The data-provider for route: ${route} is not correct.`,
        '"page" is no longer a property of the params object but is now the first function parameter: ',
        'https://github.com/rdkcentral/Lightning-SDK/blob/feature/router/docs/plugins/router/dataproviding.md#data-providing',
        "It's supported for now but will be removed in a future release.",
      ].join('\n')
    )
    return true
  }
  return false
}

const getQueryStringParams = (hash = (0,_router__WEBPACK_IMPORTED_MODULE_2__.getActiveHash)()) => {
  const resumeHash = (0,_index__WEBPACK_IMPORTED_MODULE_3__.getResumeHash)()
  if ((hash === '$' || !hash) && resumeHash) {
    if (isString(resumeHash)) {
      hash = resumeHash
    }
  }

  let parse = ''
  const getQuery = /([?&].*)/
  const matches = getQuery.exec(hash)
  const params = {}

  if (document.location && document.location.search) {
    parse = document.location.search
  }

  if (matches && matches.length) {
    let hashParams = matches[1]
    if (parse) {
      // if location.search is not empty we
      // remove the leading ? to create a
      // valid string
      hashParams = hashParams.replace(/^\?/, '')
      // we parse hash params last so they we can always
      // override search params with hash params
      parse = `${parse}&${hashParams}`
    } else {
      parse = hashParams
    }
  }

  if (parse) {
    const urlParams = new URLSearchParams(parse)
    for (const [key, value] of urlParams.entries()) {
      params[key] = value
    }
    return params
  } else {
    return false
  }
}

const objectToQueryString = obj => {
  if (!isObject(obj)) {
    return ''
  }
  return (
    '?' +
    Object.keys(obj)
      .map(key => {
        return `${key}=${obj[key]}`
      })
      .join('&')
  )
}

const symbols = {
  route: Symbol('route'),
  hash: Symbol('hash'),
  store: Symbol('store'),
  fromHistory: Symbol('fromHistory'),
  expires: Symbol('expires'),
  resume: Symbol('resume'),
  backtrack: Symbol('backtrack'),
  historyState: Symbol('historyState'),
  queryParams: Symbol('queryParams'),
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/history.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHistory: () => (/* binding */ getHistory),
/* harmony export */   getHistoryState: () => (/* binding */ getHistoryState),
/* harmony export */   replaceHistoryState: () => (/* binding */ replaceHistoryState),
/* harmony export */   setHistory: () => (/* binding */ setHistory),
/* harmony export */   updateHistory: () => (/* binding */ updateHistory)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Simple flat array that holds the visited hashes + state Object
 * so the router can navigate back to them
 * @type {Array}
 */
let history = []

const updateHistory = request => {
  const hash = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActiveHash)()
  if (!hash) {
    return
  }

  // navigate storage flag
  const register = request.register
  const forceNavigateStore = register.get(_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.store)

  // test preventStorage on route configuration
  const activeRoute = (0,_route__WEBPACK_IMPORTED_MODULE_1__.getRouteByHash)(hash)
  const preventStorage = (0,_route__WEBPACK_IMPORTED_MODULE_1__.getOption)(activeRoute.options, 'preventStorage')

  // we give prio to navigate storage flag
  let store = (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(forceNavigateStore) ? forceNavigateStore : !preventStorage

  if (store) {
    const toStore = hash.replace(/^\//, '')
    const location = locationInHistory(toStore)
    const stateObject = getStateObject((0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)(), request)
    const routerConfig = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getRouterConfig)()

    // store hash if it's not a part of history or flag for
    // storage of same hash is true
    if (location === -1 || routerConfig.get('storeSameHash')) {
      history.push({ hash: toStore, state: stateObject })
    } else {
      // if we visit the same route we want to sync history
      const prev = history.splice(location, 1)[0]
      history.push({ hash: prev.hash, state: stateObject })
    }
  }
}

const locationInHistory = hash => {
  for (let i = 0; i < history.length; i++) {
    if (history[i].hash === hash) {
      return i
    }
  }
  return -1
}

const getHistoryState = hash => {
  let state = null
  if (history.length) {
    // if no hash is provided we get the last
    // pushed history record
    if (!hash) {
      const record = history[history.length - 1]
      // could be null
      state = record.state
    } else {
      if (locationInHistory(hash) !== -1) {
        const record = history[locationInHistory(hash)]
        state = record.state
      }
    }
  }
  return state
}

const replaceHistoryState = (state = null, hash) => {
  if (!history.length) {
    return
  }
  const location = hash ? locationInHistory(hash) : history.length - 1
  if (location !== -1 && (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isObject)(state)) {
    history[location].state = state
  }
}

const getStateObject = (page, request) => {
  // if the new request shared instance with the
  // previous request we used the copied state object
  if (request.isSharedInstance) {
    if (request.copiedHistoryState) {
      return request.copiedHistoryState
    }
  } else if (page && (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isFunction)(page.historyState)) {
    return page.historyState()
  }
  return null
}

const getHistory = () => {
  return history.slice(0)
}

const setHistory = (arr = []) => {
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isArray)(arr)) {
    history = arr
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/loader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/loader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   mustReuse: () => (/* binding */ mustReuse)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./provider */ "./node_modules/@lightningjs/sdk/src/Router/utils/provider.js");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components */ "./node_modules/@lightningjs/sdk/src/Router/utils/components.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transition */ "./node_modules/@lightningjs/sdk/src/Router/utils/transition.js");
/* harmony import */ var _widgets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./history */ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js");
/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















/**
 * The actual loading of the component
 * */
const load = async request => {
  let expired = false
  try {
    request = await loader(request)
    if (request && !request.isCancelled) {
      // in case of on() providing we need to reset
      // app state;
      if (_router__WEBPACK_IMPORTED_MODULE_0__.app.state === 'Loading') {
        if ((0,_router__WEBPACK_IMPORTED_MODULE_0__.getPreviousState)() === 'Widgets') {
          _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('Widgets', [(0,_widgets__WEBPACK_IMPORTED_MODULE_6__.getActiveWidget)()])
        } else {
          _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('')
        }
      }
      // Do page transition if instance
      // is not shared between the routes
      if (!request.isSharedInstance && !request.isCancelled) {
        await (0,_transition__WEBPACK_IMPORTED_MODULE_5__.executeTransition)(request.page, (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)())
      }
    } else {
      expired = true
    }
    // on expired we only cleanup
    if (expired || request.isCancelled) {
      _Log__WEBPACK_IMPORTED_MODULE_1__["default"].debug('[router]:', `Rejected ${request.hash} because route to ${(0,_router__WEBPACK_IMPORTED_MODULE_0__.getLastHash)()} started`)
      if (request.isCreated && !request.isSharedInstance) {
        // remove from render-tree
        _router__WEBPACK_IMPORTED_MODULE_0__.pagesHost.remove(request.page)
      }
    } else {
      (0,_router__WEBPACK_IMPORTED_MODULE_0__.onRequestResolved)(request)
      // resolve promise
      return request.page
    }
  } catch (request) {
    if (!request.route) {
      console.error(request)
    } else if (!expired) {
      // @todo: revisit
      const { route } = request
      // clean up history if modifier is set
      if ((0,_route__WEBPACK_IMPORTED_MODULE_8__.getOption)(route.options, 'clearHistory')) {
        (0,_history__WEBPACK_IMPORTED_MODULE_10__.setHistory)([])
      } else if (!_regex__WEBPACK_IMPORTED_MODULE_11__.isWildcard.test(route.path)) {
        (0,_history__WEBPACK_IMPORTED_MODULE_10__.updateHistory)(request)
      }

      if (request.isCreated && !request.isSharedInstance) {
        // remove from render-tree
        _router__WEBPACK_IMPORTED_MODULE_0__.pagesHost.remove(request.page)
      }
      handleError(request)
    }
  }
}

const loader = async request => {
  const route = request.route
  const hash = request.hash
  const register = request.register

  // todo: grab from Route instance
  let type = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getComponent)(route.path)
  let isConstruct = (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isComponentConstructor)(type)
  let provide = false

  // if it's an instance bt we're not coming back from
  // history we test if we can re-use this instance
  if (!isConstruct && !register.get(_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.backtrack)) {
    if (!mustReuse(route)) {
      type = type.constructor
      isConstruct = true
    }
  }

  // If page is Lightning Component instance
  if (!isConstruct) {
    request.page = type
    // if we have have a data route for current page
    if ((0,_provider__WEBPACK_IMPORTED_MODULE_3__.hasProvider)(route.path)) {
      if ((0,_provider__WEBPACK_IMPORTED_MODULE_3__.isPageExpired)(type) || type[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.hash] !== hash) {
        provide = true
      }
    }
    let currentRoute = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)() && (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)()[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.route]
    // if the new route is equal to the current route it means that both
    // route share the Component instance and stack location / since this case
    // is conflicting with the way before() and after() loading works we flag it,
    // and check platform settings in we want to re-use instance
    if (route.path === currentRoute) {
      request.isSharedInstance = true
      // since we're re-using the instance we must attach
      // historyState to the request to prevent it from
      // being overridden.
      if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isFunction)(request.page.historyState)) {
        request.copiedHistoryState = request.page.historyState()
      }
    }
  } else {
    request.page = (0,_components__WEBPACK_IMPORTED_MODULE_4__.createComponent)(_router__WEBPACK_IMPORTED_MODULE_0__.stage, type)
    _router__WEBPACK_IMPORTED_MODULE_0__.pagesHost.a(request.page)
    // test if need to request data provider
    if ((0,_provider__WEBPACK_IMPORTED_MODULE_3__.hasProvider)(route.path)) {
      provide = true
    }
    request.isCreated = true
  }

  // we store hash and route as properties on the page instance
  // that way we can easily calculate new behaviour on page reload
  request.page[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.hash] = hash
  request.page[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.route] = route.path

  try {
    if (provide) {
      // extract attached data-provider for route
      // we're processing
      const { type: loadType, provider } = (0,_provider__WEBPACK_IMPORTED_MODULE_3__.getProvider)(route)

      // update running request
      request.provider = provider
      request.providerType = loadType

      await _provider__WEBPACK_IMPORTED_MODULE_3__.dataHooks[loadType](request)

      // we early exit if the current request is expired
      if (hash !== (0,_router__WEBPACK_IMPORTED_MODULE_0__.getLastHash)()) {
        return false
      } else {
        if (request.providerType !== 'after') {
          (0,_emit__WEBPACK_IMPORTED_MODULE_7__["default"])(request.page, 'dataProvided')
        }
        // resolve promise
        return request
      }
    } else {
      (0,_provider__WEBPACK_IMPORTED_MODULE_3__.addPersistData)(request)
      return request
    }
  } catch (e) {
    request.error = e
    return Promise.reject(request)
  }
}

const handleError = request => {
  if (request && request.error) {
    console.error(request.error)
  } else if (request) {
    _Log__WEBPACK_IMPORTED_MODULE_1__["default"].error(request)
  }

  if (request.page && (0,_router__WEBPACK_IMPORTED_MODULE_0__.routeExists)('!')) {
    (0,_index__WEBPACK_IMPORTED_MODULE_9__.navigate)('!', { request }, false)
  }
}

const mustReuse = route => {
  const opt = (0,_route__WEBPACK_IMPORTED_MODULE_8__.getOption)(route.options, 'reuseInstance')
  const config = _router__WEBPACK_IMPORTED_MODULE_0__.routerConfig.get('reuseInstance')

  // route always has final decision
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(opt)) {
    return opt
  }
  return !((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(config) && config === false)
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addPersistData: () => (/* binding */ addPersistData),
/* harmony export */   dataHooks: () => (/* binding */ dataHooks),
/* harmony export */   getProvider: () => (/* binding */ getProvider),
/* harmony export */   hasProvider: () => (/* binding */ hasProvider),
/* harmony export */   isPageExpired: () => (/* binding */ isPageExpired),
/* harmony export */   previousState: () => (/* binding */ previousState)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






let previousState

const dataHooks = {
  on: request => {
    previousState = _router__WEBPACK_IMPORTED_MODULE_1__.app.state || ''
    _router__WEBPACK_IMPORTED_MODULE_1__.app._setState('Loading')
    return execProvider(request)
  },
  before: request => {
    return execProvider(request)
  },
  after: request => {
    try {
      execProvider(request, true)
    } catch (e) {
      // for now we fail silently
    }
    return Promise.resolve()
  },
}

const execProvider = (request, emitProvided) => {
  const route = request.route
  const provider = route.provider
  const expires = route.cache ? route.cache * 1000 : 0
  const params = addPersistData(request)
  return provider.request(request.page, { ...params }).then(() => {
    request.page[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.expires] = Date.now() + expires
    if (emitProvided) {
      (0,_emit__WEBPACK_IMPORTED_MODULE_3__["default"])(request.page, 'dataProvided')
    }
  })
}

const addPersistData = ({ page, route, hash, register = new Map() }) => {
  const urlValues = (0,_route__WEBPACK_IMPORTED_MODULE_2__.getValuesFromHash)(hash, route.path)
  const queryParams = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getQueryStringParams)(hash)
  const pageData = new Map([...urlValues, ...register])
  const params = {}

  // make dynamic url data available to the page
  // as instance properties
  for (let [name, value] of pageData) {
    params[name] = value
  }

  if (queryParams) {
    params[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.queryParams] = queryParams
  }

  // check navigation register for persistent data
  if (register.size) {
    const obj = {}
    for (let [k, v] of register) {
      obj[k] = v
    }
    page.persist = obj
  }

  // make url data and persist data available
  // via params property
  page.params = params
  ;(0,_emit__WEBPACK_IMPORTED_MODULE_3__["default"])(page, ['urlParams'], params)

  return params
}

/**
 * Test if page passed cache-time
 * @param page
 * @returns {boolean}
 */
const isPageExpired = page => {
  if (!page[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.expires]) {
    return false
  }

  const expires = page[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.expires]
  const now = Date.now()

  return now >= expires
}

const hasProvider = path => {
  if ((0,_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(path)) {
    const record = _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(path)
    return !!record.provider
  }
  return false
}

const getProvider = route => {
  // @todo: fix, route already is passed in
  if ((0,_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(route.path)) {
    const { provider } = _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(route.path)
    return {
      type: provider.type,
      provider: provider.request,
    }
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/regex.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasLookupId: () => (/* binding */ hasLookupId),
/* harmony export */   hasRegex: () => (/* binding */ hasRegex),
/* harmony export */   isNamedGroup: () => (/* binding */ isNamedGroup),
/* harmony export */   isWildcard: () => (/* binding */ isWildcard),
/* harmony export */   stripRegex: () => (/* binding */ stripRegex)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const hasRegex = /\{\/(.*?)\/([igm]{0,3})\}/g
const isWildcard = /^[!*$]$/
const hasLookupId = /\/:\w+?@@([0-9]+?)@@/
const isNamedGroup = /^\/:/

/**
 * Test if a route is part regular expressed
 * and replace it for a simple character
 * @param route
 * @returns {*}
 */
const stripRegex = (route, char = 'R') => {
  // if route is part regular expressed we replace
  // the regular expression for a character to
  // simplify floor calculation and backtracking
  if (hasRegex.test(route)) {
    route = route.replace(hasRegex, char)
  }
  return route
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/register.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/register.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRegister: () => (/* binding */ createRegister)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Create a local request register
 * @param flags
 * @returns {Map<any, any>}
 */
const createRegister = flags => {
  const reg = new Map()
  // store user defined and router
  // defined flags in register
  ;[...Object.keys(flags), ...Object.getOwnPropertySymbols(flags)].forEach(key => {
    reg.set(key, flags[key])
  })
  return reg
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/route.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRequest: () => (/* binding */ createRequest),
/* harmony export */   createRoute: () => (/* binding */ createRoute),
/* harmony export */   getFloor: () => (/* binding */ getFloor),
/* harmony export */   getHashByName: () => (/* binding */ getHashByName),
/* harmony export */   getOption: () => (/* binding */ getOption),
/* harmony export */   getRouteByHash: () => (/* binding */ getRouteByHash),
/* harmony export */   getValuesFromHash: () => (/* binding */ getValuesFromHash),
/* harmony export */   keepActivePageAlive: () => (/* binding */ keepActivePageAlive)
/* harmony export */ });
/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _model_Request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/Request */ "./node_modules/@lightningjs/sdk/src/Router/model/Request.js");
/* harmony import */ var _model_Route__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/Route */ "./node_modules/@lightningjs/sdk/src/Router/model/Route.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Simple route length calculation
 * @param route {string}
 * @returns {number} - floor
 */
const getFloor = route => {
  return (0,_regex__WEBPACK_IMPORTED_MODULE_0__.stripRegex)(route).split('/').length
}

/**
 * return all stored routes that live on the same floor
 * @param floor
 * @returns {Array}
 */
const getRoutesByFloor = floor => {
  const matches = []
  // simple filter of level candidates
  for (let [route] of _router__WEBPACK_IMPORTED_MODULE_1__.routes.entries()) {
    if (getFloor(route) === floor) {
      matches.push(route)
    }
  }
  return matches
}

/**
 * return a matching route by provided hash
 * hash: home/browse/12 will match:
 * route: home/browse/:categoryId
 * @param hash {string}
 * @returns {boolean|{}} - route
 */
const getRouteByHash = hash => {
  // @todo: clean up on handleHash
  hash = hash.replace(/^#/, '')

  const getUrlParts = /(\/?:?[^/]+)/g
  // grab possible candidates from stored routes
  const candidates = getRoutesByFloor(getFloor(hash))
  // break hash down in chunks
  const hashParts = hash.match(getUrlParts) || []

  // to simplify the route matching and prevent look around
  // in our getUrlParts regex we get the regex part from
  // route candidate and store them so that we can reference
  // them when we perform the actual regex against hash
  let regexStore = []

  let matches = candidates.filter(route => {
    let isMatching = true
    // replace regex in route with lookup id => @@{storeId}@@
    if (_regex__WEBPACK_IMPORTED_MODULE_0__.hasRegex.test(route)) {
      const regMatches = route.match(_regex__WEBPACK_IMPORTED_MODULE_0__.hasRegex)
      if (regMatches && regMatches.length) {
        route = regMatches.reduce((fullRoute, regex) => {
          const lookupId = regexStore.length
          fullRoute = fullRoute.replace(regex, `@@${lookupId}@@`)
          regexStore.push(regex.substring(1, regex.length - 1))
          return fullRoute
        }, route)
      }
    }

    const routeParts = route.match(getUrlParts) || []

    for (let i = 0, j = routeParts.length; i < j; i++) {
      const routePart = routeParts[i]
      const hashPart = hashParts[i]

      // Since we support catch-all and regex driven name groups
      // we first test for regex lookup id and see if the regex
      // matches the value from the hash
      if (_regex__WEBPACK_IMPORTED_MODULE_0__.hasLookupId.test(routePart)) {
        const routeMatches = _regex__WEBPACK_IMPORTED_MODULE_0__.hasLookupId.exec(routePart)
        const storeId = routeMatches[1]
        const routeRegex = regexStore[storeId]

        // split regex and modifiers so we can use both
        // to create a new RegExp
        // eslint-disable-next-line
                const regMatches = /\/([^\/]+)\/([igm]{0,3})/.exec(routeRegex)

        if (regMatches && regMatches.length) {
          const expression = regMatches[1]
          const modifiers = regMatches[2]

          const regex = new RegExp(`^/${expression}$`, modifiers)

          if (!regex.test(hashPart)) {
            isMatching = false
          }
        }
      } else if (_regex__WEBPACK_IMPORTED_MODULE_0__.isNamedGroup.test(routePart)) {
        // we kindly skip namedGroups because this is dynamic
        // we only need to the static and regex drive parts
        continue
      } else if (hashPart && routePart.toLowerCase() !== hashPart.toLowerCase()) {
        isMatching = false
      }
    }
    return isMatching
  })

  if (matches.length) {
    if (matches.indexOf(hash) !== -1) {
      const match = matches[matches.indexOf(hash)]
      return _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(match)
    } else {
      // we give prio to static routes over dynamic
      matches = matches.sort(a => {
        return _regex__WEBPACK_IMPORTED_MODULE_0__.isNamedGroup.test(a) ? -1 : 1
      })
      // would be strange if this fails
      // but still we test
      if ((0,_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(matches[0])) {
        return _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(matches[0])
      }
    }
  }
  return false
}

const getValuesFromHash = (hash = '', path) => {
  // replace the regex definition from the route because
  // we already did the matching part
  path = (0,_regex__WEBPACK_IMPORTED_MODULE_0__.stripRegex)(path, '')

  const getUrlParts = /(\/?:?[\w%\s:.-]+)/g
  const hashParts = hash.match(getUrlParts) || []
  const routeParts = path.match(getUrlParts) || []
  const getNamedGroup = /^\/:([\w-]+)\/?/

  return routeParts.reduce((storage, value, index) => {
    const match = getNamedGroup.exec(value)
    if (match && match.length) {
      storage.set(match[1], decodeURIComponent(hashParts[index].replace(/^\//, '')))
    }
    return storage
  }, new Map())
}

const getOption = (stack, prop) => {
  // eslint-disable-next-line
    if(stack && stack.hasOwnProperty(prop)){
    return stack[prop]
  }
  // we explicitly return undefined since we're testing
  // for explicit test values
}

/**
 * create and return new Route instance
 * @param config
 */
const createRoute = config => {
  // we need to provide a bit of additional logic
  // for the bootComponent
  if (config.path === '$') {
    let options = {
      preventStorage: true,
    }
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_4__.isObject)(config.options)) {
      options = {
        ...config.options,
        ...options,
      }
    }
    config.options = options
    // if configured add reference to bootRequest
    // as router after provider
    if (_router__WEBPACK_IMPORTED_MODULE_1__.bootRequest) {
      config.after = _router__WEBPACK_IMPORTED_MODULE_1__.bootRequest
    }
  }
  return new _model_Route__WEBPACK_IMPORTED_MODULE_3__["default"](config)
}

/**
 * Create a new Router request object
 * @param url
 * @param args
 * @param store
 * @returns {*}
 */
const createRequest = (url, args, store) => {
  return new _model_Request__WEBPACK_IMPORTED_MODULE_2__["default"](url, args, store)
}

const getHashByName = obj => {
  if (!obj.to && !obj.name) {
    return false
  }
  const route = getRouteByName(obj.to || obj.name)
  const hasDynamicGroup = /\/:([\w-]+)\/?/
  let hash = route

  // if route contains dynamic group
  // we replace them with the provided params
  if (hasDynamicGroup.test(route)) {
    if (obj.params) {
      const keys = Object.keys(obj.params)
      hash = keys.reduce((acc, key) => {
        return acc.replace(`:${key}`, obj.params[key])
      }, route)
    }
    if (obj.query) {
      return `${hash}${(0,_helpers__WEBPACK_IMPORTED_MODULE_4__.objectToQueryString)(obj.query)}`
    }
  }
  return hash
}

const getRouteByName = name => {
  for (let [path, route] of _router__WEBPACK_IMPORTED_MODULE_1__.routes.entries()) {
    if (route.name === name) {
      return path
    }
  }
  return false
}

const keepActivePageAlive = (route, request) => {
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_4__.isString)(route)) {
    const routes = (0,_router__WEBPACK_IMPORTED_MODULE_1__.getRoutes)()
    if (routes.has(route)) {
      route = routes.get(route)
    } else {
      return false
    }
  }

  const register = request.register
  const routeOptions = route.options

  if (register.has('keepAlive')) {
    return register.get('keepAlive')
  } else if (routeOptions && routeOptions.keepAlive) {
    return routeOptions.keepAlive
  }

  return false
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/router.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   afterEachRoute: () => (/* binding */ afterEachRoute),
/* harmony export */   app: () => (/* binding */ app),
/* harmony export */   application: () => (/* binding */ application),
/* harmony export */   beforeEachRoute: () => (/* binding */ beforeEachRoute),
/* harmony export */   bootRequest: () => (/* binding */ bootRequest),
/* harmony export */   bootRouter: () => (/* binding */ bootRouter),
/* harmony export */   components: () => (/* binding */ components),
/* harmony export */   getActiveHash: () => (/* binding */ getActiveHash),
/* harmony export */   getActivePage: () => (/* binding */ getActivePage),
/* harmony export */   getActiveRoute: () => (/* binding */ getActiveRoute),
/* harmony export */   getBootRequest: () => (/* binding */ getBootRequest),
/* harmony export */   getComponent: () => (/* binding */ getComponent),
/* harmony export */   getLastHash: () => (/* binding */ getLastHash),
/* harmony export */   getPreviousState: () => (/* binding */ getPreviousState),
/* harmony export */   getRootHash: () => (/* binding */ getRootHash),
/* harmony export */   getRouterConfig: () => (/* binding */ getRouterConfig),
/* harmony export */   getRoutes: () => (/* binding */ getRoutes),
/* harmony export */   mustUpdateLocationHash: () => (/* binding */ mustUpdateLocationHash),
/* harmony export */   onRequestResolved: () => (/* binding */ onRequestResolved),
/* harmony export */   pagesHost: () => (/* binding */ pagesHost),
/* harmony export */   routeExists: () => (/* binding */ routeExists),
/* harmony export */   routerConfig: () => (/* binding */ routerConfig),
/* harmony export */   routes: () => (/* binding */ routes),
/* harmony export */   setActiveHash: () => (/* binding */ setActiveHash),
/* harmony export */   setActivePage: () => (/* binding */ setActivePage),
/* harmony export */   setLastHash: () => (/* binding */ setLastHash),
/* harmony export */   setPreviousState: () => (/* binding */ setPreviousState),
/* harmony export */   stage: () => (/* binding */ stage),
/* harmony export */   storeComponent: () => (/* binding */ storeComponent),
/* harmony export */   updateHash: () => (/* binding */ updateHash),
/* harmony export */   widgetsHost: () => (/* binding */ widgetsHost)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components */ "./node_modules/@lightningjs/sdk/src/Router/utils/components.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/* harmony import */ var _widgets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./history */ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js");
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../Application */ "./node_modules/@lightningjs/sdk/src/Application/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












/**
 * @type {Lightning.Application}
 */
let application

/**
 * Actual instance of the app
 * @type {Lightning.Component}
 */
let app

/**
 * Component that hosts all routed pages
 * @type {Lightning.Component}
 */
let pagesHost

/**
 * @type {Lightning.Stage}
 */
let stage

/**
 * Platform driven Router configuration
 * @type {Map<string>}
 */
let routerConfig

/**
 * Component that hosts all attached widgets
 * @type {Lightning.Component}
 */
let widgetsHost

/**
 * Hash we point the browser to when we boot the app
 * and there is no deep-link provided
 * @type {string|Function}
 */
let rootHash

/**
 * Boot request will fire before app start
 * can be used to execute some global logic
 * and can be configured
 */
let bootRequest

/**
 * Flag if we need to update the browser location hash.
 * Router can work without.
 * @type {boolean}
 */
let updateHash = true

/**
 * Will be called before a route starts, can be overridden
 * via routes config
 * @param from - route we came from
 * @param to - route we navigate to
 * @returns {Promise<*>}
 */
// eslint-disable-next-line
let beforeEachRoute = async (from, to)=>{
  return true
}

/**
 *  * Will be called after a navigate successfully resolved,
 * can be overridden via routes config
 */
let afterEachRoute = () => {}

/**
 * All configured routes
 * @type {Map<string, object>}
 */
let routes = new Map()

/**
 * Store all page components per route
 * @type {Map<string, object>}
 */
let components = new Map()

/**
 * Flag if router has been initialised
 * @type {boolean}
 */
let initialised = false

/**
 * Current page being rendered on screen
 * @type {null}
 */
let activePage = null
let activeHash
let activeRoute

/**
 *  During the process of a navigation request a new
 *  request can start, to prevent unwanted behaviour
 *  the navigate()-method stores the last accepted hash
 *  so we can invalidate any prior requests
 */
let lastAcceptedHash

/**
 * With on()-data providing behaviour the Router forced the App
 * in a Loading state. When the data-provider resolves we want to
 * change the state back to where we came from
 */
let previousState

const mixin = app => {
  // by default the Router Baseclass provides the component
  // reference in which we store our pages
  if (app.pages) {
    pagesHost = app.pages.childList
  }
  // if the app is using widgets we grab refs
  // and hide all the widgets
  if (app.widgets && app.widgets.children) {
    widgetsHost = app.widgets.childList
    // hide all widgets on boot
    widgetsHost.forEach(w => (w.visible = false))
  }
  app._handleBack = e => {
    (0,_index__WEBPACK_IMPORTED_MODULE_1__.step)(-1)
    e.preventDefault()
  }
}

const bootRouter = (config, instance) => {
  let { appInstance, routes } = config

  // if instance is provided and it's and Lightning Component instance
  if (instance && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isPage)(instance)) {
    app = instance
  }
  if (!app) {
    app = appInstance || _Application__WEBPACK_IMPORTED_MODULE_9__.AppInstance
  }

  application = app.application
  pagesHost = application.childList
  stage = app.stage
  routerConfig = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getConfigMap)()

  mixin(app)

  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(routes)) {
    setup(config)
  } else if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(routes)) {
    console.warn('[Router]: Calling Router.route() directly is deprecated.')
    console.warn(
      'Use object config: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration'
    )
  }
}

const setup = config => {
  if (!initialised) {
    init(config)
  }
  config.routes.forEach(r => {
    const path = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.cleanHash)(r.path)
    if (!routeExists(path)) {
      const route = (0,_route__WEBPACK_IMPORTED_MODULE_2__.createRoute)(r)
      routes.set(path, route)
      // if route has a configured component property
      // we store it in a different map to simplify
      // the creating and destroying per route
      if (route.component) {
        let type = route.component
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isComponentConstructor)(type)) {
          if (!routerConfig.get('lazyCreate')) {
            type = (0,_components__WEBPACK_IMPORTED_MODULE_3__.createComponent)(stage, type)
            pagesHost.a(type)
          }
        }
        components.set(path, type)
      }
    } else {
      console.error(`${path} already exists in routes configuration`)
    }
  })
}

const init = config => {
  rootHash = config.root
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config.boot)) {
    bootRequest = config.boot
  }
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(config.updateHash)) {
    updateHash = config.updateHash
  }
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config.beforeEachRoute)) {
    beforeEachRoute = config.beforeEachRoute
  }
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config.afterEachRoute)) {
    afterEachRoute = config.afterEachRoute
  }
  if (config.bootComponent) {
    console.warn(
      '[Router]: Boot Component is now available as a special router: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration?id=special-routes'
    )
    console.warn(
      '[Router]: setting { bootComponent } property will be deprecated in a future release'
    )
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isPage)(config.bootComponent)) {
      config.routes.push({
        path: '$',
        component: config.bootComponent,
        // we try to assign the bootRequest as after data-provider
        // so it will behave as any other component
        after: bootRequest || null,
        options: {
          preventStorage: true,
        },
      })
    } else {
      console.error(`[Router]: ${config.bootComponent} is not a valid boot component`)
    }
  }
  initialised = true
}

const storeComponent = (route, type) => {
  if (components.has(route)) {
    components.set(route, type)
  }
}

const getComponent = route => {
  if (components.has(route)) {
    return components.get(route)
  }
  return null
}
/**
 * Test if router needs to update browser location hash
 * @returns {boolean}
 */
const mustUpdateLocationHash = () => {
  if (!routerConfig || !routerConfig.size) {
    return false
  }
  // we need support to either turn change hash off
  // per platform or per app
  const updateConfig = routerConfig.get('updateHash')
  return !(((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(updateConfig) && !updateConfig) || ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(updateHash) && !updateHash))
}

/**
 * Will be called when a new navigate() request has completed
 * and has not been expired due to it's async nature
 * @param request
 */
const onRequestResolved = request => {
  const hash = request.hash
  const route = request.route
  const register = request.register
  const page = request.page

  // clean up history if modifier is set
  if ((0,_route__WEBPACK_IMPORTED_MODULE_2__.getOption)(route.options, 'clearHistory')) {
    (0,_history__WEBPACK_IMPORTED_MODULE_8__.setHistory)([])
  } else if (hash && !_regex__WEBPACK_IMPORTED_MODULE_5__.isWildcard.test(route.path)) {
    (0,_history__WEBPACK_IMPORTED_MODULE_8__.updateHistory)(request)
  }

  // we only update the stackLocation if a route
  // is not expired before it resolves
  storeComponent(route.path, page)

  if (request.isSharedInstance || !request.isCreated) {
    (0,_emit__WEBPACK_IMPORTED_MODULE_6__["default"])(page, 'changed')
  } else if (request.isCreated) {
    (0,_emit__WEBPACK_IMPORTED_MODULE_6__["default"])(page, 'mounted')
  }

  // only update widgets if we have a host
  if (widgetsHost) {
    (0,_widgets__WEBPACK_IMPORTED_MODULE_7__.updateWidgets)(route.widgets, page)
  }

  // we want to clean up if there is an
  // active page that is not being shared
  // between current and previous route
  if (getActivePage() && !request.isSharedInstance) {
    cleanUp(activePage, request)
  }

  // provide history object to active page
  if (register.get(_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.historyState) && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(page.historyState)) {
    page.historyState(register.get(_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.historyState))
  }

  setActivePage(page)

  activeHash = request.hash
  activeRoute = route.path

  // cleanup all cancelled requests
  for (let request of _index__WEBPACK_IMPORTED_MODULE_1__.navigateQueue.values()) {
    if (request.isCancelled && request.hash) {
      _index__WEBPACK_IMPORTED_MODULE_1__.navigateQueue.delete(request.hash)
    }
  }

  afterEachRoute(request)

  _Log__WEBPACK_IMPORTED_MODULE_4__["default"].info('[route]:', route.path)
  _Log__WEBPACK_IMPORTED_MODULE_4__["default"].info('[hash]:', hash)
}

const cleanUp = (page, request) => {
  const route = activeRoute
  const register = request.register
  const lazyDestroy = routerConfig.get('lazyDestroy')
  const destroyOnBack = routerConfig.get('destroyOnHistoryBack')
  const keepAlive = register.get('keepAlive')
  const isFromHistory = register.get(_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.backtrack)

  let doCleanup = false

  // if this request is executed due to a step back in history
  // and we have configured to destroy active page when we go back
  // in history or lazyDestory is enabled
  if (isFromHistory && (destroyOnBack || lazyDestroy)) {
    doCleanup = true
  }

  // clean up if lazyDestroy is enabled and the keepAlive flag
  // in navigation register is false
  if (lazyDestroy && !keepAlive) {
    doCleanup = true
  }

  // if the current and new request share the same route blueprint
  if (activeRoute === request.route.path) {
    doCleanup = true
  }

  if (doCleanup) {
    // grab original class constructor if
    // statemachine routed else store constructor
    storeComponent(route, page._routedType || page.constructor)

    // actual remove of page from memory
    pagesHost.remove(page)

    // force texture gc() if configured
    // so we can cleanup textures in the same tick
    if (routerConfig.get('gcOnUnload')) {
      stage.gc()
    }
  } else {
    // If we're not removing the page we need to
    // reset it's properties
    page.patch({
      x: 0,
      y: 0,
      scale: 1,
      alpha: 1,
      visible: false,
    })
  }
}

const getActiveHash = () => {
  return activeHash
}

const setActiveHash = hash => {
  activeHash = hash
}

const setActivePage = page => {
  activePage = page
}

const getActivePage = () => {
  return activePage
}

const getActiveRoute = () => {
  return activeRoute
}

const getLastHash = () => {
  return lastAcceptedHash
}

const setLastHash = hash => {
  lastAcceptedHash = hash
}

const setPreviousState = state => {
  previousState = state
}

const getPreviousState = () => {
  return previousState
}

const routeExists = key => {
  return routes.has(key)
}

const getRootHash = () => {
  return rootHash
}

const getBootRequest = () => {
  return bootRequest
}

const getRouterConfig = () => {
  return routerConfig
}

const getRoutes = () => {
  return routes
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/transition.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/transition.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   executeTransition: () => (/* binding */ executeTransition)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transitions */ "./node_modules/@lightningjs/sdk/src/Router/transitions.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * execute transition between new / old page and
 * toggle the defined widgets
 * @todo: platform override default transition
 * @param pageIn
 * @param pageOut
 */
const executeTransition = (pageIn, pageOut = null) => {
  const transition = pageIn.pageTransition || pageIn.easing
  const hasCustomTransitions = !!(pageIn.smoothIn || pageIn.smoothInOut || transition)
  const transitionsDisabled = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getRouterConfig)().get('disableTransitions')

  if (pageIn.easing) {
    console.warn('easing() method is deprecated and will be removed. Use pageTransition()')
  }

  // default behaviour is a visibility toggle
  if (!hasCustomTransitions || transitionsDisabled) {
    pageIn.visible = true
    if (pageOut) {
      pageOut.visible = false
    }
    return Promise.resolve()
  }

  if (transition) {
    let type
    try {
      type = transition.call(pageIn, pageIn, pageOut)
    } catch (e) {
      type = 'crossFade'
    }

    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isPromise)(type)) {
      return type
    }

    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isString)(type)) {
      const fn = _transitions__WEBPACK_IMPORTED_MODULE_2__["default"][type]
      if (fn) {
        return fn(pageIn, pageOut)
      }
    }

    // keep backwards compatible for now
    if (pageIn.smoothIn) {
      // provide a smooth function that resolves itself
      // on transition finish
      const smooth = (p, v, args = {}) => {
        return new Promise(resolve => {
          pageIn.visible = true
          pageIn.setSmooth(p, v, args)
          pageIn.transition(p).on('finish', () => {
            resolve()
          })
        })
      }
      return pageIn.smoothIn({ pageIn, smooth })
    }
  }
  return _transitions__WEBPACK_IMPORTED_MODULE_2__["default"].crossFade(pageIn, pageOut)
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   focusWidget: () => (/* binding */ focusWidget),
/* harmony export */   getActiveWidget: () => (/* binding */ getActiveWidget),
/* harmony export */   getReferences: () => (/* binding */ getReferences),
/* harmony export */   handleRemote: () => (/* binding */ handleRemote),
/* harmony export */   restoreFocus: () => (/* binding */ restoreFocus),
/* harmony export */   setActiveWidget: () => (/* binding */ setActiveWidget),
/* harmony export */   updateWidgets: () => (/* binding */ updateWidgets)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





let activeWidget = null

const getReferences = () => {
  if (!_router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost) {
    return
  }
  return _router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost.get().reduce((storage, widget) => {
    const key = widget.ref.toLowerCase()
    storage[key] = widget
    return storage
  }, {})
}

/**
 * update the visibility of the available widgets
 * for the current page / route
 * @param page
 */
const updateWidgets = (widgets, page) => {
  // force lowercase lookup
  const configured = (widgets || []).map(ref => ref.toLowerCase())

  _router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost.forEach(widget => {
    widget.visible = configured.indexOf(widget.ref.toLowerCase()) !== -1
    if (widget.visible) {
      (0,_emit__WEBPACK_IMPORTED_MODULE_2__["default"])(widget, ['activated'], page)
    }
  })
  if (_router__WEBPACK_IMPORTED_MODULE_0__.app.state === 'Widgets' && activeWidget && !activeWidget.visible) {
    _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('')
  }
}

const getWidgetByName = name => {
  name = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.ucfirst)(name)
  return _router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost.getByRef(name) || false
}

/**
 * delegate app focus to a on-screen widget
 * @param name - {string}
 */
const focusWidget = name => {
  const widget = getWidgetByName(name)
  if (widget) {
    setActiveWidget(widget)

    // if app is already in 'Widgets' state we can assume that
    // focus has been delegated from one widget to another so
    // we need to set the new widget reference and trigger a
    // new focus calculation of Lightning's focuspath
    if (_router__WEBPACK_IMPORTED_MODULE_0__.app.state === 'Widgets') {
      _router__WEBPACK_IMPORTED_MODULE_0__.app.reload(activeWidget)
    } else {
      _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('Widgets', [activeWidget])
    }
  }
}

const handleRemote = (type, name) => {
  if (type === 'widget') {
    focusWidget(name)
  } else if (type === 'page') {
    restoreFocus()
  }
}

const restoreFocus = () => {
  activeWidget = null
  _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('')
}

const getActiveWidget = () => {
  return activeWidget
}

const setActiveWidget = instance => {
  activeWidget = instance
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Settings/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Settings/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initSettings: () => (/* binding */ initSettings)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const settings = {}
const subscribers = {}

const initSettings = (appSettings, platformSettings) => {
  settings['app'] = appSettings
  settings['platform'] = platformSettings
  settings['user'] = {}
}

const publish = (key, value) => {
  subscribers[key] && subscribers[key].forEach(subscriber => subscriber(value))
}

const dotGrab = (obj = {}, key) => {
  if (obj === null) return undefined
  const keys = key.split('.')
  for (let i = 0; i < keys.length; i++) {
    obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {}
  }
  return typeof obj === 'object' && obj !== null ? (Object.keys(obj).length ? obj : undefined) : obj
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(type, key, fallback = undefined) {
    const val = dotGrab(settings[type], key)
    return val !== undefined ? val : fallback
  },
  has(type, key) {
    return !!this.get(type, key)
  },
  set(key, value) {
    settings['user'][key] = value
    publish(key, value)
  },
  subscribe(key, callback) {
    subscribers[key] = subscribers[key] || []
    subscribers[key].push(callback)
  },
  unsubscribe(key, callback) {
    if (callback) {
      const index = subscribers[key] && subscribers[key].findIndex(cb => cb === callback)
      index > -1 && subscribers[key].splice(index, 1)
    } else {
      if (key in subscribers) {
        subscribers[key] = []
      }
    }
  },
  clearSubscribers() {
    for (const key of Object.getOwnPropertyNames(subscribers)) {
      delete subscribers[key]
    }
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Storage/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Storage/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initStorage: () => (/* binding */ initStorage)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var localCookie_module_localCookie_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! localCookie/module/localCookie.js */ "./node_modules/localCookie/module/localCookie.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let namespace
let lc

const initStorage = () => {
  namespace = _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'id')
  // todo: pass options (for example to force the use of cookies)
  lc = new localCookie_module_localCookie_js__WEBPACK_IMPORTED_MODULE_1__["default"]()
}

const namespacedKey = key => (namespace ? [namespace, key].join('.') : key)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(key) {
    try {
      return JSON.parse(lc.getItem(namespacedKey(key)))
    } catch (e) {
      return null
    }
  },
  set(key, value) {
    try {
      lc.setItem(namespacedKey(key), JSON.stringify(value))
      return true
    } catch (e) {
      return false
    }
  },
  remove(key) {
    lc.removeItem(namespacedKey(key))
  },
  clear() {
    if (namespace) {
      lc.keys().forEach(key => {
        // remove the item if in the namespace
        key.indexOf(namespace + '.') === 0 ? lc.removeItem(key) : null
      })
    } else {
      lc.clear()
    }
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/TV/defaults.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/TV/defaults.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   channels: () => (/* binding */ channels),
/* harmony export */   randomChannel: () => (/* binding */ randomChannel)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const defaultChannels = [
  {
    number: 1,
    name: 'Metro News 1',
    description: 'New York Cable News Channel',
    entitled: true,
    program: {
      title: 'The Morning Show',
      description: "New York's best morning show",
      startTime: new Date(new Date() - 60 * 5 * 1000).toUTCString(), // started 5 minutes ago
      duration: 60 * 30, // 30 minutes
      ageRating: 0,
    },
  },
  {
    number: 2,
    name: 'MTV',
    description: 'Music Television',
    entitled: true,
    program: {
      title: 'Beavis and Butthead',
      description: 'American adult animated sitcom created by Mike Judge',
      startTime: new Date(new Date() - 60 * 20 * 1000).toUTCString(), // started 20 minutes ago
      duration: 60 * 45, // 45 minutes
      ageRating: 18,
    },
  },
  {
    number: 3,
    name: 'NBC',
    description: 'NBC TV Network',
    entitled: false,
    program: {
      title: 'The Tonight Show Starring Jimmy Fallon',
      description: 'Late-night talk show hosted by Jimmy Fallon on NBC',
      startTime: new Date(new Date() - 60 * 10 * 1000).toUTCString(), // started 10 minutes ago
      duration: 60 * 60, // 1 hour
      ageRating: 10,
    },
  },
]

const channels = () => _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'tv', defaultChannels)

const randomChannel = () => channels()[~~(channels.length * Math.random())]


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/TV/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/TV/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initTV: () => (/* binding */ initTV)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaults */ "./node_modules/@lightningjs/sdk/src/TV/defaults.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





let currentChannel
const callbacks = {}

const emit = (event, ...args) => {
  callbacks[event] &&
    callbacks[event].forEach(cb => {
      cb.apply(null, args)
    })
}

// local mock methods
let methods = {
  getChannel() {
    if (!currentChannel) currentChannel = (0,_defaults__WEBPACK_IMPORTED_MODULE_1__.randomChannel)()
    return new Promise((resolve, reject) => {
      if (currentChannel) {
        const channel = { ...currentChannel }
        delete channel.program
        resolve(channel)
      } else {
        reject('No channel found')
      }
    })
  },
  getProgram() {
    if (!currentChannel) currentChannel = (0,_defaults__WEBPACK_IMPORTED_MODULE_1__.randomChannel)()
    return new Promise((resolve, reject) => {
      currentChannel.program ? resolve(currentChannel.program) : reject('No program found')
    })
  },
  setChannel(number) {
    return new Promise((resolve, reject) => {
      if (number) {
        const newChannel = (0,_defaults__WEBPACK_IMPORTED_MODULE_1__.channels)().find(c => c.number === number)
        if (newChannel) {
          currentChannel = newChannel
          const channel = { ...currentChannel }
          delete channel.program
          emit('channelChange', channel)
          resolve(channel)
        } else {
          reject('Channel not found')
        }
      } else {
        reject('No channel number supplied')
      }
    })
  },
}

const initTV = config => {
  methods = {}
  if (config.getChannel && typeof config.getChannel === 'function') {
    methods.getChannel = config.getChannel
  }
  if (config.getProgram && typeof config.getProgram === 'function') {
    methods.getProgram = config.getProgram
  }
  if (config.setChannel && typeof config.setChannel === 'function') {
    methods.setChannel = config.setChannel
  }
  if (config.emit && typeof config.emit === 'function') {
    config.emit(emit)
  }
}

// public API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  channel(number = null) {
    return new Promise((resolve, reject) => {
      try {
        // call setChannel when number argument is passed, otherwise getChannel
        methods[number ? 'setChannel' : 'getChannel'](number)
          .then(channel => {
            // to do: ensure consistent formatting of channel info here?
            resolve(channel)
          })
          .catch(reject)
      } catch (e) {
        reject(e)
      }
    })
  },
  program() {
    return new Promise((resolve, reject) => {
      try {
        methods
          .getProgram()
          .then(program => {
            // to do: ensure consistent formatting of program info here?
            resolve(program)
          })
          .catch(reject)
      } catch (e) {
        reject(e)
      }
    })
  },
  entitled() {
    return new Promise((resolve, reject) => {
      try {
        methods
          .getChannel()
          .then(channel => {
            'entitled' in channel ? resolve(!!channel.entitled) : reject()
          })
          .catch(reject)
      } catch (e) {
        reject(e)
      }
    })
  },
  addEventListener(event, cb) {
    if (typeof cb === 'function') {
      callbacks[event] = callbacks[event] || []
      callbacks[event].push(cb)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Please provide a function as a callback')
    }
  },
  removeEventListener(event, cb = false) {
    if (callbacks[event] && callbacks[event].length) {
      callbacks[event] = cb ? callbacks[event].filter(_cb => _cb === cb) : []
    }
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Utils/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Utils/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cleanUpPathName: () => (/* binding */ cleanUpPathName),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   ensureUrlWithProtocol: () => (/* binding */ ensureUrlWithProtocol),
/* harmony export */   initUtils: () => (/* binding */ initUtils),
/* harmony export */   makeFullStaticPath: () => (/* binding */ makeFullStaticPath)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let basePath
let proxyUrl

const initUtils = config => {
  basePath = ensureUrlWithProtocol(makeFullStaticPath(window.location.pathname, config.path || '/'))

  if (config.proxyUrl) {
    proxyUrl = ensureUrlWithProtocol(config.proxyUrl)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  asset(relPath) {
    return basePath + relPath
  },
  proxyUrl(url, options = {}) {
    return proxyUrl ? proxyUrl + '?' + makeQueryString(url, options) : url
  },
  makeQueryString() {
    return makeQueryString(...arguments)
  },
  // since imageworkers don't work without protocol
  ensureUrlWithProtocol() {
    return ensureUrlWithProtocol(...arguments)
  },
});

const ensureUrlWithProtocol = url => {
  if (/^\/\//.test(url)) {
    return window.location.protocol + url
  }
  if (!/^(?:https?:)/i.test(url)) {
    return window.location.origin + url
  }
  return url
}

const makeFullStaticPath = (pathname = '/', path) => {
  // ensure path has traling slash
  path = path.charAt(path.length - 1) !== '/' ? path + '/' : path

  // if path is URL, we assume it's already the full static path, so we just return it
  if (/^(?:https?:)?(?:\/\/)/.test(path)) {
    return path
  }

  if (path.charAt(0) === '/') {
    return path
  } else {
    // cleanup the pathname (i.e. remove possible index.html)
    pathname = cleanUpPathName(pathname)

    // remove possible leading dot from path
    path = path.charAt(0) === '.' ? path.substr(1) : path
    // ensure path has leading slash
    path = path.charAt(0) !== '/' ? '/' + path : path
    return pathname + path
  }
}

const cleanUpPathName = pathname => {
  if (pathname.slice(-1) === '/') return pathname.slice(0, -1)
  const parts = pathname.split('/')
  if (parts[parts.length - 1].indexOf('.') > -1) parts.pop()
  return parts.join('/')
}

const makeQueryString = (url, options = {}, type = 'url') => {
  // add operator as an option
  options.operator = 'metrological' // Todo: make this configurable (via url?)
  // add type (= url or qr) as an option, with url as the value
  options[type] = url

  return Object.keys(options)
    .map(key => {
      return encodeURIComponent(key) + '=' + encodeURIComponent('' + options[key])
    })
    .join('&')
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VersionLabel/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VersionLabel/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VersionLabel)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class VersionLabel extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      rect: true,
      color: 0xbb0078ac,
      h: 40,
      w: 100,
      x: w => w - 50,
      y: h => h - 50,
      mount: 1,
      Text: {
        w: w => w,
        h: h => h,
        y: 5,
        x: 20,
        text: {
          fontSize: 22,
          lineHeight: 26,
        },
      },
    }
  }

  _firstActive() {
    this.tag('Text').text = `APP - v${this.version}\nSDK - v${this.sdkVersion}`
    this.tag('Text').loadTexture()
    this.w = this.tag('Text').renderWidth + 40
    this.h = this.tag('Text').renderHeight + 5
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VideoPlayer/VideoTexture.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VideoPlayer/VideoTexture.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoTexture)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class VideoTexture extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      Video: {
        alpha: 1,
        visible: false,
        pivot: 0.5,
        texture: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].textures.StaticTexture, options: {} },
      },
    }
  }

  set videoEl(v) {
    this._videoEl = v
  }

  get videoEl() {
    return this._videoEl
  }

  get videoView() {
    return this.tag('Video')
  }

  get videoTexture() {
    return this.videoView.texture
  }

  get isVisible() {
    return this.videoView.alpha === 1 && this.videoView.visible === true
  }

  _init() {
    this._createVideoTexture()
  }

  _createVideoTexture() {
    const stage = this.stage

    const gl = stage.gl
    const glTexture = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, glTexture)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
    this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height }

    this.videoView.w = this.videoEl.width / this.stage.getRenderPrecision()
    this.videoView.h = this.videoEl.height / this.stage.getRenderPrecision()
  }

  start() {
    const stage = this.stage
    this._lastTime = 0
    if (!this._updateVideoTexture) {
      this._updateVideoTexture = () => {
        if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
          const gl = stage.gl

          const currentTime = new Date().getTime()
          const getVideoPlaybackQuality = this.videoEl.getVideoPlaybackQuality()

          // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
          // We'll fallback to fixed 30fps in this case.
          // As 'webkitDecodedFrameCount' is about to deprecate, check for the 'totalVideoFrames'
          const frameCount = getVideoPlaybackQuality
            ? getVideoPlaybackQuality.totalVideoFrames
            : this.videoEl.webkitDecodedFrameCount

          const mustUpdate = frameCount
            ? this._lastFrame !== frameCount
            : this._lastTime < currentTime - 30

          if (mustUpdate) {
            this._lastTime = currentTime
            this._lastFrame = frameCount
            try {
              gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
              gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false)
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl)
              this._lastFrame = this.videoEl.webkitDecodedFrameCount
              this.videoView.visible = true

              this.videoTexture.options.w = this.videoEl.width
              this.videoTexture.options.h = this.videoEl.height
              const expectedAspectRatio = this.videoView.w / this.videoView.h
              const realAspectRatio = this.videoEl.width / this.videoEl.height

              if (expectedAspectRatio > realAspectRatio) {
                this.videoView.scaleX = realAspectRatio / expectedAspectRatio
                this.videoView.scaleY = 1
              } else {
                this.videoView.scaleY = expectedAspectRatio / realAspectRatio
                this.videoView.scaleX = 1
              }
            } catch (e) {
              _Log__WEBPACK_IMPORTED_MODULE_1__["default"].error('texImage2d video', e)
              this.stop()
            }
            this.videoTexture.source.forceRenderUpdate()
          }
        }
      }
    }
    if (!this._updatingVideoTexture) {
      stage.on('frameStart', this._updateVideoTexture)
      this._updatingVideoTexture = true
    }
  }

  stop() {
    const stage = this.stage
    stage.removeListener('frameStart', this._updateVideoTexture)
    this._updatingVideoTexture = false
    this.videoView.visible = false

    if (this.videoTexture.options.source) {
      const gl = stage.gl
      gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
      gl.clearColor(0, 0, 0, 1)
      gl.clear(gl.COLOR_BUFFER_BIT)
    }
  }

  position(top, left) {
    this.videoView.patch({
      smooth: {
        x: left,
        y: top,
      },
    })
  }

  size(width, height) {
    this.videoView.patch({
      smooth: {
        w: width,
        h: height,
      },
    })
  }

  show() {
    this.videoView.setSmooth('alpha', 1)
  }

  hide() {
    this.videoView.setSmooth('alpha', 0)
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VideoPlayer/events.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VideoPlayer/events.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  abort: 'Abort',
  canplay: 'CanPlay',
  canplaythrough: 'CanPlayThrough',
  durationchange: 'DurationChange',
  emptied: 'Emptied',
  encrypted: 'Encrypted',
  ended: 'Ended',
  error: 'Error',
  interruptbegin: 'InterruptBegin',
  interruptend: 'InterruptEnd',
  loadeddata: 'LoadedData',
  loadedmetadata: 'LoadedMetadata',
  loadstart: 'LoadStart',
  pause: 'Pause',
  play: 'Play',
  playing: 'Playing',
  progress: 'Progress',
  ratechange: 'Ratechange',
  seeked: 'Seeked',
  seeking: 'Seeking',
  stalled: 'Stalled',
  // suspend: 'Suspend', // this one is called a looooot for some videos
  timeupdate: 'TimeUpdate',
  volumechange: 'VolumeChange',
  waiting: 'Waiting',
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initVideoPlayer: () => (/* binding */ initVideoPlayer),
/* harmony export */   mediaUrl: () => (/* binding */ mediaUrl),
/* harmony export */   setUpVideoTexture: () => (/* binding */ setUpVideoTexture),
/* harmony export */   setupVideoTag: () => (/* binding */ setupVideoTag)
/* harmony export */ });
/* harmony import */ var _michieljs_execute_as_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @michieljs/execute-as-promise */ "./node_modules/@michieljs/execute-as-promise/src/execute-as-promise.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _Ads__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Ads */ "./node_modules/@lightningjs/sdk/src/Ads/index.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/events.js");
/* harmony import */ var _helpers_autoSetupMixin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/autoSetupMixin */ "./node_modules/@lightningjs/sdk/src/helpers/autoSetupMixin.js");
/* harmony import */ var _helpers_easeExecution__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/easeExecution */ "./node_modules/@lightningjs/sdk/src/helpers/easeExecution.js");
/* harmony import */ var _Launch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Launch */ "./node_modules/@lightningjs/sdk/src/Launch/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _VideoTexture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./VideoTexture */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/VideoTexture.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














let mediaUrl = url => url
let videoEl
let videoTexture
let metrics
let consumer
let precision = 1
let textureMode = false

const initVideoPlayer = config => {
  if (config.mediaUrl) {
    mediaUrl = config.mediaUrl
  }
}

// todo: add this in a 'Registry' plugin
// to be able to always clean this up on app close
let eventHandlers = {}

const state = {
  adsEnabled: false,
  playing: false,
  _playingAds: false,
  get playingAds() {
    return this._playingAds
  },
  set playingAds(val) {
    if (this._playingAds !== val) {
      this._playingAds = val
      fireOnConsumer(val === true ? 'AdStart' : 'AdEnd')
    }
  },
  skipTime: false,
  playAfterSeek: null,
}

const hooks = {
  play() {
    state.playing = true
  },
  pause() {
    state.playing = false
  },
  seeked() {
    state.playAfterSeek === true && videoPlayerPlugin.play()
    state.playAfterSeek = null
  },
  abort() {
    deregisterEventListeners()
  },
}

const withPrecision = val => Math.round(precision * val) + 'px'

const fireOnConsumer = (event, args) => {
  if (consumer) {
    consumer.fire('$videoPlayer' + event, args, videoEl.currentTime)
    consumer.fire('$videoPlayerEvent', event, args, videoEl.currentTime)
  }
}

const fireHook = (event, args) => {
  hooks[event] && typeof hooks[event] === 'function' && hooks[event].call(null, event, args)
}

let customLoader = null
let customUnloader = null

const loader = (url, videoEl, config) => {
  return customLoader && typeof customLoader === 'function'
    ? customLoader(url, videoEl, config)
    : new Promise(resolve => {
        url = mediaUrl(url)
        videoEl.setAttribute('src', url)
        videoEl.load()
        resolve()
      })
}

const unloader = videoEl => {
  return customUnloader && typeof customUnloader === 'function'
    ? customUnloader(videoEl)
    : new Promise(resolve => {
        videoEl.removeAttribute('src')
        videoEl.load()
        resolve()
      })
}

const setupVideoTag = () => {
  const videoEls = document.getElementsByTagName('video')
  if (videoEls && videoEls.length) {
    return videoEls[0]
  } else {
    const videoEl = document.createElement('video')
    const platformSettingsWidth = _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'width')
      ? _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'width')
      : 1920
    const platformSettingsHeight = _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'height')
      ? _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'height')
      : 1080
    videoEl.setAttribute('id', 'video-player')
    videoEl.setAttribute('width', withPrecision(platformSettingsWidth))
    videoEl.setAttribute('height', withPrecision(platformSettingsHeight))
    videoEl.style.position = 'absolute'
    videoEl.style.zIndex = '1'
    videoEl.style.display = 'none'
    videoEl.style.visibility = 'hidden'
    videoEl.style.top = withPrecision(0)
    videoEl.style.left = withPrecision(0)
    videoEl.style.width = withPrecision(platformSettingsWidth)
    videoEl.style.height = withPrecision(platformSettingsHeight)
    document.body.appendChild(videoEl)
    return videoEl
  }
}

const setUpVideoTexture = () => {
  if (!_Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.tag('VideoTexture')) {
    const el = _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.stage.c({
      type: _VideoTexture__WEBPACK_IMPORTED_MODULE_9__["default"],
      ref: 'VideoTexture',
      zIndex: 0,
      videoEl,
    })
    _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.childList.addAt(el, 0)
  }
  return _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.tag('VideoTexture')
}

const registerEventListeners = () => {
  _Log__WEBPACK_IMPORTED_MODULE_2__["default"].info('VideoPlayer', 'Registering event listeners')
  Object.keys(_events__WEBPACK_IMPORTED_MODULE_4__["default"]).forEach(event => {
    const handler = e => {
      // Fire a metric for each event (if it exists on the metrics object)
      if (metrics && metrics[event] && typeof metrics[event] === 'function') {
        metrics[event]({ currentTime: videoEl.currentTime })
      }
      // fire an internal hook
      fireHook(event, { videoElement: videoEl, event: e })

      // fire the event (with human friendly event name) to the consumer of the VideoPlayer
      fireOnConsumer(_events__WEBPACK_IMPORTED_MODULE_4__["default"][event], { videoElement: videoEl, event: e })
    }

    eventHandlers[event] = handler
    videoEl.addEventListener(event, handler)
  })
}

const deregisterEventListeners = () => {
  _Log__WEBPACK_IMPORTED_MODULE_2__["default"].info('VideoPlayer', 'Deregistering event listeners')
  Object.keys(eventHandlers).forEach(event => {
    videoEl.removeEventListener(event, eventHandlers[event])
  })
  eventHandlers = {}
}

const videoPlayerPlugin = {
  consumer(component) {
    consumer = component
  },

  loader(loaderFn) {
    customLoader = loaderFn
  },

  unloader(unloaderFn) {
    customUnloader = unloaderFn
  },

  position(top = 0, left = 0) {
    videoEl.style.left = withPrecision(left)
    videoEl.style.top = withPrecision(top)
    if (textureMode === true) {
      videoTexture.position(top, left)
    }
  },

  size(width = 1920, height = 1080) {
    videoEl.style.width = withPrecision(width)
    videoEl.style.height = withPrecision(height)
    videoEl.width = parseFloat(videoEl.style.width)
    videoEl.height = parseFloat(videoEl.style.height)
    if (textureMode === true) {
      videoTexture.size(width, height)
    }
  },

  area(top = 0, right = 1920, bottom = 1080, left = 0) {
    this.position(top, left)
    this.size(right - left, bottom - top)
  },

  open(url, config = {}) {
    if (!this.canInteract) return
    metrics = _Metrics__WEBPACK_IMPORTED_MODULE_1__["default"].media(url)

    this.hide()
    deregisterEventListeners()

    if (this.src == url) {
      this.clear().then(this.open(url, config))
    } else {
      const adConfig = { enabled: state.adsEnabled, duration: 300 }
      if (config.videoId) {
        adConfig.caid = config.videoId
      }
      _Ads__WEBPACK_IMPORTED_MODULE_3__["default"].get(adConfig, consumer).then(ads => {
        state.playingAds = true
        ads.prerolls().then(() => {
          state.playingAds = false
          loader(url, videoEl, config)
            .then(() => {
              registerEventListeners()
              this.show()
              this.play()
            })
            .catch(e => {
              fireOnConsumer('error', { videoElement: videoEl, event: e })
            })
        })
      })
    }
  },

  reload() {
    if (!this.canInteract) return
    const url = videoEl.getAttribute('src')
    this.close()
    this.open(url)
  },

  close() {
    _Ads__WEBPACK_IMPORTED_MODULE_3__["default"].cancel()
    if (state.playingAds) {
      state.playingAds = false
      _Ads__WEBPACK_IMPORTED_MODULE_3__["default"].stop()
      // call self in next tick
      setTimeout(() => {
        this.close()
      })
    }
    if (!this.canInteract) return
    this.clear()
    this.hide()
    deregisterEventListeners()
  },

  clear() {
    if (!this.canInteract) return
    // pause the video first to disable sound
    this.pause()
    if (textureMode === true) videoTexture.stop()
    return unloader(videoEl).then(() => {
      fireOnConsumer('Clear', { videoElement: videoEl })
    })
  },

  play() {
    if (!this.canInteract) return
    if (textureMode === true) videoTexture.start()
    ;(0,_michieljs_execute_as_promise__WEBPACK_IMPORTED_MODULE_0__["default"])(videoEl.play, null, videoEl).catch(e => {
      fireOnConsumer('error', { videoElement: videoEl, event: e })
    })
  },

  pause() {
    if (!this.canInteract) return
    videoEl.pause()
  },

  playPause() {
    if (!this.canInteract) return
    this.playing === true ? this.pause() : this.play()
  },

  mute(muted = true) {
    if (!this.canInteract) return
    videoEl.muted = muted
  },

  loop(looped = true) {
    videoEl.loop = looped
  },

  seek(time) {
    if (!this.canInteract) return
    if (!this.src) return
    // define whether should continue to play after seek is complete (in seeked hook)
    if (state.playAfterSeek === null) {
      state.playAfterSeek = !!state.playing
    }
    // pause before actually seeking
    this.pause()
    // currentTime always between 0 and the duration of the video (minus 0.1s to not set to the final frame and stall the video)
    videoEl.currentTime = Math.max(0, Math.min(time, this.duration - 0.1))
  },

  skip(seconds) {
    if (!this.canInteract) return
    if (!this.src) return

    state.skipTime = (state.skipTime || videoEl.currentTime) + seconds
    ;(0,_helpers_easeExecution__WEBPACK_IMPORTED_MODULE_6__["default"])(() => {
      this.seek(state.skipTime)
      state.skipTime = false
    }, 300)
  },

  show() {
    if (!this.canInteract) return
    if (textureMode === true) {
      videoTexture.show()
    } else {
      videoEl.style.display = 'block'
      videoEl.style.visibility = 'visible'
    }
  },

  hide() {
    if (!this.canInteract) return
    if (textureMode === true) {
      videoTexture.hide()
    } else {
      videoEl.style.display = 'none'
      videoEl.style.visibility = 'hidden'
    }
  },

  enableAds(enabled = true) {
    state.adsEnabled = enabled
  },

  /* Public getters */
  get duration() {
    return videoEl && (isNaN(videoEl.duration) ? Infinity : videoEl.duration)
  },

  get currentTime() {
    return videoEl && videoEl.currentTime
  },

  get muted() {
    return videoEl && videoEl.muted
  },

  get looped() {
    return videoEl && videoEl.loop
  },

  get src() {
    return videoEl && videoEl.getAttribute('src')
  },

  get playing() {
    return state.playing
  },

  get playingAds() {
    return state.playingAds
  },

  get canInteract() {
    // todo: perhaps add an extra flag wether we allow interactions (i.e. pauze, mute, etc.) during ad playback
    return state.playingAds === false
  },

  get top() {
    return videoEl && parseFloat(videoEl.style.top)
  },

  get left() {
    return videoEl && parseFloat(videoEl.style.left)
  },

  get bottom() {
    return videoEl && parseFloat(videoEl.style.top - videoEl.style.height)
  },

  get right() {
    return videoEl && parseFloat(videoEl.style.left - videoEl.style.width)
  },

  get width() {
    return videoEl && parseFloat(videoEl.style.width)
  },

  get height() {
    return videoEl && parseFloat(videoEl.style.height)
  },

  get visible() {
    if (textureMode === true) {
      return videoTexture.isVisible
    } else {
      return videoEl && videoEl.style.display === 'block'
    }
  },

  get adsEnabled() {
    return state.adsEnabled
  },

  // prefixed with underscore to indicate 'semi-private'
  // because it's not recommended to interact directly with the video element
  get _videoEl() {
    return videoEl
  },

  get _consumer() {
    return consumer
  },
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_helpers_autoSetupMixin__WEBPACK_IMPORTED_MODULE_5__["default"])(videoPlayerPlugin, () => {
  precision =
    (_Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance &&
      _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.stage &&
      _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.stage.getRenderPrecision()) ||
    precision

  videoEl = setupVideoTag()

  textureMode = _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'textureMode', false)
  if (textureMode === true) {
    videoEl.setAttribute('crossorigin', 'anonymous')
    videoTexture = setUpVideoTexture()
  }
}));


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/helpers/autoSetupMixin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/helpers/autoSetupMixin.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((sourceObject, setup = () => {}) => {
  let ready = false

  const doSetup = () => {
    if (ready === false) {
      setup()
      ready = true
    }
  }

  return Object.keys(sourceObject).reduce((obj, key) => {
    if (typeof sourceObject[key] === 'function') {
      obj[key] = function() {
        doSetup()
        return sourceObject[key].apply(sourceObject, arguments)
      }
    } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).get === 'function') {
      obj.__defineGetter__(key, function() {
        doSetup()
        return Object.getOwnPropertyDescriptor(sourceObject, key).get.apply(sourceObject)
      })
    } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).set === 'function') {
      obj.__defineSetter__(key, function() {
        doSetup()
        return Object.getOwnPropertyDescriptor(sourceObject, key).set.sourceObject[key].apply(
          sourceObject,
          arguments
        )
      })
    } else {
      obj[key] = sourceObject[key]
    }
    return obj
  }, {})
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/helpers/easeExecution.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/helpers/easeExecution.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let timeout = null

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((cb, delay) => {
  clearTimeout(timeout)
  timeout = setTimeout(() => {
    cb()
  }, delay)
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/helpers/sequence.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/helpers/sequence.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (steps => {
  return steps.reduce((promise, method) => {
    return promise
      .then(function() {
        return method(...arguments)
      })
      .catch(e => Promise.reject(e))
  }, Promise.resolve(null))
});


/***/ }),

/***/ "./node_modules/@michieljs/execute-as-promise/src/execute-as-promise.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@michieljs/execute-as-promise/src/execute-as-promise.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((method, args = null, context = null) => {
  let result
  if (method && typeof method === 'function') {
    try {
      result = method.apply(context, args)
    } catch (e) {
      result = e
    }
  } else {
    result = method
  }

  // if it looks like a duck .. ehm ... promise and talks like a promise, let's assume it's a promise
  if (
    result !== null &&
    typeof result === 'object' &&
    result.then &&
    typeof result.then === 'function'
  ) {
    return result
  }
  // otherwise make it into a promise
  else {
    return new Promise((resolve, reject) => {
      if (result instanceof Error) {
        reject(result)
      } else {
        resolve(result)
      }
    })
  }
});


/***/ }),

/***/ "./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/***/ ((module) => {



var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ "./node_modules/localCookie/module/localCookie.js":
/*!********************************************************!*\
  !*** ./node_modules/localCookie/module/localCookie.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class localCookie{constructor(e){return e=e||{},this.forceCookies=e.forceCookies||!1,!0===this._checkIfLocalStorageWorks()&&!0!==e.forceCookies?{getItem:this._getItemLocalStorage,setItem:this._setItemLocalStorage,removeItem:this._removeItemLocalStorage,clear:this._clearLocalStorage}:{getItem:this._getItemCookie,setItem:this._setItemCookie,removeItem:this._removeItemCookie,clear:this._clearCookies}}_checkIfLocalStorageWorks(){if("undefined"==typeof localStorage)return!1;try{return localStorage.setItem("feature_test","yes"),"yes"===localStorage.getItem("feature_test")&&(localStorage.removeItem("feature_test"),!0)}catch(e){return!1}}_getItemLocalStorage(e){return window.localStorage.getItem(e)}_setItemLocalStorage(e,t){return window.localStorage.setItem(e,t)}_removeItemLocalStorage(e){return window.localStorage.removeItem(e)}_clearLocalStorage(){return window.localStorage.clear()}_getItemCookie(e){var t=document.cookie.match(RegExp("(?:^|;\\s*)"+function(e){return e.replace(/([.*+?\^${}()|\[\]\/\\])/g,"\\$1")}(e)+"=([^;]*)"));return t&&""===t[1]&&(t[1]=null),t?t[1]:null}_setItemCookie(e,t){var o=new Date,r=new Date(o.getTime()+15768e7);document.cookie=`${e}=${t}; expires=${r.toUTCString()};`}_removeItemCookie(e){document.cookie=`${e}=;Max-Age=-99999999;`}_clearCookies(){document.cookie.split(";").forEach(e=>{document.cookie=e.replace(/^ +/,"").replace(/=.*/,"=;expires=Max-Age=-99999999")})}}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localCookie);


/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   App: () => (/* binding */ App)
/* harmony export */ });
/* harmony import */ var _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/sdk */ "./node_modules/@lightningjs/sdk/index.js");
/* harmony import */ var _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebolt-js/sdk */ "./node_modules/@firebolt-js/sdk/dist/firebolt.js");
/* harmony import */ var _MyButton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MyButton */ "./src/MyButton.js");






class App extends _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.Component {
  static getFonts() {
    return [
      { family: "Regular", url: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("fonts/Roboto-Regular.ttf") },
    ];
  }

  static _template() {
    return {
      HelloWorld: {
        w: 1920,
        h: 1080,
        y: 0,
        rect: true,
        // color: 0xff000000,
       src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/pp.png"),

        FireboltStatus: {
          Rdklogo: {
            x: 70,
            y: 50,
            w: 300,
            h: 65,
            zIndex: 10,
           // shadowColor: 0xffff00ff,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/RDK-Logo-web.webp"),
          },
          Alexalogo: {
            x: 1050,
            y: 5,
            w: 170,
            h: 150,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/alexa.png"),
          },

          Trailer: {
            x: 120,
            y: 385,
            w: 100,
            h: 100,
            //color: 0xffff00ff,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/facebook.png"),
          },

          Watchparty: {
            x: 480,
            y: 385,
            w: 90,
             h: 90,
           
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/share.png"),
          },

          Bookmark: {
         
            x: 300,
            y: 385,
            w: 100,
            h: 90,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/bookmark.png"),
          },

          Info: {
            x: 650,
            y: 380,
            w: 100,
            h: 100,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/info.png"),
          },

          Belllogo: {
            x: 1285
            ,
            y: 30,
            w: 90,
            h: 90,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/sett.png"),
          },
          Notifilogo: {
            x: 1450,
            y: 30,
            w: 100,
            h: 100,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/noti.png"),
          },
          CurrentTime: {
            mountX: 0.5,
            x: 1700,
            y: 40,
            w: 200,
            h: 100, // Adjust the Y position as needed
            text: {
              text: "",
              fontFace: "Regular",
              fontSize: 70,
              //textColor: 0xff09f676,
            },
          },
          Text1: {
          
            x: 100,
            y: 610,
            w: 500,
            h: 80,
            text: {
              text: "Featured Video on Demand",
              fontFace: "Regular",
              fontSize: 30,
              //textColor: 0xff09f676,
            }
          },
        
          Device: {
            mountX: 0.5,
            x: 960,
            y: 1030,
            text: {
              // text: "Device not Ready!",
              fontFace: "Regular",
              fontSize: 24,
              //textColor: 0xff09f676,
            },
          },
        },
        Playbutton: {
          type: _MyButton__WEBPACK_IMPORTED_MODULE_2__.MyButton,
          mount: -0.2,
          x: 115,
          y: 130,
          text: {
            //text: "Recent",
            fontFace: "Regular",
            fontSize: 45,
            textColor: 0xffffffff,
          },
          signals: {
            onClick: "$onItemSelect",
          },
        },
      },
      Slider: {
        w: 800,
        h: 350,
        x: 480,
        y: 750,
        mount: 0.5,
        Wrapper: {},
      },
      SecondSlider: {
        w: 800,
        h: 350,
        x: 480,
        y: 750, // Adjust the Y position for the second slider
        mount: 0.5,
        SecondWrapper: {},
      },
      VideoSection: {
        alpha: 1,
        x: 0,
        y: 0,
        w: 1920,
        h: 1080,
        color: "0xff000000",
        rect: true,
        visible: false,
        HelpMsg: {
          x: 80,
          y: 50,
          w: 1920,
          text: {
            text: "Play the Video using AAMP Player",
            fontSize: 40,
            fontFace: "Regular",
            textAlign: "center",
            lineHeight: 50,
          },
          color: "0xffffffff",
          alpha: 1,
        },
        Video: {
          x: 0,
          y: 0,
          w: 1920, // Set to your desired width
          h: 1080, // Set to your desired height
          type: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.components.VideoItem, // Use the appropriate Lightning video
        },
      },
    };
  }

  _getFocused() {
    return this.tag("Playbutton");
  }

  _init() {
    // New code
    this.index = 0;
    this.dataLength = 6;
    this.currentSlider = "slider1"; // This keeps track of the current slider

    // Create buttons for the first slider
    const sliderButtons = [];
    for (let i = 0; i < this.dataLength; i++) {
      sliderButtons.push({
        type: _MyButton__WEBPACK_IMPORTED_MODULE_2__.MyButton,
        x: i * (300 + 10),
        item: {
          label: `Train`,
          src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset(`images/cardImage${i + 1}.jpg`),
        },
      });
    }
    this.tag("Wrapper").children = sliderButtons;
    this._updateCurrentTime();

    // Update the time every second (1000 milliseconds)
    setInterval(() => {
      this._updateCurrentTime();
    }, 1000);
  }

  _setSliderFocus() {
    if (this.currentSlider === "slider1") {
      this.tag("Wrapper").setSmooth("alpha", 1);
      this.tag("SecondWrapper").setSmooth("alpha", 1);
      this.tag("Wrapper").children[this.index].setFocus(true);
    } else if (this.currentSlider === "slider2") {
      this.tag("Wrapper").setSmooth("alpha", 1);
      this.tag("SecondWrapper").setSmooth("alpha", 1);
      this.tag("SecondWrapper").children[this.index].setFocus(true);
    }
  }

  $onItemSelect(obj) {
    const url =
      "https://media.axprod.net/TestVectors/v9-MultiFormat/Clear/Manifest_1080p.m3u8";
    this._player = new AAMPMediaPlayer();
    this._player.load(url);
    this._setState("VideoPlay");
  }

  _updateCurrentTime() {
    const currentTime = new Date();
    const hours = currentTime.getHours().toString().padStart(2, "0");
    const minutes = currentTime.getMinutes().toString().padStart(2, "0");
    const seconds = currentTime.getSeconds().toString().padStart(2, "0");
    const formattedTime = `${hours}:${minutes}`;
    this.tag("CurrentTime").text.text = `${formattedTime}`;
  }

  repositionWrapper() {
    const wrapper = this.tag("Wrapper");
    const sliderW = this.tag("Slider").w;
    const currentWrapperX =
      wrapper.transition("x").targetvalue || wrapper.x;
    const currentFocus = wrapper.children[this.index];
    const currentFocusX = currentFocus.x + currentWrapperX;
    const currentFocusOuterWidth =
      currentFocus.x + currentFocus.w;

    if (currentFocusX < 0) {
      wrapper.setSmooth("x", -currentFocus.x);
    } else if (currentFocusOuterWidth > sliderW) {
      wrapper.setSmooth(
        "x",
        sliderW - currentFocusOuterWidth
      );
    }
  }
  _handleLeft() {
    const slider =
      this.currentSlider === "slider1"
        ? this.tag("Wrapper")
        : this.tag("SecondWrapper");
    if (this.index > 0) {
      this.index--;
      slider.children[this.index].setFocus(true);
      slider.children[this.index + 1].setFocus(false);
    } else if (this.index === 0) {
      // If the current index is 0, set focus to the last index
      this.index = slider.children.length - 1;
      slider.children[0].setFocus(false);
      slider.children[this.index].setFocus(true);
    }
  }
  _handleRight() {
    const slider =
      this.currentSlider === "slider1"
        ? this.tag("Wrapper")
        : this.tag("SecondWrapper");
    if (this.index < this.dataLength - 1) {
      this.index++;
      slider.children[this.index].setFocus(true);
      slider.children[this.index - 1].setFocus(false);
    } else if (this.index === this.dataLength - 1) {
      // If the current index is the last index, set focus to the 0th index
      this.index = 0;
      slider.children[this.dataLength - 1].setFocus(false);
      slider.children[0].setFocus(true);
    }
  }

  _getSliderFocused() {
    return this.tag("Slider.Wrapper").children[this.index];
  }

  static _states() {
    return [
      class LaunchView extends this {
        _getFocused() {
          return this.tag("Playbutton");
        }
      },
      class SecondSliderState extends this {
        _getFocused() {
          if (this.currentSlider === "slider1") {
            return this.tag("Slider.Wrapper").children[this.index];
          } else {
            return this.tag("SecondSlider.SecondWrapper").children[this.index];
          }
        }
      },
      class VideoPlay extends this {
        _getFocused() {
          return this.tag("Video");
        }
        $enter() {
          this.tag("Video").visible = true;
          this.tag("HelloWorld").visible = false;
          this.tag("Slider").visible = false;
          this.tag("SecondSlider").visible = false;
        }
        _handleBack() {
          console.log("back to launchView");
          this.tag("Video").visible = false;

          this.tag("HelloWorld").visible = true;
          this.tag("Slider").visible = true;
          this.tag("SecondSlider").visible = true;

          this._setState("LaunchView");
          if (this._player) {
            this._player.stop();
            this._player = null;
          }
        }
      },
    ];
  }

  _active() {
    console.log("active set state to launchView");
    this._setState("LaunchView");

    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Device.version().then((version) => {
      const deviceVersion =
        "version:" +
        version.sdk.readable +
        " : v" +
        version.sdk.major +
        "." +
        version.sdk.minor +
        "." +
        version.sdk.patch;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(deviceVersion);
      this.tag("Device").text.text += deviceVersion;
    });
  }
}


/***/ }),

/***/ "./src/MyButton.js":
/*!*************************!*\
  !*** ./src/MyButton.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MyButton: () => (/* binding */ MyButton)
/* harmony export */ });
/* harmony import */ var _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/sdk */ "./node_modules/@lightningjs/sdk/index.js");


class MyButton extends _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.Component {
  static _template() {
    return {
      w: 250,
      h: 350,
      
      y: 100,
      Image: {
        x: 5,
        w: w => w,
        h: h => h - 50,
      },
    };
  }



  set item(obj) {
    const { label, src, videoUrl } = obj;
    this._videoUrl = videoUrl;
    this.patch({
      Image: { src },
    });
  }

  setFocus(isFocused) {
    if (isFocused) {
      this._focus();
    } else {
      this._unfocus();
    }
  }
  
  _handleEnter() {
    //console.log('Enter pressed');
    // this.signal("onClick");
    this.fireAncestors('$onItemSelect', {
     // videoUrl: this._videoUrl
      // item: this._item,

    })

  }

  _focus() {
    console.log('Button Focus');
    this.patch({
      smooth: { color: 0xff005500, scale: 1.1 },
      shader: { type: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.shaders.Outline, stroke: 1.1, color: 0xff09f676 },
    });
  }


  _unfocus() {
    console.log('Button Unfocus');
    this.patch({
      smooth: { color: 0xffffffff, scale: 1.0 },
      shader: { type: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.shaders.Outline, stroke: 0, color: 0x0000000 },
    });
  }
}

/***/ }),

/***/ "./src/settings.js":
/*!*************************!*\
  !*** ./src/settings.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appData: () => (/* binding */ appData),
/* harmony export */   appSettings: () => (/* binding */ appSettings),
/* harmony export */   platformSettings: () => (/* binding */ platformSettings)
/* harmony export */ });
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ "./package.json");



const isDevelopment = "development" === 'development';

const appData = {};

const appSettings = {
  version: _package_json__WEBPACK_IMPORTED_MODULE_0__.version,
  stage: {
    clearColor: '0x000000',
  },
  debug: false,
  
};

const platformSettings = {
  log: true,
  path: "./static",
  showVersion: false,
  
};


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/EventEmitter.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/EventEmitter.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventEmitter)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This is a partial (and more efficient) implementation of the event emitter.
 * It attempts to maintain a one-to-one mapping between events and listeners, skipping an array lookup.
 * Only if there are multiple listeners, they are combined in an array.
 */
class EventEmitter {

    constructor() {
        // This is set (and kept) to true when events are used at all.
        this._hasEventListeners = false;
    }

    on(name, listener) {
        if (!this._hasEventListeners) {
            this._eventFunction = {}
            this._eventListeners = {}
            this._hasEventListeners = true;
        }

        const current = this._eventFunction[name];
        if (!current) {
            this._eventFunction[name] = listener;
        } else {
            if (this._eventFunction[name] !== EventEmitter.combiner) {
                this._eventListeners[name] = [this._eventFunction[name], listener];
                this._eventFunction[name] = EventEmitter.combiner;
            } else {
                this._eventListeners[name].push(listener);
            }
        }
    }

    once(name, listener) {
        const wrapper = (arg1, arg2, arg3) => {
            listener(arg1, arg2, arg3);
            this.off(name, wrapper);
        }
        wrapper.__originalFunc = listener;
        this.on(name, wrapper);
    }

    has(name, listener) {
        if (this._hasEventListeners) {
            const current = this._eventFunction[name];
            if (current) {
                if (current === EventEmitter.combiner) {
                    const listeners = this._eventListeners[name];
                    for (const l of listeners) {
                        if (l === listener || l.__originalFunc == listener) {
                            return true;
                        }
                    }
                } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
                    return true;
                }
            }
        }
        return false;
    }

    off(name, listener) {
        if (this._hasEventListeners) {
            const current = this._eventFunction[name];
            if (current) {
                if (current === EventEmitter.combiner) {
                    const listeners = this._eventListeners[name];
                    let index = listeners.indexOf(listener);
                    if (index >= 0) {
                        listeners.splice(index, 1);
                    }
                    index = listeners.map((l) => l.__originalFunc).indexOf(listener);
                    if (index >= 0) {
                        listeners.splice(index, 1);
                    }
                    if (listeners.length === 1) {
                        this._eventFunction[name] = listeners[0];
                        this._eventListeners[name] = undefined;
                    }
                } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
                    this._eventFunction[name] = undefined;
                }
            }
        }
    }

    removeListener(name, listener) {
        this.off(name, listener);
    }

    emit(name, arg1, arg2, arg3) {
        if (this._hasEventListeners) {
            const func = this._eventFunction[name];
            if (func) {
                if (func === EventEmitter.combiner) {
                    func(this, name, arg1, arg2, arg3);
                } else {
                    func(arg1, arg2, arg3);
                }
            }
        }
    }

    listenerCount(name) {
        if (this._hasEventListeners) {
            const func = this._eventFunction[name];
            if (func) {
                if (func === EventEmitter.combiner) {
                    return this._eventListeners[name].length;
                } else {
                    return 1;
                }
            }
        }
        return 0;
    }

    removeAllListeners(name) {
        if (this._hasEventListeners) {
            delete this._eventFunction[name];
            delete this._eventListeners[name];
        }
    }

}

EventEmitter.combiner = function(object, name, arg1, arg2, arg3) {
    const listeners = object._eventListeners[name];
    if (listeners) {
        /* Because listener may detach itself while being invoked and therefore invalidate the iterator,
           we need to create a copy to loop over it */
        for (const listener of [...listeners]) {
            listener(arg1, arg2, arg3);
        }
    }
}

EventEmitter.addAsMixin = function(cls) {
    cls.prototype.on = EventEmitter.prototype.on;
    cls.prototype.once = EventEmitter.prototype.once;
    cls.prototype.has = EventEmitter.prototype.has;
    cls.prototype.off = EventEmitter.prototype.off;
    cls.prototype.removeListener = EventEmitter.prototype.removeListener;
    cls.prototype.emit = EventEmitter.prototype.emit;
    cls.prototype.listenerCount = EventEmitter.prototype.listenerCount;
    cls.prototype.removeAllListeners = EventEmitter.prototype.removeAllListeners;
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/Animation.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/Animation.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Animation)
/* harmony export */ });
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class Animation extends _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(manager, settings, element) {
        super();

        this.manager = manager;

        this._settings = settings;

        this._element = element;

        this._state = Animation.STATES.IDLE;

        this._p = 0;
        this._delayLeft = 0;
        this._repeatsLeft = 0;

        this._stopDelayLeft = 0;
        this._stopP = 0;
    }

    start() {
        if (this._element && this._element.attached) {
            this._p = 0;
            this._delayLeft = this.settings.delay;
            this._repeatsLeft = this.settings.repeat;
            this._state = Animation.STATES.PLAYING;
            this.emit('start');
            this.checkActive();
        } else {
            console.warn("[Lightning] Element must be attached before starting animation");
        }
    }

    play() {
        if (this._state === Animation.STATES.PAUSED) {
            // Continue.;
            this._state = Animation.STATES.PLAYING;
            this.checkActive();
            this.emit('resume');
        } else if (this._state == Animation.STATES.STOPPING && this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.REVERSE) {
            // Continue.;
            this._state = Animation.STATES.PLAYING;
            this.emit('stopContinue');
        } else if (this._state != Animation.STATES.PLAYING && this._state != Animation.STATES.FINISHED) {
            // Restart.;
            this.start();
        }
    }

    pause() {
        if (this._state === Animation.STATES.PLAYING) {
            this._state = Animation.STATES.PAUSED;
            this.emit('pause');
        }
    }

    replay() {
        if (this._state == Animation.STATES.FINISHED) {
            this.start();
        } else {
            this.play();
        }
    }

    skipDelay() {
        this._delayLeft = 0;
        this._stopDelayLeft = 0;
    }

    finish() {
        if (this._state === Animation.STATES.PLAYING) {
            this._delayLeft = 0;
            this._p = 1;
        } else if (this._state === Animation.STATES.STOPPING) {
            this._stopDelayLeft = 0;
            this._p = 0;
        }
    }

    stop() {
        if (this._state === Animation.STATES.STOPPED || this._state === Animation.STATES.IDLE) return;

        this._stopDelayLeft = this.settings.stopDelay || 0;

        if (((this.settings.stopMethod === _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.IMMEDIATE) && !this._stopDelayLeft) || this._delayLeft > 0) {
            // Stop upon next progress.;
            this._state = Animation.STATES.STOPPING;
            this.emit('stop');
        } else {
            if (this.settings.stopMethod === _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FADE) {
                this._stopP = 0;
            }

            this._state = Animation.STATES.STOPPING;
            this.emit('stop');
        }

        this.checkActive();
    }

    stopNow() {
        if (this._state !== Animation.STATES.STOPPED || this._state !== Animation.STATES.IDLE) {
            this._state = Animation.STATES.STOPPING;
            this._p = 0;
            this.emit('stop');
            this.reset();
            this._state = Animation.STATES.STOPPED;
            this.emit('stopFinish');
        }
    }

    isPaused() {
        return this._state === Animation.STATES.PAUSED;
    }

    isPlaying() {
        return this._state === Animation.STATES.PLAYING;
    }

    isStopping() {
        return this._state === Animation.STATES.STOPPING;
    }

    isFinished() {
        return this._state === Animation.STATES.FINISHED;
    }

    checkActive() {
        if (this.isActive()) {
            this.manager.addActive(this);
        }
    }

    isActive() {
        return (this._state == Animation.STATES.PLAYING || this._state == Animation.STATES.STOPPING) && this._element && this._element.attached;
    }

    progress(dt) {
        if (!this._element) return;
        this._progress(dt);
        this.apply();
    }

    _progress(dt) {
        if (this._state == Animation.STATES.STOPPING) {
            this._stopProgress(dt);
            return;
        }

        if (this._state != Animation.STATES.PLAYING) {
            return;
        }

        if (this._delayLeft > 0) {
            this._delayLeft -= dt;

            if (this._delayLeft < 0) {
                dt = -this._delayLeft;
                this._delayLeft = 0;

                this.emit('delayEnd');
            } else {
                return;
            }
        }

        if (this.settings.duration === 0) {
            this._p = 1;
        } else if (this.settings.duration > 0) {
            this._p += dt / this.settings.duration;
        }
        if (this._p >= 1) {
            // Finished!;
            if (this.settings.repeat == -1 || this._repeatsLeft > 0) {
                if (this._repeatsLeft > 0) {
                    this._repeatsLeft--;
                }
                this._p = this.settings.repeatOffset;
                this.emit('progress', this._p);
                
                if (this.settings.repeatDelay) {
                    this._delayLeft = this.settings.repeatDelay;
                }

                this.emit('repeat', this._repeatsLeft);
            } else {
                this._p = 1;
                this.emit('progress', this._p);
                
                this._state = Animation.STATES.FINISHED;
                this.emit('finish');
                if (this.settings.autostop) {
                    this.stop();
                }
            }
        } else {
            this.emit('progress', this._p);
        }
    }
    
    _stopProgress(dt) {
        let duration = this._getStopDuration();

        if (this._stopDelayLeft > 0) {
            this._stopDelayLeft -= dt;

            if (this._stopDelayLeft < 0) {
                dt = -this._stopDelayLeft;
                this._stopDelayLeft = 0;

                this.emit('stopDelayEnd');
            } else {
                return;
            }
        }
        if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.IMMEDIATE) {
            this._state = Animation.STATES.STOPPED;
            this.emit('stopFinish');
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.REVERSE) {
            if (duration === 0) {
                this._p = 0;
            } else if (duration > 0) {
                this._p -= dt / duration;
            }

            if (this._p <= 0) {
                this._p = 0;
                this._state = Animation.STATES.STOPPED;
                this.emit('stopFinish');
            }
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FADE) {
            this._progressStopTransition(dt);
            if (this._stopP >= 1) {
                this._p = 0;
                this._state = Animation.STATES.STOPPED;
                this.emit('stopFinish');
            }
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.ONETOTWO) {
            if (this._p < 2) {
                if (duration === 0) {
                    this._p = 2;
                } else if (duration > 0) {
                    if (this._p < 1) {
                        this._p += dt / this.settings.duration;
                    } else {
                        this._p += dt / duration;
                    }
                }
                if (this._p >= 2) {
                    this._p = 2;
                    this._state = Animation.STATES.STOPPED;
                    this.emit('stopFinish');
                } else {
                    this.emit('progress', this._p);
                }
            }
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FORWARD) {
            if (this._p < 1) {
                if (this.settings.duration == 0) {
                    this._p = 1;
                } else {
                    this._p += dt / this.settings.duration;
                }
                if (this._p >= 1) {
                    if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FORWARD) {
                        this._p = 1;
                        this._state = Animation.STATES.STOPPED;
                        this.emit('stopFinish');
                    } else {
                        if (this._repeatsLeft > 0) {
                            this._repeatsLeft--;
                            this._p = 0;
                            this.emit('repeat', this._repeatsLeft);
                        } else {
                            this._p = 1;
                            this._state = Animation.STATES.STOPPED;
                            this.emit('stopFinish');
                        }
                    }
                } else {
                    this.emit('progress', this._p);
                }
            }
        }
        
    }
    
    _progressStopTransition(dt) {
        if (this._stopP < 1) {
            if (this._stopDelayLeft > 0) {
                this._stopDelayLeft -= dt;

                if (this._stopDelayLeft < 0) {
                    dt = -this._stopDelayLeft;
                    this._stopDelayLeft = 0;

                    this.emit('delayEnd');
                } else {
                    return;
                }
            }
            
            const duration = this._getStopDuration();

            if (duration == 0) {
                this._stopP = 1;
            } else {
                this._stopP += dt / duration;
            }
            if (this._stopP >= 1) {
                // Finished!;
                this._stopP = 1;
            }
        }
    }

    _getStopDuration() {
        return this.settings.stopDuration || this.settings.duration;
    }

    apply() {
        if (this._state === Animation.STATES.STOPPED) {
            this.reset();
        } else {
            let factor = 1;
            if (this._state === Animation.STATES.STOPPING && this.settings.stopMethod === _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FADE) {
                factor = (1 - this.settings.stopTimingFunctionImpl(this._stopP));
            }
            this._settings.apply(this._element, this._p, factor);
        }
    }

    reset() {
        this._settings.reset(this._element);
    }

    get state() {
        return this._state;
    }

    get p() {
        return this._p;
    }

    get delayLeft() {
        return this._delayLeft;
    }

    get element() {
        return this._element;
    }

    get frame() {
        return Math.round(this._p * this._settings.duration * 60);
    }

    get settings() {
        return this._settings;
    }

}

Animation.STATES = {
    IDLE: 0,
    PLAYING: 1,
    STOPPING: 2,
    STOPPED: 3,
    FINISHED: 4,
    PAUSED: 5
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/AnimationActionSettings.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/AnimationActionSettings.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationActionSettings)
/* harmony export */ });
/* harmony import */ var _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/MultiSpline.mjs */ "./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs");
/* harmony import */ var _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tree/Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class AnimationActionSettings {

    constructor(animationSettings) {

        this.animationSettings = animationSettings;

        /**
         * The selector that selects the elements.
         * @type {string}
         */
        this._selector = "";

        /**
         * The value items, ordered by progress offset.
         * @type {MultiSpline}
         * @private;
         */
        this._items = new _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]();

        /**
         * The affected properties (paths).
         * @private;
         */
        this._props = [];

        /**
         * Property setters, indexed according to props.
         * @private;
         */
        this._propSetters = [];

        this._resetValue = undefined;
        this._hasResetValue = false;

        this._hasColorProperty = undefined;
    }

    getResetValue() {
        if (this._hasResetValue) {
            return this._resetValue;
        } else {
            return this._items.getValue(0);
        }
    }

    apply(element, p, factor) {
        const elements = this.getAnimatedElements(element);

        let v = this._items.getValue(p);

        if (v === undefined || !elements.length) {
            return;
        }

        if (factor !== 1) {
            // Stop factor.;
            let sv = this.getResetValue();

            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(v) && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(sv)) {
                if (this.hasColorProperty()) {
                    v = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].mergeColors(v, sv, factor);
                } else {
                    v = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].mergeNumbers(v, sv, factor);
                }
            }
        }

        // Apply transformation to all components.;
        const n = this._propSetters.length;

        const m = elements.length;
        for (let j = 0; j < m; j++) {
            for (let i = 0; i < n; i++) {
                this._propSetters[i](elements[j], v);
            }
        }
    }
    
    getAnimatedElements(element) {
        return element.select(this._selector);
    }

    reset(element) {
        const elements = this.getAnimatedElements(element);

        let v = this.getResetValue();

        if (v === undefined || !elements.length) {
            return;
        }

        // Apply transformation to all components.
        const n = this._propSetters.length;

        const m = elements.length;
        for (let j = 0; j < m; j++) {
            for (let i = 0; i < n; i++) {
                this._propSetters[i](elements[j], v);
            }
        }
    }
    
    set selector(v) {
        this._selector = v;
    }

    set t(v) {
        this.selector = v;
    }

    get resetValue() {
        return this._resetValue;
    }
    
    set resetValue(v) {
        this._resetValue = v;
        this._hasResetValue = (v !== undefined);
    }

    set rv(v) {
        this.resetValue = v;
    }

    set value(v) {
        this._items.parse(this.hasColorProperty(), v);
    }

    set v(v) {
        this.value = v;
    }

    set properties(v) {
        if (!Array.isArray(v)) {
            v = [v];
        }

        this._props = [];

        v.forEach((prop) => {
            this._props.push(prop);
            this._propSetters.push(_tree_Element_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].getSetter(prop));
        });
    }

    set property(v) {
        this._hasColorProperty = undefined;
        this.properties = v;
    }

    set p(v) {
        this.properties = v;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].patchObject(this, settings);
    }

    hasColorProperty() {
        if (this._hasColorProperty === undefined) {
            this._hasColorProperty = this._props.length ? _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isColorProperty(this._props[0]) : false;
        }
        return this._hasColorProperty;
    }
}

AnimationActionSettings.prototype.isAnimationActionSettings = true;








/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/AnimationManager.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/AnimationManager.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationManager)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnimationSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs");
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@lightningjs/core/src/animation/Animation.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class AnimationManager {

    constructor(stage) {
        this.stage = stage;

        this.stage.on('frameStart', () => this.progress());

        /**
         * All running animations on attached subjects.
         * @type {Set<Animation>}
         */
        this.active = new Set();
    }

    progress() {
        if (this.active.size) {
            let dt = this.stage.dt;

            let filter = false;
            this.active.forEach(function(a) {
                if (a.isActive()) {
                    a.progress(dt);
                } else {
                    filter = true;
                }
            });

            if (filter) {
                this.active = new Set([...this.active].filter(t => t.isActive()));
            }
        }
    }

    createAnimation(element, settings) {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(settings)) {
            // Convert plain object to proper settings object.
            settings = this.createSettings(settings);
        }

        return new _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
            this,
            settings,
            element
        );
    }

    createSettings(settings) {
        const animationSettings = new _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]();
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].patchObject(animationSettings, settings);
        return animationSettings;
    }

    addActive(transition) {
        this.active.add(transition);
    }
}







/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationSettings)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _AnimationActionSettings_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationActionSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationActionSettings.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class AnimationSettings {
    constructor() {
        /**
         * @type {AnimationActionSettings[]}
         */
        this._actions = [];

        this.delay = 0;
        this.duration = 1;

        this.repeat = 0;
        this.repeatOffset = 0;
        this.repeatDelay = 0;

        this.autostop = false;

        this.stopMethod = AnimationSettings.STOP_METHODS.FADE;
        this._stopTimingFunction = 'ease';
        this._stopTimingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(this._stopTimingFunction);
        this.stopDuration = 0;
        this.stopDelay = 0;
    }

    get actions() {
        return this._actions;
    }

    set actions(v) {
        this._actions = [];
        for (let i = 0, n = v.length; i < n; i++) {
            const e = v[i];
            if (!e.isAnimationActionSettings) {
                const aas = new _AnimationActionSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
                aas.patch(e);
                this._actions.push(aas);
            } else {
                this._actions.push(e);
            }
        }
    }

    /**
     * Applies the animation to the specified element, for the specified progress between 0 and 1.
     * @param {Element} element;
     * @param {number} p;
     * @param {number} factor;
     */
    apply(element, p, factor = 1) {
        this._actions.forEach(function(action) {
            action.apply(element, p, factor);
        });
    }

    /**
     * Resets the animation to the reset values.
     * @param {Element} element;
     */
    reset(element) {
        this._actions.forEach(function(action) {
            action.reset(element);
        });
    }

    get stopTimingFunction() {
        return this._stopTimingFunction;
    }

    set stopTimingFunction(v) {
        this._stopTimingFunction = v;
        this._stopTimingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(v);
    }

    get stopTimingFunctionImpl() {
        return this._stopTimingFunctionImpl;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObject(this, settings);
    }

}

AnimationSettings.STOP_METHODS = {
    FADE: 'fade',
    REVERSE: 'reverse',
    FORWARD: 'forward',
    IMMEDIATE: 'immediate',
    ONETOTWO: 'onetotwo'
};



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/Transition.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/Transition.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Transition)
/* harmony export */ });
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Transition extends _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(manager, settings, element, property) {
        super();

        this.manager = manager;

        this._settings = settings;

        this._element = element;

        this._getter = element.constructor.getGetter(property);
        this._setter = element.constructor.getSetter(property);

        this._merger = settings.merger;

        if (!this._merger) {
            this._merger = element.constructor.getMerger(property);
        }

        this._startValue = this._getter(this._element);
        this._targetValue = this._startValue;

        this._p = 1;
        this._delayLeft = 0;
    }

    start(targetValue) {
        this._startValue = this._getter(this._element);

        if (!this.isAttached()) {
            // We don't support transitions on non-attached elements. Just set value without invoking listeners.
            this._targetValue = targetValue;
            this._p = 1;
            this._updateDrawValue();
        } else {
            if (targetValue === this._startValue) {
                this.reset(targetValue, 1);
            } else {
                this._targetValue = targetValue;
                this._p = 0;
                this._delayLeft = this._settings.delay;
                this.emit('start');
                this.add();
            }
        }
    }

    finish() {
        if (this._p < 1) {
            // Value setting and will must be invoked (async) upon next transition cycle.
            this._p = 1;
        }
    }

    stop() {
        // Just stop where the transition is at.
        this.emit('stop');
        this.manager.removeActive(this);
    }

    pause() {
        this.stop();
    }

    play() {
        this.manager.addActive(this);
    }

    reset(targetValue, p) {
        if (!this.isAttached()) {
            // We don't support transitions on non-attached elements. Just set value without invoking listeners.
            this._startValue = this._getter(this._element);
            this._targetValue = targetValue;
            this._p = 1;
            this._updateDrawValue();
        } else {
            this._startValue = this._getter(this._element);
            this._targetValue = targetValue;
            this._p = p;
            this.add();
        }
    }

    _updateDrawValue() {
        this._setter(this._element, this.getDrawValue());
    }

    add() {
        this.manager.addActive(this);
    }

    isAttached() {
        return this._element.attached;
    }

    isRunning() {
        return (this._p < 1.0);
    }

    progress(dt) {
        if (!this.isAttached()) {
            // Skip to end of transition so that it is removed.
            this._p = 1;
        }

        if (this.p < 1) {
            if (this.delayLeft > 0) {
                this._delayLeft -= dt;

                if (this.delayLeft < 0) {
                    dt = -this.delayLeft;
                    this._delayLeft = 0;

                    this.emit('delayEnd');
                } else {
                    return;
                }
            }

            if (this._settings.duration == 0) {
                this._p = 1;
            } else {
                this._p += dt / this._settings.duration;
            }
            if (this._p >= 1) {
                // Finished!;
                this._p = 1;
            }
        }

        this._updateDrawValue();

        this.invokeListeners();
    }

    invokeListeners() {
        this.emit('progress', this.p);
        if (this.p === 1) {
            this.emit('finish');
        }
    }

    updateTargetValue(targetValue) {
        let t = this._settings.timingFunctionImpl(this.p);
        if (t === 1) {
            this._targetValue = targetValue;
        } else if (t === 0) {
            this._startValue = this._targetValue;
            this._targetValue = targetValue;
        } else {
            this._startValue = targetValue - ((targetValue - this._targetValue) / (1 - t));
            this._targetValue = targetValue;
        }
    }

    getDrawValue() {
        if (this.p >= 1) {
            return this.targetValue;
        } else {
            let v = this._settings._timingFunctionImpl(this.p);
            return this._merger(this.targetValue, this.startValue, v);
        }
    }

    skipDelay() {
        this._delayLeft = 0;
    }

    get startValue() {
        return this._startValue;
    }

    get targetValue() {
        return this._targetValue;
    }

    get p() {
        return this._p;
    }

    get delayLeft() {
        return this._delayLeft;
    }

    get element() {
        return this._element;
    }

    get settings() {
        return this._settings;
    }

    set settings(v) {
        this._settings = v;
    }

}

Transition.prototype.isTransition = true;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/TransitionManager.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/TransitionManager.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransitionManager)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _TransitionSettings_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransitionSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/TransitionSettings.mjs");
/* harmony import */ var _Transition_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transition.mjs */ "./node_modules/@lightningjs/core/src/animation/Transition.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class TransitionManager {

    constructor(stage) {
        this.stage = stage;

        this.stage.on('frameStart', () => this.progress());

        /**
         * All transitions that are running and attached.
         * (we don't support transitions on un-attached elements to prevent memory leaks)
         * @type {Set<Transition>}
         */
        this.active = new Set();

        this.defaultTransitionSettings = new _TransitionSettings_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this.stage);
    }

    progress() {
        if (this.active.size) {
            let dt = this.stage.dt;

            let filter = false;
            this.active.forEach(function(a) {
                a.progress(dt);
                if (!a.isRunning()) {
                    filter = true;
                }
            });

            if (filter) {
                this.active = new Set([...this.active].filter(t => (t.isRunning())));
            }
        }
    }

    createSettings(settings) {
        const transitionSettings = new _TransitionSettings_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]();
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(transitionSettings, settings);
        return transitionSettings;
    }

    addActive(transition) {
        this.active.add(transition);
    }

    removeActive(transition) {
        this.active.delete(transition);
    }
}






/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/TransitionSettings.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/TransitionSettings.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransitionSettings)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TransitionSettings {
    constructor(stage) {
        this.stage = stage;
        this._timingFunction = 'ease';
        this._timingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(this._timingFunction);
        this.delay = 0;
        this.duration = 0.2;
        this.merger = null;
    }

    get timingFunction() {
        return this._timingFunction;
    }

    set timingFunction(v) {
        this._timingFunction = v;
        this._timingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(v);
    }

    get timingFunctionImpl() {
        return this._timingFunctionImpl;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(this, settings);
    }
}

TransitionSettings.prototype.isTransitionSettings = true;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/application/Application.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/application/Application.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Application)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/Stage.mjs */ "./node_modules/@lightningjs/core/src/tree/Stage.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class Application extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(options = {}, properties) {
        // Save options temporarily to avoid having to pass it through the constructor.
        Application._temp_options = options;

        // Booting flag is used to postpone updateFocusSettings;
        Application.booting = true;
        const stage = new _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](options.stage);
        super(stage, properties);
        Application.booting = false;

        this.__updateFocusCounter = 0;
        this.__keypressTimers = new Map();
        this.__hoveredChild = null;

        // We must construct while the application is not yet attached.
        // That's why we 'init' the stage later (which actually emits the attach event).
        this.stage.init();

        // Initially, the focus settings are updated after both the stage and application are constructed.
        this.updateFocusSettings();

        this.__keymap = this.getOption('keys');

        if (this.__keymap) {
            this.stage.platform.registerKeydownHandler((e) => {
                this._receiveKeydown(e);
            });

            this.stage.platform.registerKeyupHandler((e) => {
                this._receiveKeyup(e);
            });
        }

        if (this.getOption("enablePointer")) {
            this.stage.platform.registerClickHandler((e) => {
                this._receiveClick(e);
            });

            this.stage.platform.registerHoverHandler((e) => {
                this._receiveHover(e);
            });

            this.stage.platform.registerScrollWheelHandler((e) => {
                this._recieveScrollWheel(e);
            });

            this.cursor = 'default';
        }
    }

    getOption(name) {
        return this.__options[name];
    }

    _setOptions(o) {
        this.__options = {};

        let opt = (name, def) => {
            let value = o[name];

            if (value === undefined) {
                this.__options[name] = def;
            } else {
                this.__options[name] = value;
            }
        }

        opt('debug', false);
        opt('keys', {
            38: "Up",
            40: "Down",
            37: "Left",
            39: "Right",
            13: "Enter",
            8: "Back",
            27: "Exit"
        });
        opt('enablePointer', false);
    }

    __construct() {
        this.stage.setApplication(this);

        this._setOptions(Application._temp_options);
        delete Application._temp_options;

        super.__construct();
    }

    __init() {
        super.__init();
        this.__updateFocus();
    }

    updateFocusPath() {
        this.__updateFocus();
    }

    __updateFocus() {
        const notOverridden = this.__updateFocusRec();

        if (!Application.booting && notOverridden) {
            this.updateFocusSettings();
        }
    }

    __updateFocusRec() {
        const updateFocusId = ++this.__updateFocusCounter;
        this.__updateFocusId = updateFocusId;

        const newFocusPath = this.__getFocusPath();
        const newFocusedComponent = newFocusPath[newFocusPath.length - 1];
        const prevFocusedComponent = this._focusPath ? this._focusPath[this._focusPath.length - 1] : undefined;

        if (!prevFocusedComponent) {
            // Focus events.
            this._focusPath = [];
            for (let i = 0, n = newFocusPath.length; i < n; i++) {
                this._focusPath.push(newFocusPath[i]);
                this._focusPath[i]._focus(newFocusedComponent, undefined);
                const focusOverridden = (this.__updateFocusId !== updateFocusId);
                if (focusOverridden) {
                    return false;
                }
            }
            return true;
        } else {
            let m = Math.min(this._focusPath.length, newFocusPath.length);
            let index;
            for (index = 0; index < m; index++) {
                if (this._focusPath[index] !== newFocusPath[index]) {
                    break;
                }
            }

            if (this._focusPath.length !== newFocusPath.length || index !== newFocusPath.length) {

                if (this.getOption('debug')) {
                    console.log('[Lightning] Focus changed: ' + newFocusedComponent.getLocationString());
                }

                // Unfocus events.
                for (let i = this._focusPath.length - 1; i >= index; i--) {
                    const unfocusedElement = this._focusPath.pop();
                    unfocusedElement._unfocus(newFocusedComponent, prevFocusedComponent);
                    const focusOverridden = (this.__updateFocusId !== updateFocusId);
                    if (focusOverridden) {
                        return false;
                    }
                }

                // Focus events.
                for (let i = index, n = newFocusPath.length; i < n; i++) {
                    this._focusPath.push(newFocusPath[i]);
                    this._focusPath[i]._focus(newFocusedComponent, prevFocusedComponent);
                    const focusOverridden = (this.__updateFocusId !== updateFocusId);
                    if (focusOverridden) {
                        return false;
                    }
                }

                // Focus changed events.
                for (let i = 0; i < index; i++) {
                    this._focusPath[i]._focusChange(newFocusedComponent, prevFocusedComponent);
                }
            }
        }

        return true;
    }

    updateFocusSettings() {
        const focusedComponent = this._focusPath[this._focusPath.length - 1];

        // Get focus settings. These can be used for dynamic application-wide settings that depend on the
        // focus directly (such as the application background).
        const focusSettings = {};
        const defaultSetFocusSettings = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].prototype._setFocusSettings;
        for (let i = 0, n = this._focusPath.length; i < n; i++) {
            if (this._focusPath[i]._setFocusSettings !== defaultSetFocusSettings) {
                this._focusPath[i]._setFocusSettings(focusSettings);
            }
        }

        const defaultHandleFocusSettings = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].prototype._handleFocusSettings;
        for (let i = 0, n = this._focusPath.length; i < n; i++) {
            if (this._focusPath[i]._handleFocusSettings !== defaultHandleFocusSettings) {
                this._focusPath[i]._handleFocusSettings(focusSettings, this.__prevFocusSettings, focusedComponent);
            }
        }

        this.__prevFocusSettings = focusSettings;
    }

    _handleFocusSettings(settings, prevSettings, focused, prevFocused) {
        // Override to handle focus-based settings.
    }

    __getFocusPath() {
        const path = [this];
        let current = this;
        do {
            const nextFocus = current._getFocused();
            if (!nextFocus || (nextFocus === current)) {
                // Found!;
                break;
            }


            let ptr = nextFocus.cparent;
            if (ptr === current) {
                path.push(nextFocus);
            } else {
                // Not an immediate child: include full path to descendant.
                const newParts = [nextFocus];
                do {
                    if (!ptr) {
                        current._throwError("Return value for _getFocused must be an attached descendant component but its '" + nextFocus.getLocationString() + "'");
                    }
                    newParts.push(ptr);
                    ptr = ptr.cparent;
                } while (ptr !== current);

                // Add them reversed.
                for (let i = 0, n = newParts.length; i < n; i++) {
                    path.push(newParts[n - i - 1]);
                }
            }

            current = nextFocus;
        } while(true);

        return path;
    }

    get focusPath() {
        return this._focusPath;
    }

    /**
     * Injects an event in the state machines, top-down from application to focused component.
     */
    focusTopDownEvent(events, ...args) {
        const path = this.focusPath;
        const n = path.length;

        // Multiple events.
        for (let i = 0; i < n; i++) {
            const event = path[i]._getMostSpecificHandledMember(events);
            if (event !== undefined) {
                const returnValue = path[i][event](...args);
                if (returnValue !== false) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Injects an event in the state machines, bottom-up from focused component to application.
     */
    focusBottomUpEvent(events, ...args) {
        const path = this.focusPath;
        const n = path.length;

        // Multiple events.
        for (let i = n - 1; i >= 0; i--) {
            const event = path[i]._getMostSpecificHandledMember(events);
            if (event !== undefined) {
                const returnValue = path[i][event](...args);
                if (returnValue !== false) {
                    return true;
                }
            }
        }

        return false;
    }

    _receiveKeydown(e) {
        const obj = e;
        const key = this.__keymap[e.keyCode];
        const path = this.focusPath;

        let keys;
        if (key) {
            keys = Array.isArray(key) ? key : [key];
        }

        if (keys) {
            for (let i = 0, n = keys.length; i < n; i++) {
                const hasTimer = this.__keypressTimers.has(keys[i]);
                // prevent event from getting fired when the timeout is still active
                if (path[path.length - 1].longpress && hasTimer) {
                    return;
                }

                if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}`, "_captureKey"], obj)) {
                    this.stage.application.focusBottomUpEvent([`_handle${keys[i]}`, "_handleKey"], obj);
                }
            }
        } else {
            if (!this.stage.application.focusTopDownEvent(["_captureKey"], obj)) {
                this.stage.application.focusBottomUpEvent(["_handleKey"], obj);
            }
        }

        this.updateFocusPath();

        const consumer = path[path.length - 1];

        if (keys && consumer.longpress) {
            for (let i = 0, n = keys.length; i < n; i++) {
                this._startLongpressTimer(keys[i], consumer);
            }
        }
    }

    /**
     * Keyup listener
     * To take away some confusion we add `Release` to the event to prevent ending up with method names like:
     *  _handleLeftUp / _handleUpUp / _handleEnterUp etc
     *
     * @param e
     * @private
     */
    _receiveKeyup(e) {
        const obj = e;
        const key = this.__keymap[e.keyCode];

        let keys;
        if (key) {
            keys = Array.isArray(key) ? key : [key];
        }

        if (keys) {
            for (let i = 0, n = keys.length; i < n; i++) {
                if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}Release`, "_captureKeyRelease"], obj)) {
                    this.stage.application.focusBottomUpEvent([`_handle${keys[i]}Release`, "_handleKeyRelease"], obj);
                }
            }
        } else {
            if (!this.stage.application.focusTopDownEvent(["_captureKeyRelease"], obj)) {
                this.stage.application.focusBottomUpEvent(["_handleKeyRelease"], obj);
            }
        }

        this.updateFocusPath();

        if (keys) {
            for (let i = 0, n = keys.length; i < n; i++) {
                if (this.__keypressTimers.has(keys[i])) {
                    // keyup has fired before end of timeout so we clear it
                    clearTimeout(this.__keypressTimers.get(keys[i]));
                    // delete so we can register it again
                    this.__keypressTimers.delete(keys[i]);
                }
            }
        }
    }

    /**
     * Registers and starts a timer for the pressed key. Timer will be cleared when the key is released
     * before the timer goes off.
     *
     * If key is not release (keyup) the longpress handler will be fired.
     * Configuration can be via the Components template:
     *
     * static _template() {
     *     return {
     *         w:100, h:100,
     *         longpress:{up:700, down:500}
     *     }
     * }     *
     * // this will get called when up has been pressed for 700ms
     * _handleUpLong() {
     *
     * }
     *
     * @param key
     * @param element
     * @private
     */
    _startLongpressTimer(key, element) {
        const config = element.longpress;
        const lookup = key.toLowerCase();

        if (config[lookup]) {
            const timeout = config[lookup];
            if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(timeout)) {
                element._throwError("config value for longpress must be a number");
            } else {
                this.__keypressTimers.set(key, setTimeout(() => {
                    if (!this.stage.application.focusTopDownEvent([`_capture${key}Long`, "_captureKey"], {})) {
                        this.stage.application.focusBottomUpEvent([`_handle${key}Long`, "_handleKey"], {});
                    }

                    this.__keypressTimers.delete(key);
                }, timeout || 500 /* prevent 0ms */));
            }
        }
        return;
    }

    _recieveScrollWheel(e) {
        const obj = e;
        const {clientX, clientY} = obj;

        if (clientX <= this.stage.w && clientY <= this.stage.h) {
            if (!this.fireTopDownScrollWheelHandler("_captureScroll", obj)) {
                this.fireBottomUpScrollWheelHandler("_handleScroll", obj);
            }
        }
    }

    fireTopDownScrollWheelHandler(event, obj) {
        let children = this.stage.application.children;
        let affected = this._findChildren([], children).reverse();
        let n = affected.length;

        while(n--) {
            const child = affected[n];
            if (child && child[event]) {
                child._captureScroll(obj);
                return true; 
            }
        }
        return false;
    }

    fireBottomUpScrollWheelHandler(event, obj) {
        const {clientX, clientY} = obj;
        const target = this._getTargetChild(clientX, clientY);
        let child = target;

        // Search tree bottom up for a handler
        while (child !== null) {
            if (child && child[event]) {
                child._handleScroll(obj);
                return true;
            }
            child = child.parent;
        }
        return false;
    }

    _receiveClick(e) {
        const obj = e;
        const {clientX, clientY} = obj;

        if (clientX <= this.stage.w && clientY <= this.stage.h) {
            this.stage.application.fireBottomUpClickHandler(obj);
        }
    }

    fireBottomUpClickHandler(obj) {
        const {clientX, clientY} = obj;
        const target = this._getTargetChild(clientX, clientY);
        let child = target;

        // Search tree bottom up for a handler
        while (child !== null) {
            if (child && child["_handleClick"]) {
                child._handleClick(target);
                break;
            }
            child = child.parent;
        }
    }

    _receiveHover(e) {
        const obj = e;
        const {clientX, clientY} = obj;

        if (clientX <= this.stage.w && clientY <= this.stage.h) {
            this.stage.application.fireBottomUpHoverHandler(obj);
        }
    }

    fireBottomUpHoverHandler(obj) {
        const {clientX, clientY} = obj;
        const target = this._getTargetChild(clientX, clientY);

        // Only fire handlers when pointer target changes
        if (target !== this.__hoveredChild) {

            let hoveredBranch = new Set();
            let newHoveredBranch = new Set();

            if (target) {
                newHoveredBranch = new Set(target.getAncestors());
            }

            if (this.__hoveredChild) {
                hoveredBranch = new Set(this.__hoveredChild.getAncestors());
                for (const elem of [...hoveredBranch].filter((e) => !newHoveredBranch.has(e))) {
                    const c = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(elem);
                    if (c["_handleUnhover"]) {
                        c._handleUnhover(elem);
                    }
                    if (elem.parent && elem.parent.cursor) {
                        this.stage.getCanvas().style.cursor = elem.parent.cursor;
                    }
                }
            }

            this.__hoveredChild = target;

            const diffBranch = [...newHoveredBranch].filter((e) => !hoveredBranch.has(e))
            for (const elem of diffBranch) {
                const c = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(elem);
                if (c["_handleHover"]) {
                    c._handleHover(elem);
                }
            }

            // New element hover cursor
            const lastElement = diffBranch[0];
            if (lastElement && lastElement.cursor) {
                this.stage.getCanvas().style.cursor = lastElement.cursor;
            }

            // Rerun _handleHover for target element in case it's been hovered
            // back from its child
            if (diffBranch.length === 0 && target) {
                const c = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(target);
                if (c["_handleHover"]) {
                    c._handleHover(target);
                }
            }
        }
    }

    _getTargetChild(clientX, clientY) {
        let children = this.stage.application.children;
        let affected = this._findChildren([], children);
        let hoverableChildren = this._withinClickableRange(affected, clientX, clientY);

        hoverableChildren.sort((a,b) => {
            // Sort by zIndex and then id
            if (a.zIndex > b.zIndex) {
                return 1;
            } else if (a.zIndex < b.zIndex) {
                return -1;
            } else {
                return a.id > b.id ? 1: -1;
            }
        });

        if (hoverableChildren.length) {
            // Assume target has highest zIndex (id when zIndex equal)
            return hoverableChildren.slice(-1)[0];
        } else {
            return null;
        }
    }

    _findChildren(bucket, children) {
        let n = children.length;
        while (n--) {
            const child = children[n];
            // only add active children
            if (child.__active && child.collision) {
                if (child.collision === true) {
                    bucket.push(child);
                }
                if (child.hasChildren()) {
                    this._findChildren(bucket, child.children);
                }
            }
        }
        return bucket;
    }

    _withinClickableRange(affectedChildren, cursorX, cursorY) {
        let n = affectedChildren.length;
        const candidates = [];

        // loop through affected children
        // and perform collision detection
        while (n--) {
            const child = affectedChildren[n];
            const precision = this.stage.getRenderPrecision();
            const ctx = child.core._worldContext;

            const cx = ctx.px * precision;
            const cy = ctx.py * precision;
            const cw = child.finalW * ctx.ta * precision;
            const ch = child.finalH * ctx.td * precision;

            if (cx > this.stage.w || cy > this.stage.h) {
                continue;
            }

            if (child.parent.core._scissor) {
                const scissor = child.parent.core._scissor.map((v) => v * precision);
                if (!this._testCollision(cursorX, cursorY, ...scissor))
                    continue
            }

            if (this._testCollision(cursorX, cursorY, cx, cy, cw, ch)) {
                candidates.push(child);
            }
        }
        return candidates;
    }

    _testCollision(px, py, cx, cy, cw, ch) {
        if (px >= cx &&
            px <= cx + cw &&
            py >= cy &&
            py <= cy + ch) {
            return true;
        }
        return false;
    }

    destroy() {
        if (!this._destroyed) {
            this._destroy();
            this.stage.destroy();
            this._destroyed = true;
        }
    }

    _destroy() {
        // This forces the _detach, _disabled and _active events to be called.
        this.stage.setApplication(undefined);
        this._updateAttachedFlag();
        this._updateEnabledFlag();

        if (this.__keypressTimers.size) {
            for (const timer of this.__keypressTimers.values()) {
                clearTimeout(timer);
            }

            this.__keypressTimers.clear();
        }
    }

    getCanvas() {
        return this.stage.getCanvas();
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/application/Component.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/application/Component.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _StateMachine_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StateMachine.mjs */ "./node_modules/@lightningjs/core/src/application/StateMachine.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @extends StateMachine
 */
class Component extends _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage, properties) {
        super(stage);

        // Encapsulate tags to prevent leaking.
        this.tagRoot = true;

        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(properties)) {
            Object.assign(this, properties);
        }

        this.__initialized = false;
        this.__firstActive = false;
        this.__firstEnable = false;

        this.__signals = undefined;

        this.__passSignals = undefined;

        this.__construct();

        // Quick-apply template.
        const func = this.constructor.getTemplateFunc(this);
        func.f(this, func.a);

        this._build();
    }

    __start() {
        _StateMachine_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].setupStateMachine(this);
        this._onStateChange = Component.prototype.__onStateChange;
    }

    get state() {
        return this._getState();
    }

    __onStateChange() {
        /* FIXME: Workaround for case, where application was shut but component still lives */
        if (this.application) {
            this.application.updateFocusPath();
        }
    }

    _refocus() {
        /* FIXME: Workaround for case, where application was shut but component still lives */
        if (this.application) {
            this.application.updateFocusPath();
        }
    }

    static bindProp(name, func = null) {
        return {__propertyBinding: true, __name: name, __func: func};
    }

    __bindProperty(propObj, targetObj, targetProp) {
        // 1. find binding position: find object and property name to be bound
        const obj = targetObj;
        const prop = targetProp;
        const propDependencies = Array.isArray(propObj.__name) ? propObj.__name : [propObj.__name];

        // 2. create setters for every given dependency
        for (let i = 0; i < propDependencies.length; i++) {
            const propName = propDependencies[i];
            const func = propObj.__func ? propObj.__func : (context) => context[propName];

            if (!this.hasOwnProperty(propName)) {
                this[`__prop_bindings_${propName}`] = [{__obj: obj, __prop: prop, __func: func}];
                Object.defineProperty(this, propName, {
                    set: (value) => {
                        this[`__prop_${propName}`] = value;
                        for (const {__obj, __prop, __func} of this[`__prop_bindings_${propName}`]) {
                            __obj[__prop] = __func(this);
                        }
                    },
                    get: () => this[`__prop_${propName}`]
                });
            } else {
                this[`__prop_bindings_${propName}`].push({__obj: obj, __prop: prop, __func: func});
            }
        }
    }

    /**
     * Returns a high-performance template patcher.
     */
    static getTemplateFunc(ctx) {
        // We need a different template function per patch id.
        const name = "_templateFunc";

        // Be careful with class-based static inheritance.
        const hasName = '__has' + name;
        if (this[hasName] !== this) {
            this[hasName] = this;
            this[name] = this.parseTemplate(this._template(ctx));
        }
        return this[name];
    }

    static parseTemplate(obj) {
        const context = {
            loc: [],
            store: [],
            rid: 0
        };

        this.parseTemplateRec(obj, context, "element");

        const code = context.loc.join(";\n");
        const f = new Function("element", "store", code);
        return {f: f, a: context.store};
    }

    static parseTemplateRec(obj, context, cursor) {
        const store = context.store;
        const loc = context.loc;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            let value = obj[key];
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isUcChar(key.charCodeAt(0))) {
                // Value must be expanded as well.
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value)) {
                    // Ref.
                    const childCursor = `r${key.replace(/[^a-z0-9]/gi, "") + context.rid}`;
                    let type = value.type ? value.type : _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__["default"];
                    if (type === _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]) {
                        loc.push(`var ${childCursor} = element.stage.createElement()`);
                    } else {
                        store.push(type);
                        loc.push(`var ${childCursor} = new store[${store.length - 1}](${cursor}.stage)`);
                    }
                    loc.push(`${childCursor}.ref = "${key}"`);
                    context.rid++;

                    // Enter sub.
                    this.parseTemplateRec(value, context, childCursor);

                    loc.push(`${cursor}.childList.add(${childCursor})`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value)) {
                    // Dynamic assignment.
                    store.push(value);
                    loc.push(`${cursor}.childList.add(store[${store.length - 1}])`);
                }
            } else {
                if (key === "text") {
                    const propKey = cursor + "__text";
                    loc.push(`var ${propKey} = ${cursor}.enableTextTexture()`);
                    if (value.__propertyBinding === true) {
                        // Allow binding entire objects to text property
                        store.push(value);
                        loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                    } else {
                        this.parseTemplatePropRec(value, context, propKey);
                    }
                } else if (key === "shader" && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value)) {
                    const shaderCursor = `${cursor}["shader"]`
                    store.push(value);
                    loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                    this.parsePropertyBindings(value, context, shaderCursor);
                } else if (key === "texture" && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value)) {
                    const propKey = cursor + "__texture";
                    const type = value.type;
                    if (type) {
                        store.push(type);
                        loc.push(`var ${propKey} = new store[${store.length - 1}](${cursor}.stage)`);
                        this.parseTemplatePropRec(value, context, propKey);
                        loc.push(`${cursor}["${key}"] = ${propKey}`);
                    } else {
                        loc.push(`${propKey} = ${cursor}.texture`);
                        this.parseTemplatePropRec(value, context, propKey);
                    }
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value) && value.__propertyBinding === true) {
                    store.push(value);
                    loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                } else {
                    // Property;
                    if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(value)) {
                        loc.push(`${cursor}["${key}"] = ${value}`);
                    } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isBoolean(value)) {
                        loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
                    } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value) || Array.isArray(value)) {
                        // Dynamic assignment.
                        // Because literal objects may contain dynamics, we store the full object.
                        store.push(value);
                        loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                    } else {
                        // String etc.
                        loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
                    }
                }
            }
        });
    }

    static parseTemplatePropRec(obj, context, cursor) {
        const store = context.store;
        const loc = context.loc;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            if (key !== "type") {
                const value = obj[key];
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(value)) {
                    loc.push(`${cursor}["${key}"] = ${value}`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isBoolean(value)) {
                    loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value) && value.__propertyBinding === true) {
                    store.push(value);
                    loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value) || Array.isArray(value)) {
                    // Dynamic assignment.
                    // Because literal objects may contain dynamics, we store the full object.
                    store.push(value);
                    loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                } else {
                    // String etc.
                    loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
                }
            }
        });
    }

    static parsePropertyBindings(obj, context, cursor) {
        const store = context.store;
        const loc = context.loc;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            if (key !== "type") {
                const value = obj[key];
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value) && value.__propertyBinding === true) {
                    store.push(value);
                    loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                }
            }
        });
    }

    _onSetup() {
        if (!this.__initialized) {
            this._setup();
        }
    }

    _setup() {
    }

    _onAttach() {
        if (!this.__initialized) {
            this.__init();
            this.__initialized = true;
        }

        this._attach();
    }

    _attach() {
    }

    _onDetach() {
        this._detach();
    }

    _detach() {
    }

    _onEnabled() {
        if (!this.__firstEnable) {
            this._firstEnable();
            this.__firstEnable = true;
        }

        this._enable();
    }

    _firstEnable() {
    }

    _enable() {
    }

    _onDisabled() {
        this._disable();
    }

    _disable() {
    }

    _onActive() {
        if (!this.__firstActive) {
            this._firstActive();
            this.__firstActive = true;
        }

        this._active();
    }

    _firstActive() {
    }

    _active() {
    }

    _onInactive() {
        this._inactive();
    }

    _inactive() {
    }

    get application() {
        return this.stage.application;
    }

    __construct() {
        this._construct();
    }

    _construct() {
    }

    _build() {
    }

    __init() {
        this._init();
    }

    _init() {
    }

    _focus(newTarget, prevTarget) {
    }

    _unfocus(newTarget) {
    }

    _focusChange(target, newTarget) {
    }

    _getFocused() {
        // Override to delegate focus to child components.
        return this;
    }

    _setFocusSettings(settings) {
        // Override to add custom settings. See Application._handleFocusSettings().
    }

    _handleFocusSettings(settings) {
        // Override to react on custom settings. See Application._handleFocusSettings().
    }

    static _template() {
        return {};
    }

    hasFinalFocus() {
        let path = this.application._focusPath;
        return path && path.length && path[path.length - 1] === this;
    }

    hasFocus() {
        let path = this.application._focusPath;
        return path && (path.indexOf(this) >= 0);
    }

    get cparent() {
        return Component.getParent(this);
    }

    seekAncestorByType(type) {
        let c = this.cparent;
        while (c) {
            if (c.constructor === type) {
                return c;
            }
            c = c.cparent;
        }
    }

    getSharedAncestorComponent(element) {
        let ancestor = this.getSharedAncestor(element);
        while (ancestor && !ancestor.isComponent) {
            ancestor = ancestor.parent;
        }
        return ancestor;
    }

    get signals() {
        return this.__signals;
    }

    set signals(v) {
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._throwError("Signals: specify an object with signal-to-fire mappings");
        }
        this.__signals = v;
    }

    set alterSignals(v) {
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._throwError("Signals: specify an object with signal-to-fire mappings");
        }
        if (!this.__signals) {
            this.__signals = {};
        }
        for (let key in v) {
            const d = v[key];
            if (d === undefined) {
                delete this.__signals[key];
            } else {
                this.__signals[key] = v;
            }
        }
    }

    get passSignals() {
        return this.__passSignals || {};
    }

    set passSignals(v) {
        this.__passSignals = Object.assign(this.__passSignals || {}, v);
    }

    set alterPassSignals(v) {
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._throwError("Signals: specify an object with signal-to-fire mappings");
        }
        if (!this.__passSignals) {
            this.__passSignals = {};
        }
        for (let key in v) {
            const d = v[key];
            if (d === undefined) {
                delete this.__passSignals[key];
            } else {
                this.__passSignals[key] = v;
            }
        }
    }

    /**
     * Signals the parent of the specified event.
     * A parent/ancestor that wishes to handle the signal should set the 'signals' property on this component.
     * @param {string} event
     * @param {...*} args
     */
    signal(event, ...args) {
        return this._signal(event, args);
    }

    _signal(event, args) {
        const signalParent = this._getParentSignalHandler();
        if (signalParent) {
            if (this.__signals) {
                let fireEvent = this.__signals[event];
                if (fireEvent === false) {
                    // Ignore event.
                    return;
                }
                if (fireEvent) {
                    if (fireEvent === true) {
                        fireEvent = event;
                    }
 
                    if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(fireEvent)) {
                        return fireEvent(...args);
                    }

                    if (signalParent._hasMethod(fireEvent)) {
                        return signalParent[fireEvent](...args);
                    }
                }
            }

            let passSignal = (this.__passSignals && this.__passSignals[event]);
            if (passSignal) {
                // Bubble up.
                if (passSignal && passSignal !== true) {
                    // Replace signal name.
                    event = passSignal;
                }

                return signalParent._signal(event, args);
            }
        }
    }

    _getParentSignalHandler() {
        return this.cparent ? this.cparent._getSignalHandler() : null;
    }

    _getSignalHandler() {
        if (this._signalProxy) {
            return this.cparent ? this.cparent._getSignalHandler() : null;
        }
        return this;
    }

    get _signalProxy() {
        return false;
    }

    fireAncestors(name, ...args) {
        if (!name.startsWith('$')) {
            throw new Error("Ancestor event name must be prefixed by dollar sign.");
        }

        const parent = this._getParentSignalHandler();
        if (parent) {
            return parent._doFireAncestors(name, args);
        }
    }

    _doFireAncestors(name, args) {
        if (this._hasMethod(name)) {
            return this.fire(name, ...args);
        } else {
            const signalParent = this._getParentSignalHandler();
            if (signalParent) {
                return signalParent._doFireAncestors(name, args);
            }
        }
    }

    static collectSubComponents(subs, element) {
        if (element.hasChildren()) {
            const childList = element.__childList;
            for (let i = 0, n = childList.length; i < n; i++) {
                const child = childList.getAt(i);
                if (child.isComponent) {
                    subs.push(child);
                } else {
                    Component.collectSubComponents(subs, child);
                }
            }
        }
    }

    static getComponent(element) {
        let parent = element;
        while (parent && !parent.isComponent) {
            parent = parent.parent;
        }
        return parent;
    }

    static getParent(element) {
        return Component.getComponent(element.parent);
    }
}

Component.prototype.isComponent = true;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/application/StateMachine.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/application/StateMachine.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StateMachine)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class StateMachine {

    constructor() {
        StateMachine.setupStateMachine(this);
    }

    static setupStateMachine(target) {
        const targetConstructor = target.constructor;
        const router = StateMachine.create(targetConstructor);
        Object.setPrototypeOf(target, router.prototype);
        target.constructor = targetConstructor;
        target._initStateMachine();
    }

    /**
     * Creates a state machine implementation.
     * It extends the original type and should be used when creating new instances.
     * The original type is available as static property 'original', and it must be used when subclassing as follows:
     * const type = StateMachine.create(class YourNewStateMachineClass extends YourBaseStateMachineClass.original {  })
     * @param {Class} type
     * @returns {StateMachine}
     */
    static create(type) {
        if (!type.hasOwnProperty('_sm')) {
            // Only need to run once.
            const stateMachineType = new StateMachineType(type);
            type._sm = stateMachineType;
        }

        return type._sm.router;
    }

    /**
     * Calls the specified method if it exists.
     * @param {string} event
     * @param {*...} args
     */
    fire(event, ...args) {
        if (this._hasMethod(event)) {
            return this[event](...args);
        }
    }

    /**
     * Returns the current state path (for example "Initialized.Loading").
     * @returns {string}
     * @protected
     */
    _getState() {
        return this._state.__path;
    }

    /**
     * Returns true iff statePath is (an ancestor of) currentStatePath.
     * @param {string} statePath
     * @param {string} currentStatePath
     * @returns {Boolean}
     * @protected
     */
    _inState(statePath, currentStatePath = this._state.__path) {
        const state = this._sm.getStateByPath(statePath);
        const currentState = this._sm.getStateByPath(currentStatePath);
        const level = state.__level;
        const stateAtLevel = StateMachine._getStateAtLevel(currentState, level);
        return (stateAtLevel === state);
    }

    /**
     * Returns true if the specified class member is defined for the currently set state.
     * @param {string} name
     * @returns {boolean}
     * @protected
     */
    _hasMember(name) {
        return !!this.constructor.prototype[name];
    }

    /**
     * Returns true if the specified class member is a method for the currently set state.
     * @param {string} name
     * @returns {boolean}
     * @protected
     */
    _hasMethod(name) {
        const member = this.constructor.prototype[name];
        return !!member && (typeof member === "function")
    }

    /**
     * Switches to the specified state.
     * @param {string} statePath
     *   Substates are seperated by a underscores (for example "Initialized.Loading").
     * @param {*[]} [args]
     *   Args that are supplied in $enter and $exit events.
     * @protected
     */
    _setState(statePath, args) {
        const setStateId = ++this._setStateCounter;
        this._setStateId = setStateId;

        if (this._state.__path !== statePath) {
            // Performance optimization.
            let newState = this._sm._stateMap[statePath];
            if (!newState) {
                // Check for super state.
                newState = this._sm.getStateByPath(statePath);
            }

            const prevState = this._state;

            const hasDifferentEnterMethod = (newState.prototype.$enter !== this._state.prototype.$enter);
            const hasDifferentExitMethod = (newState.prototype.$exit !== this._state.prototype.$exit);
            if (hasDifferentEnterMethod || hasDifferentExitMethod) {
                const sharedState = StateMachine._getSharedState(this._state, newState);
                const context = {
                    newState: newState.__path,
                    prevState: prevState.__path,
                    sharedState: sharedState.__path
                };
                const sharedLevel = sharedState.__level;

                if (hasDifferentExitMethod) {
                    const exitStates = StateMachine._getStatesUntilLevel(this._state, sharedLevel);
                    for (let i = 0, n = exitStates.length; i < n; i++) {
                        this.__setState(exitStates[i]);
                        this._callExit(this._state, args, context);
                        const stateChangeOverridden = (this._setStateId !== setStateId);
                        if (stateChangeOverridden) {
                            return;
                        }
                    }
                }

                if (hasDifferentEnterMethod) {
                    const enterStates = StateMachine._getStatesUntilLevel(newState, sharedLevel).reverse();
                    for (let i = 0, n = enterStates.length; i < n; i++) {
                        this.__setState(enterStates[i]);
                        this._callEnter(this._state, args, context);
                        const stateChangeOverridden = (this._setStateId !== setStateId);
                        if (stateChangeOverridden) {
                            return;
                        }
                    }
                }

            }

            this.__setState(newState);

            if (this._changedState) {
                const context = {
                    newState: newState.__path,
                    prevState: prevState.__path
                };

                if (args) {
                    this._changedState(context, ...args);
                } else {
                    this._changedState(context);
                }
            }

            if (this._onStateChange) {
                const context = {
                    newState: newState.__path,
                    prevState: prevState.__path
                };
                this._onStateChange(context);
            }

        }
    }

    _callEnter(state, args = [], context) {
        const hasParent = !!state.__parent;
        if (state.prototype.$enter) {
            if (!hasParent || (state.__parent.prototype.$enter !== state.prototype.$enter)) {
                state.prototype.$enter.apply(this, [context, ...args]);
            }
        }
    }

    _callExit(state, args = [], context) {
        const hasParent = !!state.__parent;
        if (state.prototype.$exit) {
            if (!hasParent || (state.__parent.prototype.$exit !== state.prototype.$exit)) {
                state.prototype.$exit.apply(this, [context, ...args]);
            }
        }
    }

    __setState(state) {
        this._state = state;
        this._stateIndex = state.__index;
        this.constructor = state;
    }

    _initStateMachine() {
        this._state = null;
        this._stateIndex = 0;
        this._setStateCounter = 0;
        this._sm = this._routedType._sm;
        this.__setState(this._sm.getStateByPath(""));
        const context = {newState: "", prevState: undefined, sharedState: undefined};
        this._callEnter(this._state, [], context);
        this._onStateChange = undefined;
    }

    /**
     * Between multiple member names, select the one specified in the deepest state.
     * If multiple member names are specified in the same deepest state, the first one in the array is returned.
     * @param {string[]} memberNames
     * @returns {string|undefined}
     * @protected
     */
    _getMostSpecificHandledMember(memberNames) {
        let cur = this._state;
        do {
            for (let i = 0, n = memberNames.length; i < n; i++) {
                const memberName = memberNames[i];
                if (!cur.__parent) {
                    if (cur.prototype[memberName]) {
                        return memberName;
                    }
                } else {
                    const alias = StateMachineType.getStateMemberAlias(cur.__path, memberName);
                    if (this[alias]) {
                        return memberName;
                    }
                }
            }
            cur = cur.__parent;
        } while (cur);
    }

    static _getStatesUntilLevel(state, level) {
        const states = [];
        while (state.__level > level) {
            states.push(state);
            state = state.__parent;
        }
        return states;
    }

    static _getSharedState(state1, state2) {
        const state1Array = StateMachine._getAncestorStates(state1);
        const state2Array = StateMachine._getAncestorStates(state2);
        const n = Math.min(state1Array.length, state2Array.length);
        for (let i = 0; i < n; i++) {
            if (state1Array[i] !== state2Array[i]) {
                return state1Array[i - 1];
            }
        }
        return state1Array[n - 1];
    }

    static _getAncestorStates(state) {
        const result = [];
        do {
            result.push(state);
        } while(state = state.__parent);
        return result.reverse();
    }

    static _getStateAtLevel(state, level) {
        if (level > state.__level) {
            return undefined;
        }

        while(level < state.__level) {
            state = state.__parent;
        }
        return state;
    }
}

class StateMachineType {

    constructor(type) {
        this._type = type;
        this._router = null;

        this.init();
    }

    get router() {
        return this._router;
    }

    init() {
        this._router = this._createRouter();

        this._stateMap = this._getStateMap();

        this._addStateMemberDelegatorsToRouter();

    }

    _createRouter() {
        const type = this._type;

        const router = class StateMachineRouter extends type {
            constructor() {
                super(...arguments);
                if (!this.constructor.hasOwnProperty('_isRouter')) {
                    throw new Error(`You need to extend ${type.name}.original instead of ${type.name}.`);
                }
            }
        };
        router._isRouter = true;
        router.prototype._routedType = type;
        router.original = type;

        this._mixinStateMachineMethods(router);

        return router;
    }

    _mixinStateMachineMethods(router) {
        // Mixin the state machine methods, so that we reuse the methods instead of re-creating them.
        const names = Object.getOwnPropertyNames(StateMachine.prototype);
        for (let i = 0, n = names.length; i < n; i++) {
            const name = names[i];
            if (name !== "constructor") {
                const descriptor = Object.getOwnPropertyDescriptor(StateMachine.prototype, name);
                Object.defineProperty(router.prototype, name, descriptor);
            }
        }
    }

    _addStateMemberDelegatorsToRouter() {
        const members = this._getAllMemberNames();

        members.forEach(member => {
            this._addMemberRouter(member);
        });
    }

    /**
     * @note We are generating code because it yields much better performance.
     */
    _addMemberRouter(member) {
        const statePaths = Object.keys(this._stateMap);
        const descriptors = [];
        const aliases = [];
        statePaths.forEach((statePath, index) => {
            const state = this._stateMap[statePath];
            const descriptor = this._getDescriptor(state, member);
            if (descriptor) {
                descriptors[index] = descriptor;

                // Add to prototype.
                const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;

                if (!this._router.prototype.hasOwnProperty(alias)) {
                    Object.defineProperty(this._router.prototype, alias, descriptor);
                }
            } else {
                descriptors[index] = null;
                aliases[index] = null;
            }
        });

        let type = undefined;
        descriptors.forEach(descriptor => {
            if (descriptor) {
                const descType = this._getDescriptorType(descriptor);
                if (type && (type !== descType)) {
                    console.warn(`[Lightning] Member ${member} in ${this._type.name} has inconsistent types.`);
                    return;
                }
                type = descType;
            }
        });

        switch(type) {
            case "method":
                this._addMethodRouter(member, descriptors, aliases);
                break;
            case "getter":
                this._addGetterSetterRouters(member);
                break;
            case "property":
                console.warn("[Lightning] Fixed properties are not supported; please use a getter instead!")
                break;
        }
    }

    _getDescriptor(state, member, isValid = () => true) {
        let type = state;
        let curState = state;

        do {
            const descriptor = Object.getOwnPropertyDescriptor(type.prototype, member);
            if (descriptor) {
                if (isValid(descriptor)) {
                    descriptor._source = curState;
                    return descriptor;
                }
            }
            type = Object.getPrototypeOf(type);
            if (type && type.hasOwnProperty('__state')) {
                curState = type;
            }
        } while(type && type.prototype);
        return undefined;
    }

    _getDescriptorType(descriptor) {
        if (descriptor.get || descriptor.set) {
            return 'getter';
        } else {
            if (typeof descriptor.value === "function") {
                return 'method';
            } else {
                return 'property';
            }
        }
    }

    static _supportsSpread() {
        if (this.__supportsSpread === undefined) {
            this.__supportsSpread = false;
            try {
                const func = new Function("return [].concat(...arguments);");
                func();
                this.__supportsSpread = true;
            } catch(e) {}
        }
        return this.__supportsSpread;
    }

    _addMethodRouter(member, descriptors, aliases) {
        const code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js",
            "var i = this._stateIndex;"
        ];
        let cur = aliases[0];
        const supportsSpread = StateMachineType._supportsSpread();
        for (let i = 1, n = aliases.length; i < n; i++) {
            const alias = aliases[i];
            if (alias !== cur) {
                if (cur) {
                    if (supportsSpread) {
                        code.push(`if (i < ${i}) return this["${cur}"](...arguments); else`);
                    } else {
                        code.push(`if (i < ${i}) return this["${cur}"].apply(this, arguments); else`);
                    }
                } else {
                    code.push(`if (i < ${i}) return ; else`);
                }
            }
            cur = alias;
        }
        if (cur) {
            if (supportsSpread) {
                code.push(`return this["${cur}"](...arguments);`);
            } else {
                code.push(`return this["${cur}"].apply(this, arguments);`);
            }
        } else {
            code.push(`;`);
        }
        const functionBody = code.join("\n");
        const router = new Function([], functionBody);

        const descriptor = {value: router};
        Object.defineProperty(this._router.prototype, member, descriptor);
    }

    _addGetterSetterRouters(member) {
        const getter = this._getGetterRouter(member);
        const setter = this._getSetterRouter(member);
        const descriptor = {
            get: getter,
            set: setter
        };
        Object.defineProperty(this._router.prototype, member, descriptor);
    }

    _getGetterRouter(member) {
        const statePaths = Object.keys(this._stateMap);
        const descriptors = [];
        const aliases = [];
        statePaths.forEach((statePath, index) => {
            const state = this._stateMap[statePath];
            const descriptor = this._getDescriptor(state, member, (descriptor => descriptor.get));
            if (descriptor) {
                descriptors[index] = descriptor;

                // Add to prototype.
                const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;

                if (!this._router.prototype.hasOwnProperty(alias)) {
                    Object.defineProperty(this._router.prototype, alias, descriptor);
                }
            } else {
                descriptors[index] = null;
                aliases[index] = null;
            }
        });

        const code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js",
            "var i = this._stateIndex;"
        ];
        let cur = aliases[0];
        for (let i = 1, n = aliases.length; i < n; i++) {
            const alias = aliases[i];
            if (alias !== cur) {
                if (cur) {
                    code.push(`if (i < ${i}) return this["${cur}"]; else`);
                } else {
                    code.push(`if (i < ${i}) return ; else`);
                }
            }
            cur = alias;
        }
        if (cur) {
            code.push(`return this["${cur}"];`);
        } else {
            code.push(`;`);
        }
        const functionBody = code.join("\n");
        const router = new Function([], functionBody);
        return router;
    }

    _getSetterRouter(member) {
        const statePaths = Object.keys(this._stateMap);
        const descriptors = [];
        const aliases = [];
        statePaths.forEach((statePath, index) => {
            const state = this._stateMap[statePath];
            const descriptor = this._getDescriptor(state, member, (descriptor => descriptor.set));
            if (descriptor) {
                descriptors[index] = descriptor;

                // Add to prototype.
                const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;

                if (!this._router.prototype.hasOwnProperty(alias)) {
                    Object.defineProperty(this._router.prototype, alias, descriptor);
                }
            } else {
                descriptors[index] = null;
                aliases[index] = null;
            }
        });

        const code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js",
            "var i = this._stateIndex;"
        ];
        let cur = aliases[0];
        for (let i = 1, n = aliases.length; i < n; i++) {
            const alias = aliases[i];
            if (alias !== cur) {
                if (cur) {
                    code.push(`if (i < ${i}) this["${cur}"] = arg; else`);
                } else {
                    code.push(`if (i < ${i}) ; else`);
                }
            }
            cur = alias;
        }
        if (cur) {
            code.push(`this["${cur}"] = arg;`);
        } else {
            code.push(`;`);
        }
        const functionBody = code.join("\n");
        const router = new Function(["arg"], functionBody);
        return router;
    }

    static getStateMemberAlias(path, member) {
        return "$" + (path ? path + "." : "") + member;
    }

    _getAllMemberNames() {
        const stateMap = this._stateMap;
        const map = Object.keys(stateMap);
        let members = new Set();
        map.forEach(statePath => {
            if (statePath === "") {
                // Root state can be skipped: if the method only occurs in the root state, we don't need to re-delegate it based on state.
                return;
            }
            const state = stateMap[statePath];
            const names = this._getStateMemberNames(state);
            names.forEach(name => {
                members.add(name);
            })
        });
        return [...members];
    }

    _getStateMemberNames(state) {
        let type = state;
        let members = new Set();
        const isRoot = this._type === state;
        do {
            const names = this._getStateMemberNamesForType(type);
            names.forEach(name => {
                members.add(name)
            });

            type = Object.getPrototypeOf(type);
        } while(type && type.prototype && (!type.hasOwnProperty("__state") || isRoot));

        return members;
    }

    _getStateMemberNamesForType(type) {
        const memberNames = Object.getOwnPropertyNames(type.prototype);
        return memberNames.filter(memberName => {
            return (memberName !== "constructor") && !StateMachineType._isStateLocalMember(memberName);
        });
    }

    static _isStateLocalMember(memberName) {
        return (memberName === "$enter") || (memberName === "$exit");
    }

    getStateByPath(statePath) {
        if (this._stateMap[statePath]) {
            return this._stateMap[statePath];
        }

        // Search for closest match.
        const parts = statePath.split(".");
        while(parts.pop()) {
            const statePath = parts.join(".");
            if (this._stateMap[statePath]) {
                return this._stateMap[statePath];
            }
        }
    }

    _getStateMap() {
        if (!this._stateMap) {
            this._stateMap = this._createStateMap();
        }
        return this._stateMap;
    }

    _createStateMap() {
        const stateMap = {};
        this._addState(this._type, null, "", stateMap);
        return stateMap;
    }

    _addState(state, parentState, name, stateMap) {
        state.__state = true;
        state.__name = name;

        this._addStaticStateProperty(state, parentState);

        const parentPath = (parentState ? parentState.__path : "");
        let path = (parentPath ? parentPath + "." : "") + name;
        state.__path = path;
        state.__level = parentState ? parentState.__level + 1 : 0;
        state.__parent = parentState;
        state.__index = Object.keys(stateMap).length;
        stateMap[path] = state;

        const states = state._states;
        if (states) {
            const isInheritedFromParent = (parentState && parentState._states === states);
            if (!isInheritedFromParent) {
                const subStates = state._states();
                subStates.forEach(subState => {
                    const stateName = StateMachineType._getStateName(subState);
                    this._addState(subState, state, stateName, stateMap);
                });
            }
        }
    }

    static _getStateName(state) {
        const name = state.name;

        const index = name.indexOf('$');
        if (index > 0) {
            // Strip off rollup name suffix.
            return name.substr(0, index);
        }

        return name;
    }

    _addStaticStateProperty(state, parentState) {
        if (parentState) {
            const isClassStateLevel = parentState && !parentState.__parent;
            if (isClassStateLevel) {
                this._router[state.__name] = state;
            } else {
                parentState[state.__name] = state;
            }
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/BloomComponent.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/BloomComponent.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BloomComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/webgl/shaders/LinearBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/webgl/shaders/BoxBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class BloomComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        const onUpdate = function(element, elementCore) {
            if ((elementCore._recalc & (2 + 128))) {
                const w = elementCore.w;
                const h = elementCore.h;
                let cur = elementCore;
                do {
                    cur = cur._children[0];
                    cur._element.w = w;
                    cur._element.h = h;
                } while(cur._children);
            }
        };

        return {
            Textwrap: {rtt: true, forceZIndexContext: true, renderOffscreen: true,
                BloomBase: {shader: {type: BloomBaseShader},
                    Content: {}
                }
            },
            Layers: {
                L0: {rtt: true, onUpdate: onUpdate, scale: 2, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L1: {rtt: true, onUpdate: onUpdate, scale: 4, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L2: {rtt: true, onUpdate: onUpdate, scale: 8, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L3: {rtt: true, onUpdate: onUpdate, scale: 16, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}}
            }
        }
    }

    get _signalProxy() {
        return true;
    }

    constructor(stage) {
        super(stage);
        this._textwrap = this.sel("Textwrap");
        this._wrapper = this.sel("Textwrap.Content");
        this._layers = this.sel("Layers");

        this._amount = 0;
        this._paddingX = 0;
        this._paddingY = 0;
    }

    _build() {
        const filterShaderSettings = [{x:1,y:0,kernelRadius:3},{x:0,y:1,kernelRadius:3},{x:1.5,y:0,kernelRadius:3},{x:0,y:1.5,kernelRadius:3}];
        const filterShaders = filterShaderSettings.map(s => {
            const shader = this.stage.createShader(Object.assign({type: _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]}, s));
            return shader;
        });

        this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
        this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);

        // Notice that 1.5 filters should be applied before 1.0 filters.
        this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
        this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
    }

    _setLayerTexture(element, texture, steps) {
        if (!steps.length) {
            element.texture = texture;
        } else {
            const step = steps.pop();
            const child = element.stage.c({rtt: true, shader: step});

            // Recurse.
            this._setLayerTexture(child, texture, steps);

            element.childList.add(child);
        }
        return element;
    }

    get content() {
        return this.sel('Textwrap.Content');
    }

    set content(v) {
        this.sel('Textwrap.Content').patch(v);
    }

    set padding(v) {
        this._paddingX = v;
        this._paddingY = v;
        this._updateBlurSize();
    }

    set paddingX(v) {
        this._paddingX = v;
        this._updateBlurSize();
    }

    set paddingY(v) {
        this._paddingY = v;
        this._updateBlurSize();
    }

    getLayer(i) {
        return this._layers.sel("L" + i);
    }

    getLayerContents(i) {
        return this.getLayer(i).sel("Content");
    }

    _onResize() {
        this._updateBlurSize();
    }

    _updateBlurSize() {
        let w = this.renderWidth;
        let h = this.renderHeight;

        let paddingX = this._paddingX;
        let paddingY = this._paddingY;

        let fw = w + paddingX * 2;
        let fh = h + paddingY * 2;
        this._textwrap.w = fw;
        this._wrapper.x = paddingX;
        this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
        this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
        this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
        this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
        this._textwrap.x = -paddingX;

        this._textwrap.h = fh;
        this._wrapper.y = paddingY;
        this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
        this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
        this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
        this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
        this._textwrap.y = -paddingY;

        this.w = w;
        this.h = h;
    }

    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
        this._amount = v;
        this._update();
    }

    get amount() {
        return this._amount;
    }

    _update() {
        let v = Math.min(4, Math.max(0, this._amount));
        if (v > 0) {
            this.getLayer(0).visible = (v > 0);
            this.getLayer(1).visible = (v > 1);
            this.getLayer(2).visible = (v > 2);
            this.getLayer(3).visible = (v > 3);
        }
    }

    set shader(s) {
        super.shader = s;
        if (!this.renderToTexture) {
            console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
        }
    }

    _firstActive() {
        this._build();
    }

}

class BloomBaseShader extends _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
}

BloomBaseShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float m = max(max(color.r, color.g), color.b);
        float c = max(0.0, (m - 0.80)) * 5.0;
        color = color * c;
        gl_FragColor = color;
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/BorderComponent.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/BorderComponent.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BorderComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class BorderComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        return {
            Content: {},
            Borders: {
                Top: {rect: true, visible: false, mountY: 1},
                Right: {rect: true, visible: false},
                Bottom: {rect: true, visible: false},
                Left: {rect: true, visible: false, mountX: 1}
            }
        };
    }

    get _signalProxy() {
        return true;
    }

    constructor(stage) {
        super(stage);

        this._borderTop = this.tag("Top");
        this._borderRight = this.tag("Right");
        this._borderBottom = this.tag("Bottom");
        this._borderLeft = this.tag("Left");

        this.onAfterUpdate = function (element) {
            const content = element.childList.first;
            let w = element.core.w || content.renderWidth;
            let h = element.core.h || content.renderHeight;
            element._borderTop.w = w;
            element._borderBottom.y = h;
            element._borderBottom.w = w;
            element._borderLeft.h = h + element._borderTop.h + element._borderBottom.h;
            element._borderLeft.y = -element._borderTop.h;
            element._borderRight.x = w;
            element._borderRight.h = h + element._borderTop.h + element._borderBottom.h;
            element._borderRight.y = -element._borderTop.h;
        };

        this.borderWidth = 1;
    }

    get content() {
        return this.sel('Content');
    }

    set content(v) {
        this.sel('Content').patch(v, true);
    }

    get borderWidth() {
        return this.borderWidthTop;
    }

    get borderWidthTop() {
        return this._borderTop.h;
    }

    get borderWidthRight() {
        return this._borderRight.w;
    }

    get borderWidthBottom() {
        return this._borderBottom.h;
    }

    get borderWidthLeft() {
        return this._borderLeft.w;
    }

    set borderWidth(v) {
        this.borderWidthTop = v;
        this.borderWidthRight = v;
        this.borderWidthBottom = v;
        this.borderWidthLeft = v;
    }

    set borderWidthTop(v) {
        this._borderTop.h = v;
        this._borderTop.visible = (v > 0);
    }

    set borderWidthRight(v) {
        this._borderRight.w = v;
        this._borderRight.visible = (v > 0);
    }

    set borderWidthBottom(v) {
        this._borderBottom.h = v;
        this._borderBottom.visible = (v > 0);
    }

    set borderWidthLeft(v) {
        this._borderLeft.w = v;
        this._borderLeft.visible = (v > 0);
    }

    get colorBorder() {
        return this.colorBorderTop;
    }

    get colorBorderTop() {
        return this._borderTop.color;
    }

    get colorBorderRight() {
        return this._borderRight.color;
    }

    get colorBorderBottom() {
        return this._borderBottom.color;
    }

    get colorBorderLeft() {
        return this._borderLeft.color;
    }

    set colorBorder(v) {
        this.colorBorderTop = v;
        this.colorBorderRight = v;
        this.colorBorderBottom = v;
        this.colorBorderLeft = v;
    }

    set colorBorderTop(v) {
        this._borderTop.color = v;
    }

    set colorBorderRight(v) {
        this._borderRight.color = v;
    }

    set colorBorderBottom(v) {
        this._borderBottom.color = v;
    }

    set colorBorderLeft(v) {
        this._borderLeft.color = v;
    }

    get borderTop() {
        return this._borderTop;
    }

    set borderTop(settings) {
        this.borderTop.patch(settings);
    }

    get borderRight() {
        return this._borderRight;
    }

    set borderRight(settings) {
        this.borderRight.patch(settings);
    }

    get borderBottom() {
        return this._borderBottom;
    }

    set borderBottom(settings) {
        this.borderBottom.patch(settings);
    }

    get borderLeft() {
        return this._borderLeft;
    }

    set borderLeft(settings) {
        this.borderLeft.patch(settings);
    }

    set borders(settings) {
        this.borderTop = settings;
        this.borderLeft = settings;
        this.borderBottom = settings;
        this.borderRight = settings;
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/FastBlurComponent.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/FastBlurComponent.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FastBlurComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/webgl/shaders/LinearBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/webgl/shaders/BoxBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/c2d/shaders/BlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs");
/* harmony import */ var _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tree/Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/* harmony import */ var _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tools/MultiSpline.mjs */ "./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









class FastBlurComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static _template() {
        return {}
    }

    get wrap() {
        return this.tag("Wrap");
    }

    set content(v) {
        return this.wrap.content = v;
    }

    get content() {
        return this.wrap.content;
    }

    set padding(v) {
        this.wrap._paddingX = v;
        this.wrap._paddingY = v;
        this.wrap._updateBlurSize();
    }

    set paddingX(v) {
        this.wrap._paddingX = v;
        this.wrap._updateBlurSize();
    }

    set paddingY(v) {
        this.wrap._paddingY = v;
        this.wrap._updateBlurSize();
    }

    set amount(v) {
        return this.wrap.amount = v;
    }

    get amount() {
        return this.wrap.amount;
    }

    _onResize() {
        this.wrap.w = this.renderWidth;
        this.wrap.h = this.renderHeight;
    }

    get _signalProxy() {
        return true;
    }

    _build() {
        this.patch({
            Wrap: {type: this.stage.gl ? WebGLFastBlurComponent : C2dFastBlurComponent}
        });
    }

}


class C2dFastBlurComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        return {
            forceZIndexContext: true,
            rtt: true,
            Textwrap: {shader: {type: _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]}, Content: {}}
        }
    }

    constructor(stage) {
        super(stage);
        this._textwrap = this.sel("Textwrap");
        this._wrapper = this.sel("Textwrap>Content");

        this._amount = 0;
        this._paddingX = 0;
        this._paddingY = 0;

    }

    static getSpline() {
        if (!this._multiSpline) {
            this._multiSpline = new _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]();
            this._multiSpline.parse(false, {0: 0, 0.25: 1.5, 0.5: 5.5, 0.75: 18, 1: 39});
        }
        return this._multiSpline;
    }

    get content() {
        return this.sel('Textwrap>Content');
    }

    set content(v) {
        this.sel('Textwrap>Content').patch(v, true);
    }

    set padding(v) {
        this._paddingX = v;
        this._paddingY = v;
        this._updateBlurSize();
    }

    set paddingX(v) {
        this._paddingX = v;
        this._updateBlurSize();
    }

    set paddingY(v) {
        this._paddingY = v;
        this._updateBlurSize();
    }

    _updateBlurSize() {
        let w = this.renderWidth;
        let h = this.renderHeight;

        let paddingX = this._paddingX;
        let paddingY = this._paddingY;

        this._wrapper.x = paddingX;
        this._textwrap.x = -paddingX;

        this._wrapper.y = paddingY;
        this._textwrap.y = -paddingY;

        this._textwrap.w = w + paddingX * 2;
        this._textwrap.h = h + paddingY * 2;
    }

    get amount() {
        return this._amount;
    }

    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
        this._amount = v;
        this._textwrap.shader.kernelRadius = C2dFastBlurComponent._amountToKernelRadius(v);
    }

    static _amountToKernelRadius(v) {
        return C2dFastBlurComponent.getSpline().getValue(Math.min(1, v * 0.25));
    }

    get _signalProxy() {
        return true;
    }

}

class WebGLFastBlurComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        const onUpdate = function(element, elementCore) {
            if ((elementCore._recalc & (2 + 128))) {
                const w = elementCore.w;
                const h = elementCore.h;
                let cur = elementCore;
                do {
                    cur = cur._children[0];
                    cur._element.w = w;
                    cur._element.h = h;
                } while(cur._children);
            }
        };

        return {
            Textwrap: {rtt: true, forceZIndexContext: true, renderOffscreen: true, Content: {}},
            Layers: {
                L0: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L1: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L2: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L3: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}}
            },
            Result: {shader: {type: FastBlurOutputShader}, visible: false}
        }
    }

    get _signalProxy() {
        return true;
    }

    constructor(stage) {
        super(stage);
        this._textwrap = this.sel("Textwrap");
        this._wrapper = this.sel("Textwrap>Content");
        this._layers = this.sel("Layers");
        this._output = this.sel("Result");

        this._amount = 0;
        this._paddingX = 0;
        this._paddingY = 0;
    }

    _buildLayers() {
        const filterShaderSettings = [{x:1,y:0,kernelRadius:1},{x:0,y:1,kernelRadius:1},{x:1.5,y:0,kernelRadius:1},{x:0,y:1.5,kernelRadius:1}];
        const filterShaders = filterShaderSettings.map(s => {
            const shader = _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].create(this.stage, Object.assign({type: _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]}, s));
            return shader;
        });

        this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
        this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);

        // Notice that 1.5 filters should be applied before 1.0 filters.
        this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
        this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
    }

    _setLayerTexture(element, texture, steps) {
        if (!steps.length) {
            element.texture = texture;
        } else {
            const step = steps.pop();
            const child = element.stage.c({rtt: true, shader: step});

            // Recurse.
            this._setLayerTexture(child, texture, steps);

            element.childList.add(child);
        }
        return element;
    }

    get content() {
        return this.sel('Textwrap>Content');
    }

    set content(v) {
        this.sel('Textwrap>Content').patch(v, true);
    }

    set padding(v) {
        this._paddingX = v;
        this._paddingY = v;
        this._updateBlurSize();
    }

    set paddingX(v) {
        this._paddingX = v;
        this._updateBlurSize();
    }

    set paddingY(v) {
        this._paddingY = v;
        this._updateBlurSize();
    }

    getLayer(i) {
        return this._layers.sel("L" + i);
    }

    getLayerContents(i) {
        return this.getLayer(i).sel("Content");
    }

    _onResize() {
        this._updateBlurSize();
    }

    _updateBlurSize() {
        let w = this.renderWidth;
        let h = this.renderHeight;

        let paddingX = this._paddingX;
        let paddingY = this._paddingY;

        let fw = w + paddingX * 2;
        let fh = h + paddingY * 2;
        this._textwrap.w = fw;
        this._wrapper.x = paddingX;
        this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
        this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
        this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
        this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
        this._output.x = -paddingX;
        this._textwrap.x = -paddingX;
        this._output.w = fw;

        this._textwrap.h = fh;
        this._wrapper.y = paddingY;
        this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
        this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
        this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
        this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
        this._output.y = -paddingY;
        this._textwrap.y = -paddingY;
        this._output.h = fh;

        this.w = w;
        this.h = h;
    }

    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
        this._amount = v;
        this._update();
    }

    get amount() {
        return this._amount;
    }

    _update() {
        let v = Math.min(4, Math.max(0, this._amount));
        if (v === 0) {
            this._textwrap.renderToTexture = false;
            this._output.shader.otherTextureSource = null;
            this._output.visible = false;
        } else {
            this._textwrap.renderToTexture = true;
            this._output.visible = true;

            this.getLayer(0).visible = (v > 0);
            this.getLayer(1).visible = (v > 1);
            this.getLayer(2).visible = (v > 2);
            this.getLayer(3).visible = (v > 3);

            if (v <= 1) {
                this._output.texture = this._textwrap.getTexture();
                this._output.shader.otherTextureSource = this.getLayer(0).getTexture();
                this._output.shader.a = v;
            } else if (v <= 2) {
                this._output.texture = this.getLayer(0).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(1).getTexture();
                this._output.shader.a = v - 1;
            } else if (v <= 3) {
                this._output.texture = this.getLayer(1).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(2).getTexture();
                this._output.shader.a = v - 2;
            } else if (v <= 4) {
                this._output.texture = this.getLayer(2).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(3).getTexture();
                this._output.shader.a = v - 3;
            }
        }
    }

    set shader(s) {
        super.shader = s;
        if (!this.renderToTexture) {
            console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
        }
    }

    _firstActive() {
        this._buildLayers();
    }

}

/**
 * Shader that combines two textures into one output.
 */
class FastBlurOutputShader extends _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {

    constructor(ctx) {
        super(ctx);

        this._a = 0;
        this._otherTextureSource = null;
    }

    get a() {
        return this._a;
    }

    set a(v) {
        this._a = v;
        this.redraw();
    }

    set otherTextureSource(v) {
        this._otherTextureSource = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("a", this._a, this.gl.uniform1f);
        this._setUniform("uSampler2", 1, this.gl.uniform1i);
    }

    beforeDraw(operation) {
        let glTexture = this._otherTextureSource ? this._otherTextureSource.nativeTexture : null;

        let gl = this.gl;
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.activeTexture(gl.TEXTURE0);
    }
}

FastBlurOutputShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uSampler2;
    uniform float a;
    void main(void){
        if (a == 1.0) {
            gl_FragColor = texture2D(uSampler2, vTextureCoord) * vColor;
        } else {
            gl_FragColor = ((1.0 - a) * texture2D(uSampler, vTextureCoord) + (a * texture2D(uSampler2, vTextureCoord))) * vColor;
        }
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/ListComponent.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/ListComponent.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ListComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/ObjectListWrapper.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ListComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        this._wrapper = super._children.a({});

        this._reloadVisibleElements = false;

        this._visibleItems = new Set();

        this._index = 0;

        this._started = false;

        /**
         * The transition definition that is being used when scrolling the items.
         * @type TransitionSettings
         */
        this._scrollTransitionSettings = this.stage.transitions.createSettings({});

        /**
         * The scroll area size in pixels per item.
         */
        this._itemSize = 100;

        this._viewportScrollOffset = 0;

        this._itemScrollOffset = 0;

        /**
         * Should the list jump when scrolling between end to start, or should it be continuous, like a carrousel?
         */
        this._roll = false;

        /**
         * Allows restricting the start scroll position.
         */
        this._rollMin = 0;

        /**
         * Allows restricting the end scroll position.
         */
        this._rollMax = 0;

        /**
         * Definition for a custom animation that is applied when an item is (partially) selected.
         * @type AnimationSettings
         */
        this._progressAnimation = null;

        /**
         * Inverts the scrolling direction.
         * @type {boolean}
         * @private
         */
        this._invertDirection = false;

        /**
         * Layout the items horizontally or vertically?
         * @type {boolean}
         * @private
         */
        this._horizontal = true;

        this.itemList = new ListItems(this);
    }

    _allowChildrenAccess() {
        return false;
    }

    get items() {
        return this.itemList.get();
    }

    set items(children) {
        this.itemList.patch(children);
    }

    start() {
        this._wrapper.transition(this.property, this._scrollTransitionSettings);
        this._scrollTransition = this._wrapper.transition(this.property);
        this._scrollTransition.on('progress', p => this.update());

        this.setIndex(0, true, true);

        this._started = true;

        this.update();
    }

    setIndex(index, immediate = false, closest = false) {
        let nElements = this.length;
        if (!nElements) return;

        this.emit('unfocus', this.getElement(this.realIndex), this._index, this.realIndex);

        if (closest) {
            // Scroll to same offset closest to the index.
            let offset = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(index, nElements);
            let o = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(this.index, nElements);
            let diff = offset - o;
            if (diff > 0.5 * nElements) {
                diff -= nElements;
            } else if (diff < -0.5 * nElements) {
                diff += nElements;
            }
            this._index += diff;
        } else {
            this._index = index;
        }

        if (this._roll || (this.viewportSize > this._itemSize * nElements)) {
            this._index = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(this._index, nElements);
        }

        let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);
        let value = direction * this._index * this._itemSize;

        if (this._roll) {
            let min, max, scrollDelta;
            if (direction == 1) {
                max = (nElements - 1) * this._itemSize;
                scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;

                max -= scrollDelta;

                min = this.viewportSize - (this._itemSize + scrollDelta);

                if (this._rollMin) min -= this._rollMin;
                if (this._rollMax) max += this._rollMax;

                value = Math.max(Math.min(value, max), min);
            } else {
                max = (nElements * this._itemSize - this.viewportSize);
                scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;

                max += scrollDelta;

                let min = scrollDelta;

                if (this._rollMin) min -= this._rollMin;
                if (this._rollMax) max += this._rollMax;

                value = Math.min(Math.max(-max, value), -min);
            }
        }

        this._scrollTransition.start(value);

        if (immediate) {
            this._scrollTransition.finish();
        }

        this.emit('focus', this.getElement(this.realIndex), this._index, this.realIndex);
    }

    getAxisPosition() {
        let target = -this._scrollTransition._targetValue;

        let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);
        let value = -direction * this._index * this._itemSize;

        return this._viewportScrollOffset * this.viewportSize + (value - target);
    }

    update() {
        if (!this._started) return;

        let nElements = this.length;
        if (!nElements) return;

        let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);

        // Map position to index value.
        let v = (this._horizontal ? this._wrapper.x : this._wrapper.y);

        let viewportSize = this.viewportSize;
        let scrollDelta = this._viewportScrollOffset * viewportSize - this._itemScrollOffset * this._itemSize;
        v += scrollDelta;

        let s, e, ps, pe;
        if (direction == -1) {
            s = Math.floor(-v / this._itemSize);
            ps = 1 - ((-v / this._itemSize) - s);
            e = Math.floor((viewportSize - v) / this._itemSize);
            pe = (((viewportSize - v) / this._itemSize) - e);
        } else {
            s = Math.ceil(v / this._itemSize);
            ps = 1 + (v / this._itemSize) - s;
            e = Math.ceil((v - viewportSize) / this._itemSize);
            pe = e - ((v - viewportSize) / this._itemSize);
        }
        if (this._roll || (viewportSize > this._itemSize * nElements)) {
            // Don't show additional items.
            if (e >= nElements) {
                e = nElements - 1;
                pe = 1;
            }
            if (s >= nElements) {
                s = nElements - 1;
                ps = 1;
            }
            if (e <= -1) {
                e = 0;
                pe = 1;
            }
            if (s <= -1) {
                s = 0;
                ps = 1;
            }
        }

        let offset = -direction * s * this._itemSize;

        let item;
        for (let index = s; (direction == -1 ? index <= e : index >= e); (direction == -1 ? index++ : index--)) {
            let realIndex = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(index, nElements);

            let element = this.getElement(realIndex);
            item = element.parent;
            this._visibleItems.delete(item);
            if (this._horizontal) {
                item.x = offset + scrollDelta;
            } else {
                item.y = offset + scrollDelta;
            }

            let wasVisible = item.visible;
            item.visible = true;

            if (!wasVisible || this._reloadVisibleElements) {
                // Turned visible.
                this.emit('visible', index, realIndex);
            }



            if (this._progressAnimation) {
                let p = 1;
                if (index == s) {
                    p = ps;
                } else if (index == e) {
                    p = pe;
                }

                // Use animation to progress.
                this._progressAnimation.apply(element, p);
            }

            offset += this._itemSize;
        }

        // Handle item visibility.
        let self = this;
        this._visibleItems.forEach(function(invisibleItem) {
            invisibleItem.visible = false;
            self._visibleItems.delete(invisibleItem);
        });

        for (let index = s; (direction == -1 ? index <= e : index >= e); (direction == -1 ? index++ : index--)) {
            let realIndex = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(index, nElements);
            this._visibleItems.add(this.getWrapper(realIndex));
        }

        this._reloadVisibleElements = false;
    }

    setPrevious() {
        this.setIndex(this._index - 1);
    }

    setNext() {
        this.setIndex(this._index + 1);
    }

    getWrapper(index) {
        return this._wrapper.children[index];
    }

    getElement(index) {
        let e = this._wrapper.children[index];
        return e ? e.children[0] : null;
    }

    reload() {
        this._reloadVisibleElements = true;
        this.update();
    }

    get element() {
        let e = this._wrapper.children[this.realIndex];
        return e ? e.children[0] : null;
    }

    get length() {
        return this._wrapper.children.length;
    }

    get property() {
        return this._horizontal ? 'x' : 'y';
    }

    get viewportSize() {
        return this._horizontal ? this.w : this.h;
    }

    get index() {
        return this._index;
    }

    get realIndex() {
        return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(this._index, this.length);
    }

    get itemSize() {
        return this._itemSize;
    }

    set itemSize(v) {
        this._itemSize = v;
        this.update();
    }

    get viewportScrollOffset() {
        return this._viewportScrollOffset;
    }

    set viewportScrollOffset(v) {
        this._viewportScrollOffset = v;
        this.update();
    }

    get itemScrollOffset() {
        return this._itemScrollOffset;
    }

    set itemScrollOffset(v) {
        this._itemScrollOffset = v;
        this.update();
    }

    get scrollTransitionSettings() {
        return this._scrollTransitionSettings;
    }

    set scrollTransitionSettings(v) {
        this._scrollTransitionSettings.patch(v);
    }

    set scrollTransition(v) {
        this._scrollTransitionSettings.patch(v);
    }

    get scrollTransition() {
        return this._scrollTransition;
    }

    get progressAnimation() {
        return this._progressAnimation;
    }

    set progressAnimation(v) {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._progressAnimation = this.stage.animations.createSettings(v);
        } else {
            this._progressAnimation = v;
        }
        this.update();
    }

    get roll() {
        return this._roll;
    }

    set roll(v) {
        this._roll = v;
        this.update();
    }

    get rollMin() {
        return this._rollMin;
    }

    set rollMin(v) {
        this._rollMin = v;
        this.update();
    }

    get rollMax() {
        return this._rollMax;
    }

    set rollMax(v) {
        this._rollMax = v;
        this.update();
    }

    get invertDirection() {
        return this._invertDirection;
    }

    set invertDirection(v) {
        if (!this._started) {
            this._invertDirection = v;
        }
    }

    get horizontal() {
        return this._horizontal;
    }

    set horizontal(v) {
        if (v !== this._horizontal) {
            if (!this._started) {
                this._horizontal = v;
            }
        }
    }

}


class ListItems extends _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(list) {
        let wrap = (item => {
            let parent = item.stage.createElement();
            parent.add(item);
            parent.visible = false;
            return parent;
        })

        super(list._wrapper._children, wrap);
        this.list = list;
    }

    onAdd(item, index) {
        super.onAdd(item, index);
        this.checkStarted(index);
    }

    checkStarted(index) {
        this.list._reloadVisibleElements = true;
        if (!this.list._started) {
            this.list.start();
        } else {
            if (this.list.length === 1) {
                this.list.setIndex(0, true, true);
            } else {
                if (this.list._index >= this.list.length) {
                    this.list.setIndex(0);
                }
            }
            this.list.update();
        }
    }

    onRemove(item, index) {
        super.onRemove(item, index);
        let ri = this.list.realIndex;
        if (ri === index) {
            if (ri === this.list.length) {
                ri--;
            }
            if (ri >= 0) {
                this.list.setIndex(ri);
            }
        } else if (ri > index) {
            this.list.setIndex(ri - 1);
        }

        this.list._reloadVisibleElements = true;
    }

    onSet(item, index) {
        super.onSet(item, index);
        this.checkStarted(index);
    }

    onSync(removed, added, order) {
        super.onSync(removed, added, order);
        this.checkStarted(0);
    }

    get _signalProxy() {
        return true;
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/SmoothScaleComponent.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/SmoothScaleComponent.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SmoothScaleComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class SmoothScaleComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        return {
            ContentWrap: {renderOffscreen: true, forceZIndexContext: true, onAfterUpdate: SmoothScaleComponent._updateDimensions,
                Content: {}
            },
            Scale: {visible: false}
        }
    }

    constructor(stage) {
        super(stage);

        this._smoothScale = 1;
        this._iterations = 0;
    }

    get content() {
        return this.tag('Content');
    }

    set content(v) {
        this.tag('Content').patch(v, true);
    }

    get smoothScale() {
        return this._smoothScale;
    }

    set smoothScale(v) {
        if (this._smoothScale !== v) {
            let its = 0;
            while(v < 0.5 && its < 12) {
                its++;
                v = v * 2;
            }

            this.scale = v;
            this._setIterations(its);

            this._smoothScale = v;
        }
    }

    _setIterations(its) {
        if (this._iterations !== its) {
            const scalers = this.sel("Scale").childList;
            const content = this.sel("ContentWrap");
            while (scalers.length < its) {
                const first = scalers.length === 0;
                const texture = (first ? content.getTexture() : scalers.last.getTexture());
                scalers.a({rtt: true, renderOffscreen: true, texture: texture});
            }

            SmoothScaleComponent._updateDimensions(this.tag("ContentWrap"), true);

            const useScalers = (its > 0);
            this.patch({
                ContentWrap: {renderToTexture: useScalers},
                Scale: {visible: useScalers}
            });

            for (let i = 0, n = scalers.length; i < n; i++) {
                scalers.getAt(i).patch({
                    visible: i < its,
                    renderOffscreen: i !== its - 1
                });
            }
            this._iterations = its;
        }
    }

    static _updateDimensions(contentWrap, force) {
        const content = contentWrap.children[0];
        let w = content.renderWidth;
        let h = content.renderHeight;
        if (w !== contentWrap.w || h !== contentWrap.h || force) {
            contentWrap.w = w;
            contentWrap.h = h;

            const scalers = contentWrap.parent.tag("Scale").children;
            for (let i = 0, n = scalers.length; i < n; i++) {
                w = w * 0.5;
                h = h * 0.5;
                scalers[i].w = w;
                scalers[i].h = h;
            }
        }
    }

    get _signalProxy() {
        return true;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexContainer)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _layout_FlexLayout_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layout/FlexLayout.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/FlexLayout.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class FlexContainer {


    constructor(item) {
        this._item = item;

        this._layout = new _layout_FlexLayout_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        this._horizontal = true;
        this._reverse = false;
        this._wrap = false;
        this._alignItems = 'stretch';
        this._justifyContent = 'flex-start';
        this._alignContent = 'flex-start';

        this._paddingLeft = 0;
        this._paddingTop = 0;
        this._paddingRight = 0;
        this._paddingBottom = 0;
    }

    get item() {
        return this._item;
    }

    _changedDimensions() {
        this._item.changedDimensions();
    }

    _changedContents() {
        this._item.changedContents();
    }

    get direction() {
        return (this._horizontal ? "row" : "column") + (this._reverse ? "-reverse" : "");
    }

    set direction(f) {
        if (this.direction === f) return;

        this._horizontal = (f === 'row' || f === 'row-reverse');
        this._reverse = (f === 'row-reverse' || f === 'column-reverse');

        this._changedContents();
    }

    set wrap(v) {
        this._wrap = v;
        this._changedContents();
    }

    get wrap() {
        return this._wrap;
    }

    get alignItems() {
        return this._alignItems;
    }

    set alignItems(v) {
        if (this._alignItems === v) return;
        if (FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
            throw new Error("Unknown alignItems, options: " + FlexContainer.ALIGN_ITEMS.join(","));
        }
        this._alignItems = v;

        this._changedContents();
    }

    get alignContent() {
        return this._alignContent;
    }

    set alignContent(v) {
        if (this._alignContent === v) return;
        if (FlexContainer.ALIGN_CONTENT.indexOf(v) === -1) {
            throw new Error("Unknown alignContent, options: " + FlexContainer.ALIGN_CONTENT.join(","));
        }
        this._alignContent = v;

        this._changedContents();
    }

    get justifyContent() {
        return this._justifyContent;
    }

    set justifyContent(v) {
        if (this._justifyContent === v) return;

        if (FlexContainer.JUSTIFY_CONTENT.indexOf(v) === -1) {
            throw new Error("Unknown justifyContent, options: " + FlexContainer.JUSTIFY_CONTENT.join(","));
        }
        this._justifyContent = v;

        this._changedContents();
    }

    set padding(v) {
        this.paddingLeft = v;
        this.paddingTop = v;
        this.paddingRight = v;
        this.paddingBottom = v;
    }

    get padding() {
        return this.paddingLeft;
    }
    
    set paddingLeft(v) {
        this._paddingLeft = v;
        this._changedDimensions();
    }
    
    get paddingLeft() {
        return this._paddingLeft;
    }

    set paddingTop(v) {
        this._paddingTop = v;
        this._changedDimensions();
    }

    get paddingTop() {
        return this._paddingTop;
    }

    set paddingRight(v) {
        this._paddingRight = v;
        this._changedDimensions();
    }

    get paddingRight() {
        return this._paddingRight;
    }

    set paddingBottom(v) {
        this._paddingBottom = v;
        this._changedDimensions();
    }

    get paddingBottom() {
        return this._paddingBottom;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
    }

}

FlexContainer.ALIGN_ITEMS = ["flex-start", "flex-end", "center", "stretch"];
FlexContainer.ALIGN_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly", "stretch"];
FlexContainer.JUSTIFY_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly"];


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexItem.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexItem.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexItem)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/* harmony import */ var _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FlexContainer.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class FlexItem {

    constructor(item) {
        this._ctr = null;
        this._item = item;
        this._grow = 0;
        this._shrink = FlexItem.SHRINK_AUTO;
        this._alignSelf = undefined;
        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = 0;
        this._maxHeight = 0;

        this._marginLeft = 0;
        this._marginTop = 0;
        this._marginRight = 0;
        this._marginBottom = 0;
    }

    get item() {
        return this._item;
    }

    get grow() {
        return this._grow;
    }

    set grow(v) {
        if (this._grow === v) return;

        this._grow = parseInt(v) || 0;

        this._changed();
    }

    get shrink() {
        if (this._shrink === FlexItem.SHRINK_AUTO) {
            return this._getDefaultShrink();
        }
        return this._shrink;
    }

    _getDefaultShrink() {
        if (this.item.isFlexEnabled()) {
            return 1;
        } else {
            // All non-flex containers are absolutely positioned items with fixed dimensions, and by default not shrinkable.
            return 0;
        }
    }

    set shrink(v) {
        if (this._shrink === v) return;

        this._shrink = parseInt(v) || 0;

        this._changed();
    }

    get alignSelf() {
        return this._alignSelf;
    }

    set alignSelf(v) {
        if (this._alignSelf === v) return;

        if (v === undefined) {
            this._alignSelf = undefined;
        } else {
            if (_FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ALIGN_ITEMS.indexOf(v) === -1) {
                throw new Error("Unknown alignSelf, options: " + _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ALIGN_ITEMS.join(","));
            }
            this._alignSelf = v;
        }

        this._changed();
    }

    get minWidth() {
        return this._minWidth;
    }

    set minWidth(v) {
        this._minWidth = Math.max(0, v);
        this._item.changedDimensions(true, false);
    }

    get minHeight() {
        return this._minHeight;
    }

    set minHeight(v) {
        this._minHeight = Math.max(0, v);
        this._item.changedDimensions(false, true);
    }

    get maxWidth() {
        return this._maxWidth;
    }

    set maxWidth(v) {
        this._maxWidth = Math.max(0, v);
        this._item.changedDimensions(true, false);
    }

    get maxHeight() {
        return this._maxHeight;
    }

    set maxHeight(v) {
        this._maxHeight = Math.max(0, v);
        this._item.changedDimensions(false, true);
    }

    /**
     * @note margins behave slightly different than in HTML with regard to shrinking.
     * In HTML, (outer) margins can be removed when shrinking. In this engine, they will not shrink at all.
     */
    set margin(v) {
        this.marginLeft = v;
        this.marginTop = v;
        this.marginRight = v;
        this.marginBottom = v;
    }

    get margin() {
        return this.marginLeft;
    }

    set marginLeft(v) {
        this._marginLeft = v;
        this._changed();
    }

    get marginLeft() {
        return this._marginLeft;
    }

    set marginTop(v) {
        this._marginTop = v;
        this._changed();
    }

    get marginTop() {
        return this._marginTop;
    }

    set marginRight(v) {
        this._marginRight = v;
        this._changed();
    }

    get marginRight() {
        return this._marginRight;
    }

    set marginBottom(v) {
        this._marginBottom = v;
        this._changed();
    }

    get marginBottom() {
        return this._marginBottom;
    }
    
    _changed() {
        if (this.ctr) this.ctr._changedContents();
    }

    set ctr(v) {
        this._ctr = v;
    }

    get ctr() {
        return this._ctr;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
    }

    _resetLayoutSize() {
        this._resetHorizontalAxisLayoutSize();
        this._resetVerticalAxisLayoutSize();
    }

    _resetCrossAxisLayoutSize() {
        if (this.ctr._horizontal) {
            this._resetVerticalAxisLayoutSize();
        } else {
            this._resetHorizontalAxisLayoutSize();
        }
    }

    _resetHorizontalAxisLayoutSize() {
        let w = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, true);
        if (this._minWidth) {
            w = Math.max(this._minWidth, w);
        }
        if (this._maxWidth) {
            w = Math.min(this._maxWidth, w);
        }
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, true, w);
    }

    _resetVerticalAxisLayoutSize() {
        let h = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, false);
        if (this._minHeight) {
            h = Math.max(this._minHeight, h);
        }
        if (this._maxHeight) {
            h = Math.min(this._maxHeight, h);
        }
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, false, h);
    }

    _getCrossAxisMinSizeSetting() {
        return this._getMinSizeSetting(!this.ctr._horizontal);
    }

    _getCrossAxisMaxSizeSetting() {
        return this._getMaxSizeSetting(!this.ctr._horizontal);
    }

    _getMainAxisMaxSizeSetting() {
        return this._getMaxSizeSetting(this.ctr._horizontal);
    }

    _getMinSizeSetting(horizontal) {
        if (horizontal) {
            return this._minWidth;
        } else {
            return this._minHeight;
        }
    }

    _getMaxSizeSetting(horizontal) {
        if (horizontal) {
            return this._maxWidth;
        } else {
            return this._maxHeight;
        }
    }

    _getMainAxisMinSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisMinSize(this.item, this.ctr._horizontal);
    }

    _getCrossAxisMinSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisMinSize(this.item, !this.ctr._horizontal);
    }

    _getMainAxisLayoutSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, this.ctr._horizontal);
    }

    _getMainAxisLayoutPos() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutPos(this.item, this.ctr._horizontal);
    }

    _setMainAxisLayoutPos(pos) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutPos(this.item, this.ctr._horizontal, pos);
    }

    _setCrossAxisLayoutPos(pos) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutPos(this.item, !this.ctr._horizontal, pos);
    }

    _getCrossAxisLayoutSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, !this.ctr._horizontal);
    }

    _resizeCrossAxis(size) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resizeAxis(this.item, !this.ctr._horizontal, size);
    }

    _resizeMainAxis(size) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resizeAxis(this.item, this.ctr._horizontal, size);
    }

    _getMainAxisPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, this.ctr._horizontal);
    }

    _getCrossAxisPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, !this.ctr._horizontal);
    }

    _getMainAxisMargin() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalMargin(this.item, this.ctr._horizontal);
    }

    _getCrossAxisMargin() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalMargin(this.item, !this.ctr._horizontal);
    }

    _getHorizontalMarginOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getMarginOffset(this.item, true);
    }

    _getVerticalMarginOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getMarginOffset(this.item, false);
    }

    _getMainAxisMinSizeWithPaddingAndMargin() {
        return this._getMainAxisMinSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
    }

    _getCrossAxisMinSizeWithPaddingAndMargin() {
        return this._getCrossAxisMinSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
    }

    _getMainAxisLayoutSizeWithPaddingAndMargin() {
        return this._getMainAxisLayoutSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
    }

    _getCrossAxisLayoutSizeWithPaddingAndMargin() {
        return this._getCrossAxisLayoutSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
    }

    _hasFixedCrossAxisSize() {
        return !_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isZeroAxisSize(this.item, !this.ctr._horizontal);
    }

    _hasRelCrossAxisSize() {
        return !!(this.ctr._horizontal ? this.item.funcH : this.item.funcW);
    }

}


FlexItem.SHRINK_AUTO = -1;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexTarget.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexTarget.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexTarget)
/* harmony export */ });
/* harmony import */ var _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FlexContainer.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs");
/* harmony import */ var _FlexItem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FlexItem.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexItem.mjs");
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * This is the connection between the render tree with the layout tree of this flex container/item.
 */
class FlexTarget {

    constructor(target) {
        this._target = target;

        /**
         * Possible values (only in case of container):
         * bit 0: has changed or contains items with changes
         * bit 1: width changed
         * bit 2: height changed
         */
        this._recalc = 0;
        
        this._enabled = false;

        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;

        this._originalX = 0;
        this._originalY = 0;
        this._originalWidth = 0;
        this._originalHeight = 0;

        this._flex = null;
        this._flexItem = null;
        this._flexItemDisabled = false;

        this._items = null;
    }

    get flexLayout() {
        return this.flex ? this.flex._layout : null;
    }

    layoutFlexTree() {
        if (this.isFlexEnabled() && this.isChanged()) {
            this.flexLayout.layoutTree();
        }
    }

    get target() {
        return this._target;
    }

    get flex() {
        return this._flex;
    }

    set flex(v) {
        if (!v) {
            if (this.isFlexEnabled()) {
                this._disableFlex();
            }
        } else {
            if (!this.isFlexEnabled()) {
                this._enableFlex();
            }
            this._flex.patch(v);
        }
    }

    get flexItem() {
        if (this._flexItemDisabled) {
            return false;
        }
        this._ensureFlexItem();
        return this._flexItem;
    }

    set flexItem(v) {
        if (v === false) {
            if (!this._flexItemDisabled) {
                const parent = this.flexParent;
                this._flexItemDisabled = true;
                this._checkEnabled();
                if (parent) {
                    parent._clearFlexItemsCache();
                    parent.changedContents();
                }
            }
        } else {
            this._ensureFlexItem();

            this._flexItem.patch(v);

            if (this._flexItemDisabled) {
                this._flexItemDisabled = false;
                this._checkEnabled();
                const parent = this.flexParent;
                if (parent) {
                    parent._clearFlexItemsCache();
                    parent.changedContents();
                }
            }
        }
    }

    _enableFlex() {
        this._flex = new _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        this._checkEnabled();
        this.changedDimensions();
        this._enableChildrenAsFlexItems();
    }

    _disableFlex() {
        this.changedDimensions();
        this._flex = null;
        this._checkEnabled();
        this._disableChildrenAsFlexItems();
    }

    _enableChildrenAsFlexItems() {
        const children = this._target._children;
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const child = children[i];
                child.layout._enableFlexItem();
            }
        }
    }

    _disableChildrenAsFlexItems() {
        const children = this._target._children;
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const child = children[i];
                child.layout._disableFlexItem();
            }
        }
    }

    _enableFlexItem() {
        this._ensureFlexItem();
        const flexParent = this._target._parent._layout;
        this._flexItem.ctr = flexParent._flex;
        flexParent.changedContents();
        this._checkEnabled();
    }

    _disableFlexItem() {
        if (this._flexItem) {
            this._flexItem.ctr = null;
        }

        // We keep the flexItem object because it may contain custom settings.
        this._checkEnabled();

        // Offsets have been changed. We can't recover them, so we'll just clear them instead.
        this._resetOffsets();
    }

    _resetOffsets() {
        this.x = 0;
        this.y = 0;
    }

    _ensureFlexItem() {
        if (!this._flexItem) {
            this._flexItem = new _FlexItem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        }
    }

    _checkEnabled() {
        const enabled = this.isEnabled();
        if (this._enabled !== enabled) {
            if (enabled) {
                this._enable();
            } else {
                this._disable();
            }
            this._enabled = enabled;
        }
    }
    
    _enable() {
        this._setupTargetForFlex();
        this._target.enableFlexLayout();
    }

    _disable() {
        this._restoreTargetToNonFlex();
        this._target.disableFlexLayout();
    }

    isEnabled() {
        return this.isFlexEnabled() || this.isFlexItemEnabled();
    }

    isFlexEnabled() {
        return this._flex !== null;
    }

    isFlexItemEnabled() {
        return this.flexParent !== null;
    }

    _restoreTargetToNonFlex() {
        const target = this._target;
        target.x = this._originalX;
        target.y = this._originalY;
        target.setDimensions(this._originalWidth, this._originalHeight);
    }

    _setupTargetForFlex() {
        const target = this._target;
        this._originalX = target._x;
        this._originalY = target._y;
        this._originalWidth = target._w;
        this._originalHeight = target._h;
    }
    
    setParent(from, to) {
        if (from && from.isFlexContainer()) {
            from._layout._changedChildren();
        }

        if (to && to.isFlexContainer()) {
            this._enableFlexItem();
            to._layout._changedChildren();
        }
        this._checkEnabled();
    }

    get flexParent() {
        if (this._flexItemDisabled) {
            return null;
        }

        const parent = this._target._parent;
        if (parent && parent.isFlexContainer()) {
            return parent._layout;
        }
        return null;
    }

    setVisible(v) {
        const parent = this.flexParent;
        if (parent) {
            parent._changedChildren();
        }
    }

    get items() {
        if (!this._items) {
            this._items = this._getFlexItems();
        }
        return this._items;
    }

    _getFlexItems() {
        const items = [];
        const children = this._target._children;
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const item = children[i];
                if (item.visible) {
                    if (item.isFlexItem()) {
                        items.push(item.layout);
                    }
                }
            }
        }
        return items;
    }

    _changedChildren() {
        this._clearFlexItemsCache();
        this.changedContents();
    }

    _clearFlexItemsCache() {
        this._items = null;
    }

    setLayout(x, y, w, h) {
        let originalX = this._originalX;
        let originalY = this._originalY;
        if (this.funcX) {
            originalX = this.funcX(_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParentAxisSizeWithPadding(this, true));
        }
        if (this.funcY) {
            originalY = this.funcY(_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParentAxisSizeWithPadding(this, false));
        }

        if (this.isFlexItemEnabled()) {
            this.target.setLayout(x + originalX, y + originalY, w, h);
        } else {
            // Reuse the x,y 'settings'.
            this.target.setLayout(originalX, originalY, w, h);
        }
    }

    changedDimensions(changeWidth = true, changeHeight = true) {
        this._updateRecalc(changeWidth, changeHeight);
    }

    changedContents() {
        this._updateRecalc();
    }

    forceLayout() {
        this._updateRecalc();
    }

    isChanged() {
        return this._recalc > 0;
    }

    _updateRecalc(changeExternalWidth = false, changeExternalHeight = false) {
        if (this.isFlexEnabled()) {
            const layout = this._flex._layout;

            // When something internal changes, it can have effect on the external dimensions.
            changeExternalWidth = changeExternalWidth || layout.isAxisFitToContents(true);
            changeExternalHeight = changeExternalHeight || layout.isAxisFitToContents(false);
        }

        const recalc = 1 + (changeExternalWidth ? 2 : 0) + (changeExternalHeight ? 4 : 0);
        const newRecalcFlags = this.getNewRecalcFlags(recalc);
        this._recalc |= recalc;
        if (newRecalcFlags > 1) {
            if (this.flexParent) {
                this.flexParent._updateRecalcBottomUp(recalc);
            } else {
                this._target.triggerLayout();
            }
        } else {
            this._target.triggerLayout();
        }
    }

    getNewRecalcFlags(flags) {
        return (7 - this._recalc) & flags;
    }

    _updateRecalcBottomUp(childRecalc) {
        const newRecalc = this._getRecalcFromChangedChildRecalc(childRecalc);
        const newRecalcFlags = this.getNewRecalcFlags(newRecalc);
        this._recalc |= newRecalc;
        if (newRecalcFlags > 1) {
            const flexParent = this.flexParent;
            if (flexParent) {
                flexParent._updateRecalcBottomUp(newRecalc);
            } else {
                this._target.triggerLayout();
            }
        } else {
            this._target.triggerLayout();
        }
    }

    _getRecalcFromChangedChildRecalc(childRecalc) {
        const layout = this._flex._layout;

        const mainAxisRecalcFlag = layout._horizontal ? 1 : 2;
        const crossAxisRecalcFlag = layout._horizontal ? 2 : 1;

        const crossAxisDimensionsChangedInChild = (childRecalc & crossAxisRecalcFlag);
        if (!crossAxisDimensionsChangedInChild) {
            const mainAxisDimensionsChangedInChild = (childRecalc & mainAxisRecalcFlag);
            if (mainAxisDimensionsChangedInChild) {
                const mainAxisIsWrapping = layout.isWrapping();
                if (mainAxisIsWrapping) {
                    const crossAxisIsFitToContents = layout.isCrossAxisFitToContents();
                    if (crossAxisIsFitToContents) {
                        // Special case: due to wrapping, the cross axis size may be changed.
                        childRecalc += crossAxisRecalcFlag;
                    }
                }
            }
        }

        let isWidthDynamic = layout.isAxisFitToContents(true);
        let isHeightDynamic = layout.isAxisFitToContents(false);

        if (layout.shrunk) {
            // If during previous layout this container was 'shrunk', any changes may change the 'min axis size' of the
            // contents, leading to a different axis size on this container even when it was not 'fit to contents'.
            if (layout._horizontal) {
                isWidthDynamic = true;
            } else {
                isHeightDynamic = true;
            }
        }

        const localRecalc = 1 + (isWidthDynamic ? 2 : 0) + (isHeightDynamic ? 4 : 0);

        const combinedRecalc = childRecalc & localRecalc;
        return combinedRecalc;
    }

    get recalc() {
        return this._recalc;
    }

    clearRecalcFlag() {
        this._recalc = 0;
    }

    enableLocalRecalcFlag() {
        this._recalc = 1;
    }

    get originalX() {
        return this._originalX;
    }

    setOriginalXWithoutUpdatingLayout(v) {
        this._originalX = v;
    }

    get originalY() {
        return this._originalY;
    }

    setOriginalYWithoutUpdatingLayout(v) {
        this._originalY = v;
    }

    get originalWidth() {
        return this._originalWidth;
    }

    set originalWidth(v) {
        if (this._originalWidth !== v) {
            this._originalWidth = v;
            this.changedDimensions(true, false);
        }
    }

    get originalHeight() {
        return this._originalHeight;
    }

    set originalHeight(v) {
        if (this._originalHeight !== v) {
            this._originalHeight = v;
            this.changedDimensions(false, true);
        }
    }

    get funcX() {
        return this._target.funcX;
    }

    get funcY() {
        return this._target.funcY;
    }

    get funcW() {
        return this._target.funcW;
    }

    get funcH() {
        return this._target.funcH;
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexUtils)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class FlexUtils {

    static getParentAxisSizeWithPadding(item, horizontal) {
        const target = item.target;
        const parent = target.getParent();
        if (!parent) {
            return 0;
        } else {
            const flexParent = item.flexParent;
            if (flexParent) {
                // Use pending layout size.
                return this.getAxisLayoutSize(flexParent, horizontal) + this.getTotalPadding(flexParent, horizontal);
            } else {
                // Use 'absolute' size.
                return horizontal ? parent.w : parent.h;
            }
        }
    }

    static getRelAxisSize(item, horizontal) {
        if (horizontal) {
            if (item.funcW) {
                if (this._allowRelAxisSizeFunction(item, true)) {
                    return item.funcW(this.getParentAxisSizeWithPadding(item, true));
                } else {
                    return 0;
                }
            } else {
                return item.originalWidth;
            }
        } else {
            if (item.funcH) {
                if (this._allowRelAxisSizeFunction(item, false)) {
                    return item.funcH(this.getParentAxisSizeWithPadding(item, false));
                } else {
                    return 0;
                }
            } else {
                return item.originalHeight;
            }
        }
    }

    static _allowRelAxisSizeFunction(item, horizontal) {
        const flexParent = item.flexParent;
        if (flexParent && flexParent._flex._layout.isAxisFitToContents(horizontal)) {
            // We don't allow relative width on fit-to-contents because it leads to conflicts.
            return false;
        }
        return true;
    }

    static isZeroAxisSize(item, horizontal) {
        if (horizontal) {
            return !item.originalWidth && !item.funcW;
        } else {
            return !item.originalHeight && !item.funcH;
        }
    }

    static getAxisLayoutPos(item, horizontal) {
        return horizontal ? item.x : item.y;
    }

    static getAxisLayoutSize(item, horizontal) {
        return horizontal ? item.w : item.h;
    }

    static setAxisLayoutPos(item, horizontal, pos) {
        if (horizontal) {
            item.x = pos;
        } else {
            item.y = pos;
        }
    }

    static setAxisLayoutSize(item, horizontal, size) {
        if (horizontal) {
            item.w = size;
        } else {
            item.h = size;
        }
    }

    static getAxisMinSize(item, horizontal) {
        let minSize = this.getPlainAxisMinSize(item, horizontal);

        let flexItemMinSize = 0;
        if (item.isFlexItemEnabled()) {
            flexItemMinSize = item._flexItem._getMinSizeSetting(horizontal);
        }

        const hasLimitedMinSize = (flexItemMinSize > 0);
        if (hasLimitedMinSize) {
            minSize = Math.max(minSize, flexItemMinSize);
        }
        return minSize;
    }

    static getPlainAxisMinSize(item, horizontal) {
        if (item.isFlexEnabled()) {
            return item._flex._layout.getAxisMinSize(horizontal);
        } else {
            const isShrinkable = (item.flexItem.shrink !== 0);
            if (isShrinkable) {
                return 0;
            } else {
                return this.getRelAxisSize(item, horizontal);
            }
        }
    }

    static resizeAxis(item, horizontal, size) {
        if (item.isFlexEnabled()) {
            const isMainAxis = (item._flex._horizontal === horizontal);
            if (isMainAxis) {
                item._flex._layout.resizeMainAxis(size);
            } else {
                item._flex._layout.resizeCrossAxis(size);
            }
        } else {
            this.setAxisLayoutSize(item, horizontal, size);
        }
    }


    static getPaddingOffset(item, horizontal) {
        if (item.isFlexEnabled()) {
            const flex = item._flex;
            if (horizontal) {
                return flex.paddingLeft;
            } else {
                return flex.paddingTop;
            }
        } else {
            return 0;
        }
    }

    static getTotalPadding(item, horizontal) {
        if (item.isFlexEnabled()) {
            const flex = item._flex;
            if (horizontal) {
                return flex.paddingRight + flex.paddingLeft;
            } else {
                return flex.paddingTop + flex.paddingBottom;
            }
        } else {
            return 0;
        }
    }

    static getMarginOffset(item, horizontal) {
        const flexItem = item.flexItem;
        if (flexItem) {
            if (horizontal) {
                return flexItem.marginLeft;
            } else {
                return flexItem.marginTop;
            }
        } else {
            return 0;
        }
    }

    static getTotalMargin(item, horizontal) {
        const flexItem = item.flexItem;
        if (flexItem) {
            if (horizontal) {
                return flexItem.marginRight + flexItem.marginLeft;
            } else {
                return flexItem.marginTop + flexItem.marginBottom;
            }
        } else {
            return 0;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/ContentAligner.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/ContentAligner.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContentAligner)
/* harmony export */ });
/* harmony import */ var _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpacingCalculator.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ContentAligner {

    constructor(layout) {
        this._layout = layout;
        this._totalCrossAxisSize = 0;
    }

    get _lines() {
        return this._layout._lines;
    }

    init() {
        this._totalCrossAxisSize = this._getTotalCrossAxisSize();
    }

    align() {
        const crossAxisSize = this._layout.crossAxisSize;
        const remainingSpace = crossAxisSize - this._totalCrossAxisSize;

        const {spacingBefore, spacingBetween} = this._getSpacing(remainingSpace);

        const lines = this._lines;

        const mode = this._layout._flexContainer.alignContent;
        let growSize = 0;
        if (mode === "stretch" && lines.length && (remainingSpace > 0)) {
            growSize = remainingSpace / lines.length;
        }

        let currentPos = spacingBefore;
        for (let i = 0, n = lines.length; i < n; i++) {
            const crossAxisLayoutOffset = currentPos;
            const aligner = lines[i].createItemAligner();

            let finalCrossAxisLayoutSize = lines[i].crossAxisLayoutSize + growSize;

            aligner.setCrossAxisLayoutSize(finalCrossAxisLayoutSize);
            aligner.setCrossAxisLayoutOffset(crossAxisLayoutOffset);

            aligner.align();

            if (aligner.recursiveResizeOccured) {
                lines[i].setItemPositions();
            }

            currentPos += finalCrossAxisLayoutSize;
            currentPos += spacingBetween;
        }
    }

    get totalCrossAxisSize() {
        return this._totalCrossAxisSize;
    }

    _getTotalCrossAxisSize() {
        const lines = this._lines;
        let total = 0;
        for (let i = 0, n = lines.length; i < n; i++) {
            const line = lines[i];
            total += line.crossAxisLayoutSize;
        }
        return total;
    }

    _getSpacing(remainingSpace) {
        const mode = this._layout._flexContainer.alignContent;
        const numberOfItems = this._lines.length;
        return _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getSpacing(mode, numberOfItems, remainingSpace);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/FlexLayout.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/FlexLayout.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexLayout)
/* harmony export */ });
/* harmony import */ var _ContentAligner_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentAligner.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/ContentAligner.mjs");
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/* harmony import */ var _LineLayouter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LineLayouter.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/LineLayouter.mjs");
/* harmony import */ var _ItemCoordinatesUpdater_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ItemCoordinatesUpdater.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/ItemCoordinatesUpdater.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Layouts a flex container (and descendants).
 */
class FlexLayout {

    constructor(flexContainer) {
        this._flexContainer = flexContainer;

        this._lineLayouter = new _LineLayouter_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);

        this._resizingMainAxis = false;
        this._resizingCrossAxis = false;

        this._cachedMainAxisSizeAfterLayout = 0;
        this._cachedCrossAxisSizeAfterLayout = 0;

        this._shrunk = false;
    }

    get shrunk() {
        return this._shrunk;
    }

    get recalc() {
        return this.item.recalc;
    }

    layoutTree() {
        const isSubTree = (this.item.flexParent !== null);
        if (isSubTree) {
            // Use the dimensions set by the parent flex tree.
            this._updateSubTreeLayout();
        } else {
            this.updateTreeLayout();
        }
        this.updateItemCoords();
    }

    updateTreeLayout() {
        if (this.recalc) {
            this._performUpdateLayoutTree();
        } else {
            this._performUpdateLayoutTreeFromCache();
        }
    }

    _performUpdateLayoutTree() {
        this._setInitialAxisSizes();
        this._layoutAxes();
        this._refreshLayoutCache();
    }

    _refreshLayoutCache() {
        this._cachedMainAxisSizeAfterLayout = this.mainAxisSize;
        this._cachedCrossAxisSizeAfterLayout = this.crossAxisSize;
    }

    _performUpdateLayoutTreeFromCache() {
        const sizeMightHaveChanged = (this.item.funcW || this.item.funcH);
        if (sizeMightHaveChanged) {
            // Update after all.
            this.item.enableLocalRecalcFlag();
            this._performUpdateLayoutTree();
        } else {
            this.mainAxisSize = this._cachedMainAxisSizeAfterLayout;
            this.crossAxisSize = this._cachedCrossAxisSizeAfterLayout;
        }
    }

    updateItemCoords() {
        const updater = new _ItemCoordinatesUpdater_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this);
        updater.finalize();
    }

    _updateSubTreeLayout() {
        // The dimensions of this container are guaranteed not to have changed.
        // That's why we can safely 'reuse' those and re-layout the contents.
        const crossAxisSize = this.crossAxisSize;
        this._layoutMainAxis();
        this.performResizeCrossAxis(crossAxisSize);
    }

    _setInitialAxisSizes() {
        if (this.item.isFlexItemEnabled()) {
            this.item.flexItem._resetLayoutSize();
        } else {
            this.mainAxisSize = this._getMainAxisBasis();
            this.crossAxisSize = this._getCrossAxisBasis();
        }
        this._resizingMainAxis = false;
        this._resizingCrossAxis = false;
        this._shrunk = false;
    }

    _layoutAxes() {
        this._layoutMainAxis();
        this._layoutCrossAxis();
    }

    /**
     * @pre mainAxisSize should exclude padding.
     */
    _layoutMainAxis() {
        this._layoutLines();
        this._fitMainAxisSizeToContents();
    }

    _layoutLines() {
        this._lineLayouter.layoutLines();
    }

    get _lines() {
        return this._lineLayouter.lines;
    }

    _fitMainAxisSizeToContents() {
        if (!this._resizingMainAxis) {
            if (this.isMainAxisFitToContents()) {
                this.mainAxisSize = this._lineLayouter.mainAxisContentSize;
            }
        }
    }

    /**
     * @pre crossAxisSize should exclude padding.
     */
    _layoutCrossAxis() {
        const aligner = new _ContentAligner_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        aligner.init();
        this._totalCrossAxisSize = aligner.totalCrossAxisSize;
        this._fitCrossAxisSizeToContents();
        aligner.align();
    }

    _fitCrossAxisSizeToContents() {
        if (!this._resizingCrossAxis) {
            if (this.isCrossAxisFitToContents()) {
                this.crossAxisSize = this._totalCrossAxisSize;
            }
        }
    }

    isWrapping() {
        return this._flexContainer.wrap;
    }

    isAxisFitToContents(horizontal) {
        if (this._horizontal === horizontal) {
            return this.isMainAxisFitToContents();
        } else {
            return this.isCrossAxisFitToContents();
        }
    }

    isMainAxisFitToContents() {
        return !this.isWrapping() && !this._hasFixedMainAxisBasis();
    }

    isCrossAxisFitToContents() {
        return !this._hasFixedCrossAxisBasis();
    }

    _hasFixedMainAxisBasis() {
        return !_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isZeroAxisSize(this.item, this._horizontal);
    }

    _hasFixedCrossAxisBasis() {
        return !_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isZeroAxisSize(this.item, !this._horizontal);
    }

    getAxisMinSize(horizontal) {
        if (this._horizontal === horizontal) {
            return this._getMainAxisMinSize();
        } else {
            return this._getCrossAxisMinSize();
        }
    }

    _getMainAxisMinSize() {
        return this._lineLayouter.mainAxisMinSize;
    }

    _getCrossAxisMinSize() {
        return this._lineLayouter.crossAxisMinSize;
    }

    resizeMainAxis(size) {
        if (this.mainAxisSize !== size) {
            if (this.recalc > 0) {
                this.performResizeMainAxis(size);
            } else {
                if (this._checkValidCacheMainAxisResize()) {
                    this.mainAxisSize = size;
                    this._fitCrossAxisSizeToContents();
                } else {
                    // Cache miss.
                    this.item.enableLocalRecalcFlag();
                    this.performResizeMainAxis(size);
                }
            }
        }
    }

    _checkValidCacheMainAxisResize(size) {
        const isFinalMainAxisSize = (size === this.targetMainAxisSize);
        if (isFinalMainAxisSize) {
            return true;
        }
        const canIgnoreCacheMiss = !this.isCrossAxisFitToContents();
        if (canIgnoreCacheMiss) {
            // Allow other main axis resizes and check if final resize matches the target main axis size
            //  (ItemCoordinatesUpdater).
            return true;
        }
        return false;
    }

    performResizeMainAxis(size) {
        const isShrinking = (size < this.mainAxisSize);
        this._shrunk = isShrinking;

        this.mainAxisSize = size;

        this._resizingMainAxis = true;
        this._layoutAxes();
        this._resizingMainAxis = false;
    }

    resizeCrossAxis(size) {
        if (this.crossAxisSize !== size) {
            if (this.recalc > 0) {
                this.performResizeCrossAxis(size);
            } else {
                this.crossAxisSize = size;
            }
        }
    }

    performResizeCrossAxis(size) {
        this.crossAxisSize = size;

        this._resizingCrossAxis = true;
        this._layoutCrossAxis();
        this._resizingCrossAxis = false;
    }

    get targetMainAxisSize() {
        return this._horizontal ? this.item.target.w : this.item.target.h;
    }

    get targetCrossAxisSize() {
        return this._horizontal ? this.item.target.h : this.item.target.w;
    }

    getParentFlexContainer() {
        return this.item.isFlexItemEnabled() ? this.item.flexItem.ctr : null;
    }

    _getHorizontalPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, true);
    }

    _getVerticalPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, false);
    }

    _getHorizontalPaddingOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getPaddingOffset(this.item, true);
    }

    _getVerticalPaddingOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getPaddingOffset(this.item, false);
    }

    _getMainAxisBasis() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, this._horizontal);
    }

    _getCrossAxisBasis() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, !this._horizontal);
    }

    get _horizontal() {
        return this._flexContainer._horizontal;
    }

    get _reverse() {
        return this._flexContainer._reverse;
    }

    get item() {
        return this._flexContainer.item;
    }

    get items() {
        return this.item.items;
    }

    get resizingMainAxis() {
        return this._resizingMainAxis;
    }

    get resizingCrossAxis() {
        return this._resizingCrossAxis;
    }

    get numberOfItems() {
        return this.items.length;
    }

    get mainAxisSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, this._horizontal);
    }

    get crossAxisSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, !this._horizontal);
    }

    set mainAxisSize(v) {
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, this._horizontal, v);
    }

    set crossAxisSize(v) {
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, !this._horizontal, v);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/ItemCoordinatesUpdater.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/ItemCoordinatesUpdater.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ItemCoordinatesUpdater)
/* harmony export */ });
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ItemCoordinatesUpdater {

    constructor(layout) {
        this._layout = layout;
        this._isReverse = this._flexContainer._reverse;
        this._horizontalPaddingOffset = this._layout._getHorizontalPaddingOffset();
        this._verticalPaddingOffset = this._layout._getVerticalPaddingOffset();
    }

    get _flexContainer() {
        return this._layout._flexContainer;
    }

    finalize() {
        const parentFlex = this._layout.getParentFlexContainer();
        if (parentFlex) {
            // We must update it from the parent to set padding offsets and reverse position.
            const updater = new ItemCoordinatesUpdater(parentFlex._layout);
            updater._finalizeItemAndChildren(this._flexContainer.item);
        } else {
            this._finalizeRoot();
            this._finalizeItems();
        }
    }

    _finalizeRoot() {
        const item = this._flexContainer.item;
        let x = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, true);
        let y = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, false);
        let w = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, true);
        let h = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, false);

        w += this._layout._getHorizontalPadding();
        h += this._layout._getVerticalPadding();

        item.clearRecalcFlag();

        item.setLayout(x, y, w, h);
    }

    _finalizeItems() {
        const items = this._layout.items;
        for (let i = 0, n = items.length; i < n; i++) {
            const item = items[i];
            const validCache = this._validateItemCache(item);

            // Notice that we must also finalize a cached items, as it's coordinates may have changed.
            this._finalizeItem(item);

            if (!validCache) {
                this._finalizeItemChildren(item);
            }
        }
    }

    _validateItemCache(item) {
        if (item.recalc === 0) {
            if (item.isFlexEnabled()) {
                const layout = item._flex._layout;

                const dimensionsMatchPreviousResult = (item.w === item.target.w && item.h === item.target.h);
                if (dimensionsMatchPreviousResult) {
                    // Cache is valid.
                    return true;
                } else {
                    const crossAxisSize = layout.crossAxisSize;
                    layout.performResizeMainAxis(layout.mainAxisSize);
                    layout.performResizeCrossAxis(crossAxisSize);
                }
            }
        }
        return false;
    }

    _finalizeItemAndChildren(item) {
        this._finalizeItem(item);
        this._finalizeItemChildren(item);
    }

    _finalizeItem(item) {
        if (this._isReverse) {
            this._reverseMainAxisLayoutPos(item);
        }

        let x = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, true);
        let y = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, false);
        let w = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, true);
        let h = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, false);

        x += this._horizontalPaddingOffset;
        y += this._verticalPaddingOffset;

        const flex = item.flex;
        if (flex) {
            w += item._flex._layout._getHorizontalPadding();
            h += item._flex._layout._getVerticalPadding();
        }

        const flexItem = item.flexItem;
        if (flexItem) {
            x += flexItem._getHorizontalMarginOffset();
            y += flexItem._getVerticalMarginOffset();
        }

        item.clearRecalcFlag();
        item.setLayout(x, y, w, h);
    }

    _finalizeItemChildren(item) {
        const flex = item._flex;
        if (flex) {
            const updater = new ItemCoordinatesUpdater(flex._layout);
            updater._finalizeItems();
        }
    }

    _reverseMainAxisLayoutPos(item) {
        const endPos = (item.flexItem._getMainAxisLayoutPos() + item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin());
        const reversedPos = this._layout.mainAxisSize - endPos;
        item.flexItem._setMainAxisLayoutPos(reversedPos);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/LineLayouter.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/LineLayouter.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineLayouter)
/* harmony export */ });
/* harmony import */ var _line_LineLayout_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line/LineLayout.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/LineLayout.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Distributes items over layout lines.
 */
class LineLayouter {

    constructor(layout) {
        this._layout = layout;
        this._mainAxisMinSize = -1;
        this._crossAxisMinSize = -1;
        this._mainAxisContentSize = 0;
    }

    get lines() {
        return this._lines;
    }

    get mainAxisMinSize() {
        if (this._mainAxisMinSize === -1) {
            this._mainAxisMinSize = this._getMainAxisMinSize();
        }
        return this._mainAxisMinSize;
    }

    get crossAxisMinSize() {
        if (this._crossAxisMinSize === -1) {
            this._crossAxisMinSize = this._getCrossAxisMinSize();
        }
        return this._crossAxisMinSize;
    }

    get mainAxisContentSize() {
        return this._mainAxisContentSize;
    }

    layoutLines() {
        this._setup();
        const items = this._layout.items;
        const wrap = this._layout.isWrapping();

        let startIndex = 0;
        let i;
        const n = items.length;
        for (i = 0; i < n; i++) {
            const item = items[i];

            this._layoutFlexItem(item);

            // Get predicted main axis size.
            const itemMainAxisSize = item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();

            if (wrap && (i > startIndex)) {
                const isOverflowing = (this._curMainAxisPos + itemMainAxisSize > this._mainAxisSize);
                if (isOverflowing) {
                    this._layoutLine(startIndex, i - 1);
                    this._curMainAxisPos = 0;
                    startIndex = i;
                }
            }

            this._addToMainAxisPos(itemMainAxisSize);
        }

        if (startIndex < i) {
            this._layoutLine(startIndex, i - 1);
        }
    }

    _layoutFlexItem(item) {
        if (item.isFlexEnabled()) {
            item.flexLayout.updateTreeLayout();
        } else {
            item.flexItem._resetLayoutSize();
        }
    }

    _setup() {
        this._mainAxisSize = this._layout.mainAxisSize;
        this._curMainAxisPos = 0;
        this._maxMainAxisPos = 0;
        this._lines = [];

        this._mainAxisMinSize = -1;
        this._crossAxisMinSize = -1;
        this._mainAxisContentSize = 0;
    }

    _addToMainAxisPos(itemMainAxisSize) {
        this._curMainAxisPos += itemMainAxisSize;
        if (this._curMainAxisPos > this._maxMainAxisPos) {
            this._maxMainAxisPos = this._curMainAxisPos;
        }
    }

    _layoutLine(startIndex, endIndex) {
        const availableSpace = this._getAvailableMainAxisLayoutSpace();
        const line = new _line_LineLayout_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this._layout, startIndex, endIndex, availableSpace);
        line.performLayout();
        this._lines.push(line);

        if (this._mainAxisContentSize === 0 || (this._curMainAxisPos > this._mainAxisContentSize)) {
            this._mainAxisContentSize = this._curMainAxisPos;
        }
    }

    _getAvailableMainAxisLayoutSpace() {
        if (!this._layout.resizingMainAxis && this._layout.isMainAxisFitToContents()) {
            return 0;
        } else {
            return this._mainAxisSize - this._curMainAxisPos;
        }
    }

    _getCrossAxisMinSize() {
        let crossAxisMinSize = 0;
        const items = this._layout.items;
        for (let i = 0, n = items.length; i < n; i++) {
            const item = items[i];
            const itemCrossAxisMinSize = item.flexItem._getCrossAxisMinSizeWithPaddingAndMargin();
            crossAxisMinSize = Math.max(crossAxisMinSize, itemCrossAxisMinSize);
        }
        return crossAxisMinSize;
    }

    _getMainAxisMinSize() {
        if (this._lines.length === 1) {
            return this._lines[0].getMainAxisMinSize();
        } else {
            // Wrapping lines: specified width is used as min width (in accordance to W3C flexbox).
            return this._layout.mainAxisSize;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpacingCalculator)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class SpacingCalculator {

    static getSpacing(mode, numberOfItems, remainingSpace) {
        const itemGaps = (numberOfItems - 1);
        let spacePerGap;

        let spacingBefore, spacingBetween;

        switch(mode) {
            case "flex-start":
                spacingBefore = 0;
                spacingBetween = 0;
                break;
            case "flex-end":
                spacingBefore = remainingSpace;
                spacingBetween = 0;
                break;
            case "center":
                spacingBefore = remainingSpace / 2;
                spacingBetween = 0;
                break;
            case "space-between":
                spacingBefore = 0;
                spacingBetween = Math.max(0, remainingSpace) / itemGaps;
                break;
            case "space-around":
                if (remainingSpace < 0) {
                    return this.getSpacing("center", numberOfItems, remainingSpace);
                } else {
                    spacePerGap = remainingSpace / (itemGaps + 1);
                    spacingBefore = 0.5 * spacePerGap;
                    spacingBetween = spacePerGap;
                }
                break;
            case "space-evenly":
                if (remainingSpace < 0) {
                    return this.getSpacing("center", numberOfItems, remainingSpace);
                } else {
                    spacePerGap = remainingSpace / (itemGaps + 2);
                    spacingBefore = spacePerGap;
                    spacingBetween = spacePerGap;
                }
                break;
            case "stretch":
                spacingBefore = 0;
                spacingBetween = 0;
                break;
            default:
                throw new Error("Unknown mode: " + mode);
        }

        return {spacingBefore, spacingBetween}
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemAligner.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/ItemAligner.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ItemAligner)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ItemAligner {

    constructor(line) {
        this._line = line;
        this._crossAxisLayoutSize = 0;
        this._crossAxisLayoutOffset = 0;
        this._alignItemsSetting = null;
        this._recursiveResizeOccured = false;
        this._isCrossAxisFitToContents = false;
    }

    get _layout() {
        return this._line._layout;
    }

    get _flexContainer() {
        return this._layout._flexContainer;
    }

    setCrossAxisLayoutSize(size) {
        this._crossAxisLayoutSize = size;
    }

    setCrossAxisLayoutOffset(offset) {
        this._crossAxisLayoutOffset = offset;
    }

    align() {
        this._alignItemsSetting = this._flexContainer.alignItems;

        this._isCrossAxisFitToContents = this._layout.isAxisFitToContents(!this._flexContainer._horizontal);

        this._recursiveResizeOccured = false;
        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            this._alignItem(item);
        }
    }

    get recursiveResizeOccured() {
        return this._recursiveResizeOccured;
    }

    _alignItem(item) {
        const flexItem = item.flexItem;
        let align = flexItem.alignSelf || this._alignItemsSetting;

        if (align === "stretch" && this._preventStretch(flexItem)) {
            align = "flex-start";
        }

        if (align !== "stretch" && !this._isCrossAxisFitToContents) {
            if (flexItem._hasRelCrossAxisSize()) {
                // As cross axis size might have changed, we need to recalc the relative flex item's size.
                flexItem._resetCrossAxisLayoutSize();
            }
        }

        switch(align) {
            case "flex-start":
                this._alignItemFlexStart(flexItem);
                break;
            case "flex-end":
                this._alignItemFlexEnd(flexItem);
                break;
            case "center":
                this._alignItemFlexCenter(flexItem);
                break;
            case "stretch":
                this._alignItemStretch(flexItem);
                break;
        }
    }

    _alignItemFlexStart(flexItem) {
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
    }

    _alignItemFlexEnd(flexItem) {
        const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + (this._crossAxisLayoutSize - itemCrossAxisSize));
    }

    _alignItemFlexCenter(flexItem) {
        const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
        const center = (this._crossAxisLayoutSize - itemCrossAxisSize) / 2;
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + center);
    }

    _alignItemStretch(flexItem) {
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);

        const mainAxisLayoutSizeBeforeResize = flexItem._getMainAxisLayoutSize();
        let size = this._crossAxisLayoutSize - flexItem._getCrossAxisMargin() - flexItem._getCrossAxisPadding();

        const crossAxisMinSizeSetting = flexItem._getCrossAxisMinSizeSetting();
        if (crossAxisMinSizeSetting > 0) {
            size = Math.max(size, crossAxisMinSizeSetting);
        }

        const crossAxisMaxSizeSetting = flexItem._getCrossAxisMaxSizeSetting();
        const crossAxisMaxSizeSettingEnabled = (crossAxisMaxSizeSetting > 0);
        if (crossAxisMaxSizeSettingEnabled) {
            size = Math.min(size, crossAxisMaxSizeSetting);
        }

        flexItem._resizeCrossAxis(size);
        const mainAxisLayoutSizeAfterResize = flexItem._getMainAxisLayoutSize();

        const recursiveResize = (mainAxisLayoutSizeAfterResize !== mainAxisLayoutSizeBeforeResize);
        if (recursiveResize) {
            // Recursive resize can happen when this flex item has the opposite direction than the container
            // and is wrapping and auto-sizing. Due to item/content stretching the main axis size of the flex
            // item may decrease. If it does so, we must re-justify-content the complete line.
            // Notice that we don't account for changes to the (if autosized) main axis size caused by recursive
            // resize, which may cause the container's main axis to not shrink to the contents properly.
            // This is by design, because if we had re-run the main axis layout, we could run into issues such
            // as slow layout or endless loops.
            this._recursiveResizeOccured = true;
        }
    }

    _preventStretch(flexItem) {
        const hasFixedCrossAxisSize = flexItem._hasFixedCrossAxisSize();
        const forceStretch = (flexItem.alignSelf === "stretch");
        return hasFixedCrossAxisSize && !forceStretch;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemPositioner.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/ItemPositioner.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ItemPositioner)
/* harmony export */ });
/* harmony import */ var _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../SpacingCalculator.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ItemPositioner {

    constructor(lineLayout) {
        this._line = lineLayout;
    }

    get _layout() {
        return this._line._layout;
    }

    position() {
        const {spacingBefore, spacingBetween} = this._getSpacing();

        let currentPos = spacingBefore;

        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];

            item.flexItem._setMainAxisLayoutPos(currentPos);
            currentPos += item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
            currentPos += spacingBetween;
        }
    }

    _getSpacing() {
        const remainingSpace = this._line._availableSpace;
        let mode = this._layout._flexContainer.justifyContent;
        const numberOfItems = this._line.numberOfItems;

        return _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getSpacing(mode, numberOfItems, remainingSpace);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/LineLayout.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/LineLayout.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineLayout)
/* harmony export */ });
/* harmony import */ var _SizeShrinker_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SizeShrinker.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeShrinker.mjs");
/* harmony import */ var _SizeGrower_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SizeGrower.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeGrower.mjs");
/* harmony import */ var _ItemPositioner_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ItemPositioner.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemPositioner.mjs");
/* harmony import */ var _ItemAligner_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ItemAligner.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemAligner.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class LineLayout {

    constructor(layout, startIndex, endIndex, availableSpace) {
        this._layout = layout;
        this.items = layout.items;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this._availableSpace = availableSpace;
    }

    performLayout() {
        this._setItemSizes();
        this.setItemPositions();
        this._calcLayoutInfo();
    }

    _setItemSizes() {
        if (this._availableSpace > 0) {
            this._growItemSizes(this._availableSpace);
        } else if (this._availableSpace < 0) {
            this._shrinkItemSizes(-this._availableSpace);
        }
    }

    _growItemSizes(amount) {
        const grower = new _SizeGrower_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        grower.grow(amount);
        this._availableSpace -= grower.getGrownSize();
    }

    _shrinkItemSizes(amount) {
        const shrinker = new _SizeShrinker_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        shrinker.shrink(amount);
        this._availableSpace += shrinker.getShrunkSize();
    }

    setItemPositions() {
        const positioner = new _ItemPositioner_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);
        positioner.position();
    }

    createItemAligner() {
        return new _ItemAligner_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this);
    }

    _calcLayoutInfo() {
        this._calcCrossAxisMaxLayoutSize();
    }

    getMainAxisMinSize() {
        let mainAxisMinSize = 0;
        for (let i = this.startIndex; i <= this.endIndex; i++) {
            const item = this.items[i];
            mainAxisMinSize += item.flexItem._getMainAxisMinSizeWithPaddingAndMargin();
        }
        return mainAxisMinSize;
    }
    
    get numberOfItems() {
        return this.endIndex - this.startIndex + 1;
    }

    get crossAxisLayoutSize() {
        const noSpecifiedCrossAxisSize = (this._layout.isCrossAxisFitToContents() && !this._layout.resizingCrossAxis);
        const shouldFitToContents = (this._layout.isWrapping() || noSpecifiedCrossAxisSize);
        if (shouldFitToContents) {
            return this._crossAxisMaxLayoutSize;
        } else {
            return this._layout.crossAxisSize;
        }
    }

    _calcCrossAxisMaxLayoutSize() {
        this._crossAxisMaxLayoutSize = this._getCrossAxisMaxLayoutSize();
    }

    _getCrossAxisMaxLayoutSize() {
        let crossAxisMaxSize = 0;
        for (let i = this.startIndex; i <= this.endIndex; i++) {
            const item = this.items[i];
            crossAxisMaxSize = Math.max(crossAxisMaxSize, item.flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin());
        }
        return crossAxisMaxSize;
    }


}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeGrower.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/SizeGrower.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SizeGrower)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class SizeGrower {

    constructor(line) {
        this._line = line;
        this._amountRemaining = 0;
        this._grownSize = 0;
    }

    grow(amount) {
        this._grownSize = 0;

        this._amountRemaining = amount;
        let totalGrowAmount = this._getTotalGrowAmount();
        if (totalGrowAmount) {
            const items = this._line.items;
            do {
                let amountPerGrow = this._amountRemaining / totalGrowAmount;
                for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                    const item = items[i];
                    const flexItem = item.flexItem;
                    const growAmount = flexItem.grow;
                    const isGrowableItem = (growAmount > 0);
                    if (isGrowableItem) {
                        let grow = growAmount * amountPerGrow;
                        const maxSize = flexItem._getMainAxisMaxSizeSetting();
                        const size = flexItem._getMainAxisLayoutSize();
                        if (maxSize > 0) {
                            if (size >= maxSize) {
                                // Already fully grown.
                                grow = 0;
                            } else {
                                const maxGrow = maxSize - size;
                                const isFullyGrown = (grow >= maxGrow);
                                if (isFullyGrown) {
                                    grow = maxGrow;

                                    // Destribute remaining amount over the other flex items.
                                    totalGrowAmount -= growAmount;
                                }
                            }
                        }

                        if (grow > 0) {
                            const finalSize = size + grow;
                            flexItem._resizeMainAxis(finalSize);

                            this._grownSize += grow;
                            this._amountRemaining -= grow;

                            if (Math.abs(this._amountRemaining) < 10e-6) {
                                return;
                            }
                        }
                    }
                }
            } while(totalGrowAmount && (Math.abs(this._amountRemaining) > 10e-6));
        }
    }

    _getTotalGrowAmount() {
        let total = 0;
        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            const flexItem = item.flexItem;

            if (flexItem.grow) {
                const maxSize = flexItem._getMainAxisMaxSizeSetting();
                const size = flexItem._getMainAxisLayoutSize();

                // Exclude those already fully grown.
                if (maxSize === 0 || size < maxSize) {
                    total += flexItem.grow;
                }
            }
        }
        return total;
    }

    getGrownSize() {
        return this._grownSize;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeShrinker.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/SizeShrinker.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SizeShrinker)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class SizeShrinker {

    constructor(line) {
        this._line = line;
        this._amountRemaining = 0;
        this._shrunkSize = 0;
    }

    shrink(amount) {
        this._shrunkSize = 0;

        this._amountRemaining = amount;
        let totalShrinkAmount = this._getTotalShrinkAmount();
        if (totalShrinkAmount) {
            const items = this._line.items;
            do {
                let amountPerShrink = this._amountRemaining / totalShrinkAmount;
                for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                    const item = items[i];
                    const flexItem = item.flexItem;
                    const shrinkAmount = flexItem.shrink;
                    const isShrinkableItem = (shrinkAmount > 0);
                    if (isShrinkableItem) {
                        let shrink = shrinkAmount * amountPerShrink;
                        const minSize = flexItem._getMainAxisMinSize();
                        const size = flexItem._getMainAxisLayoutSize();
                        if (size > minSize) {
                            const maxShrink = size - minSize;
                            const isFullyShrunk = (shrink >= maxShrink);
                            if (isFullyShrunk) {
                                shrink = maxShrink;

                                // Destribute remaining amount over the other flex items.
                                totalShrinkAmount -= shrinkAmount;
                            }

                            const finalSize = size - shrink;
                            flexItem._resizeMainAxis(finalSize);

                            this._shrunkSize += shrink;
                            this._amountRemaining -= shrink;

                            if (Math.abs(this._amountRemaining) < 10e-6) {
                                return;
                            }
                        }
                    }
                }
            } while(totalShrinkAmount && (Math.abs(this._amountRemaining) > 10e-6));
        }
    }

    _getTotalShrinkAmount() {
        let total = 0;
        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            const flexItem = item.flexItem;

            if (flexItem.shrink) {
                const minSize = flexItem._getMainAxisMinSize();
                const size = flexItem._getMainAxisLayoutSize();

                // Exclude those already fully shrunk.
                if (size > minSize) {
                    total += flexItem.shrink;
                }
            }
        }
        return total;
    }

    getShrunkSize() {
        return this._shrunkSize;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/lightning.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/lightning.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _application_Application_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./application/Application.mjs */ "./node_modules/@lightningjs/core/src/application/Application.mjs");
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tree/Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _tree_core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tree/core/ElementCore.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs");
/* harmony import */ var _tree_core_ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tree/core/ElementTexturizer.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs");
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/* harmony import */ var _tools_Tools_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tools/Tools.mjs */ "./node_modules/@lightningjs/core/src/tools/Tools.mjs");
/* harmony import */ var _tools_ObjMerger_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools/ObjMerger.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjMerger.mjs");
/* harmony import */ var _tools_ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tools/ObjectListProxy.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs");
/* harmony import */ var _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tools/ObjectListWrapper.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs");
/* harmony import */ var _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textures/RectangleTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs");
/* harmony import */ var _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./textures/NoiseTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs");
/* harmony import */ var _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./textures/TextTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTexture.mjs");
/* harmony import */ var _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./textures/ImageTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs");
/* harmony import */ var _textures_HtmlTexture_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./textures/HtmlTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/HtmlTexture.mjs");
/* harmony import */ var _textures_StaticTexture_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./textures/StaticTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/StaticTexture.mjs");
/* harmony import */ var _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./textures/StaticCanvasTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs");
/* harmony import */ var _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./textures/SourceTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs");
/* harmony import */ var _components_ListComponent_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/ListComponent.mjs */ "./node_modules/@lightningjs/core/src/components/ListComponent.mjs");
/* harmony import */ var _components_FastBlurComponent_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/FastBlurComponent.mjs */ "./node_modules/@lightningjs/core/src/components/FastBlurComponent.mjs");
/* harmony import */ var _components_BloomComponent_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/BloomComponent.mjs */ "./node_modules/@lightningjs/core/src/components/BloomComponent.mjs");
/* harmony import */ var _components_SmoothScaleComponent_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/SmoothScaleComponent.mjs */ "./node_modules/@lightningjs/core/src/components/SmoothScaleComponent.mjs");
/* harmony import */ var _components_BorderComponent_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/BorderComponent.mjs */ "./node_modules/@lightningjs/core/src/components/BorderComponent.mjs");
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _renderer_webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./renderer/webgl/WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./renderer/webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _renderer_common_shaders_GrayscaleShader_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./renderer/common/shaders/GrayscaleShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/common/shaders/GrayscaleShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./renderer/webgl/shaders/BoxBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DitheringShader_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./renderer/webgl/shaders/DitheringShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DitheringShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_CircularPushShader_mjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./renderer/webgl/shaders/CircularPushShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/CircularPushShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_InversionShader_mjs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./renderer/webgl/shaders/InversionShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/InversionShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./renderer/webgl/shaders/LinearBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_OutlineShader_mjs__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./renderer/webgl/shaders/OutlineShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/OutlineShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_PixelateShader_mjs__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./renderer/webgl/shaders/PixelateShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PixelateShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_RadialFilterShader_mjs__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./renderer/webgl/shaders/RadialFilterShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialFilterShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_RoundedRectangleShader_mjs__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./renderer/webgl/shaders/RoundedRectangleShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RoundedRectangleShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_FadeOutShader_mjs__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./renderer/webgl/shaders/FadeOutShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/FadeOutShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_VignetteShader_mjs__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./renderer/webgl/shaders/VignetteShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/VignetteShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_SpinnerShader_mjs__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./renderer/webgl/shaders/SpinnerShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_HoleShader_mjs__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./renderer/webgl/shaders/HoleShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/HoleShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_RadialGradientShader_mjs__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./renderer/webgl/shaders/RadialGradientShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialGradientShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_Light3dShader_mjs__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./renderer/webgl/shaders/Light3dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/Light3dShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_PerspectiveShader_mjs__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./renderer/webgl/shaders/PerspectiveShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PerspectiveShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_MagnifierShader_mjs__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./renderer/webgl/shaders/MagnifierShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/MagnifierShader.mjs");
/* harmony import */ var _renderer_c2d_C2dShader_mjs__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./renderer/c2d/C2dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs");
/* harmony import */ var _renderer_c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./renderer/c2d/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/* harmony import */ var _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./renderer/c2d/shaders/BlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs");
/* harmony import */ var _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./tree/Stage.mjs */ "./node_modules/@lightningjs/core/src/tree/Stage.mjs");
/* harmony import */ var _renderer_webgl_shaders_SpinnerShader2_mjs__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./renderer/webgl/shaders/SpinnerShader2.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader2.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





























































const lightning = {
    Application: _application_Application_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    Component: _application_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
    Base: _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
    Utils: _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
    StageUtils: _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
    Element: _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
    Tools: _tools_Tools_mjs__WEBPACK_IMPORTED_MODULE_9__["default"],
    Stage: _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_50__["default"],
    ElementCore: _tree_core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
    ElementTexturizer: _tree_core_ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
    Texture: _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_8__["default"],
    EventEmitter: _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_26__["default"],
    shaders: {
        Grayscale: _renderer_common_shaders_GrayscaleShader_mjs__WEBPACK_IMPORTED_MODULE_29__.WebGLGrayscaleShader,
        BoxBlur: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_30__["default"],
        Dithering: _renderer_webgl_shaders_DitheringShader_mjs__WEBPACK_IMPORTED_MODULE_31__["default"],
        CircularPush: _renderer_webgl_shaders_CircularPushShader_mjs__WEBPACK_IMPORTED_MODULE_32__["default"],
        Inversion: _renderer_webgl_shaders_InversionShader_mjs__WEBPACK_IMPORTED_MODULE_33__["default"],
        LinearBlur: _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_34__["default"],
        Outline: _renderer_webgl_shaders_OutlineShader_mjs__WEBPACK_IMPORTED_MODULE_35__["default"],
        Pixelate: _renderer_webgl_shaders_PixelateShader_mjs__WEBPACK_IMPORTED_MODULE_36__["default"],
        RadialFilter: _renderer_webgl_shaders_RadialFilterShader_mjs__WEBPACK_IMPORTED_MODULE_37__["default"],
        RoundedRectangle: _renderer_webgl_shaders_RoundedRectangleShader_mjs__WEBPACK_IMPORTED_MODULE_38__["default"],
        Spinner2: _renderer_webgl_shaders_SpinnerShader2_mjs__WEBPACK_IMPORTED_MODULE_51__["default"],
        FadeOut: _renderer_webgl_shaders_FadeOutShader_mjs__WEBPACK_IMPORTED_MODULE_39__["default"],
        Hole: _renderer_webgl_shaders_HoleShader_mjs__WEBPACK_IMPORTED_MODULE_42__["default"],
        Vignette: _renderer_webgl_shaders_VignetteShader_mjs__WEBPACK_IMPORTED_MODULE_40__["default"],
        Spinner: _renderer_webgl_shaders_SpinnerShader_mjs__WEBPACK_IMPORTED_MODULE_41__["default"],
        RadialGradient: _renderer_webgl_shaders_RadialGradientShader_mjs__WEBPACK_IMPORTED_MODULE_43__["default"],
        Light3d: _renderer_webgl_shaders_Light3dShader_mjs__WEBPACK_IMPORTED_MODULE_44__["default"],
        Perspective: _renderer_webgl_shaders_PerspectiveShader_mjs__WEBPACK_IMPORTED_MODULE_45__["default"],
        Magnifier: _renderer_webgl_shaders_MagnifierShader_mjs__WEBPACK_IMPORTED_MODULE_46__["default"],
        WebGLShader: _renderer_webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_27__["default"],
        WebGLDefaultShader: _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_28__["default"],
        C2dShader: _renderer_c2d_C2dShader_mjs__WEBPACK_IMPORTED_MODULE_47__["default"],
        C2dDefaultShader: _renderer_c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_48__["default"],
        c2d: {
            Grayscale: _renderer_common_shaders_GrayscaleShader_mjs__WEBPACK_IMPORTED_MODULE_29__.C2dGrayscaleShader,
            Blur: _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_49__["default"]
        }
    },
    textures: {
        RectangleTexture: _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_13__["default"],
        NoiseTexture: _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_14__["default"],
        TextTexture: _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_15__["default"],
        ImageTexture: _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_16__["default"],
        HtmlTexture: _textures_HtmlTexture_mjs__WEBPACK_IMPORTED_MODULE_17__["default"],
        StaticTexture: _textures_StaticTexture_mjs__WEBPACK_IMPORTED_MODULE_18__["default"],
        StaticCanvasTexture: _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_19__["default"],
        SourceTexture: _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_20__["default"]
    },
    components: {
        FastBlurComponent: _components_FastBlurComponent_mjs__WEBPACK_IMPORTED_MODULE_22__["default"],
        BloomComponent: _components_BloomComponent_mjs__WEBPACK_IMPORTED_MODULE_23__["default"],
        SmoothScaleComponent: _components_SmoothScaleComponent_mjs__WEBPACK_IMPORTED_MODULE_24__["default"],
        BorderComponent: _components_BorderComponent_mjs__WEBPACK_IMPORTED_MODULE_25__["default"],
        ListComponent: _components_ListComponent_mjs__WEBPACK_IMPORTED_MODULE_21__["default"]
    },
    tools: {
        ObjMerger: _tools_ObjMerger_mjs__WEBPACK_IMPORTED_MODULE_10__["default"],
        ObjectListProxy: _tools_ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_11__["default"],
        ObjectListWrapper: _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_12__["default"]
    }
};

if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isWeb) {
    window.lng = lightning;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lightning);


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/platforms/PlatformLoader.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/platforms/PlatformLoader.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PlatformLoader)
/* harmony export */ });
/* harmony import */ var _browser_WebPlatform_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser/WebPlatform.mjs */ "./node_modules/@lightningjs/core/src/platforms/browser/WebPlatform.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class PlatformLoader {
    static load(options) {
        if (options.platform) {
            return options.platform;
        } else {
            return _browser_WebPlatform_mjs__WEBPACK_IMPORTED_MODULE_0__["default"];
        }
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/platforms/browser/ImageWorker.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/platforms/browser/ImageWorker.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageWorker)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ImageWorker {

    constructor(options = {}) {
        this._items = new Map();
        this._id = 0;

        this._initWorker();
    }

    destroy() {
        if (this._worker) {
            this._worker.terminate();
        }
    }

    _initWorker() {
        const code = `(${createWorker.toString()})()`;
        const blob = new Blob([code.replace('"use strict";', '')]); // firefox adds "use strict"; to any function which might block worker execution so knock it off
        const blobURL = (window.URL ? URL : webkitURL).createObjectURL(blob, {
            type: 'application/javascript; charset=utf-8'
        });
        this._worker = new Worker(blobURL);

        this._worker.postMessage({type: 'config', config: {path: window.location.href, protocol: window.location.protocol}});

        this._worker.onmessage = (e) => {
            if (e.data && e.data.id) {
                const id = e.data.id;
                const item = this._items.get(id);
                if (item) {
                    if (e.data.type == 'data') {
                        this.finish(item, e.data.info);
                    } else {
                        this.error(item, e.data.info);
                    }
                }
            }
        }
    }

    create(src) {
        const id = ++this._id;
        const item = new ImageWorkerImage(this, id, src);
        this._items.set(id, item);
        this._worker.postMessage({type: "add", id: id, src: src});
        return item;
    }

    cancel(image) {
        this._worker.postMessage({type: "cancel", id: image.id});
        this._items.delete(image.id);
    }

    error(image, info) {
        image.error(info);
        this._items.delete(image.id);
    }

    finish(image, info) {
        image.load(info);
        this._items.delete(image.id);
    }

}

class ImageWorkerImage {

    constructor(manager, id, src) {
        this._manager = manager;
        this._id = id;
        this._src = src;
        this._onError = null;
        this._onLoad = null;
    }

    get id() {
        return this._id;
    }

    get src() {
        return this._src;
    }

    set onError(f) {
        this._onError = f;
    }

    set onLoad(f) {
        this._onLoad = f;
    }

    cancel() {
        this._manager.cancel(this);
    }

    load(info) {
        if (this._onLoad) {
            this._onLoad(info);
        }
    }

    error(info) {
        if (this._onError) {
            this._onError(info);
        }
    }

}

/**
 * Notice that, within the createWorker function, we must only use ES5 code to keep it ES5-valid after babelifying, as
 *  the converted code of this section is converted to a blob and used as the js of the web worker thread.
 */
const createWorker = function() {

    function ImageWorkerServer() {

        this.items = new Map();

        var t = this;
        onmessage = function(e) {
            t._receiveMessage(e);
        }

    }

    ImageWorkerServer.isPathAbsolute = function(path) {
        return /^(?:\/|[a-z]+:\/\/)/.test(path) || path.substr(0, 5) == 'data:';
    };

    ImageWorkerServer.prototype._receiveMessage = function(e) {
        if (e.data.type === 'config') {
            this.config = e.data.config;

            var base = this.config.path;
            // the constructing of the basepath fails
            // if location.hash contains a slash
            var hasHashPath = /#.*?\//;
            if(hasHashPath.test(base)){
                base = base.replace(/#.*$/,'');
            }

            var parts = base.split("/");
            parts.pop();
            this._relativeBase = parts.join("/") + "/";

        } else if (e.data.type === 'add') {
            this.add(e.data.id, e.data.src);
        } else if (e.data.type === 'cancel') {
            this.cancel(e.data.id);
        }
    };

    ImageWorkerServer.prototype.add = function(id, src) {
        // Convert relative URLs.
        if (!ImageWorkerServer.isPathAbsolute(src)) {
            src = this._relativeBase + src;
        }

        if (src.substr(0,2) === "//") {
            // This doesn't work for image workers.
            src = this.config.protocol + src;
        }

        var item = new ImageWorkerServerItem(id, src);
        var t = this;
        item.onFinish = function(result) {
            t.finish(item, result);
        };
        item.onError = function(info) {
            t.error(item, info);
        };
        this.items.set(id, item);
        item.start();
    };

    ImageWorkerServer.prototype.cancel = function(id) {
        var item = this.items.get(id);
        if (item) {
            item.cancel();
            this.items.delete(id);
        }
    }

    ImageWorkerServer.prototype.finish = function(item, {imageBitmap, hasAlphaChannel}) {
        postMessage({
            type: "data",
            id: item.id,
            info: {
                imageBitmap,
                hasAlphaChannel
            }
        }, [imageBitmap]);
        this.items.delete(item.id);
    };

    ImageWorkerServer.prototype.error = function(item, {type, message}) {
        postMessage({
            type: "error",
            id: item.id,
            info: {
                type,
                message
            }
        });
        this.items.delete(item.id);
    };

    ImageWorkerServer.isWPEBrowser = function() {
        return (navigator.userAgent.indexOf("WPE") !== -1);
    };

    function ImageWorkerServerItem(id, src) {

        this._onError = undefined;
        this._onFinish = undefined;
        this._id = id;
        this._src = src;
        this._xhr = undefined;
        this._mimeType = undefined;
        this._canceled = false;

    }

    Object.defineProperty(ImageWorkerServerItem.prototype, 'id', {
        get: function() {
            return this._id;
        }
    });

    Object.defineProperty(ImageWorkerServerItem.prototype, 'onFinish', {
        get: function() {
            return this._onFinish;
        },
        set: function(f) {
            this._onFinish = f;
        }
    });

    Object.defineProperty(ImageWorkerServerItem.prototype, 'onError', {
        get: function() {
            return this._onError;
        },
        set: function(f) {
            this._onError = f;
        }
    });

    ImageWorkerServerItem.prototype.start = function() {
        this._xhr = new XMLHttpRequest();
        this._xhr.open("GET", this._src, true);
        this._xhr.responseType = "blob";

        var t = this;
        this._xhr.onerror = function(oEvent) {
            t.error({type: "connection", message: "Connection error"});
        };

        this._xhr.onload = function(oEvent) {
            var blob = t._xhr.response;
            t._mimeType = blob.type;

            t._createImageBitmap(blob);
        };

        this._xhr.send();
    };

    ImageWorkerServerItem.prototype._createImageBitmap = function(blob) {
        var t = this;
        createImageBitmap(blob, {premultiplyAlpha: 'premultiply', colorSpaceConversion: 'none', imageOrientation: 'none'}).then(function(imageBitmap) {
            t.finish({
                imageBitmap,
                hasAlphaChannel: t._hasAlphaChannel()
            });
        }).catch(function(e) {
            t.error({type: "parse", message: "Error parsing image data"});
        });
    };

    ImageWorkerServerItem.prototype._hasAlphaChannel = function() {
        if (ImageWorkerServer.isWPEBrowser()) {
            // When using unaccelerated rendering image (https://github.com/WebPlatformForEmbedded/WPEWebKit/blob/wpe-20170728/Source/WebCore/html/ImageBitmap.cpp#L52),
            // everything including JPG images are in RGBA format. Upload is way faster when using an alpha channel.
            // @todo: after hardware acceleration is fixed and re-enabled, JPG should be uploaded in RGB to get the best possible performance and memory usage.
            return true;
        } else {
            return (this._mimeType.indexOf("image/png") !== -1);
        }
    };

    ImageWorkerServerItem.prototype.cancel = function() {
        if (this._canceled) return;
        if (this._xhr) {
            this._xhr.abort();
        }
        this._canceled = true;
    };

    ImageWorkerServerItem.prototype.error = function(type, message) {
        if (!this._canceled && this._onError) {
            this._onError({type, message});
        }
    };

    ImageWorkerServerItem.prototype.finish = function(info) {
        if (!this._canceled && this._onFinish) {
            this._onFinish(info);
        }
    };

    var worker = new ImageWorkerServer();
};


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/platforms/browser/WebPlatform.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/platforms/browser/WebPlatform.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebPlatform)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _ImageWorker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageWorker.mjs */ "./node_modules/@lightningjs/core/src/platforms/browser/ImageWorker.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Platform-specific functionality.
 */
class WebPlatform {

    init(stage) {
        this.stage = stage;
        this._looping = false;
        this._awaitingLoop = false;

        if (this.stage.getOption("useImageWorker")) {
            if (!window.createImageBitmap || !window.Worker) {
                console.warn("[Lightning] Can't use image worker because browser does not have createImageBitmap and Web Worker support");
            } else {
                this._imageWorker = new _ImageWorker_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]();
            }
        }
    }

    destroy() {
        if (this._imageWorker) {
            this._imageWorker.destroy();
        }
        this._removeKeyHandler();
        this._removeClickHandler();
        this._removeHoverHandler();
        this._removeScrollWheelHandler();
    }

    startLoop() {
        this._looping = true;
        if (!this._awaitingLoop) {
            this.loop();
        }
    }

    stopLoop() {
        this._looping = false;
    }

    loop() {
        let self = this;
        let lp = function() {
            self._awaitingLoop = false;
            if (self._looping) {
                self.stage.drawFrame();
                requestAnimationFrame(lp);
                self._awaitingLoop = true;
            }
        }
        requestAnimationFrame(lp);
    }

    uploadGlTexture(gl, textureSource, source, options) {
        if (source instanceof ImageData || source instanceof HTMLImageElement || source instanceof HTMLVideoElement || (window.ImageBitmap && source instanceof ImageBitmap)) {
            // Web-specific data types.
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
        } else if (source instanceof HTMLCanvasElement) {
            // Workaround for some browsers (e.g. Tizen) as they do not convert canvas data to texture correctly, sometimes causing artifacts.
            const ctx = source.getContext('2d');
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, ctx.getImageData(0, 0, source.width, source.height));
        } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, textureSource.w, textureSource.h, 0, options.format, options.type, source);
        }
    }

    loadSrcTexture({src, hasAlpha}, cb) {
        let cancelCb = undefined;
        let isPng = (src.indexOf(".png") >= 0) || src.substr(0, 21) == 'data:image/png;base64';
        if (this._imageWorker) {
            // WPE-specific image parser.
            const image = this._imageWorker.create(src);
            image.onError = function(err) {
                return cb("Image load error");
            };
            image.onLoad = function({imageBitmap, hasAlphaChannel}) {
                cb(null, {
                    source: imageBitmap,
                    renderInfo: {src: src},
                    hasAlpha: hasAlphaChannel,
                    premultiplyAlpha: true
                });
            };
            cancelCb = function() {
                image.cancel();
            }
        } else {
            let image = new Image();

            // On the PS4 platform setting the `crossOrigin` attribute on
            // images can cause CORS failures.
            if (!(src.substr(0,5) == "data:") && !_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isPS4) {
                // Base64.
                image.crossOrigin = "Anonymous";
            }
            image.onerror = function(err) {
                // Ignore error message when cancelled.
                if (image.src) {
                    return cb("Image load error");
                }
            };
            image.onload = function() {
                cb(null, {
                    source: image,
                    renderInfo: {src: src},
                    hasAlpha: isPng || hasAlpha
                });
            };
            image.src = src;

            cancelCb = function() {
                image.onerror = null;
                image.onload = null;
                image.removeAttribute('src');
            }
        }

        return cancelCb;
    }

    createWebGLContext(w, h) {
        let canvas = this.stage.getOption('canvas') || document.createElement('canvas');

        if (w && h) {
            canvas.width = w;
            canvas.height = h;
        }

        let opts = {
            alpha: true,
            antialias: false,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        };

        let gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);
        if (!gl) {
            throw new Error('This browser does not support webGL.');
        }

        return gl;
    }

    createCanvasContext(w, h) {
        let canvas = this.stage.getOption('canvas') || document.createElement('canvas');

        if (w && h) {
            canvas.width = w;
            canvas.height = h;
        }

        let c2d = canvas.getContext('2d');
        if (!c2d) {
            throw new Error('This browser does not support 2d canvas.');
        }

        return c2d;
    }

    getHrTime() {
        return window.performance ? window.performance.now() : (new Date()).getTime();
    }

    getDrawingCanvas() {
        // We can't reuse this canvas because textures may load async.
        return document.createElement('canvas');
    }

    getTextureOptionsForDrawingCanvas(canvas) {
        let options = {};
        options.source = canvas;
        return options;
    }

    nextFrame(changes) {
        /* WebGL blits automatically */
    }

    registerKeydownHandler(keyhandler) {
        this._keydownListener = (e) => {
            keyhandler(e);
        };
        window.addEventListener('keydown', this._keydownListener);
    }

    registerKeyupHandler(keyhandler) {
        this._keyupListener = (e) => {
            keyhandler(e);
        };
        window.addEventListener('keyup', this._keyupListener);
    }

    _removeKeyHandler() {
        if (this._keydownListener) {
            window.removeEventListener('keydown', this._keydownListener);
        }

        if (this._keyupListener) {
            window.removeEventListener('keyup', this._keyupListener);
        }
    }

    registerClickHandler(clickHandler) {
        this._clickListener = e => {
            clickHandler(e);
        };
        window.addEventListener('mousedown', this._clickListener);
    }

    _removeClickHandler() {
        if (this._clickListener) {
            window.removeEventListener('mousedown', this._clickListener);
        }
    }

    registerHoverHandler(hoverHandler) {
        this._hoverListener = e => {
            hoverHandler(e);
        };
        window.addEventListener('mousemove', this._hoverListener);
    }

    _removeHoverHandler() {
        if (this._hoverListener) {
            window.removeEventListener('mousemove', this._hoverListener);
        }
    }

    registerScrollWheelHandler(registerScrollWheelHandler) {
        this._scrollWheelListener = e => {
            registerScrollWheelHandler(e);
        }
        window.addEventListener('wheel', this._scrollWheelListener);
    }

    _removeScrollWheelHandler() {
        if (this._scrollWheelListener) {
            window.removeEventListener('wheel', this._scrollWheelListener);
        }
    }
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/Renderer.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/Renderer.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Renderer)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Renderer {

    constructor(stage) {
        this.stage = stage;
        this._defaultShader = undefined;
    }

    gc(aggressive) {
    }

    destroy() {
    }

    getDefaultShader(ctx = this.stage.ctx) {
        if (!this._defaultShader) {
            this._defaultShader = this._createDefaultShader(ctx);
        }
        return this._defaultShader;
    }

    _createDefaultShader(ctx) {
    }

    isValidShaderType(shaderType) {
        return (shaderType.prototype instanceof this._getShaderBaseType());
    }

    createShader(ctx, settings) {
        const shaderType = settings.type;
        // If shader type is not correct, use a different platform.
        if (!this.isValidShaderType(shaderType)) {
            const convertedShaderType = this._getShaderAlternative(shaderType);
            if (!convertedShaderType) {
                console.warn("[Lightning] Shader has no implementation for render target: " + shaderType.name);
                return this._createDefaultShader(ctx);
            }
            return new convertedShaderType(ctx);
        } else {
            const shader = new shaderType(ctx);
            _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
            return shader;
        }
    }

    _getShaderBaseType() {
    }

    _getShaderAlternative(shaderType) {
        return this.getDefaultShader();
    }

    copyRenderTexture(renderTexture, nativeTexture, options) {
        console.warn('[Lightning] copyRenderTexture not supported by renderer');
    }
}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadList.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadList.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dCoreQuadList)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class C2dCoreQuadList extends _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this.renderContexts = [];
        this.modes = [];
    }

    setRenderContext(index, v) {
        this.renderContexts[index] = v;
    }

    setSimpleTc(index, v) {
        if (v) {
            this.modes[index] |= 1;
        } else {
            this.modes[index] -= (this.modes[index] & 1);
        }
    }

    setWhite(index, v) {
        if (v) {
            this.modes[index] |= 2;
        } else {
            this.modes[index] -= (this.modes[index] & 2);
        }
    }

    getRenderContext(index) {
        return this.renderContexts[index];
    }

    getSimpleTc(index) {
        return (this.modes[index] & 1);
    }

    getWhite(index) {
        return (this.modes[index] & 2);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadOperation.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadOperation.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dCoreQuadOperation)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class C2dCoreQuadOperation extends _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    getRenderContext(index) {
        return this.quads.getRenderContext(this.index + index);
    }

    getSimpleTc(index) {
        return this.quads.getSimpleTc(this.index + index);
    }

    getWhite(index) {
        return this.quads.getWhite(this.index + index);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreRenderExecutor.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreRenderExecutor.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dCoreRenderExecutor)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class C2dCoreRenderExecutor extends _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    init() {
        this._mainRenderTexture = this.ctx.stage.getCanvas();
    }

    _renderQuadOperation(op) {
        let shader = op.shader;

        if (op.length || op.shader.addEmpty()) {
            const target = this._renderTexture || this._mainRenderTexture;
            shader.beforeDraw(op, target);
            shader.draw(op, target);
            shader.afterDraw(op, target);
        }
    }

    _clearRenderTexture() {
        const ctx = this._getContext();

        let clearColor = [0, 0, 0, 0];
        if (this._mainRenderTexture.ctx === ctx) {
            clearColor = this.ctx.stage.getClearColor();
        }

        const renderTexture = ctx.canvas;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (!clearColor[0] && !clearColor[1] && !clearColor[2] && !clearColor[3]) {
            ctx.clearRect(0, 0, renderTexture.width, renderTexture.height);
        } else {
            ctx.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaStringFromArray(clearColor);
            // Do not use fillRect because it produces artifacts.
            ctx.globalCompositeOperation = 'copy';
            ctx.beginPath();
            ctx.rect(0, 0, renderTexture.width, renderTexture.height);
            ctx.closePath();
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        }
    }
    
    _getContext() {
        if (this._renderTexture) {
            return this._renderTexture.ctx;
        } else {
            return this._mainRenderTexture.ctx;
        } 
    }

    _restoreContext() {
        const ctx = this._getContext();
        ctx.restore();
        ctx.save();
        ctx._scissor = null;
    }

    _setScissor(area) {
        const ctx = this._getContext();

        if (!C2dCoreRenderExecutor._equalScissorAreas(ctx.canvas, ctx._scissor, area)) {
            // Clipping is stored in the canvas context state.
            // We can't reset clipping alone so we need to restore the full context.
            this._restoreContext();

            let precision = this.ctx.stage.getRenderPrecision();
            if (area) {
                ctx.beginPath();
                ctx.rect(Math.round(area[0] * precision), Math.round(area[1] * precision), Math.round(area[2] * precision), Math.round(area[3] * precision));
                ctx.closePath();
                ctx.clip();
            }
            ctx._scissor = area;
        }
    }

    static _equalScissorAreas(canvas, area, current) {
        if (!area) {
            area = [0, 0, canvas.width, canvas.height]
        }
        if (!current) {
            current = [0, 0, canvas.width, canvas.height]
        }
        return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].equalValues(area, current)
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dRenderer.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dRenderer.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dRenderer)
/* harmony export */ });
/* harmony import */ var _C2dCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./C2dCoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadList.mjs");
/* harmony import */ var _C2dCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./C2dCoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadOperation.mjs");
/* harmony import */ var _C2dCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./C2dCoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreRenderExecutor.mjs");
/* harmony import */ var _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tree/core/CoreRenderState.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs");
/* harmony import */ var _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/* harmony import */ var _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./C2dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs");
/* harmony import */ var _Renderer_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Renderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/Renderer.mjs");
/* harmony import */ var _C2dTextureTintManager_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./C2dTextureTintManager.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dTextureTintManager.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










class C2dRenderer extends _Renderer_mjs__WEBPACK_IMPORTED_MODULE_6__["default"] {

    constructor(stage) {
        super(stage);

        this.tintManager = new _C2dTextureTintManager_mjs__WEBPACK_IMPORTED_MODULE_7__["default"](stage);

        this.setupC2d(this.stage.c2d.canvas);
    }

    destroy() {
        this.tintManager.destroy();
    }

    _createDefaultShader(ctx) {
        return new _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](ctx);
    }

    _getShaderBaseType() {
        return _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]
    }

    _getShaderAlternative(shaderType) {
        return shaderType.getC2d && shaderType.getC2d();
    }

    createCoreQuadList(ctx) {
        return new _C2dCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](ctx);
    }

    createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
        return new _C2dCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
    }

    createCoreRenderExecutor(ctx) {
        return new _C2dCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](ctx);
    }
    
    createCoreRenderState(ctx) {
        return new _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](ctx);
    }

    createRenderTexture(w, h, pw, ph) {
        const canvas = document.createElement('canvas');
        canvas.width = pw;
        canvas.height = ph;
        this.setupC2d(canvas);
        return canvas;
    }
    
    freeRenderTexture(nativeTexture) {
        this.tintManager.delete(nativeTexture);
    }

    gc(aggressive) {
        this.tintManager.gc(aggressive);
    }

    uploadTextureSource(textureSource, options) {
        // For canvas, we do not need to upload.
        if (options.source.buffer) {
            // Convert RGBA buffer to canvas.
            const canvas = document.createElement('canvas');
            canvas.width = options.w;
            canvas.height = options.h;

            const imageData = new ImageData(new Uint8ClampedArray(options.source.buffer), options.w, options.h);
            canvas.getContext('2d').putImageData(imageData, 0, 0);
            return canvas;
        }

        return options.source;
    }

    freeTextureSource(textureSource) {
        this.tintManager.delete(textureSource.nativeTexture);
    }

    addQuad(renderState, quads, index) {
        // Render context changes while traversing so we save it by ref.
        const elementCore = quads.quadElements[index];
        quads.setRenderContext(index, elementCore._renderContext);
        quads.setWhite(index, elementCore.isWhite());
        quads.setSimpleTc(index, elementCore.hasSimpleTexCoords());
    }

    isRenderTextureReusable(renderState, renderTextureInfo) {
        // @todo: check render coords/matrix, maybe move this to core?
        return false;
    }

    finishRenderState(renderState) {
    }

    setupC2d(canvas) {
        const ctx = canvas.getContext('2d');
        canvas.ctx = ctx;

        ctx._scissor = null;

        // Save base state so we can restore the defaults later.
        canvas.ctx.save();
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dShader)
/* harmony export */ });
/* harmony import */ var _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class C2dShader extends _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    beforeDraw(operation) {
    }

    draw(operation) {
    }

    afterDraw(operation) {
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dTextureTintManager.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dTextureTintManager.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dTextureTintManager)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class C2dTextureTintManager {

    constructor(stage) {
        this.stage = stage;
        this._usedMemory = 0;
        this._cachedNativeTextures = new Set();
    }

    destroy() {
        this.gc(true);
    }

    _addMemoryUsage(delta) {
        this._usedMemory += delta;

        this.stage.addMemoryUsage(delta);
    }

    delete(nativeTexture) {
        // Should be called when native texture is cleaned up.
        if (this._hasCache(nativeTexture)) {
            const cache = this._getCache(nativeTexture);
            const prevMemUsage = cache.memoryUsage;
            cache.clear();
            this._cachedNativeTextures.delete(nativeTexture);
            this._addMemoryUsage(cache.memoryUsage - prevMemUsage);
        }
    }

    getTintTexture(nativeTexture, color) {
        const frame = this.stage.frameCounter;

        this._cachedNativeTextures.add(nativeTexture);

        const cache = this._getCache(nativeTexture);

        const item = cache.get(color);
        item.lf = frame;

        if (item.tx) {
            if (nativeTexture.update > item.u) {
                // Native texture was updated in the mean time: renew.
                this._tintTexture(item.tx, nativeTexture, color)
            }

            return item.tx;
        } else {
            const before = cache.memoryUsage;

            // Find blanco tint texture.
            let target = cache.reuseTexture(frame);
            if (target) {
                target.ctx.clearRect(0, 0, target.width, target.height);
            } else {
                // Allocate new.
                target = document.createElement('canvas');
                target.width = nativeTexture.w;
                target.height = nativeTexture.h;
                target.ctx = target.getContext('2d');
            }

            this._tintTexture(target, nativeTexture, color);
            cache.set(color, target, frame);

            const after = cache.memoryUsage;

            if (after !== before) {
                this._addMemoryUsage(after - before);
            }

            return target;
        }
    }

    _tintTexture(target, source, color) {
        let col = color.toString(16);
        while (col.length < 6) {
            col = "0" + col;
        }
        target.ctx.fillStyle = '#' + col;
        target.ctx.globalCompositeOperation = 'copy';
        target.ctx.fillRect(0, 0, source.w, source.h);
        target.ctx.globalCompositeOperation = 'multiply';
        target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);

        // Alpha-mix the texture.
        target.ctx.globalCompositeOperation = 'destination-in';
        target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);
    }

    _hasCache(nativeTexture) {
        return !!nativeTexture._tintCache;
    }

    _getCache(nativeTexture) {
        if (!nativeTexture._tintCache) {
            nativeTexture._tintCache = new C2dTintCache(nativeTexture);
        }
        return nativeTexture._tintCache;
    }

    gc(aggressive = false) {
        const frame = this.stage.frameCounter;
        let delta = 0;
        this._cachedNativeTextures.forEach(texture => {
            const cache = this._getCache(texture);
            if (aggressive) {
                delta += cache.memoryUsage;
                cache.clear();
            } else {
                const before = cache.memoryUsage;
                cache.cleanup(frame);
                cache.releaseBlancoTextures();
                delta += (cache.memoryUsage - before);
            }
        });

        if (aggressive) {
            this._cachedNativeTextures.clear();
        }

        if (delta) {
            this._addMemoryUsage(delta);
        }
    }

}

class C2dTintCache {

    constructor(nativeTexture) {
        this._tx = nativeTexture;
        this._colors = new Map();
        this._blancoTextures = null;
        this._lastCleanupFrame = 0;
        this._memTextures = 0;
    }

    get memoryUsage() {
        return this._memTextures * this._tx.w * this._tx.h;
    }

    releaseBlancoTextures() {
        this._memTextures -= this._blancoTextures.length;
        this._blancoTextures = [];
    }

    clear() {
        // Dereference the textures.
        this._blancoTextures = null;
        this._colors.clear();
        this._memTextures = 0;
    }

    get(color) {
        let item = this._colors.get(color);
        if (!item) {
            item = {lf: -1, tx: undefined, u: -1};
            this._colors.set(color, item);
        }
        return item;
    }

    set(color, texture, frame) {
        const item = this.get(color);
        item.lf = frame;
        item.tx = texture;
        item.u = frame;
        this._memTextures++;
    }

    cleanup(frame) {
        // We only need to clean up once per frame.
        if (this._lastCleanupFrame !== frame) {

            // We limit blanco textures reuse to one frame only to prevent memory usage growth.
            this._blancoTextures = [];

            this._colors.forEach((item, color) => {
                // Clean up entries that were not used last frame.
                if (item.lf < frame - 1) {
                    if (item.tx) {
                        // Keep as reusable blanco texture.
                        this._blancoTextures.push(item.tx);
                    }
                    this._colors.delete(color);
                }
            });

            this._lastCleanupFrame = frame;
        }
    }

    reuseTexture(frame) {
        // Try to reuse textures, because creating them every frame is expensive.
        this.cleanup(frame);
        if (this._blancoTextures && this._blancoTextures.length) {
            this._memTextures--;
            return this._blancoTextures.pop();
        }
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BlurShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class BlurShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._kernelRadius = 1;
    }

    get kernelRadius() {
        return this._kernelRadius;
    }

    set kernelRadius(v) {
        this._kernelRadius = v;
        this.redraw();
    }

    useDefault() {
        return this._amount === 0;
    }

    _beforeDrawEl({target}) {
        target.ctx.filter = "blur(" + this._kernelRadius + "px)";
    }

    _afterDrawEl({target}) {
        target.ctx.filter = "none";
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DefaultShader)
/* harmony export */ });
/* harmony import */ var _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../C2dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class DefaultShader extends _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);
        this._rectangleTexture = ctx.stage.rectangleTexture.source.nativeTexture;
        this._tintManager = this.ctx.stage.renderer.tintManager;
    }

    draw(operation, target) {
        const ctx = target.ctx;
        let length = operation.length;
        for (let i = 0; i < length; i++) {
            const tx = operation.getTexture(i);
            const vc = operation.getElementCore(i);
            const rc = operation.getRenderContext(i);
            const white = operation.getWhite(i);
            const stc = operation.getSimpleTc(i);

            //@todo: try to optimize out per-draw transform setting. split translate, transform.
            const precision = this.ctx.stage.getRenderPrecision();
            ctx.setTransform(rc.ta * precision, rc.tc * precision, rc.tb * precision, rc.td * precision, rc.px * precision, rc.py * precision);

            const rect = (tx === this._rectangleTexture);
            const info = {operation, target, index: i, rect};

            if (rect) {
                // Check for gradient.
                if (white) {
                    ctx.fillStyle = 'white';
                } else {
                    this._setColorGradient(ctx, vc);
                }

                ctx.globalAlpha = rc.alpha;
                this._beforeDrawEl(info);
                ctx.fillRect(0, 0, vc.w, vc.h);
                this._afterDrawEl(info);
                ctx.globalAlpha = 1.0;
            } else {
                // @todo: set image smoothing based on the texture.

                // @todo: optimize by registering whether identity texcoords are used.
                ctx.globalAlpha = rc.alpha;
                this._beforeDrawEl(info);

                // @todo: test if rounding yields better performance.

                // Notice that simple texture coords can be turned on even though vc._ulx etc are not simple, because
                //  we are rendering a render-to-texture (texcoords were stashed). Same is true for 'white' color btw.
                const sourceX = stc ? 0 : (vc._ulx * tx.w);
                const sourceY = stc ? 0 : (vc._uly * tx.h);
                const sourceW = (stc ? 1 : (vc._brx - vc._ulx)) * tx.w;
                const sourceH = (stc ? 1 : (vc._bry - vc._uly)) * tx.h;

                let colorize = !white;
                if (colorize) {
                    // @todo: cache the tint texture for better performance.

                    // Draw to intermediate texture with background color/gradient.
                    // This prevents us from having to create a lot of render texture canvases.

                    // Notice that we don't support (non-rect) gradients, only color tinting for c2d. We'll just take the average color.
                    let color = vc._colorUl;
                    if (vc._colorUl !== vc._colorUr || vc._colorUr !== vc._colorBl || vc._colorBr !== vc._colorBl) {
                        color = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].mergeMultiColorsEqual([vc._colorUl, vc._colorUr, vc._colorBl, vc._colorBr]);
                    }

                    const alpha = ((color / 16777216) | 0) / 255.0;
                    ctx.globalAlpha *= alpha;

                    const rgb = color & 0x00FFFFFF;
                    const tintTexture = this._tintManager.getTintTexture(tx, rgb);

                    // Actually draw result.
                    ctx.fillStyle = 'white';
                    ctx.drawImage(tintTexture, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.drawImage(tx, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
                }
                this._afterDrawEl(info);
                ctx.globalAlpha = 1.0;
            }
        }
    }

    _setColorGradient(ctx, vc, w = vc.w, h = vc.h, transparency = true) {
        let color = vc._colorUl;
        let gradient;
        //@todo: quick single color check.
        //@todo: cache gradient/fill style (if possible, probably context-specific).

        if (vc._colorUl === vc._colorUr) {
            if (vc._colorBl === vc._colorBr) {
                if (vc._colorUl === vc.colorBl) {
                    // Single color.
                } else {
                    // Vertical gradient.
                    gradient = ctx.createLinearGradient(0, 0, 0, h);
                    if (transparency) {
                        gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorUl));
                        gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorBl));
                    } else {
                        gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorUl));
                        gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorBl));

                    }
                }
            } else {
                // Not supported gradient.
            }
        } else {
            if (vc._colorUl === vc._colorBl && vc._colorUr === vc._colorBr) {
                // Horizontal gradient.
                gradient = ctx.createLinearGradient(0, 0, w, 0);
                if (transparency) {
                    gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorUl));
                    gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorBr));
                } else {
                    gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorUl));
                    gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorBr));
                }
            }
        }

        if (gradient) {
            ctx.fillStyle = gradient;
        } else {
            ctx.fillStyle = transparency ? _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(color) : _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(color);
        }
    }

    _beforeDrawEl(info) {
    }

    _afterDrawEl(info) {
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/common/shaders/GrayscaleShader.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/common/shaders/GrayscaleShader.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C2dGrayscaleShader: () => (/* binding */ C2dGrayscaleShader),
/* harmony export */   WebGLGrayscaleShader: () => (/* binding */ WebGLGrayscaleShader)
/* harmony export */ });
/* harmony import */ var _c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../c2d/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/* harmony import */ var _webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class WebGLGrayscaleShader extends _webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(context) {
        super(context);
        this._amount = 1;
    }

    static getC2d() {
        return C2dGrayscaleShader;
    }


    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    useDefault() {
        return this._amount === 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
    }

}

WebGLGrayscaleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float grayness = 0.2 * color.r + 0.6 * color.g + 0.2 * color.b;
        gl_FragColor = vec4(amount * vec3(grayness, grayness, grayness) + (1.0 - amount) * color.rgb, color.a);
    }
`;

class C2dGrayscaleShader extends _c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._amount = 1;
    }

    static getWebGL() {
        return WebGLGrayscaleShader;
    }


    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    useDefault() {
        return this._amount === 0;
    }

    _beforeDrawEl({target}) {
        target.ctx.filter = "grayscale(" + this._amount + ")";
    }

    _afterDrawEl({target}) {
        target.ctx.filter = "none";
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/spark/SparkRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/spark/SparkRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SparkRenderer)
/* harmony export */ });
/* harmony import */ var _webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/WebGLRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs");
/* harmony import */ var _shaders_SparkShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/SparkShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/spark/shaders/SparkShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class SparkRenderer extends _webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);
    }

    _createDefaultShader(ctx) {
        return new _shaders_SparkShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](ctx);
    }

    createCoreRenderExecutor(ctx) {
        global.beginDrawing();
        let ret = super.createCoreRenderExecutor(ctx);
        global.endDrawing();
        return ret;
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/spark/shaders/SparkShader.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/spark/shaders/SparkShader.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SparkShader)
/* harmony export */ });
/* harmony import */ var _webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../webgl/WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class SparkShader extends _webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    enableAttribs() {
        // Enables the attribs in the shader program.
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
            gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            // Some shaders may ignore the color.
            gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
            gl.enableVertexAttribArray(this._attrib("aColor"));
        }
    }

    disableAttribs() {
        // Disables the attribs in the shader program.
        let gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aColor"));
        }
    }

    setupUniforms(operation) {
        this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
    }

    draw(operation) {
        let gl = this.gl;

        let length = operation.length;

        if (length) {
            let glTexture = operation.getTexture(0);
            let pos = 0;
            for (let i = 0; i < length; i++) {
                let tx = operation.getTexture(i);
                if (glTexture !== tx) {
                    if (glTexture.options && glTexture.options.imageRef) {
                        let elementPostion = (i > 0) ? (i - 1) : i;
                        const precision = this.ctx.stage.getOption('precision');
                        let vc = operation.getElementCore(elementPostion);
                        this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px*precision, vc._worldContext.py*precision, vc._colorUl, vc);
                    } else {
                        gl.bindTexture(gl.TEXTURE_2D, glTexture);
                        gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                    }
                    glTexture = tx;
                    pos = i;
                }
            }
            if (pos < length) {
                if (glTexture.options && glTexture.options.imageRef) {
                    const precision = this.ctx.stage.getOption('precision');
                    let vc = operation.getElementCore(pos);
                    this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px*precision, vc._worldContext.py*precision, vc._colorUl, vc);
                } else {
                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                    gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                }
            }
        }
    }

}

SparkShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

SparkShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadList.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadList.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLCoreQuadList)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class WebGLCoreQuadList extends _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        // Allocate a fairly big chunk of memory that should be enough to support ~100000 (default) quads.
        // We do not (want to) handle memory overflow.
        const byteSize = ctx.stage.getOption('bufferMemory');

        this.dataLength = 0;

        this.data = new ArrayBuffer(byteSize);
        this.floats = new Float32Array(this.data);
        this.uints = new Uint32Array(this.data);
    }

    getAttribsDataByteOffset(index) {
        // Where this quad can be found in the attribs buffer.
        return index * 80;
    }

    getQuadContents() {
        // Debug: log contents of quad buffer.
        let floats = this.floats;
        let uints = this.uints;
        let lines = [];
        for (let i = 1; i <= this.length; i++) {
            let str = 'entry ' + i + ': ';
            for (let j = 0; j < 4; j++) {
                let b = i * 20 + j * 4;
                str += floats[b] + ',' + floats[b+1] + ':' + floats[b+2] + ',' + floats[b+3] + '[' + uints[b+4].toString(16) + '] ';
            }
            lines.push(str);
        }

        return lines;
    }


}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadOperation.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadOperation.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLCoreQuadOperation)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class WebGLCoreQuadOperation extends _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
        super(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);

        this.extraAttribsDataByteOffset = 0;
    }

    getAttribsDataByteOffset(index) {
        // Where this quad can be found in the attribs buffer.
        return this.quads.getAttribsDataByteOffset(this.index + index);
    }

    /**
     * Returns the relative pixel coordinates in the shader owner to gl position coordinates in the render texture.
     * @param x
     * @param y
     * @return {number[]}
     */
    getNormalRenderTextureCoords(x, y) {
        let coords = this.shaderOwner.getRenderTextureCoords(x, y);
        coords[0] /= this.getRenderWidth();
        coords[1] /= this.getRenderHeight();
        coords[0] = coords[0] * 2 - 1;
        coords[1] = 1 - coords[1] * 2;
        return coords;
    }

    getProjection() {
        if (this.renderTextureInfo === null) {
            return this.ctx.renderExec._projection;
        } else {
            return this.renderTextureInfo.nativeTexture.projection;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreRenderExecutor.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreRenderExecutor.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLCoreRenderExecutor)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class WebGLCoreRenderExecutor extends _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx)

        this.gl = this.ctx.stage.gl;

        this.init();
    }

    init() {
        let gl = this.gl;

        // Create new sharable buffer for params.
        this._attribsBuffer = gl.createBuffer();

        let maxQuads = Math.floor(this.renderState.quads.data.byteLength / 80);

        // Init webgl arrays.
        let allIndices = new Uint16Array(maxQuads * 6);

        // fill the indices with the quads to draw.
        for (let i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
            allIndices[i] = j;
            allIndices[i + 1] = j + 1;
            allIndices[i + 2] = j + 2;
            allIndices[i + 3] = j;
            allIndices[i + 4] = j + 2;
            allIndices[i + 5] = j + 3;
        }

        // The quads buffer can be (re)used to draw a range of quads.
        this._quadsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, allIndices, gl.STATIC_DRAW);

        // The matrix that causes the [0,0 - W,H] box to map to [-1,-1 - 1,1] in the end results.
        this._projection = new Float32Array([2/this.ctx.stage.coordsWidth, -2/this.ctx.stage.coordsHeight]);

    }

    destroy() {
        super.destroy();
        this.gl.deleteBuffer(this._attribsBuffer);
        this.gl.deleteBuffer(this._quadsBuffer);
    }

    _reset() {
        super._reset();

        let gl = this.gl;
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        this._stopShaderProgram();
        this._setupBuffers();
    }

    _setupBuffers() {
        let gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
        let element = new Float32Array(this.renderState.quads.data, 0, this.renderState.quads.dataLength);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._attribsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, element, gl.DYNAMIC_DRAW);
    }

    _setupQuadOperation(quadOperation) {
        super._setupQuadOperation(quadOperation);
        this._useShaderProgram(quadOperation.shader, quadOperation);
    }

    _renderQuadOperation(op) {
        let shader = op.shader;

        if (op.length || op.shader.addEmpty()) {
            shader.beforeDraw(op);
            shader.draw(op);
            shader.afterDraw(op);
        }
    }

    /**
     * @param {WebGLShader} shader;
     * @param {CoreQuadOperation} operation;
     */
    _useShaderProgram(shader, operation) {
        if (!shader.hasSameProgram(this._currentShaderProgram)) {
            if (this._currentShaderProgram) {
                this._currentShaderProgram.stopProgram();
            }
            shader.useProgram();
            this._currentShaderProgram = shader;
        }
        shader.setupUniforms(operation);
    }

    _stopShaderProgram() {
        if (this._currentShaderProgram) {
            // The currently used shader program should be stopped gracefully.
            this._currentShaderProgram.stopProgram();
            this._currentShaderProgram = null;
        }
    }

    _bindRenderTexture(renderTexture) {
        super._bindRenderTexture(renderTexture);

        let gl = this.gl;
        if (!this._renderTexture) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0,0,this.ctx.stage.w,this.ctx.stage.h);
        } else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderTexture.framebuffer);
            gl.viewport(0,0,this._renderTexture.w, this._renderTexture.h);
        }
    }

    _clearRenderTexture() {
        super._clearRenderTexture();
        let gl = this.gl;
        if (!this._renderTexture) {
            let glClearColor = this.ctx.stage.getClearColor();
            if (glClearColor) {
                gl.clearColor(glClearColor[0] * glClearColor[3], glClearColor[1] * glClearColor[3], glClearColor[2] * glClearColor[3], glClearColor[3]);
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
        } else {
            // Clear texture.
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
    }

    _setScissor(area) {
        super._setScissor(area);

        if (this._scissor === area) {
            return;
        }
        this._scissor = area;

        let gl = this.gl;
        if (!area) {
            gl.disable(gl.SCISSOR_TEST);
        } else {
            gl.enable(gl.SCISSOR_TEST);
            let precision = this.ctx.stage.getRenderPrecision();
            let y = area[1];
            if (this._renderTexture === null) {
                // Flip.
                y = (this.ctx.stage.h / precision - (area[1] + area[3]));
            }
            gl.scissor(Math.round(area[0] * precision), Math.round(y * precision), Math.round(area[2] * precision), Math.round(area[3] * precision));
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLRenderer)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _WebGLCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGLCoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadList.mjs");
/* harmony import */ var _WebGLCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebGLCoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadOperation.mjs");
/* harmony import */ var _WebGLCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WebGLCoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreRenderExecutor.mjs");
/* harmony import */ var _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tree/core/CoreRenderState.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs");
/* harmony import */ var _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/* harmony import */ var _Renderer_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Renderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/Renderer.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











class WebGLRenderer extends _Renderer_mjs__WEBPACK_IMPORTED_MODULE_8__["default"] {

    constructor(stage) {
        super(stage);
        this.shaderPrograms = new Map();
    }

    destroy() {
        this.shaderPrograms.forEach(shaderProgram => shaderProgram.destroy());
    }

    _createDefaultShader(ctx) {
        return new _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](ctx);
    }

    _getShaderBaseType() {
        return _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]
    }

    _getShaderAlternative(shaderType) {
        return shaderType.getWebGL && shaderType.getWebGL();
    }

    createCoreQuadList(ctx) {
        return new _WebGLCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](ctx);
    }

    createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
        return new _WebGLCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
    }

    createCoreRenderExecutor(ctx) {
        return new _WebGLCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](ctx);
    }
    
    createCoreRenderState(ctx) {
        return new _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](ctx);
    }

    createRenderTexture(w, h, pw, ph) {
        const gl = this.stage.gl;
        const glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, glTexture);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pw, ph, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        glTexture.params = {};
        glTexture.params[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
        glTexture.params[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
        glTexture.params[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
        glTexture.params[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
        glTexture.options = {format: gl.RGBA, internalFormat: gl.RGBA, type: gl.UNSIGNED_BYTE};

        // We need a specific framebuffer for every render texture.
        glTexture.framebuffer = gl.createFramebuffer();
        glTexture.projection = new Float32Array([2/w, 2/h]);

        gl.bindFramebuffer(gl.FRAMEBUFFER, glTexture.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);

        return glTexture;
    }
    
    freeRenderTexture(glTexture) {
        let gl = this.stage.gl;
        gl.deleteFramebuffer(glTexture.framebuffer);
        gl.deleteTexture(glTexture);
    }

    uploadTextureSource(textureSource, options) {
        const gl = this.stage.gl;

        const source = options.source;

        const format = {
            premultiplyAlpha: true,
            hasAlpha: true
        };

        if (options && options.hasOwnProperty('premultiplyAlpha')) {
            format.premultiplyAlpha = options.premultiplyAlpha;
        }

        if (options && options.hasOwnProperty('flipBlueRed')) {
            format.flipBlueRed = options.flipBlueRed;
        }

        if (options && options.hasOwnProperty('hasAlpha')) {
            format.hasAlpha = options.hasAlpha;
        }

        if (!format.hasAlpha) {
            format.premultiplyAlpha = false;
        }

        format.texParams = options.texParams || {}
        format.texOptions = options.texOptions || {}

        let glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, glTexture);

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, format.premultiplyAlpha);

        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNode) {
            gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, !!format.flipBlueRed);
        }

        const texParams = format.texParams;
        if (!texParams[gl.TEXTURE_MAG_FILTER]) texParams[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
        if (!texParams[gl.TEXTURE_MIN_FILTER]) texParams[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
        if (!texParams[gl.TEXTURE_WRAP_S]) texParams[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
        if (!texParams[gl.TEXTURE_WRAP_T]) texParams[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;

        Object.keys(texParams).forEach(key => {
            const value = texParams[key];
            gl.texParameteri(gl.TEXTURE_2D, parseInt(key), value);
        });

        const texOptions = format.texOptions;
        texOptions.format = texOptions.format || (format.hasAlpha ? gl.RGBA : gl.RGB);
        texOptions.type = texOptions.type || gl.UNSIGNED_BYTE;
        texOptions.internalFormat = texOptions.internalFormat || texOptions.format;
        if (options && options.imageRef) {
            texOptions.imageRef = options.imageRef;
        }

        this.stage.platform.uploadGlTexture(gl, textureSource, source, texOptions);

        glTexture.params = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cloneObjShallow(texParams);
        glTexture.options = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cloneObjShallow(texOptions);

        return glTexture;
    }

    freeTextureSource(textureSource) {
        this.stage.gl.deleteTexture(textureSource.nativeTexture);
    }

    addQuad(renderState, quads, index) {
        let offset = (index * 20);
        const elementCore = quads.quadElements[index];

        let r = elementCore._renderContext;

        let floats = renderState.quads.floats;
        let uints = renderState.quads.uints;
        const mca = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].mergeColorAlpha;

        if (r.tb !== 0 || r.tc !== 0) {
            floats[offset++] = r.px;
            floats[offset++] = r.py;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUl, r.alpha);
            floats[offset++] = r.px + elementCore._w * r.ta;
            floats[offset++] = r.py + elementCore._w * r.tc;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUr, r.alpha);
            floats[offset++] = r.px + elementCore._w * r.ta + elementCore._h * r.tb;
            floats[offset++] = r.py + elementCore._w * r.tc + elementCore._h * r.td;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._bry;
            uints[offset++] = mca(elementCore._colorBr, r.alpha);
            floats[offset++] = r.px + elementCore._h * r.tb;
            floats[offset++] = r.py + elementCore._h * r.td;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._bry;
            uints[offset] = mca(elementCore._colorBl, r.alpha);
        } else {
            // Simple.
            let cx = r.px + elementCore._w * r.ta;
            let cy = r.py + elementCore._h * r.td;

            floats[offset++] = r.px;
            floats[offset++] = r.py;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUl, r.alpha);
            floats[offset++] = cx;
            floats[offset++] = r.py;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUr, r.alpha);
            floats[offset++] = cx;
            floats[offset++] = cy;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._bry;
            uints[offset++] = mca(elementCore._colorBr, r.alpha);
            floats[offset++] = r.px;
            floats[offset++] = cy;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._bry;
            uints[offset] = mca(elementCore._colorBl, r.alpha);
        }
    }

    isRenderTextureReusable(renderState, renderTextureInfo) {
        let offset = (renderState._renderTextureInfo.offset * 80) / 4;
        let floats = renderState.quads.floats;
        let uints = renderState.quads.uints;
        return ((floats[offset] === 0) &&
            (floats[offset + 1] === 0) &&
            (floats[offset + 2] === 0) &&
            (floats[offset + 3] === 0) &&
            (uints[offset + 4] === 0xFFFFFFFF) &&
            (floats[offset + 5] === renderTextureInfo.w) &&
            (floats[offset + 6] === 0) &&
            (floats[offset + 7] === 1) &&
            (floats[offset + 8] === 0) &&
            (uints[offset + 9] === 0xFFFFFFFF) &&
            (floats[offset + 10] === renderTextureInfo.w) &&
            (floats[offset + 11] === renderTextureInfo.h) &&
            (floats[offset + 12] === 1) &&
            (floats[offset + 13] === 1) &&
            (uints[offset + 14] === 0xFFFFFFFF) &&
            (floats[offset + 15] === 0) &&
            (floats[offset + 16] === renderTextureInfo.h) &&
            (floats[offset + 17] === 0) &&
            (floats[offset + 18] === 1) &&
            (uints[offset + 19] === 0xFFFFFFFF));
    }

    finishRenderState(renderState) {
        // Set extra shader attribute data.
        let offset = renderState.length * 80;
        for (let i = 0, n = renderState.quadOperations.length; i < n; i++) {
            renderState.quadOperations[i].extraAttribsDataByteOffset = offset;
            let extra = renderState.quadOperations[i].shader.getExtraAttribBytesPerVertex() * 4 * renderState.quadOperations[i].length;
            offset += extra;
            if (extra) {
                renderState.quadOperations[i].shader.setExtraAttribsInBuffer(renderState.quadOperations[i], renderState.quads);
            }
        }
        renderState.quads.dataLength = offset;
    }

    copyRenderTexture(renderTexture, nativeTexture, options) {
        const gl = this.stage.gl;
        gl.bindTexture(gl.TEXTURE_2D, nativeTexture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture.framebuffer);
        const precision = renderTexture.precision;
        gl.copyTexSubImage2D(
            gl.TEXTURE_2D,
            0,
            precision * (options.sx || 0),
            precision * (options.sy || 0),
            precision * (options.x || 0),
            precision * (options.y || 0),
            precision * (options.w || renderTexture.ow),
            precision * (options.h || renderTexture.oh));
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLShader)
/* harmony export */ });
/* harmony import */ var _WebGLShaderProgram_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLShaderProgram.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShaderProgram.mjs");
/* harmony import */ var _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tree/Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class WebGLShader extends _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);

        const stage = ctx.stage;

        this._program = stage.renderer.shaderPrograms.get(this.constructor);
        if (!this._program) {
            this._program = new _WebGLShaderProgram_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this.constructor.vertexShaderSource, this.constructor.fragmentShaderSource);

            // Let the vbo context perform garbage collection.
            stage.renderer.shaderPrograms.set(this.constructor, this._program);
        }

        this.gl = stage.gl;
    }

    get glProgram() {
        return this._program.glProgram;
    }

    _init() {
        if (!this._initialized) {
            this.initialize();
            this._initialized = true;
        }
    }

    initialize() {
        this._program.compile(this.gl);
    }

    get initialized() {
        return this._initialized;
    }

    _uniform(name) {
        return this._program.getUniformLocation(name);
    }

    _attrib(name) {
        return this._program.getAttribLocation(name);
    }

    _setUniform(name, value, glFunction) {
        this._program.setUniformValue(name, value, glFunction);
    }

    useProgram() {
        this._init();
        this.gl.useProgram(this.glProgram);
        this.beforeUsage();
        this.enableAttribs();
    }

    stopProgram() {
        this.afterUsage();
        this.disableAttribs();
    }

    hasSameProgram(other) {
        // For performance reasons, we first check for identical references.
        return (other && ((other === this) || (other._program === this._program)));
    }

    beforeUsage() {
        // Override to set settings other than the default settings (blend mode etc).
    }

    afterUsage() {
        // All settings changed in beforeUsage should be reset here.
    }

    enableAttribs() {

    }

    disableAttribs() {

    }

    getExtraAttribBytesPerVertex() {
        return 0;
    }

    getVertexAttribPointerOffset(operation) {
        return operation.extraAttribsDataByteOffset - operation.index * 4 * this.getExtraAttribBytesPerVertex();
    }

    setExtraAttribsInBuffer(operation) {
        // Set extra attrib data in in operation.quads.data/floats/uints, starting from
        // operation.extraAttribsBufferByteOffset.
    }

    setupUniforms(operation) {
        // Set all shader-specific uniforms.
        // Notice that all uniforms should be set, even if they have not been changed within this shader instance.
        // The uniforms are shared by all shaders that have the same type (and shader program).
    }

    _getProjection(operation) {
        return operation.getProjection();
    }

    getFlipY(operation) {
        return this._getProjection(operation)[1] < 0;
    }

    beforeDraw(operation) {
    }

    draw(operation) {
    }

    afterDraw(operation) {
    }

    cleanup() {
        this._initialized = false;
        // Program takes little resources, so it is only destroyed when the full stage is destroyed.
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShaderProgram.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShaderProgram.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLShaderProgram)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Base functionality for shader setup/destroy.
 */
class WebGLShaderProgram {

    constructor(vertexShaderSource, fragmentShaderSource) {

        this.vertexShaderSource = vertexShaderSource;
        this.fragmentShaderSource = fragmentShaderSource;

        this._program = null;

        this._uniformLocations = new Map();
        this._attributeLocations = new Map();

        this._currentUniformValues = {};
    }

    compile(gl) {
        if (this._program) return;

        this.gl = gl;

        this._program = gl.createProgram();

        let glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexShaderSource);
        let glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentShaderSource);

        gl.attachShader(this._program, glVertShader);
        gl.attachShader(this._program, glFragShader);
        gl.linkProgram(this._program);

        // if linking fails, then log and cleanup
        if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
            console.error('[Lightning] Error: Could not initialize shader.');
            console.error('[Lightning] gl.VALIDATE_STATUS', gl.getProgramParameter(this._program, gl.VALIDATE_STATUS));
            console.error('[Lightning] gl.getError()', gl.getError());

            // if there is a program info log, log it
            if (gl.getProgramInfoLog(this._program) !== '') {
                console.warn('[Lightning] Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(this._program));
            }

            gl.deleteProgram(this._program);
            this._program = null;
        }

        // clean up some shaders
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);
    }

    _glCompile(type, src) {
        let shader = this.gl.createShader(type);

        this.gl.shaderSource(shader, src);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('[Lightning]', this.constructor.name, 'Type: ' + (type === this.gl.VERTEX_SHADER ? 'vertex shader' : 'fragment shader') );
            console.error('[Lightning]', this.gl.getShaderInfoLog(shader));
            let idx = 0;
            console.error('[Lightning]', "========== source ==========\n" + src.split("\n").map(line => "" + (++idx) + ": " + line).join("\n"));
            return null;
        }

        return shader;
    }

    getUniformLocation(name) {
        let location = this._uniformLocations.get(name);
        if (location === undefined) {
            location = this.gl.getUniformLocation(this._program, name);
            this._uniformLocations.set(name, location);
        }

        return location;
    }

    getAttribLocation(name) {
        let location = this._attributeLocations.get(name);
        if (location === undefined) {
            location = this.gl.getAttribLocation(this._program, name);
            this._attributeLocations.set(name, location);
        }

        return location;
    }

    destroy() {
        if (this._program) {
            this.gl.deleteProgram(this._program);
            this._program = null;
        }
    }

    get glProgram() {
        return this._program;
    }

    get compiled() {
        return !!this._program;
    }

    _valueEquals(v1, v2) {
        // Uniform value is either a typed array or a numeric value.
        if (v1.length && v2.length) {
            for (let i = 0, n = v1.length; i < n; i++) {
                if (v1[i] !== v2[i]) return false;
            }
            return true;
        } else {
            return (v1 === v2);
        }
    }

    _valueClone(v) {
        if (v.length) {
            return v.slice(0);
        } else {
            return v;
        }
    }

    setUniformValue(name, value, glFunction) {
        let v = this._currentUniformValues[name];
        if (v === undefined || !this._valueEquals(v, value)) {
            let clonedValue = this._valueClone(value);
            this._currentUniformValues[name] = clonedValue;

            let loc = this.getUniformLocation(name);
            if (loc) {
                let isMatrix = (glFunction === this.gl.uniformMatrix2fv || glFunction === this.gl.uniformMatrix3fv || glFunction === this.gl.uniformMatrix4fv);
                if (isMatrix) {
                    glFunction.call(this.gl, loc, false, clonedValue);
                } else {
                    glFunction.call(this.gl, loc, clonedValue);
                }
            }
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BoxBlurShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * 4x4 box blur shader which works in conjunction with a 50% rescale.
 */
class BoxBlurShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const dx = 1.0 / operation.getTextureWidth(0);
        const dy = 1.0 / operation.getTextureHeight(0);
        this._setUniform("stepTextureCoord", new Float32Array([dx, dy]), this.gl.uniform2fv);
    }

}

BoxBlurShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 stepTextureCoord;
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec4 vColor;
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoordUl = aTextureCoord - stepTextureCoord;
        vTextureCoordBr = aTextureCoord + stepTextureCoord;
        vTextureCoordUr = vec2(vTextureCoordBr.x, vTextureCoordUl.y);
        vTextureCoordBl = vec2(vTextureCoordUl.x, vTextureCoordBr.y);
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

BoxBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = 0.25 * (texture2D(uSampler, vTextureCoordUl) + texture2D(uSampler, vTextureCoordUr) + texture2D(uSampler, vTextureCoordBl) + texture2D(uSampler, vTextureCoordBr));
        gl_FragColor = color * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/CircularPushShader.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/CircularPushShader.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CircularPushShader)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class CircularPushShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);

        this._inputValue = 0;

        this._maxDerivative = 0.01;

        this._normalizedValue = 0;

        // The offset between buckets. A value between 0 and 1.
        this._offset = 0;

        this._amount = 0.1;

        this._aspectRatio = 1;

        this._offsetX = 0;

        this._offsetY = 0;

        this.buckets = 100;
    }

    get aspectRatio() {
        return this._aspectRatio;
    }

    set aspectRatio(v) {
        this._aspectRatio = v;
        this.redraw();
    }

    get offsetX() {
        return this._offsetX;
    }

    set offsetX(v) {
        this._offsetX = v;
        this.redraw();
    }

    get offsetY() {
        return this._offsetY;
    }

    set offsetY(v) {
        this._offsetY = v;
        this.redraw();
    }

    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    set inputValue(v) {
        this._inputValue = v;
    }

    get inputValue() {
        return this._inputValue;
    }

    set maxDerivative(v) {
        this._maxDerivative = v;
    }

    get maxDerivative() {
        return this._maxDerivative;
    }

    set buckets(v) {
        if (v > 100) {
            console.warn("[Lightning] CircularPushShader: supports max 100 buckets");
            v = 100;
        }

        // This should be set before starting.
        this._buckets = v;

        // Init values array in the correct length.
        this._values = new Uint8Array(this._getValues(v));

        this.redraw();
    }

    get buckets() {
        return this._buckets;
    }

    _getValues(n) {
        const v = [];
        for (let i = 0; i < n; i++) {
            v.push(this._inputValue);
        }
        return v;
    }

    /**
     * Progresses the shader with the specified (fractional) number of buckets.
     * @param {number} o;
     *   A number from 0 to 1 (1 = all buckets).
     */
    progress(o) {
        this._offset += o * this._buckets;
        const full = Math.floor(this._offset);
        this._offset -= full;
        this._shiftBuckets(full);
        this.redraw();
    }

    _shiftBuckets(n) {
        for (let i = this._buckets - 1; i >= 0; i--) {
            const targetIndex = i - n;
            if (targetIndex < 0) {
                this._normalizedValue = Math.min(this._normalizedValue + this._maxDerivative, Math.max(this._normalizedValue - this._maxDerivative, this._inputValue));
                this._values[i] = 255 * this._normalizedValue;
            } else {
                this._values[i] = this._values[targetIndex];
            }
        }
    }

    set offset(v) {
        this._offset = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("aspectRatio", this._aspectRatio, this.gl.uniform1f);
        this._setUniform("offsetX", this._offsetX, this.gl.uniform1f);
        this._setUniform("offsetY", this._offsetY, this.gl.uniform1f);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
        this._setUniform("offset", this._offset, this.gl.uniform1f);
        this._setUniform("buckets", this._buckets, this.gl.uniform1f);
        this._setUniform("uValueSampler", 1, this.gl.uniform1i);
    }

    useDefault() {
        return this._amount === 0;
    }

    beforeDraw(operation) {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE1);
        if (!this._valuesTexture) {
            this._valuesTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNode) {
                gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, false);
            }
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
        }

        // Upload new values.
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this._buckets, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this._values);
        gl.activeTexture(gl.TEXTURE0);
    }

    cleanup() {
        if (this._valuesTexture) {
            this.gl.deleteTexture(this._valuesTexture);
        }
    }


}

CircularPushShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    uniform float offsetX;
    uniform float offsetY;
    uniform float aspectRatio;
    varying vec2 vTextureCoord;
    varying vec2 vPos;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vPos = vTextureCoord * 2.0 - 1.0;
        vPos.y = vPos.y * aspectRatio;
        vPos.y = vPos.y + offsetY;
        vPos.x = vPos.x + offsetX;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

CircularPushShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vPos;
    uniform float amount;
    uniform float offset;
    uniform float values[100];
    uniform float buckets;
    uniform sampler2D uSampler;
    uniform sampler2D uValueSampler;
    void main(void){
        float l = length(vPos);
        float m = (l * buckets * 0.678 - offset) / buckets;
        float f = texture2D(uValueSampler, vec2(m, 0.0)).a * amount;
        vec2 unit = vPos / l;
        gl_FragColor = texture2D(uSampler, vTextureCoord - f * unit) * vColor;
    }
`;




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DefaultShader)
/* harmony export */ });
/* harmony import */ var _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class DefaultShader extends _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    enableAttribs() {
        // Enables the attribs in the shader program.
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
            gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            // Some shaders may ignore the color.
            gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
            gl.enableVertexAttribArray(this._attrib("aColor"));
        }
    }

    disableAttribs() {
        // Disables the attribs in the shader program.
        let gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aColor"));
        }
    }

    setupUniforms(operation) {
        this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
    }

    draw(operation) {
        let gl = this.gl;

        let length = operation.length;

        if (length) {
            let glTexture = operation.getTexture(0);
            let pos = 0;
            for (let i = 0; i < length; i++) {
                let tx = operation.getTexture(i);
                if (glTexture !== tx) {
                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                    gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                    glTexture = tx;
                    pos = i;
                }
            }
            if (pos < length) {
                gl.bindTexture(gl.TEXTURE_2D, glTexture);
                gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
            }
        }
    }

}

DefaultShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

DefaultShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DitheringShader.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DitheringShader.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DitheringShader)
/* harmony export */ });
/* harmony import */ var _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../textures/NoiseTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs");
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * This shader can be used to fix a problem that is known as 'gradient banding'.
 */
class DitheringShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);

        this._noiseTexture = new _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](ctx.stage);

        this._graining = 1/256;

        this._random = false;
    }

    set graining(v) {
        this._graining = v;
        this.redraw();
    }

    set random(v) {
        this._random = v;
        this.redraw();
    }

    setExtraAttribsInBuffer(operation) {
        // Make sure that the noise texture is uploaded to the GPU.
        this._noiseTexture.load();

        let offset = operation.extraAttribsDataByteOffset / 4;
        let floats = operation.quads.floats;

        let length = operation.length;

        for (let i = 0; i < length; i++) {

            // Calculate noise texture coordinates so that it spans the full element.
            let brx = operation.getElementWidth(i) / this._noiseTexture.getRenderWidth();
            let bry = operation.getElementHeight(i) / this._noiseTexture.getRenderHeight();

            let ulx = 0;
            let uly = 0;
            if (this._random) {
                ulx = Math.random();
                uly = Math.random();

                brx += ulx;
                bry += uly;

                if (Math.random() < 0.5) {
                    // Flip for more randomness.
                    const t = ulx;
                    ulx = brx;
                    brx = t;
                }

                if (Math.random() < 0.5) {
                    // Flip for more randomness.
                    const t = uly;
                    uly = bry;
                    bry = t;
                }
            }

            // Specify all corner points.
            floats[offset] = ulx;
            floats[offset + 1] = uly;

            floats[offset + 2] = brx;
            floats[offset + 3] = uly;

            floats[offset + 4] = brx;
            floats[offset + 5] = bry;

            floats[offset + 6] = ulx;
            floats[offset + 7] = bry;

            offset += 8;
        }
    }

    beforeDraw(operation) {
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aNoiseTextureCoord"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));

        let glTexture = this._noiseTexture.source.nativeTexture;
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.activeTexture(gl.TEXTURE0);
    }

    getExtraAttribBytesPerVertex() {
        return 8;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("uNoiseSampler", 1, this.gl.uniform1i);
        this._setUniform("graining", 2 * this._graining, this.gl.uniform1f);
    }

    enableAttribs() {
        super.enableAttribs();
        let gl = this.gl;
        gl.enableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
    }

    disableAttribs() {
        super.disableAttribs();
        let gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
    }

    useDefault() {
        return this._graining === 0;
    }

    afterDraw(operation) {
        if (this._random) {
            this.redraw();
        }
    }

}

DitheringShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec2 aNoiseTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vNoiseTextureCoord = aNoiseTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

DitheringShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uNoiseSampler;
    uniform float graining;
    void main(void){
        vec4 noise = texture2D(uNoiseSampler, vNoiseTextureCoord);
        vec4 color = texture2D(uSampler, vTextureCoord);
        gl_FragColor = (color * vColor) + graining * (noise.r - 0.5);
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/FadeOutShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/FadeOutShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FadeOutShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class FadeOutShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._fade = [0, 0, 0, 0];
    }

    set top(num) {
        this._fade[0] = num;
        this.redraw();
    }

    get top() {
        return this._fade[0];
    }

    set right(num) {
        this._fade[1] = num;
        this.redraw();
    }

    get right() {
        return this._fade[1];
    }

    set bottom(num) {
        this._fade[2] = num;
        this.redraw();
    }

    get bottom() {
        return this._fade[2];
    }

    set left(num) {
        this._fade[3] = num;
        this.redraw();
    }

    get left() {
        return this._fade[3];
    }

    set fade(v) {
        if(Array.isArray(v)) {
            if(v.length === 2) {
                this._fade = [v[0], v[1], v[0], v[1]];
            }
            else if(v.length === 3) {
                this._fade = [v[0], v[1], v[2], this._fade[3]];
            }
            else if (v.length === 4) {
                this._fade = v;
            }
            else {
                this._fade = [v[0], v[0], v[0], v[0]];
            }
        }
        else {
            this._fade = [v, v, v, v];
        }
        this.redraw();
    }

    get fade() {
        return this._fade;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;

        const renderPrecision = this.ctx.stage.getRenderPrecision();
        const fade = this._fade.map((f) => f * renderPrecision);
        this._setUniform('fade',  new Float32Array(fade), this.gl.uniform4fv);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
}

FadeOutShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 fade;
    
    void main() {
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 point = vTextureCoord.xy * resolution.xy;
        
        vec2 pos1;
        vec2 pos2;
        vec2 d;
        float c;
        float t = 0.0;
             
        if(fade[0] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x, point.y + fade[0]);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[1] > 0.0) {
            vec2 pos1 = vec2(point.x - resolution.x - fade[1], vTextureCoord.y);
            vec2 pos2 = vec2(point.x - resolution.x, vTextureCoord.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[2] > 0.0) {
            vec2 pos1 = vec2(vTextureCoord.x, point.y - resolution.y - fade[2]);
            vec2 pos2 = vec2(vTextureCoord.x, point.y - resolution.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[3] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x + fade[3], point.y);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        gl_FragColor = color;
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/HoleShader.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/HoleShader.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HoleShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class HoleShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._x = 0;
        this._y = 0;
        this._w = 0;
        this._h = 0;
        this._radius = 0;
    }

    get x() {
        return this._x;
    }

    set x(v) {
        this._x = v;
        this.redraw();
    }

    get y() {
        return this._y;
    }

    set y(v) {
        this._y = v;
        this.redraw();
    }

    get w() {
        return this._w;
    }

    set w(v) {
        this._w = v;
        this.redraw();
    }

    get h() {
        return this._h;
    }

    set h(v) {
        this._h = v;
        this.redraw();
    }

    get radius() {
        return this._radius;
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        const owner = operation.shaderOwner;
        const renderPrecision = this.ctx.stage.getRenderPrecision()

        this._setUniform("x", this._x * renderPrecision, this.gl.uniform1f);
        this._setUniform("y", this._y * renderPrecision, this.gl.uniform1f);
        this._setUniform("w", this._w * renderPrecision, this.gl.uniform1f);
        this._setUniform("h", this._h * renderPrecision, this.gl.uniform1f);
        this._setUniform('radius',  (this._radius + .5) * renderPrecision, this.gl.uniform1f);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }

    useDefault() {
        return (this._x === 0 && this._y === 0 && this._w === 0 && this._h === 0)
    }
}

HoleShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;

HoleShader.fragmentShaderSource = `
   #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float x;
    uniform float y;
    uniform float w;
    uniform float h;
    uniform vec2 resolution;
    uniform float radius;

    float roundBox(vec2 p, vec2 b, float r) {
        float d = length(max(abs(p)-b+r, 0.1))-r;
        return smoothstep(1.0, 0.0, d);
    }

    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
        vec2 size = vec2(w, h) / 2.0;
        float b = roundBox(pos, size, radius);
        gl_FragColor = mix(color, vec4(0.0), b);
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/InversionShader.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/InversionShader.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ InversionShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class InversionShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._amount = 1;
    }

    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    useDefault() {
        return this._amount === 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
    }

}

InversionShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        color.rgb = color.rgb * (1.0 - amount) + amount * (1.0 * color.a - color.rgb); 
        gl_FragColor = color * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/Light3dShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/Light3dShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Light3dShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Light3dShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this._strength = 0.5;
        this._ambient = 0.5;
        this._fudge = 0.4;

        this._rx = 0;
        this._ry = 0;

        this._z = 0;
        this._pivotX = NaN;
        this._pivotY = NaN;
        this._pivotZ = 0;

        this._lightY = 0;
        this._lightZ = 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        let vr = operation.shaderOwner;
        let element = vr.element;

        let pivotX = isNaN(this._pivotX) ? element.pivotX * vr.w : this._pivotX;
        let pivotY = isNaN(this._pivotY) ? element.pivotY * vr.h : this._pivotY;
        let coords = vr.getRenderTextureCoords(pivotX, pivotY);

        // Counter normal rotation.

        let rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);

        let gl = this.gl;
        this._setUniform("pivot", new Float32Array([coords[0], coords[1], this._pivotZ]), gl.uniform3fv);
        this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);

        this._setUniform("z", this._z, gl.uniform1f);
        this._setUniform("lightY", this.lightY, gl.uniform1f);
        this._setUniform("lightZ", this.lightZ, gl.uniform1f);
        this._setUniform("strength", this._strength, gl.uniform1f);
        this._setUniform("ambient", this._ambient, gl.uniform1f);
        this._setUniform("fudge", this._fudge, gl.uniform1f);
    }

    set strength(v) {
        this._strength = v;
        this.redraw();
    }

    get strength() {
        return this._strength;
    }

    set ambient(v) {
        this._ambient = v;
        this.redraw();
    }

    get ambient() {
        return this._ambient;
    }

    set fudge(v) {
        this._fudge = v;
        this.redraw();
    }

    get fudge() {
        return this._fudge;
    }

    get rx() {
        return this._rx;
    }

    set rx(v) {
        this._rx = v;
        this.redraw();
    }

    get ry() {
        return this._ry;
    }

    set ry(v) {
        this._ry = v;
        this.redraw();
    }

    get z() {
        return this._z;
    }

    set z(v) {
        this._z = v;
        this.redraw();
    }

    get pivotX() {
        return this._pivotX;
    }

    set pivotX(v) {
        this._pivotX = v + 1;
        this.redraw();
    }

    get pivotY() {
        return this._pivotY;
    }

    set pivotY(v) {
        this._pivotY = v + 1;
        this.redraw();
    }

    get lightY() {
        return this._lightY;
    }

    set lightY(v) {
        this._lightY = v;
        this.redraw();
    }

    get pivotZ() {
        return this._pivotZ;
    }

    set pivotZ(v) {
        this._pivotZ = v;
        this.redraw();
    }

    get lightZ() {
        return this._lightZ;
    }

    set lightZ(v) {
        this._lightZ = v;
        this.redraw();
    }

    useDefault() {
        return (this._rx === 0 && this._ry === 0 && this._z === 0 && this._strength === 0 && this._ambient === 1);
    }

}

Light3dShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float fudge;
    uniform float strength;
    uniform float ambient;
    uniform float z;
    uniform float lightY;
    uniform float lightZ;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Set depth perspective
        float perspective = 1.0 + fudge * pos.z;

        pos.z += lightZ * projection.x;

        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, perspective);

        // Correct light source position.
        pos.y += lightY * abs(projection.y);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

Light3dShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec3 pos;
    uniform sampler2D uSampler;
    uniform float ambient;
    uniform float strength;
    void main(void){
        vec4 rgba = texture2D(uSampler, vTextureCoord);
        float d = length(pos);
        float n = 1.0 / max(0.1, d);
        rgba.rgb = rgba.rgb * (strength * n + ambient);
        gl_FragColor = rgba * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LinearBlurShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class LinearBlurShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);

        this._direction = new Float32Array([1, 0]);
        this._kernelRadius = 1;
    }

    get x() {
        return this._direction[0];
    }

    set x(v) {
        this._direction[0] = v;
        this.redraw();
    }

    get y() {
        return this._direction[1];
    }

    set y(v) {
        this._direction[1] = v;
        this.redraw();
    }

    get kernelRadius() {
        return this._kernelRadius;
    }

    set kernelRadius(v) {
        this._kernelRadius = v;
        this.redraw();
    }


    useDefault() {
        return (this._kernelRadius === 0);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("direction", this._direction, this.gl.uniform2fv);
        this._setUniform("kernelRadius", this._kernelRadius, this.gl.uniform1i);

        const w = operation.getRenderWidth();
        const h = operation.getRenderHeight();
        this._setUniform("resolution", new Float32Array([w, h]), this.gl.uniform2fv);
    }
}

LinearBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 resolution;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 direction;
    uniform int kernelRadius;
    
    vec4 blur1(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3333333333333333) * direction;
        color += texture2D(image, uv) * 0.29411764705882354;
        color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;
        color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;
        return color; 
    }
    
    vec4 blur2(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3846153846) * direction;
        vec2 off2 = vec2(3.2307692308) * direction;
        color += texture2D(image, uv) * 0.2270270270;
        color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;
        color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;
        return color;
    }
    
    vec4 blur3(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.411764705882353) * direction;
        vec2 off2 = vec2(3.2941176470588234) * direction;
        vec2 off3 = vec2(5.176470588235294) * direction;
        color += texture2D(image, uv) * 0.1964825501511404;
        color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;
        color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;
        return color;
    }    

    void main(void){
        if (kernelRadius == 1) {
            gl_FragColor = blur1(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else if (kernelRadius == 2) {
            gl_FragColor = blur2(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else {
            gl_FragColor = blur3(uSampler, vTextureCoord, resolution, direction) * vColor;
        }
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/MagnifierShader.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/MagnifierShader.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MagnifierShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class MagnifierShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
	constructor(context) {
	  super(context);
	  this._x = 0;
	  this._y = 0;
	  this._w = 0;
	  this._h = 0;
	  this._radius = 0;
	  this._magnification = 0.6;
	}
  
	get x() {
	  return this._x;
	}
  
	set x(v) {
	  this._x = v;
	  this.redraw();
	}
  
	get y() {
	  return this._y;
	}
  
	set y(v) {
	  this._y = v;
	  this.redraw();
	}
  
	get w() {
	  return this._w;
	}
  
	set w(v) {
	  this._w = v;
	  this.redraw();
	}
  
	get h() {
	  return this._h;
	}
  
	set h(v) {
	  this._h = v;
	  this.redraw();
	}
  
	get magnification() {
	  return this._magnification;
	}
  
	set magnification(v) {
	  this._magnification = v;
	  this.redraw();
	}
  
	get radius() {
	  return this._radius;
	}
  
	set radius(v) {
	  this._radius = v;
	  this.redraw();
	}
  
	setupUniforms(operation) {
	  super.setupUniforms(operation);
  
	  const owner = operation.shaderOwner;
	  const renderPrecision = this.ctx.stage.getRenderPrecision();
	  this._setUniform('x', this._x * renderPrecision, this.gl.uniform1f);
	  this._setUniform('y', this._y * renderPrecision, this.gl.uniform1f);
	  this._setUniform('w', this._w * renderPrecision, this.gl.uniform1f);
	  this._setUniform('h', this._h * renderPrecision, this.gl.uniform1f);
	  this._setUniform('magnification', this._magnification, this.gl.uniform1f);
	  this._setUniform(
		'radius',
		(this._radius + 0.5) * renderPrecision,
		this.gl.uniform1f
	  );
	  this._setUniform(
		'resolution',
		new Float32Array([
		  owner._w * renderPrecision,
		  owner._h * renderPrecision
		]),
		this.gl.uniform2fv
	  );
	}
 
	useDefault() {
	  return this._w === 0 && this._h === 0;
	}
  }
  
  MagnifierShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;
  
  MagnifierShader.fragmentShaderSource = `
	  #ifdef GL_ES
		# ifdef GL_FRAGMENT_PRECISION_HIGH
		precision highp float;
		# else
		precision lowp float;
		# endif
	  #endif

	  varying vec2 vTextureCoord;
	  varying vec4 vColor;
	  uniform sampler2D uSampler;
	  uniform float x;
	  uniform float y;
	  uniform float w;
	  uniform float h;
	  uniform vec2 resolution;
	  uniform float radius;
	  uniform float magnification;
  
	  float roundBox(vec2 p, vec2 b, float r) {
		  float d = length(max(abs(p)-b+r, 0.1))-r;
		  return smoothstep(1.0, 0.0, d);
	  }

	  float inside(vec2 v) {
		vec2 s = step(vec2(0.0, 0.0), v) - step(vec2(1.0, 1.0), v);
		return s.x * s.y;   
      }
  
	  void main(void) {
		vec4 color = texture2D(uSampler, vTextureCoord);
		vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
		vec2 size = vec2(w, h) / 2.0;
		float b = roundBox(pos, size, radius);
		vec2 pos2 = (vTextureCoord.xy * magnification * resolution + vec2(x, y) * magnification) / resolution;
		gl_FragColor = mix(color, texture2D(uSampler, pos2) * inside(pos2), b) * vColor;
	  }
  `;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/OutlineShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/OutlineShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OutlineShader)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class OutlineShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);
        this._width = 5;
        this._col = 0xFFFFFFFF;
        this._color = [1,1,1,1];
    }

    set width(v) {
        this._width = v;
        this.redraw();
    }

    get color() {
        return this._col;
    }

    set color(v) {
        if (this._col !== v) {
            const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaComponentsNormalized(v);
            col[0] = col[0] * col[3];
            col[1] = col[1] * col[3];
            col[2] = col[2] * col[3];

            this._color = col;

            this.redraw();

            this._col = v;
        }
    }

    useDefault() {
        return (this._width === 0 || this._col[3] === 0);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        let gl = this.gl;
        this._setUniform("color", new Float32Array(this._color), gl.uniform4fv);
    }

    enableAttribs() {
        super.enableAttribs();
        this.gl.enableVertexAttribArray(this._attrib("aCorner"));
    }

    disableAttribs() {
        super.disableAttribs();
        this.gl.disableVertexAttribArray(this._attrib("aCorner"));
    }

    setExtraAttribsInBuffer(operation) {
        let offset = operation.extraAttribsDataByteOffset / 4;
        let floats = operation.quads.floats;

        let length = operation.length;

        for (let i = 0; i < length; i++) {

            const elementCore = operation.getElementCore(i);

            // We are setting attributes such that if the value is < 0 or > 1, a border should be drawn.
            const ddw = this._width / elementCore.w;
            const dw = ddw / (1 - 2 * ddw);
            const ddh = this._width / elementCore.h;
            const dh = ddh / (1 - 2 * ddh);

            // Specify all corner points.
            floats[offset] = -dw;
            floats[offset + 1] = -dh;

            floats[offset + 2] = 1 + dw;
            floats[offset + 3] = -dh;

            floats[offset + 4] = 1 + dw;
            floats[offset + 5] = 1 + dh;

            floats[offset + 6] = -dw;
            floats[offset + 7] = 1 + dh;

            offset += 8;
        }
    }

    beforeDraw(operation) {
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aCorner"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
    }

    getExtraAttribBytesPerVertex() {
        return 8;
    }

}

OutlineShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aCorner;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vCorner;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vCorner = aCorner;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

OutlineShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vCorner;
    uniform vec4 color;
    uniform sampler2D uSampler;
    void main(void){
        vec2 m = min(vCorner, 1.0 - vCorner);
        float value = step(0.0, min(m.x, m.y));
        gl_FragColor = mix(color, texture2D(uSampler, vTextureCoord) * vColor, value);
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PerspectiveShader.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PerspectiveShader.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PerspectiveShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class PerspectiveShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this._fudge = 0.2;
        this._rx = 0;
        this._ry = 0;
        this._z = 1.0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        const vr = operation.shaderOwner;
        const element = vr.element;

        const pivotX = element.pivotX * vr.w;
        const pivotY = element.pivotY * vr.h;
        const coords = vr.getRenderTextureCoords(pivotX, pivotY);

        // Counter normal rotation.
        const rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);

        const gl = this.gl;
        this._setUniform("pivot", new Float32Array([coords[0], coords[1], 0]), gl.uniform3fv);
        this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
        this._setUniform("z", this._z, gl.uniform1f);
        this._setUniform("fudge", this._fudge, gl.uniform1f);
    }

    set fudge(v) {
        this._fudge = v;
        this.redraw();
    }

    get fudge() {
        return this._fudge;
    }

    get rx() {
        return this._rx;
    }

    set rx(v) {
        this._rx = v;
        this.redraw();
    }

    get ry() {
        return this._ry;
    }

    set ry(v) {
        this._ry = v;
        this.redraw();
    }

    get z() {
        return this._z;
    }

    set z(v) {
        this._z = v;
        this.redraw();
    }

    useDefault() {
        return (this._rx === 0 && this._ry === 0 && this._z === 0);
    }

}

PerspectiveShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float z;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, z);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

PerspectiveShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform vec3 rot;
    uniform float fudge;

    void main(void) {
        vec2 coords = vTextureCoord;

        coords.xy -= vec2(0.5);
        coords.y = coords.y + (sign(rot[0]) * 0.5 - coords.x) * sin(rot[0]) * fudge * coords.y;
        coords.x = coords.x + (sign(rot[1]) * 0.5 - coords.y) * sin(rot[1]) * fudge * coords.x;
        coords.xy += vec2(0.5);

        if (coords.x < 0.0 || coords.x > 1.0 || coords.y < 0.0 || coords.y > 1.0) {
            gl_FragColor = vec4(0.0);
        } else {
            gl_FragColor = texture2D(uSampler, coords) * vColor;
        }
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PixelateShader.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PixelateShader.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PixelateShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @see https://github.com/pixijs/pixi-filters/tree/master/filters/pixelate/src
 */
class PixelateShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this._size = new Float32Array([4, 4]);
    }

    get x() {
        return this._size[0];
    }

    set x(v) {
        this._size[0] = v;
        this.redraw();
    }

    get y() {
        return this._size[1];
    }

    set y(v) {
        this._size[1] = v;
        this.redraw();
    }

    get size() {
        return this._size[0];
    }

    set size(v) {
        this._size[0] = v;
        this._size[1] = v;
        this.redraw();
    }

    useDefault() {
        return ((this._size[0] === 0) && (this._size[1] === 0));
    }

    static getWebGLImpl() {
        return WebGLPixelateShaderImpl;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        let gl = this.gl;
        this._setUniform("size", new Float32Array(this._size), gl.uniform2fv);
    }

    getExtraAttribBytesPerVertex() {
        return 8;
    }

    enableAttribs() {
        super.enableAttribs();
        this.gl.enableVertexAttribArray(this._attrib("aTextureRes"));
    }

    disableAttribs() {
        super.disableAttribs();
        this.gl.disableVertexAttribArray(this._attrib("aTextureRes"));
    }

    setExtraAttribsInBuffer(operation) {
        let offset = operation.extraAttribsDataByteOffset / 4;
        let floats = operation.quads.floats;

        let length = operation.length;
        for (let i = 0; i < length; i++) {
            let w = operation.quads.getTextureWidth(operation.index + i);
            let h = operation.quads.getTextureHeight(operation.index + i);

            floats[offset] = w;
            floats[offset + 1] = h;
            floats[offset + 2] = w;
            floats[offset + 3] = h;
            floats[offset + 4] = w;
            floats[offset + 5] = h;
            floats[offset + 6] = w;
            floats[offset + 7] = h;

            offset += 8;
        }
    }

    beforeDraw(operation) {
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aTextureRes"), 2, gl.FLOAT, false, this.getExtraAttribBytesPerVertex(), this.getVertexAttribPointerOffset(operation));
    }
}

PixelateShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aTextureRes;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        vTextureRes = aTextureRes;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

PixelateShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;

    uniform vec2 size;
    uniform sampler2D uSampler;
    
    vec2 mapCoord( vec2 coord )
    {
        coord *= vTextureRes.xy;
        return coord;
    }
    
    vec2 unmapCoord( vec2 coord )
    {
        coord /= vTextureRes.xy;
        return coord;
    }
    
    vec2 pixelate(vec2 coord, vec2 size)
    {
        return floor( coord / size ) * size;
    }
    
    void main(void)
    {
        vec2 coord = mapCoord(vTextureCoord);
        coord = pixelate(coord, size);
        coord = unmapCoord(coord);
        gl_FragColor = texture2D(uSampler, coord) * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialFilterShader.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialFilterShader.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadialFilterShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class RadialFilterShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._radius = 0;
        this._cutoff = 1;
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    get radius() {
        return this._radius;
    }

    set cutoff(v) {
        this._cutoff = v;
        this.redraw();
    }

    get cutoff() {
        return this._cutoff;
    }
    
    useDefault() {
        return this._radius === 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        // We substract half a pixel to get a better cutoff effect.
        this._setUniform("radius", 2 * (this._radius - 0.5) / operation.getRenderWidth(), this.gl.uniform1f);
        this._setUniform("cutoff", 0.5 * operation.getRenderWidth() / this._cutoff, this.gl.uniform1f);
    }

}

RadialFilterShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 pos;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
        pos = gl_Position.xy;
    }
`;

RadialFilterShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 pos;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float radius;
    uniform float cutoff;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        float f = max(0.0, min(1.0, 1.0 - (length(pos) - radius) * cutoff));
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor * f;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialGradientShader.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialGradientShader.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadialGradientShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class RadialGradientShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._pivot = [0, 0];
        this._ic = 0xffffffff;
        this._normalizedIC = this._getNormalizedColor(this._ic);
        this._oc = 0x00ffffff;
        this._normalizedOC = this._getNormalizedColor(this._oc);
        this._radius = 0;
    }

    set radiusX(v) {
        this.radius = v;
    }

    get radiusX() {
        return this._radius;
    }

    set radiusY(v) {
        this._radiusY = v;
        this.redraw();
    }

    get radiusY() {
        return this._radiusY;
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    set innerColor(argb) {
        this._ic = argb;
        this._normalizedIC = this._getNormalizedColor(argb);
        this.redraw();
    }

    get innerColor() {
        return this._ic;
    }

    set outerColor(argb) {
        this._oc = argb;
        this._normalizedOC = this._getNormalizedColor(argb);
        this.redraw();
    }

    set color(argb) {
        this.innerColor = argb;
    }

    get color() {
        return this.innerColor;
    }

    get outerColor() {
        return this._ic;
    }

    set x(f) {
        this._x = f;
        this.redraw();
    }

    set y(f) {
        this._y = f;
        this.redraw();
    }

    set pivot(v) {
        if(Array.isArray(v) && v.length === 2) {
            this._pivot = v;
        }
        else if(Array.isArray(v)) {
            this._pivot = [v[0], v[1] || v[0]];
        }
        else {
            this._pivot = [v, v];
        }
        this.redraw();
    }

    get pivot() {
        return this._pivot[0];
    }

    set pivotY(f) {
        this._pivot[1] = f;
        this.redraw();
    }

    get pivotY() {
        return this._pivot[1];
    }

    set pivotX(f) {
        this._pivot[0] = f;
        this.redraw();
    }

    get pivotX() {
        return this._pivot[0];
    }

    _getNormalizedColor(color) {
        const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(color);
        col[0] *= col[3];
        col[1] *= col[3];
        col[2] *= col[3];
        return new Float32Array(col);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;

        if(this._x) {
            this._pivot[0] = this._x / owner.w;
        }
        if(this._y) {
            this._pivot[1] = this._y / owner.h;
        }

        if(this._radius === 0) {
            this._radius = owner.w * 0.5;
        }

        this._setUniform('innerColor', this._normalizedIC, this.gl.uniform4fv);
        this._setUniform('fill', _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(this._oc)[3], this.gl.uniform1f);
        this._setUniform('outerColor', this._normalizedOC, this.gl.uniform4fv);
        this._setUniform('pivot', new Float32Array(this._pivot),  this.gl.uniform2fv);
        this._setUniform('resolution', new Float32Array([owner._w, owner._h]),  this.gl.uniform2fv);
        this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
        this._setUniform('radius',  this._radius, this.gl.uniform1f);
        this._setUniform('radiusY',  (this._radiusY || this._radius), this.gl.uniform1f);
    }
}

RadialGradientShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec2 pivot;
    uniform vec4 innerColor;
    uniform vec4 outerColor;
    uniform float radius;
    uniform float radiusY;
    uniform float alpha;
    uniform float fill;
    uniform float aspectRatio;
    
    void main() {
        vec2 point = vTextureCoord.xy * resolution;
        vec2 projection = vec2(pivot.x * resolution.x, pivot.y * resolution.y);
        float d = length((point - projection) / vec2(radius * 2.0, radiusY * 2.0));
        vec4 color = mix(texture2D(uSampler, vTextureCoord) * vColor, outerColor * alpha, fill);
        gl_FragColor = mix(innerColor * alpha, color, smoothstep(0.0, 1.0, d));
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RoundedRectangleShader.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RoundedRectangleShader.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RoundedRectangleShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class RoundedRectangleShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._blend = 0;
        this._radius = [1, 1, 1, 1];
        this._stroke = 0;
        this._fc = 0x00ffffff;
        this._fillColor = this._getNormalizedColor(0xffffffff);
        this._strokeColor = this._getNormalizedColor(0x00ffffff);
    }

    set blend(p) {
        this._blend = Math.min(Math.max(p, 0), 1);
    }

    set radius(v) {
        if(Array.isArray(v)) {
            if(v.length === 2) {
                this._radius = [v[0], v[1], v[0], v[1]];
            }
            else if(v.length === 3) {
                this._radius = [v[0], v[1], v[2], this._radius[3]];
            }
            else if (v.length === 4) {
                this._radius = v;
            }
            else {
                this._radius = [v[0], v[0], v[0], v[0]];
            }
        }
        else {
            this._radius = [v, v, v, v];
        }
        this.redraw();
    }

    get radius() {
        return this._radius;
    }

    set topLeft(num) {
        this._radius[0] = num;
        this.redraw();
    }

    get topLeft() {
        return this._radius[0];
    }

    set topRight(num) {
        this._radius[1] = num;
        this.redraw();
    }

    get topRight() {
        return this._radius[1];
    }

    set bottomRight(num) {
        this._radius[2] = num;
        this.redraw();
    }

    get bottomRight() {
        return this._radius[2];
    }

    set bottomLeft(num) {
        this._radius[3] = num;
        this.redraw();
    }

    get bottomLeft() {
        return this._radius[4];
    }

    set strokeColor(argb) {
        this._sc = argb;
        this._strokeColor = this._getNormalizedColor(argb);
        this.redraw();
    }

    get strokeColor() {
        return this._sc;
    }

    set fillColor(argb) {
        this._fc = argb;
        this._fillColor = this._getNormalizedColor(argb);
        this.redraw();
    }

    get fillColor() {
        return this._fc;
    }

    set stroke(num) {
        this._stroke = num;
        this.redraw();
    }

    get stroke() {
        return this._stroke;
    }

    _getNormalizedColor(color) {
        const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(color);
        col[0] *= col[3];
        col[1] *= col[3];
        col[2] *= col[3];
        return new Float32Array(col);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;
        const renderPrecision = this.ctx.stage.getRenderPrecision();
        const _radius = this._radius.map((r) => (r + 0.5) * renderPrecision)
        this._setUniform('radius', new Float32Array(_radius), this.gl.uniform4fv);
        this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
        this._setUniform('blend', this._blend, this.gl.uniform1f);
        this._setUniform('strokeColor', this._strokeColor, this.gl.uniform4fv);
        this._setUniform('fillColor', this._fillColor, this.gl.uniform4fv);
        this._setUniform('stroke',  this._stroke * renderPrecision, this.gl.uniform1f);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
}

RoundedRectangleShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

RoundedRectangleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif

    #define PI 3.14159265359

    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 radius;
    uniform float stroke;
    uniform vec4 strokeColor;
    uniform vec4 fillColor;
    uniform float alpha;
    uniform float fill;
    uniform float blend;
    
    float boxDist(vec2 p, vec2 size, float radius){
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    float innerBorderMask(float dist, float width){
        float alpha1 = clamp(dist + width, 0.0, 1.0);
        float alpha2 = clamp(dist, 0.0, 1.0);
        return alpha1 - alpha2;
    }

    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        float r = 0.0;
        if (vTextureCoord.x < 0.5 && vTextureCoord.y < 0.5) {
            r = radius[0];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y < 0.5) {
            r = radius[1];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y >= 0.5) {
            r = radius[2];
        } else {
            r = radius[3];
        }
        
        float b = boxDist(vTextureCoord.xy * resolution - halfRes, halfRes - 0.005, r);
        vec4 tex = texture2D(uSampler, vTextureCoord) * vColor;
        vec4 blend = mix(vec4(1.0) * alpha, tex, blend);     
        vec4 layer1 = mix(vec4(0.0), tex * fillColor, fillMask(b));
        gl_FragColor = mix(layer1, blend * strokeColor, innerBorderMask(b, stroke));
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpinnerShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class SpinnerShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);
        this._radius = 100;
        this._width = 50;
        this._period = 1;
        this._angle = 0.5;
        this._smooth = 0.005;
        this._color = 0xffffffff;
        this._backgroundColor = 0xff000000;
        this._time = Date.now();
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    set width(v) {
        this._width = v;
        this.redraw();
    }

    set period(v) {
        this._period = v;
        this.redraw();
    }

    set angle(v) {
        this._angle = v
        this.redraw();
    }

    set smooth(v) {
        this._smooth = v;
        this.redraw();
    }

    set color(v) {
        this._color = v;
        this.redraw();
    }

    set backgroundColor(v) {
        this._backgroundColor = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner

        this._setUniform("iTime", Date.now() - this._time, this.gl.uniform1f);

        const renderPrecision = this.ctx.stage.getRenderPrecision();
        this._setUniform('radius', this._radius * renderPrecision, this.gl.uniform1f);
        this._setUniform('width', this._width * renderPrecision, this.gl.uniform1f);
        this._setUniform('period', this._period, this.gl.uniform1f);
        this._setUniform('angle', this._angle, this.gl.uniform1f);
        this._setUniform('smooth', this._smooth, this.gl.uniform1f);
        this._setUniform('color', new Float32Array(_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(this._color)), this.gl.uniform4fv);
        this._setUniform('backgroundColor', new Float32Array(_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(this._backgroundColor)), this.gl.uniform4fv);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv)

        this.redraw()
    }
}

SpinnerShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;

SpinnerShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float iTime;
    uniform float radius;
    uniform float width;
    uniform float period;
    uniform float angle;
    uniform float smooth;
    uniform vec2 resolution;

    uniform vec4 color;
    uniform vec4 backgroundColor;

    float ratio = resolution.y / resolution.x;

    vec2 transpose_pos(vec2 pos) {
        if (ratio < 1.) {
            float diff = 0.5 - pos.x;
            pos.x = 0.5 - diff / ratio;
        } else {
            float diff = 0.5 - pos.y;
            pos.y = 0.5 - diff * ratio;
        }
        return pos;
    }

    float get_angle(vec2 pos) {
        pos = transpose_pos(pos);
        float a = atan(pos.y - 0.5, pos.x - 0.5);
        a = (1.0+a/3.14159)/2.0;
        
        return a;
    }

    float dist(vec2 pos1, vec2 pos2) {
        pos1 = transpose_pos(pos1);
        return distance(pos1, pos2);
    }

    void main()
    {
        vec2 fragCoord = vTextureCoord;
        vec4 fragColor = vColor;
        
        vec2 st = vTextureCoord;
        float pct = dist(st, vec2(0.5));

        float a = get_angle(st);
        float t = iTime / 1000.0 / period;

        float inner = max((radius - width) / resolution.x, (radius - width) / resolution.y);
        float outer = max(radius / resolution.x, radius / resolution.y);

        float x1 = mod(t, 1.0);
        float x2 = mod(t + angle, 1.0);

        if (x1 < x2) {
            if (a > x1 && a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        } else {
            if (a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else if (a > x1) {
                float val = (1.0 - (1.0 + x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (1.0 + x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        }

        float s = smoothstep(inner, inner + smooth + 0.00001, pct) * (1.0 - smoothstep(outer, outer + smooth + 0.00001, pct));
        gl_FragColor = texture2D(uSampler, fragCoord) * vColor * (1. - s * fragColor.a) + fragColor * s;
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader2.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader2.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpinnerShader2)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class SpinnerShader2 extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._period = 1;
        this._stroke = 0;
        this._showDot = true;
        this._clockwise = true;
        this._bc = 0xff000000;
        this._normalizedBC = this._getNormalizedColor(this._bc);
        this._c = 0xffffffff;
        this._normalizedC = this._getNormalizedColor(this._c);
    }

    set radius(v) {
        if(v === 0) {
            v = 1;
        }
        this._radius = v;
    }

    set stroke(value) {
        this._stroke = Math.abs(value);
    }

    get stroke() {
        return this._stroke;
    }

    set color(argb) {
        this._c = argb;
        this._normalizedC = this._getNormalizedColor(argb);
    }

    get color() {
        return this._c;
    }

    set backgroundColor(argb) {
        this._bc = argb;
        this._normalizedBC = this._getNormalizedColor(argb);
    }

    get backgroundColor() {
        return this._sc;
    }

    set showDot(bool) {
        this._showDot = bool;
    }

    get showDot() {
        return this._showDot;
    }

    set clockwise(bool) {
        this._clockwise = bool;
    }

    get clockwise() {
        return this._clockwise;
    }

    set period(v) {
        this._period = v;
    }

    get period() {
        return this._period;
    }

    _getNormalizedColor(color) {
        const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(color);
        col[0] *= col[3];
        col[1] *= col[3];
        col[2] *= col[3];
        return new Float32Array(col);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;
        const radius = this._radius || (owner._w / 2);

        if(this._stroke === 0) {
            this._stroke = radius * 0.33;
        }

        this._setUniform('resolution', new Float32Array([owner._w, owner._h]),  this.gl.uniform2fv);
        this._setUniform('color', this._normalizedC, this.gl.uniform4fv);
        this._setUniform('backgroundColor', this._normalizedBC, this.gl.uniform4fv);
        this._setUniform('stroke',  this._stroke, this.gl.uniform1f);
        this._setUniform('radius',  radius, this.gl.uniform1f);
        this._setUniform('direction',  this._clockwise ? -1 : 1, this.gl.uniform1f);
        this._setUniform('showDot', !!this._showDot, this.gl.uniform1f);
        this._setUniform('time', Date.now() - SpinnerShader2.spinSync, this.gl.uniform1f);
        this._setUniform('period', this._period, this.gl.uniform1f);
        this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);

        if(this._sc !== this._bc || this._stroke !== radius * 0.5) {
            this.redraw();
        }
    }
}

SpinnerShader2.spinSync = Date.now();

SpinnerShader2.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 color;
    uniform vec4 backgroundColor;
    uniform float direction;
    uniform float radius;
    uniform float time;
    uniform float stroke;
    uniform float showDot;
    uniform float period;
    uniform float alpha;
    
    float circleDist(vec2 p, float radius){
        return length(p) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 center = vTextureCoord.xy * resolution - halfRes;
        
        float c = max(-circleDist(center, radius - stroke), circleDist(center, radius));
        float rot = -(time / 1000.0 / period) * 6.0 * direction;
        center *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));
        
        float a = direction * atan(center.x, center.y) * PI * 0.05 + 0.45;
        
        float strokeRad = stroke * 0.5;
        a = mix(a, max(a, fillMask(circleDist(vec2(center.x, center.y + (radius - strokeRad)), strokeRad))), showDot);
        vec4 base = mix(vec4(0.0), backgroundColor * alpha, fillMask(c));
        gl_FragColor = mix(base, color * alpha, fillMask(c) * a);
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/VignetteShader.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/VignetteShader.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VignetteShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class VignetteShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._magnitude = 1.3;
        this._intensity = 0.7;
        this._pivot = [0.5, 0.5];
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        this._setUniform("magnitude", this._magnitude , this.gl.uniform1f);
        this._setUniform("intensity", this._intensity, this.gl.uniform1f);
        this._setUniform('pivot', new Float32Array(this._pivot), this.gl.uniform2fv);
        this.redraw()
    }

    set pivot(v) {
        if(Array.isArray(v)) {
            this._pivot = v;
        }
        else {
            this._pivot = [v, v];
        }
        this.redraw();
    }

    get pivotX() {
        return this._pivot[0];
    }

    set pivotX(v) {
        this._pivot[0] = v;
        this.redraw();
    }

    get pivotY() {
        return this._pivot[1];
    }

    set pivotY(v) {
        this._pivot[1] = v;
        this.redraw();
    }

    get intensity() {
        return this._intensity;
    }

    set intensity(v) {
        this._intensity = v;
        this.redraw();
    }

    get magnitude() {
        return this._magnitude;

    }

    set magnitude(v) {
        this._magnitude = v;
        this.redraw();
    }
}

VignetteShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;

VignetteShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float magnitude;
    uniform float intensity;
    uniform vec2 pivot;

    void main() {
        vec2 uv = vTextureCoord.xy - pivot + vec2(0.5);
        uv.x = clamp(uv.x, 0.0, 1.0);
        uv.y = clamp(uv.y, 0.0, 1.0);
   
        uv *=  1.00 - uv.yx;
        float vig = uv.x * uv.y * 25.0 * intensity;
        vig = pow(vig, 0.45 * magnitude);
        vec4 fragColor = vec4(vig) * vColor;
        gl_FragColor = texture2D(uSampler, vTextureCoord) * fragColor;

    }
`


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/HtmlTexture.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/HtmlTexture.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HtmlTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class HtmlTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);
        this._htmlElement = undefined;
        this._scale = 1;
    }

    set htmlElement(v) {
        this._htmlElement = v;
        this._changed();
    }

    get htmlElement() {
        return this._htmlElement;
    }

    set scale(v) {
        this._scale = v;
        this._changed();
    }

    get scale() {
        return this._scale;
    }

    set html(v) {
        if (!v) {
            this.htmlElement = undefined;
        } else {
            const d = document.createElement('div');
            d.innerHTML = "<div>" + v + "</div>";
            this.htmlElement = d.firstElementChild;
        }
    }

    get html() {
        return this._htmlElement.innerHTML;
    }

    _getIsValid() {
        return this.htmlElement;
    }

    _getLookupId() {
        return this._scale + ":" + this._htmlElement.innerHTML;
    }

    _getSourceLoader() {
        const htmlElement = this._htmlElement;
        const scale = this._scale;
        return function(cb) {
            if (!window.html2canvas) {
                return cb(new Error("Please include html2canvas (https://html2canvas.hertzen.com/)"));
            }

            const area = HtmlTexture.getPreloadArea();
            area.appendChild(htmlElement);

            html2canvas(htmlElement, {backgroundColor: null, scale: scale}).then(function(canvas) {
                area.removeChild(htmlElement);
                if (canvas.height === 0) {
                    return cb(new Error("Canvas height is 0"));
                }
                cb(null, {source: canvas, width: canvas.width, height: canvas.height});
            }).catch(e => {
                console.error('[Lightning]', e);
            });
        }
    }

    static getPreloadArea() {
        if (!this._preloadArea) {
            // Preload area must be included in document body and must be visible to trigger html element rendering.
            this._preloadArea = document.createElement('div');
            if (this._preloadArea.attachShadow) {
                // Use a shadow DOM if possible to prevent styling from interfering.
                this._preloadArea.attachShadow({mode: 'closed'});
            }
            this._preloadArea.style.opacity = 0;
            this._preloadArea.style.pointerEvents = 'none';
            this._preloadArea.style.position = 'fixed';
            this._preloadArea.style.display = 'block';
            this._preloadArea.style.top = '100vh';
            this._preloadArea.style.overflow = 'hidden';
            document.body.appendChild(this._preloadArea);
        }
        return this._preloadArea;
    }
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ImageTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        this._src = undefined;
        this._hasAlpha = false;
    }

    get src() {
        return this._src;
    }

    set src(v) {
        if (this._src !== v) {
            this._src = v;
            this._changed();
        }
    }

    get hasAlpha() {
        return this._hasAlpha;
    }

    set hasAlpha(v) {
        if (this._hasAlpha !== v) {
            this._hasAlpha = v;
            this._changed();
        }
    }

    _getIsValid() {
        return !!this._src;
    }

    _getLookupId() {
        return this._src;
    }

    _getSourceLoader() {
        let src = this._src;
        let hasAlpha = this._hasAlpha;
        if (this.stage.getOption('srcBasePath')) {
            var fc = src.charCodeAt(0);
            if ((src.indexOf("//") === -1) && ((fc >= 65 && fc <= 90) || (fc >= 97 && fc <= 122) || fc == 46)) {
                // Alphabetical or dot: prepend base path.
                src = this.stage.getOption('srcBasePath') + src;
            }
        }

        return (cb) => {
            return this.stage.platform.loadSrcTexture({src: src, hasAlpha: hasAlpha}, cb);
        }
    }

    getNonDefaults() {
        const obj = super.getNonDefaults();
        if (this._src) {
            obj.src = this._src;
        }
        return obj;
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NoiseTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class NoiseTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    _getLookupId() {
        return '__noise';
    }

    _getSourceLoader() {
        const gl = this.stage.gl;
        return function(cb) {
            const noise = new Uint8Array(128 * 128 * 4);
            for (let i = 0; i < 128 * 128 * 4; i+=4) {
                const v = Math.floor(Math.random() * 256);
                noise[i] = v;
                noise[i+1] = v;
                noise[i+2] = v;
                noise[i+3] = 255;
            }
            const texParams = {}

            if (gl) {
                texParams[gl.TEXTURE_WRAP_S] = gl.REPEAT;
                texParams[gl.TEXTURE_WRAP_T] = gl.REPEAT;
                texParams[gl.TEXTURE_MIN_FILTER] = gl.NEAREST;
                texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
            }

            cb(null, {source: noise, w: 128, h: 128, texParams: texParams});
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RectangleTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class RectangleTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    _getLookupId() {
        return '__whitepix';
    }

    _getSourceLoader() {
        return function(cb) {
            var whitePixel = new Uint8Array([255, 255, 255, 255]);
            cb(null, {source: whitePixel, w: 1, h: 1, permanent: true});
        }
    }

    isAutosizeTexture() {
        return false;
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SourceTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class SourceTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        this._textureSource = undefined;
    }

    get textureSource() {
        return this._textureSource;
    }

    set textureSource(v) {
        if (v !== this._textureSource) {
            if (v.isResultTexture) {
                // In case of a result texture, automatically inherit the precision.
                this._precision = this.stage.getRenderPrecision();
            }
            this._textureSource = v;
            this._changed();
        }
    }

    _getTextureSource() {
        return this._textureSource;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StaticCanvasTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class StaticCanvasTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);
        this._factory = undefined;
        this._lookupId = undefined;
    }

    set content({factory, lookupId = undefined}) {
        this._factory = factory;
        this._lookupId = lookupId;
        this._changed();
    }

    _getIsValid() {
        return !!this._factory;
    }

    _getLookupId() {
        return this._lookupId;
    }

    _getSourceLoader() {
        const f = this._factory;
        return (cb) => {
            return f((err, canvas) => {
                if (err) {
                    return cb(err);
                }
                cb(null, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas));
            }, this.stage);
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/StaticTexture.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/StaticTexture.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StaticTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class StaticTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage, options) {
        super(stage);

        this._options = options;
    }

    set options(v) {
        if (this._options !== v) {
            this._options = v;
            this._changed();
        }
    }

    get options() {
        return this._options;
    }

    _getIsValid() {
        return !!this._options;
    }

    _getSourceLoader() {
        return (cb) => {
            cb(null, this._options);
        }
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/TextTexture.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/TextTexture.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _TextTextureRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TextTextureRenderer.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTextureRenderer.mjs");
/* harmony import */ var _TextTextureRendererAdvanced_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextTextureRendererAdvanced.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTextureRendererAdvanced.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TextTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        // We use the stage precision as the default precision in case of a text texture.
        this._precision = this.stage.getOption('precision');
    }

    static renderer(stage, canvas, settings) {
        if (this.advancedRenderer) {
            return new _TextTextureRendererAdvanced_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](stage, canvas, settings);
        } else {
            return new _TextTextureRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](stage, canvas, settings);
        }
    }

    get text() {
        return this._text;
    }

    set text(v) {
        if (this._text !== v) {
            this._text = "" + v;
            this._changed();
        }
    }

    get w() {
        return this._w;
    }

    set w(v) {
        if (this._w !== v) {
            this._w = v;
            this._changed();
        }
    }

    get h() {
        return this._h;
    }

    set h(v) {
        if (this._h !== v) {
            this._h = v;
            this._changed();
        }
    }

    get fontStyle() {
        return this._fontStyle;
    }

    set fontStyle(v) {
        if (this._fontStyle !== v) {
            this._fontStyle = v;
            this._changed();
        }
    }

    get fontSize() {
        return this._fontSize;
    }

    set fontSize(v) {
        if (this._fontSize !== v) {
            this._fontSize = v;
            this._changed();
        }
    }

    get fontFace() {
        return this._fontFace;
    }

    set fontFace(v) {
        if (this._fontFace !== v) {
            this._fontFace = v;
            this._changed();
        }
    }

    get wordWrap() {
        return this._wordWrap;
    }

    set wordWrap(v) {
        if (this._wordWrap !== v) {
            this._wordWrap = v;
            this._changed();
        }
    }

    get wordWrapWidth() {
        return this._wordWrapWidth;
    }

    set wordWrapWidth(v) {
        if (this._wordWrapWidth !== v) {
            this._wordWrapWidth = v;
            this._changed();
        }
    }

    get wordBreak() {
        return this._wordBreak;
    }

    set wordBreak(v) {
        if (this._wordBreak !== v) {
            this._wordBreak = v;
            this._changed();
        }
    }

    get textOverflow() {
        return this._textOverflow;
    }

    set textOverflow(v) {
        if (v != this._textOverflow) {
            this._textOverflow = v;
            this._changed();
        }
    }

    get lineHeight() {
        return this._lineHeight;
    }

    set lineHeight(v) {
        if (this._lineHeight !== v) {
            this._lineHeight = v;
            this._changed();
        }
    }

    get textBaseline() {
        return this._textBaseline;
    }

    set textBaseline(v) {
        if (this._textBaseline !== v) {
            this._textBaseline = v;
            this._changed();
        }
    }

    get textAlign() {
        return this._textAlign;
    }

    set textAlign(v) {
        if (this._textAlign !== v) {
            this._textAlign = v;
            this._changed();
        }
    }

    get verticalAlign() {
        return this._verticalAlign;
    }

    set verticalAlign(v) {
        if (this._verticalAlign !== v) {
            this._verticalAlign = v;
            this._changed();
        }
    }

    get offsetY() {
        return this._offsetY;
    }

    set offsetY(v) {
        if (this._offsetY !== v) {
            this._offsetY = v;
            this._changed();
        }
    }

    get maxLines() {
        return this._maxLines;
    }

    set maxLines(v) {
        if (this._maxLines !== v) {
            this._maxLines = v;
            this._changed();
        }
    }

    get maxLinesSuffix() {
        return this._maxLinesSuffix;
    }

    set maxLinesSuffix(v) {
        if (this._maxLinesSuffix !== v) {
            this._maxLinesSuffix = v;
            this._changed();
        }
    }

    get textColor() {
        return this._textColor;
    }

    set textColor(v) {
        if (this._textColor !== v) {
            this._textColor = v;
            this._changed();
        }
    }

    get paddingLeft() {
        return this._paddingLeft;
    }

    set paddingLeft(v) {
        if (this._paddingLeft !== v) {
            this._paddingLeft = v;
            this._changed();
        }
    }

    get paddingRight() {
        return this._paddingRight;
    }

    set paddingRight(v) {
        if (this._paddingRight !== v) {
            this._paddingRight = v;
            this._changed();
        }
    }

    get shadow() {
        return this._shadow;
    }

    set shadow(v) {
        if (this._shadow !== v) {
            this._shadow = v;
            this._changed();
        }
    }

    get shadowColor() {
        return this._shadowColor;
    }

    set shadowColor(v) {
        if (this._shadowColor !== v) {
            this._shadowColor = v;
            this._changed();
        }
    }

    get shadowOffsetX() {
        return this._shadowOffsetX;
    }

    set shadowOffsetX(v) {
        if (this._shadowOffsetX !== v) {
            this._shadowOffsetX = v;
            this._changed();
        }
    }

    get shadowOffsetY() {
        return this._shadowOffsetY;
    }

    set shadowOffsetY(v) {
        if (this._shadowOffsetY !== v) {
            this._shadowOffsetY = v;
            this._changed();
        }
    }

    get shadowBlur() {
        return this._shadowBlur;
    }

    set shadowBlur(v) {
        if (this._shadowBlur !== v) {
            this._shadowBlur = v;
            this._changed();
        }
    }

    get highlight() {
        return this._highlight;
    }

    set highlight(v) {
        if (this._highlight !== v) {
            this._highlight = v;
            this._changed();
        }
    }

    get highlightHeight() {
        return this._highlightHeight;
    }

    set highlightHeight(v) {
        if (this._highlightHeight !== v) {
            this._highlightHeight = v;
            this._changed();
        }
    }

    get highlightColor() {
        return this._highlightColor;
    }

    set highlightColor(v) {
        if (this._highlightColor !== v) {
            this._highlightColor = v;
            this._changed();
        }
    }

    get highlightOffset() {
        return this._highlightOffset;
    }

    set highlightOffset(v) {
        if (this._highlightOffset !== v) {
            this._highlightOffset = v;
            this._changed();
        }
    }

    get highlightPaddingLeft() {
        return this._highlightPaddingLeft;
    }

    set highlightPaddingLeft(v) {
        if (this._highlightPaddingLeft !== v) {
            this._highlightPaddingLeft = v;
            this._changed();
        }
    }

    get highlightPaddingRight() {
        return this._highlightPaddingRight;
    }

    set highlightPaddingRight(v) {
        if (this._highlightPaddingRight !== v) {
            this._highlightPaddingRight = v;
            this._changed();
        }
    }

    get cutSx() {
        return this._cutSx;
    }

    set cutSx(v) {
        if (this._cutSx !== v) {
            this._cutSx = v;
            this._changed();
        }
    }

    get cutEx() {
        return this._cutEx;
    }

    set cutEx(v) {
        if (this._cutEx !== v) {
            this._cutEx = v;
            this._changed();
        }
    }

    get cutSy() {
        return this._cutSy;
    }

    set cutSy(v) {
        if (this._cutSy !== v) {
            this._cutSy = v;
            this._changed();
        }
    }

    get cutEy() {
        return this._cutEy;
    }

    set cutEy(v) {
        if (this._cutEy !== v) {
            this._cutEy = v;
            this._changed();
        }
    }

    get advancedRenderer() {
        return this._advancedRenderer;
    }

    set advancedRenderer(v) {
        if (this._advancedRenderer !== v) {
            this._advancedRenderer = v;
            this._changed();
        }
    }

    set letterSpacing(v) {
        if (this._letterSpacing !== v) {
            this._letterSpacing = v;
            this._changed();
        }
    }

    get letterSpacing() {
        return this._letterSpacing;
    }

    set textIndent(v) {
        if (this._textIndent !== v) {
            this._textIndent = v;
            this._changed();
        }
    }

    get textIndent() {
        return this._textIndent;
    }

    get precision() {
        return super.precision;
    }

    set precision(v) {
        // We actually draw differently when the precision changes.
        if (this.precision !== v) {
            super.precision = v;
            this._changed();
        }
    }

    _getIsValid() {
        return !!this.text;
    }

    _getLookupId() {
        let parts = [];

        if (this.w !== 0) parts.push("w " + this.w);
        if (this.h !== 0) parts.push("h " + this.h);
        if (this.fontStyle !== "normal") parts.push("fS" + this.fontStyle);
        if (this.fontSize !== 40) parts.push("fs" + this.fontSize);
        if (this.fontFace !== null) parts.push("ff" + (Array.isArray(this.fontFace) ? this.fontFace.join(",") : this.fontFace));
        if (this.wordWrap !== true) parts.push("wr" + (this.wordWrap ? 1 : 0));
        if (this.wordWrapWidth !== 0) parts.push("ww" + this.wordWrapWidth);
        if (this.wordBreak !== false) parts.push("wb" + this.wordBreak ? 1 : 0);
        if (this.textOverflow != "") parts.push("to" + this.textOverflow);
        if (this.lineHeight !== null) parts.push("lh" + this.lineHeight);
        if (this.textBaseline !== "alphabetic") parts.push("tb" + this.textBaseline);
        if (this.textAlign !== "left") parts.push("ta" + this.textAlign);
        if (this.verticalAlign !== "top") parts.push("va" + this.verticalAlign);
        if (this.offsetY !== null) parts.push("oy" + this.offsetY);
        if (this.maxLines !== 0) parts.push("ml" + this.maxLines);
        if (this.maxLinesSuffix !== "..") parts.push("ms" + this.maxLinesSuffix);
        parts.push("pc" + this.precision);
        if (this.textColor !== 0xffffffff) parts.push("co" + this.textColor.toString(16));
        if (this.paddingLeft !== 0) parts.push("pl" + this.paddingLeft);
        if (this.paddingRight !== 0) parts.push("pr" + this.paddingRight);
        if (this.shadow !== false) parts.push("sh" + (this.shadow ? 1 : 0));
        if (this.shadowColor !== 0xff000000) parts.push("sc" + this.shadowColor.toString(16));
        if (this.shadowOffsetX !== 0) parts.push("sx" + this.shadowOffsetX);
        if (this.shadowOffsetY !== 0) parts.push("sy" + this.shadowOffsetY);
        if (this.shadowBlur !== 5) parts.push("sb" + this.shadowBlur);
        if (this.highlight !== false) parts.push("hL" + (this.highlight ? 1 : 0));
        if (this.highlightHeight !== 0) parts.push("hh" + this.highlightHeight);
        if (this.highlightColor !== 0xff000000) parts.push("hc" + this.highlightColor.toString(16));
        if (this.highlightOffset !== null) parts.push("ho" + this.highlightOffset);
        if (this.highlightPaddingLeft !== null) parts.push("hl" + this.highlightPaddingLeft);
        if (this.highlightPaddingRight !== null) parts.push("hr" + this.highlightPaddingRight);
        if (this.letterSpacing !== null) parts.push("ls" + this.letterSpacing);
        if (this.textIndent !== null) parts.push("ti" + this.textIndent);

        if (this.cutSx) parts.push("csx" + this.cutSx);
        if (this.cutEx) parts.push("cex" + this.cutEx);
        if (this.cutSy) parts.push("csy" + this.cutSy);
        if (this.cutEy) parts.push("cey" + this.cutEy);

        if (this.advancedRenderer) parts.push("aR" + this.advancedRenderer ? 1 : 0);

        let id = "TX$" + parts.join("|") + ":" + this.text;
        return id;
    }

    _getSourceLoader() {
        const args = this.cloneArgs();

        // Inherit font face from stage.
        if (args.fontFace === null) {
            args.fontFace = this.stage.getOption('defaultFontFace');
        }

        const gl = this.stage.gl;

        return function (cb) {
            const canvas = this.stage.platform.getDrawingCanvas();
            const renderer = (args.advancedRenderer)
              ? new _TextTextureRendererAdvanced_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this.stage, canvas, args)
              : new _TextTextureRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this.stage, canvas, args);
            
            const p = renderer.draw();

            const texParams = {};

            const sharpCfg = this.stage.getOption('fontSharp');
            let sharpen = false;

            // Prevent text blur when text texture is downscaled
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isBoolean(sharpCfg)) {
                sharpen = sharpCfg;
            } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(sharpCfg)) {
                const precision = this.stage.getRenderPrecision();
                sharpen = precision <= sharpCfg.precision && args.fontSize <= sharpCfg.fontSize;
            }

            if (gl && sharpen) {
                texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
            }

            if (p) {
                p.then(() => {
                    /* FIXME: on some platforms (e.g. RPI), throttling text textures cause artifacts */
                    cb(null, Object.assign({
                        renderInfo: renderer.renderInfo,
                        throttle: false,
                        texParams: texParams,
                    }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
                }).catch((err) => {
                    cb(err);
                });
            } else {
                cb(null, Object.assign({
                    renderInfo: renderer.renderInfo,
                    throttle: false,
                    texParams: texParams,
                }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
            }
        };
    }


    getNonDefaults() {
        const nonDefaults = super.getNonDefaults();
        if (this.text !== "") nonDefaults['text'] = this.text;
        if (this.w !== 0) nonDefaults['w'] = this.w;
        if (this.h !== 0) nonDefaults['h'] = this.h;
        if (this.fontStyle !== "normal") nonDefaults['fontStyle'] = this.fontStyle;
        if (this.fontSize !== 40) nonDefaults["fontSize"] = this.fontSize;
        if (this.fontFace !== null) nonDefaults["fontFace"] = this.fontFace;
        if (this.wordWrap !== true) nonDefaults["wordWrap"] = this.wordWrap;
        if (this.wordWrapWidth !== 0) nonDefaults["wordWrapWidth"] = this.wordWrapWidth;
        if (this.wordBreak !== false) nonDefaults["wordBreak"] = this.wordBreak;
        if (this.textOverflow != "") nonDefaults["textOverflow"] = this.textOverflow;
        if (this.lineHeight !== null) nonDefaults["lineHeight"] = this.lineHeight;
        if (this.textBaseline !== "alphabetic") nonDefaults["textBaseline"] = this.textBaseline;
        if (this.textAlign !== "left") nonDefaults["textAlign"] = this.textAlign;
        if (this.verticalAlign !== "top") nonDefaults["verticalAlign"] = this.verticalAlign;
        if (this.offsetY !== null) nonDefaults["offsetY"] = this.offsetY;
        if (this.maxLines !== 0) nonDefaults["maxLines"] = this.maxLines;
        if (this.maxLinesSuffix !== "..") nonDefaults["maxLinesSuffix"] = this.maxLinesSuffix;
        if (this.precision !== this.stage.getOption('precision')) nonDefaults["precision"] = this.precision;
        if (this.textColor !== 0xffffffff) nonDefaults["textColor"] = this.textColor;
        if (this.paddingLeft !== 0) nonDefaults["paddingLeft"] = this.paddingLeft;
        if (this.paddingRight !== 0) nonDefaults["paddingRight"] = this.paddingRight;
        if (this.shadow !== false) nonDefaults["shadow"] = this.shadow;
        if (this.shadowColor !== 0xff000000) nonDefaults["shadowColor"] = this.shadowColor;
        if (this.shadowOffsetX !== 0) nonDefaults["shadowOffsetX"] = this.shadowOffsetX;
        if (this.shadowOffsetY !== 0) nonDefaults["shadowOffsetY"] = this.shadowOffsetY;
        if (this.shadowBlur !== 5) nonDefaults["shadowBlur"] = this.shadowBlur;
        if (this.highlight !== false) nonDefaults["highlight"] = this.highlight;
        if (this.highlightHeight !== 0) nonDefaults["highlightHeight"] = this.highlightHeight;
        if (this.highlightColor !== 0xff000000) nonDefaults["highlightColor"] = this.highlightColor;
        if (this.highlightOffset !== 0) nonDefaults["highlightOffset"] = this.highlightOffset;
        if (this.highlightPaddingLeft !== 0) nonDefaults["highlightPaddingLeft"] = this.highlightPaddingLeft;
        if (this.highlightPaddingRight !== 0) nonDefaults["highlightPaddingRight"] = this.highlightPaddingRight;
        if (this.letterSpacing !== 0) nonDefaults["letterSpacing"] = this.letterSpacing;
        if (this.textIndent !== 0) nonDefaults["textIndent"] = this.textIndent;

        if (this.cutSx) nonDefaults["cutSx"] = this.cutSx;
        if (this.cutEx) nonDefaults["cutEx"] = this.cutEx;
        if (this.cutSy) nonDefaults["cutSy"] = this.cutSy;
        if (this.cutEy) nonDefaults["cutEy"] = this.cutEy;

        if (this.advancedRenderer) nonDefaults["renderer"] = this.advancedRenderer;
        return nonDefaults;
    }

    cloneArgs() {
        let obj = {};
        obj.text = this._text;
        obj.w = this._w;
        obj.h = this._h;
        obj.fontStyle = this._fontStyle;
        obj.fontSize = this._fontSize;
        obj.fontFace = this._fontFace;
        obj.wordWrap = this._wordWrap;
        obj.wordWrapWidth = this._wordWrapWidth;
        obj.wordBreak = this._wordBreak;
        obj.textOverflow = this._textOverflow;
        obj.lineHeight = this._lineHeight;
        obj.textBaseline = this._textBaseline;
        obj.textAlign = this._textAlign;
        obj.verticalAlign = this._verticalAlign;
        obj.offsetY = this._offsetY;
        obj.maxLines = this._maxLines;
        obj.maxLinesSuffix = this._maxLinesSuffix;
        obj.precision = this._precision;
        obj.textColor = this._textColor;
        obj.paddingLeft = this._paddingLeft;
        obj.paddingRight = this._paddingRight;
        obj.shadow = this._shadow;
        obj.shadowColor = this._shadowColor;
        obj.shadowOffsetX = this._shadowOffsetX;
        obj.shadowOffsetY = this._shadowOffsetY;
        obj.shadowBlur = this._shadowBlur;
        obj.highlight = this._highlight;
        obj.highlightHeight = this._highlightHeight;
        obj.highlightColor = this._highlightColor;
        obj.highlightOffset = this._highlightOffset;
        obj.highlightPaddingLeft = this._highlightPaddingLeft;
        obj.highlightPaddingRight = this._highlightPaddingRight;
        obj.letterSpacing = this._letterSpacing;
        obj.textIndent = this._textIndent;
        obj.cutSx = this._cutSx;
        obj.cutEx = this._cutEx;
        obj.cutSy = this._cutSy;
        obj.cutEy = this._cutEy;
        obj.advancedRenderer = this._advancedRenderer;
        return obj;
    }


}

// Because there are so many properties, we prefer to use the prototype for default values.
// This causes a decrease in performance, but also a decrease in memory usage.
let proto = TextTexture.prototype;
proto._text = "";
proto._w = 0;
proto._h = 0;
proto._fontStyle = "normal";
proto._fontSize = 40;
proto._fontFace = null;
proto._wordWrap = true;
proto._wordWrapWidth = 0;
proto._wordBreak = false;
proto._textOverflow = "";
proto._lineHeight = null;
proto._textBaseline = "alphabetic";
proto._textAlign = "left";
proto._verticalAlign = "top";
proto._offsetY = null;
proto._maxLines = 0;
proto._maxLinesSuffix = "..";
proto._textColor = 0xFFFFFFFF;
proto._paddingLeft = 0;
proto._paddingRight = 0;
proto._shadow = false;
proto._shadowColor = 0xFF000000;
proto._shadowOffsetX = 0;
proto._shadowOffsetY = 0;
proto._shadowBlur = 5;
proto._highlight = false;
proto._highlightHeight = 0;
proto._highlightColor = 0xFF000000;
proto._highlightOffset = 0;
proto._highlightPaddingLeft = 0;
proto._highlightPaddingRight = 0;
proto._letterSpacing = 0;
proto._textIndent = 0;
proto._cutSx = 0;
proto._cutEx = 0;
proto._cutSy = 0;
proto._cutEy = 0;
proto._advancedRenderer = false;






/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/TextTextureRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/TextTextureRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextTextureRenderer)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TextTextureRenderer {

    constructor(stage, canvas, settings) {
        this._stage = stage;
        this._canvas = canvas;
        this._context = this._canvas.getContext('2d');
        this._settings = settings;
    }

    getPrecision() {
        return this._settings.precision;
    };

    setFontProperties() {
        this._context.font = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.getFontSetting(this) : this._getFontSetting();
        this._context.textBaseline = this._settings.textBaseline;
    };

    _getFontSetting() {
        let ff = this._settings.fontFace;

        if (!Array.isArray(ff)) {
            ff = [ff];
        }

        let ffs = [];
        for (let i = 0, n = ff.length; i < n; i++) {
            if (ff[i] === "serif" || ff[i] === "sans-serif") {
                ffs.push(ff[i]);
            } else {
                ffs.push(`"${ff[i]}"`);
            }
        }

        return `${this._settings.fontStyle} ${this._settings.fontSize * this.getPrecision()}px ${ffs.join(",")}`
    }

    _load() {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isWeb && document.fonts) {
            const fontSetting = this._getFontSetting();
            try {
                if (!document.fonts.check(fontSetting, this._settings.text)) {
                    // Use a promise that waits for loading.
                    return document.fonts.load(fontSetting, this._settings.text).catch(err => {
                        // Just load the fallback font.
                        console.warn('[Lightning] Font load error', err, fontSetting);
                    }).then(() => {
                        if (!document.fonts.check(fontSetting, this._settings.text)) {
                            console.warn('[Lightning] Font not found', fontSetting);
                        }
                    });
                }
            } catch(e) {
                console.warn("[Lightning] Can't check font loading for " + fontSetting);
            }
        }
    }

    draw() {
        // We do not use a promise so that loading is performed syncronous when possible.
        const loadPromise = this._load();
        if (!loadPromise) {
            return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
        } else {
            return loadPromise.then(() => {
                return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
            });
        }
    }

    _calculateRenderInfo() {
        let renderInfo = {};

        const precision = this.getPrecision();

        const paddingLeft = this._settings.paddingLeft * precision;
        const paddingRight = this._settings.paddingRight * precision;
        const fontSize = this._settings.fontSize * precision;
        let offsetY = this._settings.offsetY === null ? null : (this._settings.offsetY * precision);
        let lineHeight = this._settings.lineHeight * precision;
        const w = this._settings.w * precision;
        const h = this._settings.h * precision;
        let wordWrapWidth = this._settings.wordWrapWidth * precision;
        const cutSx = this._settings.cutSx * precision;
        const cutEx = this._settings.cutEx * precision;
        const cutSy = this._settings.cutSy * precision;
        const cutEy = this._settings.cutEy * precision;
        const letterSpacing = (this._settings.letterSpacing || 0) * precision;
        const textIndent = this._settings.textIndent * precision;

        // Set font properties.
        this.setFontProperties();

        // Total width.
        let width = w || (2048 / this.getPrecision());

        // Inner width.
        let innerWidth = width - (paddingLeft);
        if (innerWidth < 10) {
            width += (10 - innerWidth);
            innerWidth += (10 - innerWidth);
        }

        if (!wordWrapWidth) {
            wordWrapWidth = innerWidth
        }

        // Text overflow
        if (this._settings.textOverflow && !this._settings.wordWrap) {
            let suffix;
            switch (this._settings.textOverflow) {
                case 'clip':
                    suffix = '';
                    break;
                case 'ellipsis':
                    suffix = this._settings.maxLinesSuffix;
                    break;
                default:
                    suffix = this._settings.textOverflow;
            }
            this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix)
        }

        // word wrap
        // preserve original text
        let linesInfo;
        if (this._settings.wordWrap) {
            linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
        } else {
            linesInfo = {l: this._settings.text.split(/(?:\r\n|\r|\n)/), n: []};
            let i, n = linesInfo.l.length;
            for (let i = 0; i < n - 1; i++) {
                linesInfo.n.push(i);
            }
        }
        let lines = linesInfo.l;

        if (this._settings.maxLines && lines.length > this._settings.maxLines) {
            let usedLines = lines.slice(0, this._settings.maxLines);

            let otherLines = null;
            if (this._settings.maxLinesSuffix) {
                // Wrap again with max lines suffix enabled.
                let w = this._settings.maxLinesSuffix ? this.measureText(this._settings.maxLinesSuffix) : 0;
                let al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - w, letterSpacing, textIndent);
                usedLines[usedLines.length - 1] = al.l[0] + this._settings.maxLinesSuffix;
                otherLines = [al.l.length > 1 ? al.l[1] : ''];
            } else {
                otherLines = [''];
            }

            // Re-assemble the remaining text.
            let i, n = lines.length;
            let j = 0;
            let m = linesInfo.n.length;
            for (i = this._settings.maxLines; i < n; i++) {
                otherLines[j] += (otherLines[j] ? " " : "") + lines[i];
                if (i + 1 < m && linesInfo.n[i + 1]) {
                    j++;
                }
            }

            renderInfo.remainingText = otherLines.join("\n");

            renderInfo.moreTextLines = true;

            lines = usedLines;
        } else {
            renderInfo.moreTextLines = false;
            renderInfo.remainingText = "";
        }

        // calculate text width
        let maxLineWidth = 0;
        let lineWidths = [];
        for (let i = 0; i < lines.length; i++) {
            let lineWidth = this.measureText(lines[i], letterSpacing) + (i === 0 ? textIndent : 0);
            lineWidths.push(lineWidth);
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }

        renderInfo.lineWidths = lineWidths;

        if (!w) {
            // Auto-set width to max text length.
            width = maxLineWidth + paddingLeft + paddingRight;
            innerWidth = maxLineWidth;
        }

        // calculate text height
        lineHeight = lineHeight || fontSize;

        let height;
        if (h) {
            height = h;
        } else {
            const baselineOffset = (this._settings.textBaseline != 'bottom') ? 0.5 * fontSize : 0;
            height = lineHeight * (lines.length - 1) + baselineOffset + Math.max(lineHeight, fontSize) + offsetY;
        }

        if (offsetY === null) {
            offsetY = fontSize;
        }

        renderInfo.w = width;
        renderInfo.h = height;
        renderInfo.lines = lines;
        renderInfo.precision = precision;

        if (!width) {
            // To prevent canvas errors.
            width = 1;
        }

        if (!height) {
            // To prevent canvas errors.
            height = 1;
        }

        if (cutSx || cutEx) {
            width = Math.min(width, cutEx - cutSx);
        }

        if (cutSy || cutEy) {
            height = Math.min(height, cutEy - cutSy);
        }

        renderInfo.width = width;
        renderInfo.innerWidth = innerWidth;
        renderInfo.height = height;
        renderInfo.fontSize = fontSize;
        renderInfo.cutSx = cutSx;
        renderInfo.cutSy = cutSy;
        renderInfo.cutEx = cutEx;
        renderInfo.cutEy = cutEy;
        renderInfo.lineHeight = lineHeight;
        renderInfo.lineWidths = lineWidths;
        renderInfo.offsetY = offsetY;
        renderInfo.paddingLeft = paddingLeft;
        renderInfo.paddingRight = paddingRight;
        renderInfo.letterSpacing = letterSpacing;
        renderInfo.textIndent = textIndent;

        return renderInfo;
    }

    _draw() {
        const renderInfo = this._calculateRenderInfo();
        const precision = this.getPrecision();

        // Add extra margin to prevent issue with clipped text when scaling.
        this._canvas.width = Math.ceil(renderInfo.width + this._stage.getOption('textRenderIssueMargin'));
        this._canvas.height = Math.ceil(renderInfo.height);

        // Canvas context has been reset.
        this.setFontProperties();

        if (renderInfo.fontSize >= 128) {
            // WpeWebKit bug: must force compositing because cairo-traps-compositor will not work with text first.
            this._context.globalAlpha = 0.01;
            this._context.fillRect(0, 0, 0.01, 0.01);
            this._context.globalAlpha = 1.0;
        }

        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
        }

        let linePositionX;
        let linePositionY;

        let drawLines = [];

        // Draw lines line by line.
        for (let i = 0, n = renderInfo.lines.length; i < n; i++) {
            linePositionX = i === 0 ? renderInfo.textIndent : 0;

            // By default, text is aligned to top
            linePositionY = (i * renderInfo.lineHeight) + renderInfo.offsetY;

            if (this._settings.verticalAlign == 'middle') {
                linePositionY += (renderInfo.lineHeight - renderInfo.fontSize) / 2;
            } else if (this._settings.verticalAlign == 'bottom') {
                linePositionY += renderInfo.lineHeight - renderInfo.fontSize;
            }

            if (this._settings.textAlign === 'right') {
                linePositionX += (renderInfo.innerWidth - renderInfo.lineWidths[i]);
            } else if (this._settings.textAlign === 'center') {
                linePositionX += ((renderInfo.innerWidth - renderInfo.lineWidths[i]) / 2);
            }
            linePositionX += renderInfo.paddingLeft;

            drawLines.push({text: renderInfo.lines[i], x: linePositionX, y: linePositionY, w: renderInfo.lineWidths[i]});
        }

        // Highlight.
        if (this._settings.highlight) {
            let color = this._settings.highlightColor || 0x00000000;

            let hlHeight = (this._settings.highlightHeight * precision || renderInfo.fontSize * 1.5);
            const offset = this._settings.highlightOffset * precision;
            const hlPaddingLeft = (this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision : renderInfo.paddingLeft);
            const hlPaddingRight = (this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision : renderInfo.paddingRight);

            this._context.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(color);
            for (let i = 0; i < drawLines.length; i++) {
                let drawLine = drawLines[i];
                this._context.fillRect((drawLine.x - hlPaddingLeft), (drawLine.y - renderInfo.offsetY + offset), (drawLine.w + hlPaddingRight + hlPaddingLeft), hlHeight);
            }
        }

        // Text shadow.
        let prevShadowSettings = null;
        if (this._settings.shadow) {
            prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];

            this._context.shadowColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.shadowColor);
            this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
            this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
            this._context.shadowBlur = this._settings.shadowBlur * precision;
        }

        this._context.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.textColor);
        for (let i = 0, n = drawLines.length; i < n; i++) {
            let drawLine = drawLines[i];

            if (renderInfo.letterSpacing === 0) {
                this._context.fillText(drawLine.text, drawLine.x, drawLine.y);
            } else {
                const textSplit = drawLine.text.split('');
                let x = drawLine.x;
                for (let i = 0, j = textSplit.length; i < j; i++) {
                    this._context.fillText(textSplit[i], x, drawLine.y);
                    x += this.measureText(textSplit[i], renderInfo.letterSpacing);
                }
            }
        }

        if (prevShadowSettings) {
            this._context.shadowColor = prevShadowSettings[0];
            this._context.shadowOffsetX = prevShadowSettings[1];
            this._context.shadowOffsetY = prevShadowSettings[2];
            this._context.shadowBlur = prevShadowSettings[3];
        }

        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
        }

        this.renderInfo = renderInfo;
    };

    wrapWord(word, wordWrapWidth, suffix) {
        const suffixWidth = this._context.measureText(suffix).width;
        const wordLen = word.length
        const wordWidth = this._context.measureText(word).width;

        /* If word fits wrapWidth, do nothing */
        if (wordWidth <= wordWrapWidth) {
            return word;
        }

        /* Make initial guess for text cuttoff */
        let cutoffIndex = Math.floor((wordWrapWidth * wordLen) / wordWidth);
        let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;

        /* In case guess was overestimated, shrink it letter by letter. */
        if (truncWordWidth > wordWrapWidth) {
            while (cutoffIndex > 0) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth > wordWrapWidth) {
                    cutoffIndex -= 1;
                } else {
                    break;
                }
            }

        /* In case guess was underestimated, extend it letter by letter. */
        } else {
            while (cutoffIndex < wordLen) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth < wordWrapWidth) {
                    cutoffIndex += 1;
                } else {
                    // Finally, when bound is crossed, retract last letter.
                    cutoffIndex -=1;
                    break;
                }
            }
        }

        /* If wrapWidth is too short to even contain suffix alone, return empty string */
        return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '');
    }

    /**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     */
    wrapText(text, wordWrapWidth, letterSpacing, indent = 0) {
        // Greedy wrapping algorithm that will wrap words as the line grows longer.
        // than its horizontal bounds.
        let lines = text.split(/\r?\n/g);
        let allLines = [];
        let realNewlines = [];
        for (let i = 0; i < lines.length; i++) {
            let resultLines = [];
            let result = '';
            let spaceLeft = wordWrapWidth - indent;
            let words = lines[i].split(' ');
            for (let j = 0; j < words.length; j++) {
                const wordWidth = this.measureText(words[j], letterSpacing);
                const wordWidthWithSpace = wordWidth + this.measureText(' ',letterSpacing);
                if (j === 0 || wordWidthWithSpace > spaceLeft) {
                    // Skip printing the newline if it's the first word of the line that is.
                    // greater than the word wrap width.
                    if (j > 0) {
                        resultLines.push(result);
                        result = '';
                    }
                    result += words[j];
                    spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
                }
                else {
                    spaceLeft -= wordWidthWithSpace;
                    result += ' ' + words[j];
                }
            }

            resultLines.push(result);
            result = '';

            allLines = allLines.concat(resultLines);

            if (i < lines.length - 1) {
                realNewlines.push(allLines.length);
            }
        }

        return {l: allLines, n: realNewlines};
    };

    measureText(word, space = 0) {
        if (!space) {
            return this._context.measureText(word).width;
        }
        return word.split('').reduce((acc, char) => {
            return acc + this._context.measureText(char).width + space;
        }, 0);
    }
    
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/TextTextureRendererAdvanced.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/TextTextureRendererAdvanced.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextTextureRendererAdvanced)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TextTextureRendererAdvanced {

    constructor(stage, canvas, settings) {
        this._stage = stage;
        this._canvas = canvas;
        this._context = this._canvas.getContext('2d');
        this._settings = settings;
    }

    getPrecision() {
        return this._settings.precision;
    };

    setFontProperties() {
        const font = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.getFontSetting(this) : this._getFontSetting();
        this._context.font = font;
        this._context.textBaseline = this._settings.textBaseline;
        return font;
    };

    _getFontSetting() {
        let ff = this._settings.fontFace;

        if (!Array.isArray(ff)) {
            ff = [ff];
        }

        let ffs = [];
        for (let i = 0, n = ff.length; i < n; i++) {
            if (ff[i] === "serif" || ff[i] === "sans-serif") {
                ffs.push(ff[i]);
            } else {
                ffs.push(`"${ff[i]}"`);
            }
        }

        return `${this._settings.fontStyle} ${this._settings.fontSize * this.getPrecision()}px ${ffs.join(",")}`
    }

    _load() {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isWeb && document.fonts) {
            const fontSetting = this._getFontSetting();
            try {
                if (!document.fonts.check(fontSetting, this._settings.text)) {
                    // Use a promise that waits for loading.
                    return document.fonts.load(fontSetting, this._settings.text).catch(err => {
                        // Just load the fallback font.
                        console.warn('Font load error', err, fontSetting);
                    }).then(() => {
                        if (!document.fonts.check(fontSetting, this._settings.text)) {
                            console.warn('Font not found', fontSetting);
                        }
                    });
                }
            } catch(e) {
                console.warn("Can't check font loading for " + fontSetting);
            }
        }
    }

    draw() {
        // We do not use a promise so that loading is performed syncronous when possible.
        const loadPromise = this._load();
        if (!loadPromise) {
            return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
        } else {
            return loadPromise.then(() => {
                return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
            });
        }
    }

    _calculateRenderInfo() {
        let renderInfo = {};

        const precision = this.getPrecision();

        const paddingLeft = this._settings.paddingLeft * precision;
        const paddingRight = this._settings.paddingRight * precision;
        const fontSize = this._settings.fontSize * precision;
        // const offsetY = this._settings.offsetY === null ? null : (this._settings.offsetY * precision);
        const lineHeight = this._settings.lineHeight * precision || fontSize;
        const w = this._settings.w != 0 ? this._settings.w * precision : 2048 / precision;
        // const h = this._settings.h * precision;
        const wordWrapWidth = this._settings.wordWrapWidth * precision;
        const cutSx = this._settings.cutSx * precision;
        const cutEx = this._settings.cutEx * precision;
        const cutSy = this._settings.cutSy * precision;
        const cutEy = this._settings.cutEy * precision;
        const letterSpacing = this._settings.letterSpacing || 0;

        // Set font properties.
        renderInfo.baseFont = this.setFontProperties();

        renderInfo.w = w;
        renderInfo.width = w;
        renderInfo.text = this._settings.text;
        renderInfo.precision = precision;
        renderInfo.fontSize = fontSize;
        renderInfo.lineHeight = lineHeight;
        renderInfo.letterSpacing = letterSpacing;
        renderInfo.textAlign = this._settings.textAlign;
        renderInfo.textColor = this._settings.textColor;
        renderInfo.verticalAlign = this._settings.verticalAlign;
        renderInfo.highlight = this._settings.highlight;
        renderInfo.highlightColor = this._settings.highlightColor;
        renderInfo.highlightHeight = this._settings.highlightHeight;
        renderInfo.highlightPaddingLeft = this._settings.highlightPaddingLeft;
        renderInfo.highlightPaddingRight = this._settings.highlightPaddingRight;
        renderInfo.highlightOffset = this._settings.highlightOffset;
        renderInfo.paddingLeft = this._settings.paddingLeft;
        renderInfo.paddingRight = this._settings.paddingRight;
        renderInfo.maxLines = this._settings.maxLines;
        renderInfo.maxLinesSuffix = this._settings.maxLinesSuffix;
        renderInfo.textOverflow = this._settings.textOverflow;
        renderInfo.wordWrap = this._settings.wordWrap;
        renderInfo.wordWrapWidth = wordWrapWidth;
        renderInfo.shadow = this._settings.shadow;
        renderInfo.shadowColor = this._settings.shadowColor;
        renderInfo.shadowOffsetX = this._settings.shadowOffsetX;
        renderInfo.shadowOffsetY = this._settings.shadowOffsetY;
        renderInfo.shadowBlur = this._settings.shadowBlur;
        renderInfo.cutSx = cutSx;
        renderInfo.cutEx = cutEx;
        renderInfo.cutSy = cutSy;
        renderInfo.cutEy = cutEy;
        renderInfo.textIndent = this._settings.textIndent * precision;
        renderInfo.wordBreak = this._settings.wordBreak;

        let text = renderInfo.text;
        let wrapWidth = renderInfo.wordWrap ? (renderInfo.wordWrapWidth || renderInfo.width) : renderInfo.width;

        // Text overflow
        if (renderInfo.textOverflow && !renderInfo.wordWrap) {
            let suffix;
            switch (this._settings.textOverflow) {
                case 'clip':
                    suffix = '';
                    break;
                case 'ellipsis':
                    suffix = this._settings.maxLinesSuffix;
                    break;
                default:
                    suffix = this._settings.textOverflow;
            }
            text = this.wrapWord(text, wordWrapWidth || renderInfo.w, suffix);
        }

        text = this.tokenize(text);
        text = this.parse(text);
        text = this.measure(text, letterSpacing, renderInfo.baseFont);

        if (renderInfo.textIndent) {
            text = this.indent(text, renderInfo.textIndent);
        }

        if (renderInfo.wordBreak) {
            text = text.reduce((acc, t) => acc.concat(this.wordBreak(t, wrapWidth, renderInfo.baseFont)), [])
            this.resetFontStyle()
        }

        // Calculate detailed drawing information
        let x = paddingLeft;
        let lineNo = 0;

        for (const t of text) {
            // Wrap text
            if (renderInfo.wordWrap && x + t.width > wrapWidth || t.text == '\n') {
                x = paddingLeft;
                lineNo += 1;
            }
            t.lineNo = lineNo;

            if (t.text == '\n') {
                continue;
            }

            t.x = x;
            x += t.width;
        }
        renderInfo.lineNum = lineNo + 1;

        // Vertical align
        let vaOffset = 0;
        if (renderInfo.verticalAlign == 'middle') {
            vaOffset += (renderInfo.lineHeight - renderInfo.fontSize) / 2;
        } else if (this._settings.verticalAlign == 'bottom') {
            vaOffset += renderInfo.lineHeight - renderInfo.fontSize;
        }

        // Calculate lines information
        renderInfo.lines = []
        for (let i = 0; i < renderInfo.lineNum; i++) {
            renderInfo.lines[i] = {
                width: 0,
                x: 0,
                y: renderInfo.lineHeight * i + vaOffset,
                text: [],
            }
        }

        for (let t of text) {
            renderInfo.lines[t.lineNo].text.push(t);
        }

        // Filter out white spaces at beginning and end of each line
        for (const l of renderInfo.lines) {
            if (l.text.length == 0) {
                continue;
            }

            const firstWord = l.text[0].text;
            const lastWord = l.text[l.text.length - 1].text;

            if (firstWord == '\n') {
                l.text.shift();
            }
            if (lastWord == ' ' || lastWord == '\n') {
                l.text.pop();
            }
        }


        // Calculate line width
        for (let l of renderInfo.lines) {
            l.width = l.text.reduce((acc, t) => acc + t.width, 0);
        }

        renderInfo.width = this._settings.w != 0 ? this._settings.w * precision : Math.max(...renderInfo.lines.map((l) => l.width)) + paddingRight;
        renderInfo.w = renderInfo.width;

        // Apply maxLinesSuffix
        if (renderInfo.maxLines && renderInfo.lineNum > renderInfo.maxLines && renderInfo.maxLinesSuffix) {
            const index = renderInfo.maxLines - 1;
            let lastLineText = text.filter((t) => t.lineNo == index)
            let suffix = renderInfo.maxLinesSuffix;
            suffix = this.tokenize(suffix);
            suffix = this.parse(suffix);
            suffix = this.measure(suffix, renderInfo.letterSpacing, renderInfo.baseFont)[0];
            suffix.lineNo = index;
            if (lastLineText.length) {
                suffix.x = lastLineText[lastLineText.length - 1].x + lastLineText[lastLineText.length - 1].width;
            } else {
                suffix.x = 0;
            }
            lastLineText.push(suffix)

            let _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
            while (_w > renderInfo.width || lastLineText[lastLineText.length - 2].text == ' ') {
                lastLineText.splice(lastLineText.length - 2, 1);
                _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
                const prev = lastLineText[lastLineText.length - 2] || {x: 0, width: 0}
                suffix.x = prev.x + prev.width;
                if (lastLineText.length < 2) {
                    break;
                }
            }

            renderInfo.lines[index].text = lastLineText;
            renderInfo.lines[index].width = _w;
        }

        if (this._settings.h) {
            renderInfo.h = this._settings.h;
        } else if (renderInfo.maxLines && renderInfo.maxLines < renderInfo.lineNum) {
            renderInfo.h = renderInfo.maxLines * renderInfo.lineHeight + fontSize / 2;
        } else {
            renderInfo.h = renderInfo.lineNum * renderInfo.lineHeight + fontSize / 2;
        }

        // Horizontal alignment offset
        if (renderInfo.textAlign == 'center') {
            for (let l of renderInfo.lines) {
                l.x = (renderInfo.width - l.width - paddingLeft) / 2;
            }
        } else if (renderInfo.textAlign == 'right') {
            for (let l of renderInfo.lines) {
                l.x = renderInfo.width - l.width - paddingLeft;
            }
        }

        return renderInfo;
    }

    _draw() {
        const renderInfo = this._calculateRenderInfo();
        const precision = this.getPrecision();
        const paddingLeft = renderInfo.paddingLeft * precision;

        // Set canvas dimensions
        let canvasWidth = renderInfo.w || renderInfo.width;
        if (renderInfo.cutSx || renderInfo.cutEx) {
            canvasWidth = Math.min(renderInfo.w, renderInfo.cutEx - renderInfo.cutSx);
        }

        let canvasHeight = renderInfo.h;
        if (renderInfo.cutSy || renderInfo.cutEy) {
            canvasHeight = Math.min(renderInfo.h, renderInfo.cutEy - renderInfo.cutSy);
        }

        this._canvas.width = Math.ceil(canvasWidth + this._stage.getOption('textRenderIssueMargin'));
        this._canvas.height = Math.ceil(canvasHeight);

        // Canvas context has been reset.
        this.setFontProperties();

        if (renderInfo.fontSize >= 128) {
            // WpeWebKit bug: must force compositing because cairo-traps-compositor will not work with text first.
            this._context.globalAlpha = 0.01;
            this._context.fillRect(0, 0, 0.01, 0.01);
            this._context.globalAlpha = 1.0;
        }

        // Cut
        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
        }

        // Highlight
        if (renderInfo.highlight) {
            const hlColor = renderInfo.highlightColor || 0x00000000;
            const hlHeight = renderInfo.highlightHeight ? renderInfo.highlightHeight * precision :  renderInfo.fontSize * 1.5;
            const hlOffset = renderInfo.highlightOffset ? renderInfo.highlightOffset * precision : 0;
            const hlPaddingLeft = (renderInfo.highlightPaddingLeft !== null ? renderInfo.highlightPaddingLeft * precision : renderInfo.paddingLeft);
            const hlPaddingRight = (renderInfo.highlightPaddingRight !== null ? renderInfo.highlightPaddingRight * precision : renderInfo.paddingRight);

            this._context.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(hlColor);
            const lineNum = renderInfo.maxLines ? Math.min(renderInfo.maxLines, renderInfo.lineNum) : renderInfo.lineNum; 
            for (let i = 0; i < lineNum; i++) {
                const l = renderInfo.lines[i];
                this._context.fillRect(l.x - hlPaddingLeft + paddingLeft, l.y + hlOffset, l.width + hlPaddingLeft + hlPaddingRight, hlHeight);
            }
        }

        // Text shadow.
        let prevShadowSettings = null;
        if (this._settings.shadow) {
            prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];

            this._context.shadowColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.shadowColor);
            this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
            this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
            this._context.shadowBlur = this._settings.shadowBlur * precision;
        }

        // Draw text
        const defaultColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.textColor);
        let currentColor = defaultColor;
        this._context.fillStyle = defaultColor;
        for (const line of renderInfo.lines) {
            for (const t of line.text) {
                let lx = 0;

                if (t.text == '\n') {
                    continue;
                }

                if (renderInfo.maxLines && t.lineNo >= renderInfo.maxLines) {
                    continue;
                }

                if (t.color != currentColor) {
                    currentColor = t.color;
                    this._context.fillStyle = currentColor;
                }

                this._context.font = t.fontStyle;

                // Draw with letter spacing
                if (t.letters) {
                    for (let l of t.letters) {
                        const _x = renderInfo.lines[t.lineNo].x + t.x + lx;
                        this._context.fillText(l.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
                        lx += l.width;
                    }
                // Standard drawing
                } else {
                    const _x = renderInfo.lines[t.lineNo].x + t.x;
                    this._context.fillText(t.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
                }
            }
        }

        // Reset text shadow
        if (prevShadowSettings) {
            this._context.shadowColor = prevShadowSettings[0];
            this._context.shadowOffsetX = prevShadowSettings[1];
            this._context.shadowOffsetY = prevShadowSettings[2];
            this._context.shadowBlur = prevShadowSettings[3];
        }

        // Reset cut translation
        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
        }
 
        // Postprocess renderInfo.lines to be compatible with standard version
        renderInfo.lines = renderInfo.lines.map((l) => l.text.reduce((acc, v) => acc + v.text, ''));
        if (renderInfo.maxLines) {
            renderInfo.lines = renderInfo.lines.slice(0, renderInfo.maxLines);
        }


        this.renderInfo = renderInfo;

    };

    measureText(word, space = 0) {
        if (!space) {
            return this._context.measureText(word).width;
        }
        return word.split('').reduce((acc, char) => {
            return acc + this._context.measureText(char).width + space;
        }, 0);
    }

    tokenize(text) {
        const re =/ |\n|<i>|<\/i>|<b>|<\/b>|<color=0[xX][0-9a-fA-F]{8}>|<\/color>/g
    
        const delimeters = text.match(re) || [];
        const words = text.split(re) || [];
    
        let final = [];
        for (let i = 0; i < words.length; i++) {
            final.push(words[i], delimeters[i])
        }
        final.pop()
        return final.filter((word) => word != '');
    
    }
    
    parse(tokens) {
        let italic = 0;
        let bold = 0;
        let colorStack = [_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.textColor)];
        let color = 0;

        const colorRegexp = /<color=(?<color>0[xX][0-9a-fA-F]{8})/;
    
        return tokens.map((t) => {
            if (t == '<i>') {
                italic += 1;
                t = '';
            } else if (t == '</i>' && italic > 0) {
                italic -= 1;
                t = '';
            } else if (t == '<b>') {
                bold += 1;
                t = '';
            } else if (t == '</b>' && bold > 0) {
                bold -= 1;
                t = '';
            } else if (t == '</color>') {
                if (colorStack.length > 1) {
                    color -= 1;
                    colorStack.pop();
                }
                t = '';
            } else if (colorRegexp.test(t)) {
                colorStack.push(_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(parseInt(colorRegexp.exec(t).groups['color'])));
                color += 1;
                t = '';
            }

            return {
                text: t,
                italic: italic,
                bold: bold,
                color: colorStack[color],
            }
        })
        .filter((o) => o.text != '');
    }

    applyFontStyle(word, baseFont) {
        let font = baseFont;
        if (word.bold) {
            font = 'bold ' + font;
        }
        if (word.italic) {
            font = 'italic ' + font;
        }
        this._context.font = font
        word.fontStyle = font;
    }

    resetFontStyle(baseFont) {
        this._context.font = baseFont;
    }

    measure(parsed, letterSpacing = 0, baseFont) {
        for (const p of parsed) {
            this.applyFontStyle(p, baseFont);
            p.width = this.measureText(p.text, letterSpacing);

            // Letter by letter detail for letter spacing
            if (letterSpacing > 0) {
                p.letters = p.text.split('').map((l) => {return {text: l}});
                for (let l of p.letters) {
                    l.width = this.measureText(l.text, letterSpacing);
                }
            }

        }
        this.resetFontStyle(baseFont);
        return parsed;
    }

    indent(parsed, textIndent) {
        parsed.splice(0, 0, {text: "", width: textIndent});
        return parsed;
    }

    wrapWord(word, wordWrapWidth, suffix) {
        const suffixWidth = this._context.measureText(suffix).width;
        const wordLen = word.length
        const wordWidth = this._context.measureText(word).width;

        /* If word fits wrapWidth, do nothing */
        if (wordWidth <= wordWrapWidth) {
            return word;
        }

        /* Make initial guess for text cuttoff */
        let cutoffIndex = Math.floor((wordWrapWidth * wordLen) / wordWidth);
        let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;

        /* In case guess was overestimated, shrink it letter by letter. */
        if (truncWordWidth > wordWrapWidth) {
            while (cutoffIndex > 0) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth > wordWrapWidth) {
                    cutoffIndex -= 1;
                } else {
                    break;
                }
            }

        /* In case guess was underestimated, extend it letter by letter. */
        } else {
            while (cutoffIndex < wordLen) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth < wordWrapWidth) {
                    cutoffIndex += 1;
                } else {
                    // Finally, when bound is crossed, retract last letter.
                    cutoffIndex -=1;
                    break;
                }
            }
        }

        /* If wrapWidth is too short to even contain suffix alone, return empty string */
        return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '')
    }

    _getBreakIndex(word, width) {
        const wordLen = word.length;
        const wordWidth = this.measureText(word);

        if (wordWidth <= width) {
            return {breakIndex: word.length, truncWordWidth: wordWidth};
        }

        let breakIndex = Math.floor((width * wordLen) / wordWidth);
        let truncWordWidth = this.measureText(word.substring(0, breakIndex))

        /* In case guess was overestimated, shrink it letter by letter. */
        if (truncWordWidth > width) {
            while (breakIndex > 0) {
                truncWordWidth = this.measureText(word.substring(0, breakIndex));
                if (truncWordWidth > width) {
                    breakIndex -= 1;
                } else {
                    break;
                }
            }

        /* In case guess was underestimated, extend it letter by letter. */
        } else {
            while (breakIndex < wordLen) {
                truncWordWidth = this.measureText(word.substring(0, breakIndex));
                if (truncWordWidth < width) {
                    breakIndex += 1;
                } else {
                    // Finally, when bound is crossed, retract last letter.
                    breakIndex -=1;
                    truncWordWidth = this.measureText(word.substring(0, breakIndex));
                    break;
                }
            }
        }
        return {breakIndex, truncWordWidth};

    }

    wordBreak(word, width, baseFont) {
        if (!word.text) {
            return word
        }
        this.applyFontStyle(word, baseFont)
        const parts = [];
        let text = word.text;
        if (!word.letters) {
            while (true) {
                const {breakIndex, truncWordWidth} = this._getBreakIndex(text, width);
                parts.push({...word});
                parts[parts.length - 1].text = text.slice(0, breakIndex);
                parts[parts.length - 1].width = truncWordWidth;

                if (breakIndex === text.length) {
                    break;
                }

                text = text.slice(breakIndex);
            }
        } else {
            let totalWidth = 0;
            let letters = [];
            let breakIndex = 0;
            for (const l of word.letters) {
                if (totalWidth + l.width >= width) {
                    parts.push({...word});
                    parts[parts.length - 1].text = text.slice(0, breakIndex);
                    parts[parts.length - 1].width = totalWidth;
                    parts[parts.length - 1].letters = letters;
                    text = text.slice(breakIndex);
                    totalWidth = 0;
                    letters = [];
                    breakIndex = 0;

                } else {
                    breakIndex += 1;
                    letters.push(l);
                    totalWidth += l.width;
                }
            }

            if (totalWidth > 0) {
                parts.push({...word});
                parts[parts.length - 1].text = text.slice(0, breakIndex);
                parts[parts.length - 1].width = totalWidth;
                parts[parts.length - 1].letters = letters;
            }
        }

        return parts;
    }
}

/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MultiSpline)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class MultiSpline {

    constructor() {
        this._clear();
    }

    _clear() {
        this._p = [];
        this._pe = [];
        this._idp = [];
        this._f = [];
        this._v = [];
        this._lv = [];
        this._sm = [];
        this._s = [];
        this._ve = [];
        this._sme = [];
        this._se = [];

        this._length = 0;
    }

    parse(rgba, def) {
        let i, n;
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(def)) {
            def = {0: def}
        }

        let defaultSmoothness = 0.5;

        let items = [];
        for (let key in def) {
            if (def.hasOwnProperty(key)) {
                let obj = def[key];
                if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(obj)) {
                    obj = {v: obj}
                }

                let p = parseFloat(key);

                if (key === "sm") {
                    defaultSmoothness = obj.v;
                } else if (!isNaN(p) && p >= 0 && p <= 2) {
                    obj.p = p;

                    obj.f = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(obj.v);
                    obj.lv = obj.f ? obj.v(0, 0) : obj.v;

                    items.push(obj);
                }
            }
        }

        // Sort by progress value.
        items = items.sort(function(a, b) {return a.p - b.p});

        n = items.length;

        for (i = 0; i < n; i++) {
            let last = (i === n - 1);
            if (!items[i].hasOwnProperty('pe')) {
                // Progress.
                items[i].pe = last ? (items[i].p <= 1 ? 1 : 2 /* support onetotwo stop */) : items[i + 1].p;
            } else {
                // Prevent multiple items at the same time.
                const max = i < n - 1 ? items[i + 1].p : 1;
                if (items[i].pe > max) {
                    items[i].pe = max;
                }
            }
            if (items[i].pe === items[i].p) {
                items[i].idp = 0;
            } else {
                items[i].idp = 1 / (items[i].pe - items[i].p);
            }
        }

        // Color merger: we need to split/combine RGBA components.

        // Calculate bezier helper values.;
        for (i = 0; i < n; i++) {
            if (!items[i].hasOwnProperty('sm')) {
                // Smoothness.;
                items[i].sm = defaultSmoothness;
            }
            if (!items[i].hasOwnProperty('s')) {
                // Slope.;
                if (i === 0 || i === n - 1 || (items[i].p === 1 /* for onetotwo */)) {
                    // Horizontal slope at start and end.;
                    items[i].s = rgba ? [0, 0, 0, 0] : 0;
                } else {
                    const pi = items[i - 1];
                    const ni = items[i + 1];
                    if (pi.p === ni.p) {
                        items[i].s = rgba ? [0, 0, 0, 0] : 0;
                    } else {
                        if (rgba) {
                            const nc = MultiSpline.getRgbaComponents(ni.lv);
                            const pc = MultiSpline.getRgbaComponents(pi.lv);
                            const d = 1 / (ni.p - pi.p);
                            items[i].s = [
                                d * (nc[0] - pc[0]),
                                d * (nc[1] - pc[1]),
                                d * (nc[2] - pc[2]),
                                d * (nc[3] - pc[3])
                            ];
                        } else {
                            items[i].s = (ni.lv - pi.lv) / (ni.p - pi.p);
                        }
                    }
                }
            }
        }

        for (i = 0; i < n - 1; i++) {
            // Calculate value function.;
            if (!items[i].f) {

                let last = (i === n - 1);
                if (!items[i].hasOwnProperty('ve')) {
                    items[i].ve = last ? items[i].lv : items[i + 1].lv;
                }

                // We can only interpolate on numeric values. Non-numeric values are set literally when reached time.
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(items[i].v) && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(items[i].lv)) {
                    if (!items[i].hasOwnProperty('sme')) {
                        items[i].sme = last ? defaultSmoothness : items[i + 1].sm;
                    }
                    if (!items[i].hasOwnProperty('se')) {
                        items[i].se = last ? (rgba ? [0, 0, 0, 0] : 0) : items[i + 1].s;
                    }

                    // Generate spline.;
                    if (rgba) {
                        items[i].v = MultiSpline.getSplineRgbaValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
                    } else {
                        items[i].v = MultiSpline.getSplineValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
                    }

                    items[i].f = true;
                }
            }
        }

        if (this.length) {
            this._clear();
        }

        for (i = 0, n = items.length; i < n; i++) {
            this._add(items[i]);
        }
    }

    _add(item) {
        this._p.push(item.p || 0);
        this._pe.push(item.pe || 0);
        this._idp.push(item.idp || 0);
        this._f.push(item.f || false);
        this._v.push(item.hasOwnProperty('v') ? item.v : 0 /* v might be false or null */ );
        this._lv.push(item.lv || 0);
        this._sm.push(item.sm || 0);
        this._s.push(item.s || 0);
        this._ve.push(item.ve || 0);
        this._sme.push(item.sme || 0);
        this._se.push(item.se || 0);
        this._length++;
    }

    _getItem(p) {
        const n = this._length;
        if (!n) {
            return -1;
        }

        if (p < this._p[0]) {
            return 0;
        }

        for (let i = 0; i < n; i++) {
            if (this._p[i] <= p && p < this._pe[i]) {
                return i;
            }
        }

        return n - 1;
    }

    getValue(p) {
        const i = this._getItem(p);
        if (i === -1) {
            return undefined;
        } else {
            if (this._f[i]) {
                const o = Math.min(1, Math.max(0, (p - this._p[i]) * this._idp[i]));
                return this._v[i](o);
            } else {
                return this._v[i];
            }
        }
    }

    get length() {
        return this._length;
    }

    static getRgbaComponents(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        let a = ((argb / 16777216) | 0);
        return [r, g, b, a];
    };

    static getSplineValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
        // Normalize slopes because we use a spline that goes from 0 to 1.
        let dp = p2 - p1;
        s1 *= dp;
        s2 *= dp;

        let helpers = MultiSpline.getSplineHelpers(v1, v2, o1, i2, s1, s2);
        if (!helpers) {
            return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;

                return v2 * p + v1 * (1 - p);
            };
        } else {
            return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;
                return MultiSpline.calculateSpline(helpers, p);
            };
        }
    };

    static getSplineRgbaValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
        // Normalize slopes because we use a spline that goes from 0 to 1.
        let dp = p2 - p1;
        s1[0] *= dp;
        s1[1] *= dp;
        s1[2] *= dp;
        s1[3] *= dp;
        s2[0] *= dp;
        s2[1] *= dp;
        s2[2] *= dp;
        s2[3] *= dp;

        let cv1 = MultiSpline.getRgbaComponents(v1);
        let cv2 = MultiSpline.getRgbaComponents(v2);

        let helpers = [
            MultiSpline.getSplineHelpers(cv1[0], cv2[0], o1, i2, s1[0], s2[0]),
            MultiSpline.getSplineHelpers(cv1[1], cv2[1], o1, i2, s1[1], s2[1]),
            MultiSpline.getSplineHelpers(cv1[2], cv2[2], o1, i2, s1[2], s2[2]),
            MultiSpline.getSplineHelpers(cv1[3], cv2[3], o1, i2, s1[3], s2[3])
        ];

        if (!helpers[0]) {
            return function (p) {
                // Linear.
                if (p === 0) return v1;
                if (p === 1) return v2;

                return MultiSpline.mergeColors(v2, v1, p);
            };
        } else {
            return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;

                return MultiSpline.getArgbNumber([
                    Math.min(255, MultiSpline.calculateSpline(helpers[0], p)),
                    Math.min(255, MultiSpline.calculateSpline(helpers[1], p)),
                    Math.min(255, MultiSpline.calculateSpline(helpers[2], p)),
                    Math.min(255, MultiSpline.calculateSpline(helpers[3], p))
                ]);
            };
        }

    };

    /**
     * Creates helpers to be used in the spline function.
     * @param {number} v1
     *   From value.
     * @param {number} v2
     *   To value.
     * @param {number} o1
     *   From smoothness (0 = linear, 1 = smooth).
     * @param {number} s1
     *   From slope (0 = horizontal, infinite = vertical).
     * @param {number} i2
     *   To smoothness.
     * @param {number} s2
     *   To slope.
     * @returns {Number[]}
     *   The helper values to be supplied to the spline function.
     *   If the configuration is actually linear, null is returned.
     */
    static getSplineHelpers(v1, v2, o1, i2, s1, s2) {
        if (!o1 && !i2) {
            // Linear.
            return null;
        }

        // Cubic bezier points.
        // http://cubic-bezier.com/
        let csx = o1;
        let csy = v1 + s1 * o1;
        let cex = 1 - i2;
        let cey = v2 - s2 * i2;

        let xa = 3 * csx - 3 * cex + 1;
        let xb = -6 * csx + 3 * cex;
        let xc = 3 * csx;

        let ya = 3 * csy - 3 * cey + v2 - v1;
        let yb = 3 * (cey + v1) - 6 * csy;
        let yc = 3 * (csy - v1);
        let yd = v1;

        return [xa, xb, xc, ya, yb, yc, yd];
    };

    /**
     * Calculates the intermediate spline value based on the specified helpers.
     * @param {number[]} helpers
     *   Obtained from getSplineHelpers.
     * @param {number} p
     * @return {number}
     */
    static calculateSpline(helpers, p) {
        let xa = helpers[0];
        let xb = helpers[1];
        let xc = helpers[2];
        let ya = helpers[3];
        let yb = helpers[4];
        let yc = helpers[5];
        let yd = helpers[6];

        if (xa === -2 && ya === -2 && xc === 0 && yc === 0) {
            // Linear.
            return p;
        }

        // Find t for p.
        let t = 0.5, cbx, dx;

        for (let it = 0; it < 20; it++) {
            // Cubic bezier function: f(t)=t*(t*(t*a+b)+c).
            cbx = t * (t * (t * xa + xb) + xc);

            dx = p - cbx;
            if (dx > -1e-8 && dx < 1e-8) {
                // Solution found!
                return t * (t * (t * ya + yb) + yc) + yd;
            }

            // Cubic bezier derivative function: f'(t)=t*(t*(3*a)+2*b)+c
            let cbxd = t * (t * (3 * xa) + 2 * xb) + xc;

            if (cbxd > 1e-10 && cbxd < 1e-10) {
                // Problematic. Fall back to binary search method.
                break;
            }

            t += dx / cbxd;
        }

        // Fallback: binary search method. This is more reliable when there are near-0 slopes.
        let minT = 0;
        let maxT = 1;
        for (let it = 0; it < 20; it++) {
            t = 0.5 * (minT + maxT);

            // Cubic bezier function: f(t)=t*(t*(t*a+b)+c)+d.
            cbx = t * (t * (t * xa + xb) + xc);

            dx = p - cbx;
            if (dx > -1e-8 && dx < 1e-8) {
                // Solution found!
                return t * (t * (t * ya + yb) + yc) + yd;
            }

            if (dx < 0) {
                maxT = t;
            } else {
                minT = t;
            }
        }

        return t;
    };

    static mergeColors(c1, c2, p) {
        let r1 = ((c1 / 65536) | 0) % 256;
        let g1 = ((c1 / 256) | 0) % 256;
        let b1 = c1 % 256;
        let a1 = ((c1 / 16777216) | 0);

        let r2 = ((c2 / 65536) | 0) % 256;
        let g2 = ((c2 / 256) | 0) % 256;
        let b2 = c2 % 256;
        let a2 = ((c2 / 16777216) | 0);

        let r = r1 * p + r2 * (1 - p);
        let g = g1 * p + g2 * (1 - p);
        let b = b1 * p + b2 * (1 - p);
        let a = a1 * p + a2 * (1 - p);

        return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
    };

    static getArgbNumber(rgba) {
        rgba[0] = Math.max(0, Math.min(255, rgba[0]));
        rgba[1] = Math.max(0, Math.min(255, rgba[1]));
        rgba[2] = Math.max(0, Math.min(255, rgba[2]));
        rgba[3] = Math.max(0, Math.min(255, rgba[3]));
        let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
        if (v < 0) {
            v = 0xFFFFFFFF + v + 1;
        }
        return v;
    };
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/ObjMerger.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/ObjMerger.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjMerger)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ObjMerger {

    static isMf(f) {
        return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(f) && f.__mf;
    }

    static mf(f) {
        // Set as merge function.
        f.__mf = true;
        return f;
    }

    static merge(a, b) {
        const aks = Object.keys(a);
        const bks = Object.keys(b);

        if (!bks.length) {
            return a;
        }

        // Create index array for all elements.
        const ai = {};
        const bi = {};
        for (let i = 0, n = bks.length; i < n; i++) {
            const key = bks[i];
            ai[key] = -1;
            bi[key] = i;
        }
        for (let i = 0, n = aks.length; i < n; i++) {
            const key = aks[i];
            ai[key] = i;
            if (bi[key] === undefined) {
                bi[key] = -1;
            }
        }

        const aksl = aks.length;

        const result = {};
        for (let i = 0, n = bks.length; i < n; i++) {
            const key = bks[i];

            // Prepend all items in a that are not in b - before the now added b attribute.
            const aIndex = ai[key];
            let curIndex = aIndex;
            while(--curIndex >= 0) {
                const akey = aks[curIndex];
                if (bi[akey] !== -1) {
                    // Already found? Stop processing.
                    // Not yet found but exists in b? Also stop processing: wait until we find it in b.
                    break;
                }
            }
            while(++curIndex < aIndex) {
                const akey = aks[curIndex];
                result[akey] = a[akey];
            }

            const bv = b[key];
            const av = a[key];
            let r;
            if (this.isMf(bv)) {
                r = bv(av);
            } else {
                if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(av) || !_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(bv)) {
                    r = bv;
                } else {
                    r = ObjMerger.merge(av, bv);
                }
            }

            // When marked as undefined, property is deleted.
            if (r !== undefined) {
                result[key] = r;
            }
        }

        // Append remaining final items in a.
        let curIndex = aksl;
        while(--curIndex >= 0) {
            const akey = aks[curIndex];
            if (bi[akey] !== -1) {
                break;
            }
        }
        while(++curIndex < aksl) {
            const akey = aks[curIndex];
            result[akey] = a[akey];
        }

        return result;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjectListProxy)
/* harmony export */ });
/* harmony import */ var _tree_ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/ObjectList.mjs */ "./node_modules/@lightningjs/core/src/tree/ObjectList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages the list of children for an element.
 */



class ObjectListProxy extends _tree_ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(target) {
        super();
        this._target = target;
    }

    onAdd(item, index) {
        this._target.addAt(item, index);
    }

    onRemove(item, index) {
        this._target.removeAt(index);
    }

    onSync(removed, added, order) {
        this._target._setByArray(order);
    }

    onSet(item, index) {
        this._target.setAt(item, index);
    }

    onMove(item, fromIndex, toIndex) {
        this._target.setAt(item, toIndex);
    }

    createItem(object) {
        return this._target.createItem(object);
    }

    isItem(object) {
        return this._target.isItem(object);
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjectListWrapper)
/* harmony export */ });
/* harmony import */ var _ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObjectListProxy.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages the list of children for an element.
 */



class ObjectListWrapper extends _ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(target, wrap) {
        super(target);
        this._wrap = wrap;
    }

    wrap(item) {
        let wrapper = this._wrap(item);
        item._wrapper = wrapper;
        return wrapper;
    }

    onAdd(item, index) {
        item = this.wrap(item);
        super.onAdd(item, index);
    }

    onRemove(item, index) {
        super.onRemove(item, index);
    }

    onSync(removed, added, order) {
        added.forEach(a => this.wrap(a));
        order = order.map(a => a._wrapper);
        super.onSync(removed, added, order);
    }

    onSet(item, index) {
        item = this.wrap(item);
        super.onSet(item, index);
    }

    onMove(item, fromIndex, toIndex) {
        super.onMove(item, fromIndex, toIndex);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/Tools.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/Tools.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tools)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../textures/StaticCanvasTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class Tools {

    static getCanvasTexture(canvasFactory, lookupId) {
        return {type: _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], content: {factory: canvasFactory, lookupId: lookupId}}
    }

    static getRoundRect(w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
        if (!Array.isArray(radius)){
            // upper-left, upper-right, bottom-right, bottom-left.
            radius = [radius, radius, radius, radius];
        }

        let factory = (cb, stage) => {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isSpark) {
                stage.platform.createRoundRect(cb, stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor);
            } else {
                cb(null, this.createRoundRect(stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor));
            }
        };
        let id = 'rect' + [w, h, strokeWidth, strokeColor, fill ? 1 : 0, fillColor].concat(radius).join(",");
        return Tools.getCanvasTexture(factory, id);
    }

    static createRoundRect(stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
        if (fill === undefined) fill = true;
        if (strokeWidth === undefined) strokeWidth = 0;

        let canvas = stage.platform.getDrawingCanvas();
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        canvas.width = w + strokeWidth + 2;
        canvas.height = h + strokeWidth + 2;

        ctx.beginPath();
        let x = 0.5 * strokeWidth + 1, y = 0.5 * strokeWidth + 1;

        ctx.moveTo(x + radius[0], y);
        ctx.lineTo(x + w - radius[1], y);
        ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
        ctx.lineTo(x + w, y + h - radius[2]);
        ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
        ctx.lineTo(x + radius[3], y + h);
        ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
        ctx.lineTo(x, y + radius[0]);
        ctx.arcTo(x, y, x + radius[0], y, radius[0]);
        ctx.closePath();

        if (fill) {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(fillColor)) {
                ctx.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(fillColor);
            } else {
                ctx.fillStyle = "white";
            }
            ctx.fill();
        }

        if (strokeWidth) {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(strokeColor)) {
                ctx.strokeStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(strokeColor);
            } else {
                ctx.strokeStyle = "white";
            }
            ctx.lineWidth = strokeWidth;
            ctx.stroke();
        }

        return canvas;
    }

    static getShadowRect(w, h, radius = 0, blur = 5, margin = blur * 2) {
        if (!Array.isArray(radius)){
            // upper-left, upper-right, bottom-right, bottom-left.
            radius = [radius, radius, radius, radius];
        }

        let factory = (cb, stage) => {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isSpark) {
                stage.platform.createShadowRect(cb, stage, w, h, radius, blur, margin);
            } else {
                cb(null, this.createShadowRect(stage, w, h, radius, blur, margin));
            }
        };
        let id = 'shadow' + [w, h, blur, margin].concat(radius).join(",");
        return Tools.getCanvasTexture(factory, id);
    }

    static createShadowRect(stage, w, h, radius, blur, margin) {
        let canvas = stage.platform.getDrawingCanvas();
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        canvas.width = w + margin * 2;
        canvas.height = h + margin * 2;

        // WpeWebKit bug: we experienced problems without this with shadows in noncompositedwebgl mode.
        ctx.globalAlpha = 0.01;
        ctx.fillRect(0, 0, 0.01, 0.01);
        ctx.globalAlpha = 1.0;

        ctx.shadowColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(0xFFFFFFFF);
        ctx.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(0xFFFFFFFF);
        ctx.shadowBlur = blur;
        ctx.shadowOffsetX = (w + 10) + margin;
        ctx.shadowOffsetY = margin;

        ctx.beginPath();
        const x = -(w + 10);
        const y = 0;

        ctx.moveTo(x + radius[0], y);
        ctx.lineTo(x + w - radius[1], y);
        ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
        ctx.lineTo(x + w, y + h - radius[2]);
        ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
        ctx.lineTo(x + radius[3], y + h);
        ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
        ctx.lineTo(x, y + radius[0]);
        ctx.arcTo(x, y, x + radius[0], y, radius[0]);
        ctx.closePath();
        ctx.fill();

        return canvas;
    }

    static getSvgTexture(url, w, h) {
        let factory = (cb, stage) => {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isSpark) {
                stage.platform.createSvg(cb, stage, url, w, h);
            } else {
                this.createSvg(cb, stage, url, w, h);
            }
        };
        let id = 'svg' + [w, h, url].join(",");
        return Tools.getCanvasTexture(factory, id);
    }

    static createSvg(cb, stage, url, w, h) {
        let canvas = stage.platform.getDrawingCanvas();
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        let img = new Image();
        img.onload = () => {
            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            cb(null, canvas);
        }
        img.onError = (err) => {
            cb(err);
        }

        // On the PS4 platform setting the `crossOrigin` attribute on images
        // can cause CORS failures.
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isPS4) {
            img.crossOrigin = "Anonymous";
        }

        img.src = url;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/WebGLStateManager.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/WebGLStateManager.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Utils {

    static isFunction(value) {
        return typeof value === 'function';
    }

    static isNumber(value) {
        return typeof value === 'number';
    }

    static isInteger(value) {
        return (typeof value === 'number' && (value % 1) === 0);
    }

    static isBoolean(value) {
        return value === true || value === false;
    }

    static isString(value) {
        return typeof value == 'string';
    }

    static isObject(value) {
        let type = typeof value;
        return !!value && (type == 'object' || type == 'function');
    }

    static isPlainObject(value) {
        let type = typeof value;
        return !!value && (type == 'object');
    }

    static isObjectLiteral(value){
        return typeof value === 'object' && value && value.constructor === Object
    }

    static getArrayIndex(index, arr) {
        return Utils.getModuloIndex(index, arr.length);
    }

    static equalValues(v1, v2) {
        if ((typeof v1) !== (typeof v2)) return false
        if (Utils.isObjectLiteral(v1)) {
            return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2)
        } else if (Array.isArray(v1)) {
            return Array.isArray(v2) && Utils.equalArrays(v1, v2)
        } else {
            return v1 === v2
        }
    }

    static equalObjectLiterals(obj1, obj2) {
        let keys1 = Object.keys(obj1);
        let keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) {
            return false
        }

        for (let i = 0, n = keys1.length; i < n; i++) {
            const k1 = keys1[i];
            const k2 = keys2[i];
            if (k1 !== k2) {
                return false
            }

            const v1 = obj1[k1];
            const v2 = obj2[k2];

            if (!Utils.equalValues(v1, v2)) {
                return false
            }
        }

        return true;
    }

    static equalArrays(v1, v2) {
        if (v1.length !== v2.length) {
            return false
        }
        for (let i = 0, n = v1.length; i < n; i++) {
            if (!this.equalValues(v1[i], v2[i])) {
                return false
            }
        }

        return true
    }

}

/**
 * Maintains the state of a WebGLRenderingContext.
 */
class WebGLState {

    constructor(id, gl) {
        this._id = id;
        this._gl = gl;
        this._program = undefined;
        this._buffers = new Map();
        this._framebuffers = new Map();
        this._renderbuffers = new Map();

        // Contains vertex attribute definition arrays (enabled, size, type, normalized, stride, offset).
        this._vertexAttribs = new Array(16);
        this._nonDefaultFlags = new Set();
        this._settings = new Map();
        this._textures = new Array(8);
        this._maxTexture = 0;
        this._activeTexture = gl.TEXTURE0;
        this._pixelStorei = new Array(5);
    }

    _getDefaultFlag(cap) {
        return (cap === this._gl.DITHER);
    }

    setFlag(cap, v) {
        const def = this._getDefaultFlag(cap);
        if (v === def) {
            return this._nonDefaultFlags.delete(cap);
        } else {
            if (!this._nonDefaultFlags.has(cap)) {
                this._nonDefaultFlags.add(cap);
                return true;
            } else {
                return false;
            }
        }
    }

    setBuffer(target, buffer) {
        const change = this._buffers.get(target) !== buffer;
        this._buffers.set(target, buffer);

        if (change && (target === this._gl.ARRAY_BUFFER)) {
            // When the array buffer is changed all attributes are cleared.
            this._vertexAttribs = [];
        }

        return change;
    }

    setFramebuffer(target, buffer) {
        const change = this._framebuffers.get(target) !== buffer;
        this._framebuffers.set(target, buffer);
        return change;
    }

    setRenderbuffer(target, buffer) {
        const change = this._renderbuffers.get(target) !== buffer;
        this._renderbuffers.set(target, buffer);
        return change;
    }

    setProgram(program) {
        const change = this._program !== program;
        this._program = program;
        return change
    }

    setSetting(func, v) {
        const s = this._settings.get(func);
        const change = !s || !Utils.equalValues(s, v);
        this._settings.set(func, v);
        return change
    }

    disableVertexAttribArray(index) {
        const va = this._vertexAttribs[index];
        if (va && va[5]) {
            va[5] = false;
            return true;
        }
        return false;
    }

    enableVertexAttribArray(index) {
        const va = this._vertexAttribs[index];
        if (va) {
            if (!va[0]) {
                va[0] = true;
                return true;
            }
        } else {
            this._vertexAttribs[index] = [0, 0, 0, 0, 0, true];
            return true;
        }
        return false;
    }

    vertexAttribPointer(index, props) {
        let va = this._vertexAttribs[index];
        let equal = false;
        if (va) {
            equal = va[0] === props[0] &&
                va[1] === props[1] &&
                va[2] === props[2] &&
                va[3] === props[3] &&
                va[4] === props[4];
        }

        if (equal) {
            return false;
        } else {
            props[5] = va ? va[5] : false;
            return true;
        }
    }

    setActiveTexture(texture) {
        const changed = this._activeTexture !== texture;
        this._activeTexture = texture;
        return changed;
    }

    bindTexture(target, texture) {
        const activeIndex = WebGLState._getTextureIndex(this._activeTexture);
        this._maxTexture = Math.max(this._maxTexture, activeIndex + 1);
        const current = this._textures[activeIndex];
        const targetIndex = WebGLState._getTextureTargetIndex(target);
        if (current) {
            if (current[targetIndex] === texture) {
                return false;
            }
            current[targetIndex] = texture;
            return true;
        } else {
            if (texture) {
                this._textures[activeIndex] = [];
                this._textures[activeIndex][targetIndex] = texture;
                return true
            } else {
                return false
            }
        }
    }

    setPixelStorei(pname, param) {
        const i = WebGLState._getPixelStoreiIndex(pname);
        const change = !Utils.equalValues(this._pixelStorei[i], param);
        this._pixelStorei[i] = param;
        return change;
    }

    migrate(s) {
        const t = this;

        // Warning: migrate should call the original prototype methods directly.

        this._migrateFlags(t, s);

        // useProgram
        if (s._program !== t._program) {
            this._gl._useProgram(s._program);
        }

        this._migrateFramebuffers(t, s);
        this._migrateRenderbuffers(t, s);

        const buffersChanged = this._migrateBuffers(t, s);
        this._migrateAttributes(t, s, buffersChanged);

        this._migrateFlags(t, s);

        this._migrateSettings(t, s);

        this._migratePixelStorei(t, s);
        
        this._migrateTextures(t, s);
        
    }

    _migratePixelStorei(t, s) {
        for (let i = 0, n = t._pixelStorei.length; i < n; i++) {
            if (t._pixelStorei[i] !== s._pixelStorei[i]) {
                const value = s._pixelStorei[i] !== undefined ? s._pixelStorei[i] : WebGLState._getDefaultPixelStoreiByIndex(i);
                this._gl._pixelStorei(WebGLState._getPixelStoreiByIndex(i), value);
            }
        }
    }

    _migrateTextures(t, s) {
        const max = Math.max(t._maxTexture, s._maxTexture);

        let activeTexture = t._activeTexture;

        for (let i = 0; i < max; i++) {
            const sTargets = s._textures[i];
            const tTargets = t._textures[i];
            const textureNumb = WebGLState._getTextureByIndex(i);

            const targetMax = Math.max(tTargets ? tTargets.length : 0, sTargets ? sTargets.length : 0);
            for (let j = 0, n = targetMax; j < n; j++) {
                const target = WebGLState._getTextureTargetByIndex(j);
                if (activeTexture !== textureNumb) {
                    this._gl._activeTexture(textureNumb);
                    activeTexture = textureNumb;
                }

                const texture = (sTargets && sTargets[j]) || null;
                this._gl._bindTexture(target, texture);
            }
        }

        if (s._activeTexture !== activeTexture) {
            this._gl._activeTexture(s._activeTexture);
        }
    }

    _migrateBuffers(t, s) {
        s._buffers.forEach((framebuffer, target) => {
            if (t._buffers.get(target) !== framebuffer) {
                this._gl._bindBuffer(target, framebuffer);
            }
        });

        t._buffers.forEach((buffer, target) => {
            const b = s._buffers.get(target);
            if (b === undefined) {
                this._gl._bindBuffer(target, null);
            }
        });
        return (s._buffers.get(this._gl.ARRAY_BUFFER) !== t._buffers.get(this._gl.ARRAY_BUFFER))
    }

    _migrateFramebuffers(t, s) {
        s._framebuffers.forEach((framebuffer, target) => {
            if (t._framebuffers.get(target) !== framebuffer) {
                this._gl._bindFramebuffer(target, framebuffer);
            }
        });

        t._framebuffers.forEach((framebuffer, target) => {
            const fb = s._framebuffers.get(target);
            if (fb === undefined) {
                this._gl._bindFramebuffer(target, null);
            }
        });
    }

    _migrateRenderbuffers(t, s) {
        s._renderbuffers.forEach((renderbuffer, target) => {
            if (t._renderbuffers.get(target) !== renderbuffer) {
                this._gl._bindRenderbuffer(target, renderbuffer);
            }
        });

        t._renderbuffers.forEach((renderbuffer, target) => {
            const fb = s._renderbuffers.get(target);
            if (fb === undefined) {
                this._gl._bindRenderbuffer(target, null);
            }
        });
    }

    _migrateAttributes(t, s, buffersChanged) {

        if (!buffersChanged) {
            t._vertexAttribs.forEach((attrib, index) => {
                if (!s._vertexAttribs[index]) {
                    // We can't 'delete' a vertex attrib so we'll disable it.
                    this._gl._disableVertexAttribArray(index);
                }
            });

            s._vertexAttribs.forEach((attrib, index) => {
                this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[4]);
                if (attrib[5]) {
                    this._gl._enableVertexAttribArray(index);
                } else {
                    this._gl._disableVertexAttribArray(index);
                }
            });
        } else {
            // When buffers are changed, previous attributes were reset automatically.
            s._vertexAttribs.forEach((attrib, index) => {
                if (attrib[0]) {
                    // Do not set vertex attrib pointer when it was just the default value.
                    this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[3], attrib[4]);
                }
                if (attrib[5]) {
                    this._gl._enableVertexAttribArray(index);
                }
            });
        }
    }

    _migrateSettings(t, s) {
        const defaults = this.constructor.getDefaultSettings();
        t._settings.forEach((value, func) => {
            const name = func.name || func.xname;
            if (!s._settings.has(func)) {
                let args = defaults.get(name);
                if (Utils.isFunction(args)) {
                    args = args(this._gl);
                }
                // We are actually setting the setting for optimization purposes.
                s._settings.set(func, args);
                func.apply(this._gl, args);
            }
        });
        s._settings.forEach((value, func) => {
            const tValue = t._settings.get(func);
            if (!tValue || !Utils.equalValues(tValue, value)) {
                func.apply(this._gl, value);
            }
        });
    }

    _migrateFlags(t, s) {
        t._nonDefaultFlags.forEach(setting => {
            if (!s._nonDefaultFlags.has(setting)) {
                if (this._getDefaultFlag(setting)) {
                    this._gl._enable(setting);
                } else {
                    this._gl._disable(setting);
                }
            }
        });
        s._nonDefaultFlags.forEach(setting => {
            if (!t._nonDefaultFlags.has(setting)) {
                if (this._getDefaultFlag(setting)) {
                    this._gl._disable(setting);
                } else {
                    this._gl._enable(setting);
                }
            }
        });
    }

    static getDefaultSettings() {
        if (!this._defaultSettings) {
            this._defaultSettings = new Map();
            const d = this._defaultSettings;
            const g = WebGLRenderingContext.prototype;
            d.set("viewport", function(gl) {return [0,0,gl.canvas.width, gl.canvas.height]});
            d.set("scissor", function(gl) {return [0,0,gl.canvas.width, gl.canvas.height]});
            d.set("blendColor", [0, 0, 0, 0]);
            d.set("blendEquation", [g.FUNC_ADD]);
            d.set("blendEquationSeparate", [g.FUNC_ADD, g.FUNC_ADD]);
            d.set("blendFunc", [g.ONE, g.ZERO]);
            d.set("blendFuncSeparate", [g.ONE, g.ZERO, g.ONE, g.ZERO]);
            d.set("clearColor", [0, 0, 0, 0]);
            d.set("clearDepth", [1]);
            d.set("clearStencil", [0]);
            d.set("colorMask", [true, true, true, true]);
            d.set("cullFace", [g.BACK]);
            d.set("depthFunc", [g.LESS]);
            d.set("depthMask", [true]);
            d.set("depthRange", [0, 1]);
            d.set("frontFace", [g.CCW]);
            d.set("lineWidth", [1]);
            d.set("polygonOffset", [0, 0]);
            d.set("sampleCoverage", [1, false]);
            d.set("stencilFunc", [g.ALWAYS, 0, 1]);
            d.set("_stencilFuncSeparateFront", [g.ALWAYS, 0, 1]);
            d.set("_stencilFuncSeparateBack", [g.ALWAYS, 0, 1]);
            d.set("_stencilFuncSeparateFrontAndBack", [g.ALWAYS, 0, 1]);
            d.set("stencilMask", [1]);
            d.set("_stencilMaskSeparateFront", [1]);
            d.set("_stencilMaskSeparateBack", [1]);
            d.set("_stencilMaskSeparateFrontAndBack", [1]);
            d.set("stencilOp", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("_stencilOpSeparateFront", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("_stencilOpSeparateBack", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("_stencilOpSeparateFrontAndBack", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("vertexAttrib1f", []);
            d.set("vertexAttrib1fv", []);
            d.set("vertexAttrib2f", []);
            d.set("vertexAttrib2fv", []);
            d.set("vertexAttrib3f", []);
            d.set("vertexAttrib3fv", []);
            d.set("vertexAttrib4f", []);
            d.set("vertexAttrib4fv", []);
        }
        return this._defaultSettings
    }

    static _getTextureTargetIndex(target) {
        switch(target) {
            case 0x0DE1:
                /* TEXTURE_2D */
                return 0;
            case 0x8513:
                /* TEXTURE_CUBE_MAP */
                return 1;
            default:
                // Shouldn't happen.
                throw new Error('Unknown texture target: ' + target);
        }
    }

    static _getTextureTargetByIndex(index) {
        if (!this._textureTargetIndices) {
            this._textureTargetIndices = [0x0DE1, 0x8513];
        }
        return this._textureTargetIndices[index]
    }

    static _getTextureIndex(index) {
        return index - 0x84C0 /* GL_TEXTURE0 */;
    }

    static _getTextureByIndex(index) {
        return index + 0x84C0;
    }

    static _getPixelStoreiIndex(pname) {
        switch(pname) {
            case 0x0D05:
                /* PACK_ALIGNMENT */
                return 0;
            case 0x0CF5:
                /* UNPACK_ALIGNMENT */
                return 1;
            case 0x9240:
                /* UNPACK_FLIP_Y_WEBGL */
                return 2;
            case 0x9241:
                /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */
                return 3;
            case 0x9243:
                /* UNPACK_COLORSPACE_CONVERSION_WEBGL */
                return 4;
                //@todo: support WebGL2 properties, see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei
            case 0x9245:
                /* UNPACK_FLIP_BLUE_RED */
                return 5;
            default:
                // Shouldn't happen.
                throw new Error('Unknown pixelstorei: ' + pname);
        }
    }

    static _getPixelStoreiByIndex(index) {
        if (!this._pixelStoreiIndices) {
            this._pixelStoreiIndices = [0x0D05, 0x0CF5, 0x9240, 0x9241, 0x9243];
        }
        return this._pixelStoreiIndices[index]
    }

    static _getDefaultPixelStoreiByIndex(index) {
        if (!this._pixelStoreiDefaults) {
            this._pixelStoreiDefaults = [4, 4, false, false, WebGLRenderingContext.prototype.BROWSER_DEFAULT_WEBGL];
        }
        return this._pixelStoreiDefaults[index]
    }
}

class WebGLStateManager {

    _initStateManager(id = "default") {
        this._states = {};
        this._state = this._getState(id);
    }

    _getState(id) {
        if (!this._states[id]) {
            this._states[id] = new WebGLState(id, this);
        }
        return this._states[id];
    }

    switchState(id = "default") {
        if (this._state._id !== id) {
            const newState = this._getState(id);
            this._state.migrate(newState);
            this._state = newState;
        }
    }

    $useProgram(program) {
        if (this._state.setProgram(program))
            this._useProgram(program);
    }

    $bindBuffer(target, fb) {
        if (this._state.setBuffer(target, fb))
            this._bindBuffer(target, fb);
    }

    $bindFramebuffer(target, fb) {
        if (this._state.setFramebuffer(target, fb))
            this._bindFramebuffer(target, fb);
    }

    $bindRenderbuffer(target, fb) {
        if (this._state.setRenderbuffer(target, fb))
            this._bindRenderbuffer(target, fb);
    }

    $enable(cap) {
        if (this._state.setFlag(cap, true))
            this._enable(cap);
    }

    $disable(cap) {
        if (this._state.setFlag(cap, false))
            this._disable(cap);
    }

    $viewport(x, y, w, h) {
        if (this._state.setSetting(this._viewport, [x, y, w, h]))
            this._viewport(x, y, w, h);
    }

    $scissor(x, y, w, h) {
        if (this._state.setSetting(this._scissor, [x, y, w, h]))
            this._scissor(x, y, w, h);
    }

    $disableVertexAttribArray(index) {
        if (this._state.disableVertexAttribArray(index))
            this._disableVertexAttribArray(index);
    }

    $enableVertexAttribArray(index) {
        if (this._state.enableVertexAttribArray(index))
            this._enableVertexAttribArray(index);
    }

    $vertexAttribPointer(index, size, type, normalized, stride, offset) {
        if (this._state.vertexAttribPointer(index, [size, type, normalized, stride, offset]))
            this._vertexAttribPointer(index, size, type, normalized, stride, offset);
    }

    $activeTexture(texture) {
        if (this._state.setActiveTexture(texture))
            this._activeTexture(texture);
    }

    $bindTexture(target, texture) {
        if (this._state.bindTexture(target, texture))
            this._bindTexture(target, texture);
    }

    $pixelStorei(pname, param) {
        if (this._state.setPixelStorei(pname, param)) {
            this._pixelStorei(pname, param);
        }
    }

    $stencilFuncSeparate(face, func, ref, mask) {
        let f;
        switch(face) {
            case this.FRONT:
                f = this._stencilFuncSeparateFront;
                break;
            case this.BACK:
                f = this._stencilFuncSeparateBack;
                break;
            case this.FRONT_AND_BACK:
                f = this._stencilFuncSeparateFrontAndBack;
                break;
        }

        if (this._state.setSetting(f, [func, ref, mask]))
            f.apply(this, [func, ref, mask]);
    }

    _stencilFuncSeparateFront(func, ref, mask) {
        this._stencilFuncSeparate(this.FRONT, func, ref, mask);
    }

    _stencilFuncSeparateBack(func, ref, mask) {
        this._stencilFuncSeparate(this.BACK, func, ref, mask);
    }

    _stencilFuncSeparateFrontAndBack(func, ref, mask) {
        this._stencilFuncSeparate(this.FRONT_AND_BACK, func, ref, mask);
    }

    $stencilMaskSeparate(face, mask) {
        let f;
        switch(face) {
            case this.FRONT:
                f = this._stencilMaskSeparateFront;
                break;
            case this.BACK:
                f = this._stencilMaskSeparateBack;
                break;
            case this.FRONT_AND_BACK:
                f = this._stencilMaskSeparateFrontAndBack;
                break;
        }

        if (this._state.setSetting(f, [mask]))
            f.apply(this, [mask]);
    }

    _stencilMaskSeparateFront(mask) {
        this._stencilMaskSeparate(this.FRONT, mask);
    }

    _stencilMaskSeparateBack(mask) {
        this._stencilMaskSeparate(this.BACK, mask);
    }

    _stencilMaskSeparateFrontAndBack(mask) {
        this._stencilMaskSeparate(this.FRONT_AND_BACK, mask);
    }

    $stencilOpSeparate(face, fail, zfail, zpass) {
        let f;
        switch(face) {
            case this.FRONT:
                f = this._stencilOpSeparateFront;
                break;
            case this.BACK:
                f = this._stencilOpSeparateBack;
                break;
            case this.FRONT_AND_BACK:
                f = this._stencilOpSeparateFrontAndBack;
                break;
        }

        if (this._state.setSetting(f, [fail, zfail, zpass]))
            f.apply(this, [fail, zfail, zpass]);
    }

    _stencilOpSeparateFront(fail, zfail, zpass) {
        this._stencilOpSeparate(this.FRONT, fail, zfail, zpass);
    }

    _stencilOpSeparateBack(fail, zfail, zpass) {
        this._stencilOpSeparate(this.BACK, fail, zfail, zpass);
    }

    _stencilOpSeparateFrontAndBack(fail, zfail, zpass) {
        this._stencilOpSeparate(this.FRONT_AND_BACK, fail, zfail, zpass);
    }

    $blendColor(red, green, blue, alpha) {
        if (this._state.setSetting(this._blendColor, [red, green, blue, alpha]))
            this._blendColor(red, green, blue, alpha);
    }

    $blendEquation(mode) {
        if (this._state.setSetting(this._blendEquation, [mode]))
            this._blendEquation(mode);
    }

    $blendEquationSeparate(modeRGB, modeAlpha) {
        if (this._state.setSetting(this._blendEquationSeparate, [modeRGB, modeAlpha]))
            this._blendEquationSeparate(modeRGB, modeAlpha);
    }

    $blendFunc(sfactor, dfactor) {
        if (this._state.setSetting(this._blendFunc, [sfactor, dfactor]))
            this._blendFunc(sfactor, dfactor);
    }

    $blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
        if (this._state.setSetting(this._blendFuncSeparate, [srcRGB, dstRGB, srcAlpha, dstAlpha]))
            this._blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    }

    $clearColor(red, green, blue, alpha) {
        if (this._state.setSetting(this._clearColor, [red, green, blue, alpha]))
            this._clearColor(red, green, blue, alpha);
    }

    $clearDepth(depth) {
        if (this._state.setSetting(this._clearDepth, [depth]))
            this._clearDepth(depth);
    }

    $clearStencil(s) {
        if (this._state.setSetting(this._clearStencil, [s]))
            this._clearStencil(s);
    }

    $colorMask(red, green, blue, alpha) {
        if (this._state.setSetting(this._colorMask, [red, green, blue, alpha]))
            this._colorMask(red, green, blue, alpha);
    }

    $cullFace(mode) {
        if (this._state.setSetting(this._cullFace, [mode]))
            this._cullFace(mode);
    }

    $depthFunc(func) {
        if (this._state.setSetting(this._depthFunc, [func]))
            this._depthFunc(func);
    }

    $depthMask(flag) {
        if (this._state.setSetting(this._depthMask, [flag]))
            this._depthMask(flag);
    }

    $depthRange(zNear, zFar) {
        if (this._state.setSetting(this._depthRange, [zNear, zFar]))
            this._depthRange(zNear, zFar);
    }

    $frontFace(mode) {
        if (this._state.setSetting(this._frontFace, [mode]))
            this._frontFace(mode);
    }

    $lineWidth(width) {
        if (this._state.setSetting(this._lineWidth, [width]))
            this._lineWidth(width);
    }

    $polygonOffset(factor, units) {
        if (this._state.setSetting(this._polygonOffset, [factor, units]))
            this._polygonOffset(factor, units);
    }

    $sampleCoverage(value, invert) {
        if (this._state.setSetting(this._sampleCoverage, [value, invert]))
            this._sampleCoverage(value, invert);
    }

    $stencilFunc(func, ref, mask) {
        if (this._state.setSetting(this._stencilFunc, [func, ref, mask]))
            this._stencilFunc(func, ref, mask);
    }

    $stencilMask(mask) {
        if (this._state.setSetting(this._stencilMask, [mask]))
            this._stencilMask(mask);
    }

    $stencilOp(fail, zfail, zpass) {
        if (this._state.setSetting(this._stencilOp, [fail, zfail, zpass]))
            this._stencilOp(fail, zfail, zpass);
    }

    $vertexAttrib1f(indx, x) {
        if (this._state.setSetting(this._vertexAttrib1f, [indx, x]))
            this._vertexAttrib1f(indx, x);
    }

    $vertexAttrib1fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib1fv, [indx, values]))
            this._vertexAttrib1fv(indx, values);
    }

    $vertexAttrib2f(indx, x, y) {
        if (this._state.setSetting(this._vertexAttrib2f, [indx, x, y]))
            this._vertexAttrib2f(indx, x, y);
    }

    $vertexAttrib2fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib2fv, [indx, values]))
            this._vertexAttrib2fv(indx, values);
    }

    $vertexAttrib3f(indx, x, y, z) {
        if (this._state.setSetting(this._vertexAttrib3f, [indx, x, y, z]))
            this._vertexAttrib3f(indx, x, y, z);
    }

    $vertexAttrib3fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib3fv, [indx, values]))
            this._vertexAttrib3fv(indx, values);
    }

    $vertexAttrib4f(indx, x, y, z, w) {
        if (this._state.setSetting(this._vertexAttrib4f, [indx, x, y, z, w]))
            this._vertexAttrib4f(indx, x, y, z, w);
    }

    $vertexAttrib4fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib4fv, [indx, values]))
            this._vertexAttrib4fv(indx, values);
    }

    /**
     * Sets up the rendering context for context sharing.
     * @param {WebGLRenderingContext} gl
     * @param {string} id
     */
    static enable(gl, id = "default") {
        const names = Object.getOwnPropertyNames(WebGLStateManager.prototype);
        const WebGLRenderingContextProto = gl.__proto__;
        names.forEach(name => {
            if (name !== "constructor") {
                const method = WebGLStateManager.prototype[name];
                if (name.charAt(0) === "$") {
                    name = name.substr(1);
                }
                if (gl[name] !== method) {
                    if (gl[name]) {
                        if (!gl[name].name) {
                            // We do this for compatibility with the Chrome WebGL Inspector plugin.
                            gl[name].xname = name;
                        }
                        gl['_' + name] = gl[name];
                    }
                    gl[name] = method;
                }
            }
        });

        WebGLStateManager.prototype._initStateManager.call(gl, id);

        return gl;
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebGLStateManager);


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Base.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Base.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Base {

    static defaultSetter(obj, name, value) {
        obj[name] = value;
    }

    static patchObject(obj, settings) {
        if (!_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(settings)) {
            console.error("[Lightning] Settings must be object literal");
        } else {
            let names = Object.keys(settings);
            for (let i = 0, n = names.length; i < n; i++) {
                let name = names[i];

                this.patchObjectProperty(obj, name, settings[name]);
            }
        }
    }

    static patchObjectProperty(obj, name, value) {
        let setter = obj.setSetting || Base.defaultSetter;

        if (name.charAt(0) === "_") {
            // Disallow patching private variables.
            if (name !== "__create") {
                console.error("[Lightning] Patch of private property '" + name + "' is not allowed");
            }
        } else if (name !== "type") {
            // Type is a reserved keyword to specify the class type on creation.
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(value) && value.__local) {
                // Local function (Base.local(s => s.something))
                value = value.__local(obj);
            }

            setter(obj, name, value);
        }
    }

    static local(func) {
        // This function can be used as an object setting, which is called with the target object.
        func.__local = true;
    }


}





/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Element.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Element.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Element)
/* harmony export */ });
/* harmony import */ var _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/ElementCore.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _Shader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/* harmony import */ var _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../textures/ImageTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs");
/* harmony import */ var _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../textures/TextTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTexture.mjs");
/* harmony import */ var _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../textures/SourceTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs");
/* harmony import */ var _animation_Transition_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../animation/Transition.mjs */ "./node_modules/@lightningjs/core/src/animation/Transition.mjs");
/* harmony import */ var _ElementChildList_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ElementChildList.mjs */ "./node_modules/@lightningjs/core/src/tree/ElementChildList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Render tree node.
 */









class Element {

    constructor(stage) {
        this.stage = stage;

        this.__id = Element.id++;

        this.__start();

        // EventEmitter constructor.
        this._hasEventListeners = false;

        this.__core = new _core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);

        /**
         * A reference that can be used while merging trees.
         * @type {string}
         */
        this.__ref = null;

        /**
         * An element is attached if it is a descendant of the stage root.
         * @type {boolean}
         */
        this.__attached = false;

        /**
         * An element is enabled when it is attached and it is visible (worldAlpha > 0).
         * @type {boolean}
         */
        this.__enabled = false;

        /**
         * An element is active when it is enabled and it is within bounds.
         * @type {boolean}
         */
        this.__active = false;

        /**
         * @type {Element}
         */
        this.__parent = null;

        /**
         * The texture that is currently set.
         * @type {Texture}
         */
        this.__texture = null;

        /**
         * The currently displayed texture. While this.texture is loading, this one may be different.
         * @type {Texture}
         */
        this.__displayedTexture = null;

        /**
         * Tags that can be used to identify/search for a specific element.
         * @type {String[]}
         */
        this.__tags = null;

        /**
         * The tree's tags mapping.
         * This contains all elements for all known tags, at all times.
         * @type {Map}
         */
        this.__treeTags = null;

        /**
         * Creates a tag context: tagged elements in this branch will not be reachable from ancestors of this elements.
         * @type {boolean}
         */
        this.__tagRoot = false;

        /**
         * (Lazy-initialised) list of children owned by this elements.
         * @type {ElementChildList}
         */
        this.__childList = null;

        this._w = 0;

        this._h = 0;
    }

    __start() {
    }

    get id() {
        return this.__id;
    }

    set ref(ref) {
        if (this.__ref !== ref) {
            const charcode = ref.charCodeAt(0);
            if (!_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(charcode)) {
                this._throwError("Ref must start with an upper case character: " + ref);
            }
            if (this.__ref !== null) {
                this.removeTag(this.__ref);
                if (this.__parent) {
                    this.__parent.__childList.clearRef(this.__ref);
                }
            }

            this.__ref = ref;

            if (this.__ref) {
                this._addTag(this.__ref);
                if (this.__parent) {
                    this.__parent.__childList.setRef(this.__ref, this);
                }
            }
        }
    }

    get ref() {
        return this.__ref;
    }

    get core() {
        return this.__core;
    }

    setAsRoot() {
        this.__core.setAsRoot();
        this._updateAttachedFlag();
        this._updateEnabledFlag();
    }

    get isRoot() {
        return this.__core.isRoot;
    }

    _setParent(parent) {
        if (this.__parent === parent) return;

        if (this.__parent) {
            this._unsetTagsParent();
        }

        this.__parent = parent;

        if (parent) {
            this._setTagsParent();
        }

        this._updateAttachedFlag();
        this._updateEnabledFlag();
        this._updateCollision();

        if (this.isRoot && parent) {
            this._throwError("Root should not be added as a child! Results are unspecified!");
        }
    };

    getDepth() {
        let depth = 0;

        let p = this.__parent;
        while(p) {
            depth++;
            p = p.__parent;
        }

        return depth;
    };

    getAncestor(l) {
        let p = this;
        while (l > 0 && p.__parent) {
            p = p.__parent;
            l--;
        }
        return p;
    };

    getAncestors() {
        const a = [];
        let p = this;
        while (p) {
            a.push(p);
            p = p.__parent;
        }
        return a;
    }

    getAncestorAtDepth(depth) {
        let levels = this.getDepth() - depth;
        if (levels < 0) {
            return null;
        }
        return this.getAncestor(levels);
    };

    isAncestorOf(c) {
        let p = c;
        while(p = p.parent) {
            if (this === p) {
                return true;
            }
        }
        return false;
    };

    getSharedAncestor(c) {
        let o1 = this;
        let o2 = c;
        let l1 = o1.getDepth();
        let l2 = o2.getDepth();
        if (l1 > l2) {
            o1 = o1.getAncestor(l1 - l2);
        } else if (l2 > l1) {
            o2 = o2.getAncestor(l2 - l1);
        }

        do {
            if (o1 === o2) {
                return o1;
            }

            o1 = o1.__parent;
            o2 = o2.__parent;
        } while (o1 && o2);

        return null;
    };

    get attached() {
        return this.__attached;
    }

    get enabled() {
        return this.__enabled;
    }

    get active() {
        return this.__active;
    }

    _isAttached() {
        return (this.__parent ? this.__parent.__attached : (this.stage.root === this));
    };

    _isEnabled() {
        return this.__core.visible && (this.__core.alpha > 0) && (this.__parent ? this.__parent.__enabled : (this.stage.root === this));
    };

    _isActive() {
        return this._isEnabled() && this.withinBoundsMargin;
    };

    /**
     * Updates the 'attached' flag for this branch.
     */
    _updateAttachedFlag() {
        let newAttached = this._isAttached();
        if (this.__attached !== newAttached) {
            this.__attached = newAttached;

            if (newAttached) {
                this._onSetup();
            }

            let children = this._children.get();
            if (children) {
                let m = children.length;
                if (m > 0) {
                    for (let i = 0; i < m; i++) {
                        children[i]._updateAttachedFlag();
                    }
                }
            }

            if (newAttached) {
                this._onAttach();
            } else {
                this._onDetach();
            }
        }
    };

    /**
     * Updates the 'enabled' flag for this branch.
     */
    _updateEnabledFlag() {
        let newEnabled = this._isEnabled();
        if (this.__enabled !== newEnabled) {
            if (newEnabled) {
                this._onEnabled();
                this._setEnabledFlag();
            } else {
                this._onDisabled();
                this._unsetEnabledFlag();
            }

            let children = this._children.get();
            if (children) {
                let m = children.length;
                if (m > 0) {
                    for (let i = 0; i < m; i++) {
                        children[i]._updateEnabledFlag();
                    }
                }
            }
        }
    };

    _setEnabledFlag() {
        this.__enabled = true;

        // Force re-check of texture because dimensions might have changed (cutting).
        this._updateDimensions();
        this._updateTextureCoords();

        if (this.__texture) {
            this.__texture.addElement(this);
        }

        if (this.withinBoundsMargin) {
            this._setActiveFlag();
        }

        if (this.__core.shader) {
            this.__core.shader.addElement(this.__core);
        }

    }

    _unsetEnabledFlag() {
        if (this.__active) {
            this._unsetActiveFlag();
        }

        if (this.__texture) {
            this.__texture.removeElement(this);
        }

        if (this.__core.shader) {
            this.__core.shader.removeElement(this.__core);
        }

        if (this._texturizer) {
            this.texturizer.filters.forEach(filter => filter.removeElement(this.__core));
        }

        this.__enabled = false;
    }

    _setActiveFlag() {
        this.__active = true;

        // This must happen before enabling the texture, because it may already be loaded or load directly.
        if (this.__texture) {
            this.__texture.incActiveCount();
        }

        if (this.__texture) {
            this._enableTexture();
        }
        this._onActive();
    }

    _unsetActiveFlag() {
        if (this.__texture) {
            this.__texture.decActiveCount();
        }

        this.__active = false;
        if (this.__texture) {
            this._disableTexture();
        }

        if (this._hasTexturizer()) {
            this.texturizer.deactivate();
        }

        this._onInactive();
    }

    _onSetup() {
    }

    _onAttach() {
    }

    _onDetach() {
    }

    _onEnabled() {
    }

    _onDisabled() {
    }

    _onActive() {
    }

    _onInactive() {
    }

    _onResize() {
    }

    _getRenderWidth() {
        if (this._w) {
            return this._w;
        } else if (this.__displayedTexture) {
            return this.__displayedTexture.getRenderWidth();
        } else if (this.__texture) {
            // Texture already loaded, but not yet updated (probably because this element is not active).
            return this.__texture.getRenderWidth();
        } else {
            return 0;
        }
    };

    _getRenderHeight() {
        if (this._h) {
            return this._h;
        } else if (this.__displayedTexture) {
            return this.__displayedTexture.getRenderHeight();
        } else if (this.__texture) {
            // Texture already loaded, but not yet updated (probably because this element is not active).
            return this.__texture.getRenderHeight();
        } else {
            return 0;
        }
    };

    get renderWidth() {
        if (this.__enabled) {
            // Render width is only maintained if this element is enabled.
            return this.__core.getRenderWidth();
        } else {
            return this._getRenderWidth();
        }
    }

    get renderHeight() {
        if (this.__enabled) {
            return this.__core.getRenderHeight();
        } else {
            return this._getRenderHeight();
        }
    }

    get finalX() {
        return this.__core.x;
    }

    get finalY() {
        return this.__core.y;
    }

    get finalW() {
        return this.__core.w;
    }

    get finalH() {
        return this.__core.h;
    }

    textureIsLoaded() {
        return this.__texture && this.__texture.isLoaded();
    }

    loadTexture() {
        if (this.__texture) {
            this.__texture.load();

            if (!this.__texture.isUsed() || !this._isEnabled()) {
                // Loading the texture will have no effect on the dimensions of this element.
                // Manually update them, so that calcs can be performed immediately in userland.
                this._updateDimensions();
            }
        }
    }

    _enableTextureError() {
        // txError event should automatically be re-triggered when a element becomes active.
        const loadError = this.__texture.loadError;
        if (loadError) {
            this.emit('txError', loadError, this.__texture._source);
        }
    }

    _enableTexture() {
        if (this.__texture.isLoaded()) {
            this._setDisplayedTexture(this.__texture);
        } else {
            // We don't want to retain the old 'ghost' image as it wasn't visible anyway.
            this._setDisplayedTexture(null);

            this._enableTextureError();
        }
    }

    _disableTexture() {
        // We disable the displayed texture because, when the texture changes while invisible, we should use that w, h,
        // mw, mh for checking within bounds.
        this._setDisplayedTexture(null);
    }

    get texture() {
        return this.__texture;
    }

    set texture(v) {
        let texture;
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v)) {
            if (v.type) {
                texture = new v.type(this.stage);
            } else {
                texture = this.texture;
            }

            if (texture) {
                _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObject(texture, v);
            }
        } else if (!v) {
            texture = null;
        } else {
            if (v.isTexture) {
                texture = v;
            } else if (v.isTextureSource) {
                texture = new _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](this.stage);
                texture.textureSource = v;
            } else {
                console.error("[Lightning] Please specify a texture type.");
                return;
            }
        }

        const prevTexture = this.__texture;
        if (texture !== prevTexture) {
            this.__texture = texture;

            if (this.__texture) {
                if (this.__enabled) {
                    this.__texture.addElement(this);

                    if (this.withinBoundsMargin) {
                        if (this.__texture.isLoaded()) {
                            this._setDisplayedTexture(this.__texture);
                        } else {
                            this._enableTextureError();
                        }
                    }
                }
            } else {
                // Make sure that current texture is cleared when the texture is explicitly set to null.
                this._setDisplayedTexture(null);
            }

            if (prevTexture && prevTexture !== this.__displayedTexture) {
                prevTexture.removeElement(this);
            }

            this._updateDimensions();
        }
    }

    get displayedTexture() {
        return this.__displayedTexture;
    }

    _setDisplayedTexture(v) {
        let prevTexture = this.__displayedTexture;

        if (prevTexture && (v !== prevTexture)) {
            if (this.__texture !== prevTexture) {
                // The old displayed texture is deprecated.
                prevTexture.removeElement(this);
            }
        }

        const prevSource = this.__core.displayedTextureSource ? this.__core.displayedTextureSource._source : null;
        const sourceChanged = (v ? v._source : null) !== prevSource;

        this.__displayedTexture = v;
        this._updateDimensions();

        if (this.__displayedTexture) {
            if (sourceChanged) {
                // We don't need to reference the displayed texture because it was already referenced (this.texture === this.displayedTexture).
                this._updateTextureCoords();
                this.__core.setDisplayedTextureSource(this.__displayedTexture._source);
            }
        } else {
            this.__core.setDisplayedTextureSource(null);
        }

        if (sourceChanged) {
            if (this.__displayedTexture) {
                this.emit('txLoaded', this.__displayedTexture);
            } else {
                this.emit('txUnloaded', this.__displayedTexture);
            }
        }
    }

    onTextureSourceLoaded() {
        // This function is called when element is enabled, but we only want to set displayed texture for active elements.
        if (this.active) {
            // We may be dealing with a texture reloading, so we must force update.
            this._setDisplayedTexture(this.__texture);
        }
    };

    onTextureSourceLoadError(e) {
        this.emit('txError', e, this.__texture._source);
    };

    forceRenderUpdate() {
        this.__core.setHasRenderUpdates(3);
    }

    onDisplayedTextureClippingChanged() {
        this._updateDimensions();
        this._updateTextureCoords();
    };

    onPrecisionChanged() {
        this._updateDimensions();
    };

    onDimensionsChanged(w, h) {
        if (this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]) {
            this.texture.w = w;
            this.texture.h = h;
            this.w = w;
            this.h = h;
        }
    }

    _updateDimensions() {
        let w = this._getRenderWidth();
        let h = this._getRenderHeight();

        let unknownSize = false;
        if (!w || !h) {
            if (!this.__displayedTexture && this.__texture) {
                // We use a 'max width' replacement instead in the ElementCore calcs.
                // This makes sure that it is able to determine withinBounds.
                w = w || this.__texture.mw;
                h = h || this.__texture.mh;

                if ((!w || !h) && this.__texture.isAutosizeTexture()) {
                    unknownSize = true;
                }
            }
        }

        if (this.__core.setDimensions(w, h, unknownSize)) {
            this._onResize();
        }
    }

    _updateTextureCoords() {
        if (this.displayedTexture && this.displayedTexture._source) {
            let displayedTexture = this.displayedTexture;
            let displayedTextureSource = this.displayedTexture._source;

            let tx1 = 0, ty1 = 0, tx2 = 1.0, ty2 = 1.0;
            if (displayedTexture.clipping) {
                // Apply texture clipping.
                let w = displayedTextureSource.getRenderWidth();
                let h = displayedTextureSource.getRenderHeight();
                let iw, ih, rw, rh;
                iw = 1 / w;
                ih = 1 / h;

                if (displayedTexture.pw) {
                    rw = (displayedTexture.pw) * iw;
                } else {
                    rw = (w - displayedTexture.px) * iw;
                }

                if (displayedTexture.ph) {
                    rh = displayedTexture.ph * ih;
                } else {
                    rh = (h - displayedTexture.py) * ih;
                }

                iw *= (displayedTexture.px);
                ih *= (displayedTexture.py);

                tx1 = iw;
                ty1 = ih;
                tx2 = tx2 * rw + iw;
                ty2 = ty2 * rh + ih;

                tx1 = Math.max(0, tx1);
                ty1 = Math.max(0, ty1);
                tx2 = Math.min(1, tx2);
                ty2 = Math.min(1, ty2);
            }

            if (displayedTextureSource._flipTextureY) {
                let tempty = ty2;
                ty2 = ty1;
                ty1 = tempty;
            }
            this.__core.setTextureCoords(tx1, ty1, tx2, ty2);
        }
    }

    getCornerPoints() {
        return this.__core.getCornerPoints();
    }

    _unsetTagsParent() {
        if (this.__tags) {
            this.__tags.forEach((tag) => {
                // Remove from treeTags.
                let p = this;
                while (p = p.__parent) {
                    let parentTreeTags = p.__treeTags.get(tag);
                    parentTreeTags.delete(this);

                    if (p.__tagRoot) {
                        break;
                    }
                }
            });
        }

        let tags = null;
        let n = 0;
        if (this.__treeTags) {
            if (!this.__tagRoot) {
                tags = _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].iteratorToArray(this.__treeTags.keys());
                n = tags.length;

                if (n > 0) {
                    for (let i = 0; i < n; i++) {
                        let tagSet = this.__treeTags.get(tags[i]);

                        // Remove from treeTags.
                        let p = this;
                        while ((p = p.__parent)) {
                            let parentTreeTags = p.__treeTags.get(tags[i]);

                            tagSet.forEach(function (comp) {
                                parentTreeTags.delete(comp);
                            });

                            if (p.__tagRoot) {
                                break;
                            }
                        }
                    }
                }
            }
        }
    };

    _setTagsParent() {
        // Just copy over the 'local' tags.
        if (this.__tags) {
            this.__tags.forEach((tag) => {
                let p = this;
                while (p = p.__parent) {
                    if (!p.__treeTags) {
                        p.__treeTags = new Map();
                    }

                    let s = p.__treeTags.get(tag);
                    if (!s) {
                        s = new Set();
                        p.__treeTags.set(tag, s);
                    }

                    s.add(this);

                    if (p.__tagRoot) {
                        break;
                    }
                }
            });
        }

        if (this.__treeTags && this.__treeTags.size) {
            if (!this.__tagRoot) {
                this.__treeTags.forEach((tagSet, tag) => {
                    let p = this;
                    while (!p.__tagRoot && (p = p.__parent)) {
                        if (p.__tagRoot) {
                            // Do not copy all subs.
                        }
                        if (!p.__treeTags) {
                            p.__treeTags = new Map();
                        }

                        let s = p.__treeTags.get(tag);
                        if (!s) {
                            s = new Set();
                            p.__treeTags.set(tag, s);
                        }

                        tagSet.forEach(function (comp) {
                            s.add(comp);
                        });
                    }
                });
            }
        }
    };


    _getByTag(tag) {
        if (!this.__treeTags) {
            return [];
        }
        let t = this.__treeTags.get(tag);
        return t ? _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].setToArray(t) : [];
    };

    getTags() {
        return this.__tags ? this.__tags : [];
    };

    setTags(tags) {
        tags = tags.reduce((acc, tag) => {
            return acc.concat(tag.split(' '));
        }, []);

        if (this.__ref) {
            tags.push(this.__ref);
        }

        let i, n = tags.length;
        let removes = [];
        let adds = [];
        for (i = 0; i < n; i++) {
            if (!this.hasTag(tags[i])) {
                adds.push(tags[i]);
            }
        }

        let currentTags = this.tags || [];
        n = currentTags.length;
        for (i = 0; i < n; i++) {
            if (tags.indexOf(currentTags[i]) == -1) {
                removes.push(currentTags[i]);
            }
        }

        for (i = 0; i < removes.length; i++) {
            this.removeTag(removes[i]);
        }

        for (i = 0; i < adds.length; i++) {
            this.addTag(adds[i]);
        }
    }

    addTag(tag) {
        if (tag.indexOf(' ') === -1) {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(tag.charCodeAt(0))) {
                this._throwError("Tag may not start with an upper case character.");
            }

            this._addTag(tag);
        } else {
            const tags = tag.split(' ');
            for (let i = 0, m = tags.length; i < m; i++) {
                const tag = tags[i];

                if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(tag.charCodeAt(0))) {
                    this._throwError("Tag may not start with an upper case character.");
                }

                this._addTag(tag);
            }
        }
    }

    _addTag(tag) {
        if (!this.__tags) {
            this.__tags = [];
        }
        if (this.__tags.indexOf(tag) === -1) {
            this.__tags.push(tag);

            // Add to treeTags hierarchy.
            let p = this.__parent;
            if (p) {
                do {
                    if (!p.__treeTags) {
                        p.__treeTags = new Map();
                    }

                    let s = p.__treeTags.get(tag);
                    if (!s) {
                        s = new Set();
                        p.__treeTags.set(tag, s);
                    }

                    s.add(this);

                } while (!p.__tagRoot && (p = p.__parent));
            }
        }
    }

    removeTag(tag) {
        let i = this.__tags.indexOf(tag);
        if (i !== -1) {
            this.__tags.splice(i, 1);

            // Remove from treeTags hierarchy.
            let p = this.__parent;
            if (p) {
                do {
                    let list = p.__treeTags.get(tag);
                    if (list) {
                        list.delete(this);
                    }
                } while (!p.__tagRoot && (p = p.__parent));
            }
        }
    }

    hasTag(tag) {
        return (this.__tags && (this.__tags.indexOf(tag) !== -1));
    }

    /**
     * Returns one of the elements from the subtree that have this tag.
     * @param {string} tag
     * @returns {Element}
     */
    _tag(tag) {
        if (tag.indexOf(".") !== -1) {
            return this.mtag(tag)[0];
        } else {
            if (this.__treeTags) {
                let t = this.__treeTags.get(tag);
                if (t) {
                    const item = t.values().next();
                    return item ? item.value : undefined;
                }
            }
        }
    };

    get tag() {
        return this._tag;
    }

    set tag(t) {
        this.tags = t;
    }

    /**
     * Returns all elements from the subtree that have this tag.
     * @param {string} tag
     * @returns {Element[]}
     */
    mtag(tag) {
        let idx = tag.indexOf(".");
        if (idx >= 0) {
            let parts = tag.split('.');
            let res = this._getByTag(parts[0]);
            let level = 1;
            let c = parts.length;
            while (res.length && level < c) {
                let resn = [];
                for (let j = 0, n = res.length; j < n; j++) {
                    resn = resn.concat(res[j]._getByTag(parts[level]));
                }

                res = resn;
                level++;
            }
            return res;
        } else {
            return this._getByTag(tag);
        }
    };

    stag(tag, settings) {
        let t = this.mtag(tag);
        let n = t.length;
        for (let i = 0; i < n; i++) {
            _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObject(t[i], settings);
        }
    }

    get tagRoot() {
        return this.__tagRoot;
    }

    set tagRoot(v) {
        if (this.__tagRoot !== v) {
            if (!v) {
                this._setTagsParent();
            } else {
                this._unsetTagsParent();
            }

            this.__tagRoot = v;
        }
    }

    sel(path) {
        const results = this.select(path);
        if (results.length) {
            return results[0];
        } else {
            return undefined;
        }
    }

    select(path) {
        if (path.indexOf(",") !== -1) {
            let selectors = path.split(',');
            let res = [];
            for (let i = 0; i < selectors.length; i++) {
                res = res.concat(this._select(selectors[i]));
            }
            return res;
        } else {
            return this._select(path);
        }
    }

    _select(path) {
        if (path === "") return [this];


        let pointIdx = path.indexOf(".");
        let arrowIdx = path.indexOf(">");
        if (pointIdx === -1 && arrowIdx === -1) {
            // Quick case.
            return this.mtag(path);
        }

        // Detect by first char.
        let isRef;
        if (arrowIdx === 0) {
            isRef = true;
            path = path.substr(1);
        } else if (pointIdx === 0) {
            isRef = false;
            path = path.substr(1);
        } else {
            isRef = false;
        }

        return this._selectChilds(path, isRef);
    }

    _selectChilds(path, isRef) {
        const pointIdx = path.indexOf(".");
        const arrowIdx = path.indexOf(">");

        if (pointIdx === -1 && arrowIdx === -1) {
            if (isRef) {
                const ref = this.getByRef(path);
                return ref ? [ref] : [];
            } else {
                return this.mtag(path);
            }
        }

        if ((arrowIdx === -1) || (pointIdx !== -1 && pointIdx < arrowIdx)) {
            let next;
            const str = path.substr(0, pointIdx);
            if (isRef) {
                const ref = this.getByRef(str);
                next = ref ? [ref] : [];
            } else {
                next = this.mtag(str);
            }
            let total = [];
            const subPath = path.substr(pointIdx + 1);
            for (let i = 0, n = next.length; i < n; i++) {
                total = total.concat(next[i]._selectChilds(subPath, false));
            }
            return total;
        } else {
            let next;
            const str = path.substr(0, arrowIdx);
            if (isRef) {
                const ref = this.getByRef(str);
                next = ref ? [ref] : [];
            } else {
                next = this.mtag(str);
            }
            let total = [];
            const subPath = path.substr(arrowIdx + 1);
            for (let i = 0, n = next.length; i < n; i++) {
                total = total.concat(next[i]._selectChilds(subPath, true));
            }
            return total;
        }
    }

    getByRef(ref) {
        return this.childList.getByRef(ref);
    }

    getLocationString() {
        let i;
        i = this.__parent ? this.__parent._children.getIndex(this) : "R";
        let localTags = this.getTags();
        let str = this.__parent ? this.__parent.getLocationString(): "";
        if (this.ref) {
            str += ":[" + i + "]" + this.ref;
        } else if (localTags.length) {
            str += ":[" + i + "]" + localTags.join(",");
        } else {
            str += ":[" + i + "]#" + this.id;
        }
        return str;
    }

    toString() {
        let obj = this.getSettings();
        return Element.getPrettyString(obj, "");
    };

    static getPrettyString(obj, indent) {
        let children = obj.children;
        delete obj.children;


        // Convert singular json settings object.
        let colorKeys = ["color", "colorUl", "colorUr", "colorBl", "colorBr"];
        let str = JSON.stringify(obj, function (k, v) {
            if (colorKeys.indexOf(k) !== -1) {
                return "COLOR[" + v.toString(16) + "]";
            }
            return v;
        });
        str = str.replace(/"COLOR\[([a-f0-9]{1,8})\]"/g, "0x$1");

        if (children) {
            let childStr = "";
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(children)) {
                let refs = Object.keys(children);
                childStr = "";
                for (let i = 0, n = refs.length; i < n; i++) {
                    childStr += `\n${indent}  "${refs[i]}":`
                    delete children[refs[i]].ref;
                    childStr += Element.getPrettyString(children[refs[i]], indent + "  ") + (i < n - 1 ? "," : "");
                }
                let isEmpty = (str === "{}");
                str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + childStr + "\n" + indent + "}";
            } else {
                let n = children.length;
                childStr = "[";
                for (let i = 0; i < n; i++) {
                    childStr += Element.getPrettyString(children[i], indent + "  ") + (i < n - 1 ? "," : "") + "\n";
                }
                childStr += indent + "]}";
                let isEmpty = (str === "{}");
                str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + "\"children\":\n" + indent + childStr + "}";
            }

        }

        return str;
    }

    getSettings() {
        let settings = this.getNonDefaults();

        let children = this._children.get();
        if (children) {
            let n = children.length;
            if (n) {
                const childArray = [];
                let missing = false;
                for (let i = 0; i < n; i++) {
                    childArray.push(children[i].getSettings());
                    missing = missing || !children[i].ref;
                }

                if (!missing) {
                    settings.children = {}
                    childArray.forEach(child => {
                        settings.children[child.ref] = child;
                    });
                } else {
                    settings.children = childArray;
                }
            }
        }

        settings.id = this.id;

        return settings;
    }

    getNonDefaults() {
        let settings = {};

        if (this.constructor !== Element) {
            settings.type = this.constructor.name;
        }

        if (this.__ref) {
            settings.ref = this.__ref;
        }

        if (this.__tags && this.__tags.length) {
            settings.tags = this.__tags;
        }

        if (this.x !== 0) settings.x = this.x;
        if (this.y !== 0) settings.y = this.y;
        if (this.w !== 0) settings.w = this.w;
        if (this.h !== 0) settings.h = this.h;

        if (this.scaleX === this.scaleY) {
            if (this.scaleX !== 1) settings.scale = this.scaleX;
        } else {
            if (this.scaleX !== 1) settings.scaleX = this.scaleX;
            if (this.scaleY !== 1) settings.scaleY = this.scaleY;
        }

        if (this.pivotX === this.pivotY) {
            if (this.pivotX !== 0.5) settings.pivot = this.pivotX;
        } else {
            if (this.pivotX !== 0.5) settings.pivotX = this.pivotX;
            if (this.pivotY !== 0.5) settings.pivotY = this.pivotY;
        }

        if (this.mountX === this.mountY) {
            if (this.mountX !== 0) settings.mount = this.mountX;
        } else {
            if (this.mountX !== 0) settings.mountX = this.mountX;
            if (this.mountY !== 0) settings.mountY = this.mountY;
        }

        if (this.alpha !== 1) settings.alpha = this.alpha;

        if (!this.visible) settings.visible = false;

        if (this.rotation !== 0) settings.rotation = this.rotation;

        if (this.colorUl === this.colorUr && this.colorBl === this.colorBr && this.colorUl === this.colorBl) {
            if (this.colorUl !== 0xFFFFFFFF) settings.color = this.colorUl.toString(16);
        } else {
            if (this.colorUl !== 0xFFFFFFFF) settings.colorUl = this.colorUl.toString(16);
            if (this.colorUr !== 0xFFFFFFFF) settings.colorUr = this.colorUr.toString(16);
            if (this.colorBl !== 0xFFFFFFFF) settings.colorBl = this.colorBl.toString(16);
            if (this.colorBr !== 0xFFFFFFFF) settings.colorBr = this.colorBr.toString(16);
        }

        if (this.zIndex) settings.zIndex = this.zIndex;

        if (this.forceZIndexContext) settings.forceZIndexContext = true;

        if (this.clipping) settings.clipping = this.clipping;

        if (!this.clipbox) settings.clipbox = this.clipbox;

        if (this.__texture) {
            let tnd = this.__texture.getNonDefaults();
            if (Object.keys(tnd).length) {
                settings.texture = tnd;
            }
        }

        if (this.shader && _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(this.shader.getNonDefaults)) {
            let tnd = this.shader.getNonDefaults();
            if (Object.keys(tnd).length) {
                settings.shader = tnd;
            }
        }

        if (this._hasTexturizer()) {
            if (this.texturizer.enabled) {
                settings.renderToTexture = this.texturizer.enabled;
            }
            if (this.texturizer.lazy) {
                settings.renderToTextureLazy = this.texturizer.lazy;
            }
            if (this.texturizer.colorize) {
                settings.colorizeResultTexture = this.texturizer.colorize;
            }
            if (this.texturizer.renderOffscreen) {
                settings.renderOffscreen = this.texturizer.renderOffscreen;
            }
        }

        return settings;
    };

    static getGetter(propertyPath) {
        let getter = Element.PROP_GETTERS.get(propertyPath);
        if (!getter) {
            getter = new Function('obj', 'return obj.' + propertyPath);
            Element.PROP_GETTERS.set(propertyPath, getter);
        }
        return getter;
    }

    static getSetter(propertyPath) {
        let setter = Element.PROP_SETTERS.get(propertyPath);
        if (!setter) {
            setter = new Function('obj', 'v', 'obj.' + propertyPath + ' = v');
            Element.PROP_SETTERS.set(propertyPath, setter);
        }
        return setter;
    }

    get withinBoundsMargin() {
        return this.__core._withinBoundsMargin;
    }

    _enableWithinBoundsMargin() {
        // Iff enabled, this toggles the active flag.
        if (this.__enabled) {
            this._setActiveFlag();
        }
    }

    _disableWithinBoundsMargin() {
        // Iff active, this toggles the active flag.
        if (this.__active) {
            this._unsetActiveFlag();
        }
    }

    set boundsMargin(v) {
        if (!Array.isArray(v) && v !== null) {
            throw new Error("boundsMargin should be an array of left-top-right-bottom values or null (inherit margin)");
        }
        this.__core.boundsMargin = v;
    }

    get boundsMargin() {
        return this.__core.boundsMargin;
    }

    get x() {
        return this.__core.offsetX;
    }

    set x(v) {
        this.__core.offsetX = v;
    }

    get y() {
        return this.__core.offsetY;
    }

    set y(v) {
        this.__core.offsetY = v;
    }

    get w() {
        return this._w;
    }

    set w(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(v)) {
            this._w = 0;
            this.__core.funcW = v;
        } else {
            v = Math.max(v, 0);
            if (this._w !== v) {
                this.__core.disableFuncW();
                this._w = v;
                this._updateDimensions();
            }
        }
    }

    get h() {
        return this._h;
    }

    set h(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(v)) {
            this._h = 0;
            this.__core.funcH = v;
        } else {
            v = Math.max(v, 0);
            if (this._h !== v) {
                this.__core.disableFuncH();
                this._h = v;
                this._updateDimensions();
            }
        }
    }

    get collision() {
        return this._collision;
    }

    set collision(v) {
        this._collision = v;
    }

    _updateCollision() {
        if (this.collision && this.__parent && this.__parent.collision === undefined) {
            /**
             * Mark collision as 2 to indicate atleast one descendant has collision enabled.
             * This narrows down the search for elements with active collision.
            */
            this.__parent.collision = 2;
        }
    }

    get scaleX() {
        return this.__core.scaleX;
    }

    set scaleX(v) {
        this.__core.scaleX = v;
    }

    get scaleY() {
        return this.__core.scaleY;
    }

    set scaleY(v) {
        this.__core.scaleY = v;
    }

    get scale() {
        return this.__core.scale;
    }

    set scale(v) {
        this.__core.scale = v;
    }

    get pivotX() {
        return this.__core.pivotX;
    }

    set pivotX(v) {
        this.__core.pivotX = v;
    }

    get pivotY() {
        return this.__core.pivotY;
    }

    set pivotY(v) {
        this.__core.pivotY = v;
    }

    get pivot() {
        return this.__core.pivot;
    }

    set pivot(v) {
        this.__core.pivot = v;
    }

    get mountX() {
        return this.__core.mountX;
    }

    set mountX(v) {
        this.__core.mountX = v;
    }

    get mountY() {
        return this.__core.mountY;
    }

    set mountY(v) {
        this.__core.mountY = v;
    }

    get mount() {
        return this.__core.mount;
    }

    set mount(v) {
        this.__core.mount = v;
    }

    get rotation() {
        return this.__core.rotation;
    }

    set rotation(v) {
        this.__core.rotation = v;
    }

    get alpha() {
        return this.__core.alpha;
    }

    set alpha(v) {
        this.__core.alpha = v;
    }

    get visible() {
        return this.__core.visible;
    }

    set visible(v) {
        this.__core.visible = v;
    }
    
    get colorUl() {
        return this.__core.colorUl;
    }

    set colorUl(v) {
        this.__core.colorUl = v;
    }

    get colorUr() {
        return this.__core.colorUr;
    }

    set colorUr(v) {
        this.__core.colorUr = v;
    }

    get colorBl() {
        return this.__core.colorBl;
    }

    set colorBl(v) {
        this.__core.colorBl = v;
    }

    get colorBr() {
        return this.__core.colorBr;
    }

    set colorBr(v) {
        this.__core.colorBr = v;
    }

    get color() {
        return this.__core.colorUl;
    }

    set color(v) {
        if (this.colorUl !== v || this.colorUr !== v || this.colorBl !== v || this.colorBr !== v) {
            this.colorUl = v;
            this.colorUr = v;
            this.colorBl = v;
            this.colorBr = v;
        }
    }

    get colorTop() {
        return this.colorUl;
    }

    set colorTop(v) {
        if (this.colorUl !== v || this.colorUr !== v) {
            this.colorUl = v;
            this.colorUr = v;
        }
    }

    get colorBottom() {
        return this.colorBl;
    }

    set colorBottom(v) {
        if (this.colorBl !== v || this.colorBr !== v) {
            this.colorBl = v;
            this.colorBr = v;
        }
    }

    get colorLeft() {
        return this.colorUl;
    }

    set colorLeft(v) {
        if (this.colorUl !== v || this.colorBl !== v) {
            this.colorUl = v;
            this.colorBl = v;
        }
    }

    get colorRight() {
        return this.colorUr;
    }

    set colorRight(v) {
        if (this.colorUr !== v || this.colorBr !== v) {
            this.colorUr = v;
            this.colorBr = v;
        }
    }

    get zIndex() {return this.__core.zIndex}
    set zIndex(v) {
        this.__core.zIndex = v;
    }

    get forceZIndexContext() {return this.__core.forceZIndexContext}
    set forceZIndexContext(v) {
        this.__core.forceZIndexContext = v;
    }

    get clipping() {return this.__core.clipping}
    set clipping(v) {
        this.__core.clipping = v;
    }

    get clipbox() {return this.__core.clipbox}
    set clipbox(v) {
        this.__core.clipbox = v;
    }

    get tags() {
        return this.getTags();
    }

    set tags(v) {
        if (!Array.isArray(v)) v = [v];
        this.setTags(v);
    }

    set t(v) {
        this.tags = v;
    }

    get _children() {
        if (!this.__childList) {
            this.__childList = new _ElementChildList_mjs__WEBPACK_IMPORTED_MODULE_8__["default"](this, false);
        }
        return this.__childList;
    }

    get childList() {
        if (!this._allowChildrenAccess()) {
            this._throwError("Direct access to children is not allowed in " + this.getLocationString());
        }
        return this._children;
    }

    hasChildren() {
        return this._allowChildrenAccess() && this.__childList && (this.__childList.length > 0);
    }

    _allowChildrenAccess() {
        return true;
    }

    get children() {
        return this.childList.get();
    }

    set children(children) {
        this.childList.patch(children);
    }

    add(o) {
        return this.childList.a(o);
    }

    get p() {
        return this.__parent;
    }

    get parent() {
        return this.__parent;
    }

    get src() {
        if (this.texture && this.texture instanceof _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_9__["default"]) {
            return this.texture._src;
        } else {
            return undefined;
        }
    }

    set src(v) {
        const texture = new _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_9__["default"](this.stage);
        texture.src = v;
        this.texture = texture;
    }

    set mw(v) {
        if (this.texture) {
            this.texture.mw = v;
            this._updateDimensions();
        } else {
            this._throwError('Please set mw after setting a texture.');
        }
    }

    set mh(v) {
        if (this.texture) {
            this.texture.mh = v;
            this._updateDimensions();
        } else {
            this._throwError('Please set mh after setting a texture.');
        }
    }

    get rect() {
        return (this.texture === this.stage.rectangleTexture);
    }

    set rect(v) {
        if (v) {
            this.texture = this.stage.rectangleTexture;
        } else {
            this.texture = null;
        }
    }

    enableTextTexture() {
        if (!this.texture || !(this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])) {
            this.texture = new _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"](this.stage);

            if (!this.texture.w && !this.texture.h) {
                // Inherit dimensions from element.
                // This allows userland to set dimensions of the Element and then later specify the text.
                this.texture.w = this.w;
                this.texture.h = this.h;
            }
        }
        return this.texture;
    }

    get text() {
        if (this.texture && (this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])) {
            return this.texture;
        } else {
            return null;
        }
    }

    set text(v) {
        if (!this.texture || !(this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])) {
            this.enableTextTexture();
        }
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isString(v)) {
            this.texture.text = v;
        } else {
            this.texture.patch(v);
        }
    }

    set onUpdate(f) {
        this.__core.onUpdate = f;
    }

    set onAfterCalcs(f) {
        this.__core.onAfterCalcs = f;
    }

    set onAfterUpdate(f) {
        this.__core.onAfterUpdate = f;
    }

    forceUpdate() {
        // Make sure that the update loop is run.
        this.__core._setHasUpdates();
    }

    get shader() {
        return this.__core.shader;
    }

    set shader(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v) && !v.type) {
            // Setting properties on an existing shader.
            if (this.shader) {
                this.shader.patch(v);
            }
        } else {
            const shader = _Shader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].create(this.stage, v);

            if (this.__enabled && this.__core.shader) {
                this.__core.shader.removeElement(this.__core);
            }

            this.__core.shader = shader;

            if (this.__enabled && this.__core.shader) {
                this.__core.shader.addElement(this.__core);
            }
        }
    }

    _hasTexturizer() {
        return !!this.__core._texturizer;
    }

    get renderToTexture() {
        return this.rtt
    }

    set renderToTexture(v) {
        this.rtt = v
    }

    get rtt() {
        return this._hasTexturizer() && this.texturizer.enabled;
    }

    set rtt(v) {
        this.texturizer.enabled = v;
    }

    get rttLazy() {
        return this._hasTexturizer() && this.texturizer.lazy;
    }

    set rttLazy(v) {
        this.texturizer.lazy = v;
    }

    get renderOffscreen() {
        return this._hasTexturizer() && this.texturizer.renderOffscreen;
    }

    set renderOffscreen(v) {
        this.texturizer.renderOffscreen = v;
    }

    get colorizeResultTexture() {
        return this._hasTexturizer() && this.texturizer.colorize;
    }

    set colorizeResultTexture(v) {
        this.texturizer.colorize = v;
    }

    getTexture() {
        return this.texturizer._getTextureSource();
    }

    get texturizer() {
        return this.__core.texturizer;
    }

    patch(settings) {
        let paths = Object.keys(settings);

        for (let i = 0, n = paths.length; i < n; i++) {
            let path = paths[i];
            const v = settings[path];

            const firstCharCode = path.charCodeAt(0);
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(firstCharCode)) {
                // Ref.
                const child = this.getByRef(path);
                if (!child) {
                    if (v !== undefined) {
                        // Add to list immediately.
                        let c;
                        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v)) {
                            // Catch this case to capture createMode flag.
                            c = this.childList.createItem(v);
                            c.patch(v);
                        } else if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObject(v)) {
                            c = v;
                        }
                        if (c.isElement) {
                            c.ref = path;
                        }

                        this.childList.a(c);
                    }
                } else {
                    if (v === undefined) {
                        if (child.parent) {
                            child.parent.childList.remove(child);
                        }
                    } else if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v)) {
                        child.patch(v);
                    } else if (v.isElement) {
                        // Replace element by new element.
                        v.ref = path;
                        this.childList.replace(v, child);
                    } else {
                        this._throwError("Unexpected value for path: " + path);
                    }
                }
            } else {
                // Property.
                _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObjectProperty(this, path, v);
            }
        }
    }

    _throwError(message) {
        throw new Error(this.constructor.name + " (" + this.getLocationString() + "): " + message);
    }

    animation(settings) {
        return this.stage.animations.createAnimation(this, settings);
    }

    transition(property, settings = null) {
        if (settings === null) {
            return this._getTransition(property);
        } else {
            this._setTransition(property, settings);
            // We do not create/return the transition, because it would undo the 'lazy transition creation' optimization.
            return null;
        }
    }

    set transitions(object) {
        let keys = Object.keys(object);
        keys.forEach(property => {
            this.transition(property, object[property]);
        });
    }

    set smooth(object) {
        let keys = Object.keys(object);
        keys.forEach(property => {
            let value = object[property];
            if (Array.isArray(value)) {
                this.setSmooth(property, value[0], value[1]);
            } else {
                this.setSmooth(property, value);
            }
        });
    }

    fastForward(property) {
        if (this._transitions) {
            let t = this._transitions[property];
            if (t && t.isTransition) {
                t.finish();
            }
        }
    }

    _getTransition(property) {
        if (!this._transitions) {
            this._transitions = {};
        }
        let t = this._transitions[property];
        if (!t) {
            // Create default transition.
            t = new _animation_Transition_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](this.stage.transitions, this.stage.transitions.defaultTransitionSettings, this, property);
        } else if (t.isTransitionSettings) {
            // Upgrade to 'real' transition.
            t = new _animation_Transition_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](
                this.stage.transitions,
                t,
                this,
                property
            );
        }
        this._transitions[property] = t;
        return t;
    }

    _setTransition(property, settings) {
        if (!settings) {
            this._removeTransition(property);
        } else {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(settings)) {
                // Convert plain object to proper settings object.
                settings = this.stage.transitions.createSettings(settings);
            }

            if (!this._transitions) {
                this._transitions = {};
            }

            let current = this._transitions[property];
            if (current && current.isTransition) {
                // Runtime settings change.
                current.settings = settings;
                return current;
            } else {
                // Initially, only set the settings and upgrade to a 'real' transition when it is used.
                this._transitions[property] = settings;
            }
        }
    }

    _removeTransition(property) {
        if (this._transitions) {
            delete this._transitions[property];
        }
    }

    getSmooth(property, v) {
        let t = this._getTransition(property);
        if (t && t.isAttached()) {
            return t.targetValue;
        } else {
            return v;
        }
    }

    setSmooth(property, v, settings) {
        if (settings) {
            this._setTransition(property, settings);
        }
        let t = this._getTransition(property);
        t.start(v);
        return t;
    }

    get flex() {
        return this.__core.flex;
    }

    set flex(v) {
        this.__core.flex = v;
    }

    get flexItem() {
        return this.__core.flexItem;
    }

    set flexItem(v) {
        this.__core.flexItem = v;
    }

    static isColorProperty(property) {
        return property.toLowerCase().indexOf("color") >= 0;
    }

    static getMerger(property) {
        if (Element.isColorProperty(property)) {
            return _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].mergeColors;
        } else {
            return _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].mergeNumbers;
        }
    }

    toJSON() {
        const ref = [`${this.constructor.name}`];
        const tree = {};
        tree[ref] = {};

        if (this.hasChildren()) {
            Element.collectChildren(tree[ref], this.__childList);
        } else {
            tree[ref] = {...Element.getProperties(this)};
        }
        return tree;
    }

    static collectChildren(tree, children) {
        const childList = children;
        for (let i = 0, j = childList.length; i < j; i++) {
            const element = childList.getAt(i);
            const ref = `${element.__ref || `Element-${element.id}`}`;
            const properties = this.getProperties(element);

            tree[ref] = {...properties};

            if (element.hasChildren()) {
                tree[ref].children = {};
                this.collectChildren(
                    tree[ref].children, element.__childList
                );
            }
        }
    }

    static getProperties(element) {
        const props = {};
        const list = [
            "alpha", "active", "attached", "boundsMargin", "color", "clipping", "enabled", "h", "id", "isComponent",
            "mount", "mountY", "mountX", "pivot", "pivotX", "pivotY", "ref", "renderOfScreen", "renderToTexture", "scale",
            "scaleX", "scaleY", "state", "tag", "visible", "w", "x", "y", "zIndex",
            "!!flex", "!!flexItem", "hasFocus()", "hasFinalFocus()"
        ];
        let n = list.length;

        while (n--) {
            let key = list[n];
            const getBoolean = /^!{2}/;
            const isFunction = /\(\)$/;

            if (getBoolean.test(key)) {
                key = key.substring(2, key.length);
                props[key] = !!element[key];
            } else if (isFunction.test(key)) {
                key = key.substring(0, key.length - 2);
                if (typeof element[key] === "function") {
                    props[key] = element[key]();
                }
            } else {
                props[key] = element[key];
            }
        }
        return {...props, ...element.getNonDefaults()};
    }
}

// This gives a slight performance benefit compared to extending EventEmitter.
_EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].addAsMixin(Element);

Element.prototype.isElement = 1;

Element.id = 1;

// Getters reused when referencing element (subobject) properties by a property path, as used in a transition or animation ('x', 'texture.x', etc).
Element.PROP_GETTERS = new Map();

// Setters reused when referencing element (subobject) properties by a property path, as used in a transition or animation ('x', 'texture.x', etc).
Element.PROP_SETTERS = new Map();









/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/ElementChildList.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/ElementChildList.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementChildList)
/* harmony export */ });
/* harmony import */ var _ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObjectList.mjs */ "./node_modules/@lightningjs/core/src/tree/ObjectList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages the list of children for an element.
 */



class ElementChildList extends _ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(element) {
        super();
        this._element = element;
    }

    _connectParent(item) {
        const prevParent = item.parent;
        if (prevParent && prevParent !== this._element) {
            // Cleanup in previous child list, without
            const prevChildList = item.parent.childList;
            const index = prevChildList.getIndex(item);

            if (item.ref) {
                prevChildList._refs[item.ref] = undefined;
            }
            prevChildList._items.splice(index, 1);

            // Also clean up element core.
            prevParent.core.removeChildAt(index);

        }

        item._setParent(this._element);

        // We are expecting the caller to sync it to the core.
    }

    onAdd(item, index) {
        this._connectParent(item);
        this._element.core.addChildAt(index, item.core);
    }

    onRemove(item, index) {
        item._setParent(null);
        this._element.core.removeChildAt(index);
    }

    onSync(removed, added, order) {
        for (let i = 0, n = removed.length; i < n; i++) {
            removed[i]._setParent(null);
        }
        for (let i = 0, n = added.length; i < n; i++) {
            this._connectParent(added[i]);
        }
        let gc = i => i.core;
        this._element.core.syncChildren(removed.map(gc), added.map(gc), order.map(gc));
    }

    onSet(item, index, prevItem) {
        prevItem._setParent(null);

        this._connectParent(item);
        this._element.core.setChildAt(index, item.core);
    }

    onMove(item, fromIndex, toIndex) {
        this._element.core.moveChild(fromIndex, toIndex);
    }

    createItem(object) {
        if (object.type) {
            return new object.type(this._element.stage);
        } else {
            return this._element.stage.createElement();
        }
    }

    isItem(object) {
        return object.isElement;
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/ObjectList.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/ObjectList.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjectList)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages a list of objects.
 * Objects may be patched. Then, they can be referenced using the 'ref' (string) property.
 */
class ObjectList {

    constructor() {
        this._items = [];
        this._refs = {}
    }

    get() {
        return this._items;
    }

    get first() {
        return this._items[0];
    }

    get last() {
        return this._items.length ? this._items[this._items.length - 1] : undefined;
    }

    add(item) {
        this.addAt(item, this._items.length);
    }

    addAt(item, index) {
        if (index >= 0 && index <= this._items.length) {
            let currentIndex = this._items.indexOf(item);
            if (currentIndex === index) {
                return item;
            }

            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(item)) {
                const o = item;
                item = this.createItem(o);
                item.patch(o);
            }

            if (currentIndex != -1) {
                this.setAt(item, index);
            } else {
                if (item.ref) {
                    this._refs[item.ref] = item;
                }
                this._items.splice(index, 0, item);
                this.onAdd(item, index);
            }
        } else {
            throw new Error('addAt: The index ' + index + ' is out of bounds ' + this._items.length);
        }
    }

    replaceByRef(item) {
        if (item.ref) {
            const existingItem = this.getByRef(item.ref);
            if (!existingItem) {
                throw new Error('replaceByRef: no item found with reference: ' + item.ref);
            }
            this.replace(item, existingItem);
        } else {
            throw new Error('replaceByRef: no ref specified in item');
        }
        this.addAt(item, this._items.length);

    }

    replace(item, prevItem) {
        const index = this.getIndex(prevItem);
        if (index === -1) {
            throw new Error('replace: The previous item does not exist');
        }
        this.setAt(item, index);
    }

    setAt(item, index) {
        if (index >= 0 && index < this._items.length) {

            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(item)) {
                const o = item;
                item = this.createItem(o);
                item.patch(o);
            }

            let currentIndex = this._items.indexOf(item);
            if (currentIndex != -1) {
                if (currentIndex !== index) {
                    const fromIndex = currentIndex;
                    if (fromIndex !== index) {
                        this._items.splice(fromIndex, 1);
                        this._items.splice(index, 0, item);
                        this.onMove(item, fromIndex, index);
                    }
                }
            } else {
                if (index < this._items.length) {
                    if (this._items[index].ref) {
                        this._refs[this._items[index].ref] = undefined;
                    }
                }

                const prevItem = this._items[index];

                // Doesn't exist yet: overwrite current.
                this._items[index] = item;

                if (item.ref) {
                    this._refs[item.ref] = item;
                }

                this.onSet(item, index, prevItem);
            }
        } else {
            throw new Error('setAt: The index ' + index + ' is out of bounds ' + this._items.length);
        }
    }

    getAt(index) {
        return this._items[index];
    }

    getIndex(item) {
        return this._items.indexOf(item);
    }

    remove(item) {
        let index = this._items.indexOf(item);

        if (index !== -1) {
            this.removeAt(index);
        }
    };

    removeAt(index) {
        if (index >= 0 && index < this._items.length) {
            const item = this._items[index];

            if (item.ref) {
                this._refs[item.ref] = undefined;
            }

            this._items.splice(index, 1);

            this.onRemove(item, index);

            return item;
        } else {
            throw new Error(`removeAt: The index ${index} is out of bounds ${this._items.length - 1}`);
        }
    };

    clear() {
        let n = this._items.length;
        if (n) {
            let prev = this._items;
            this._items = [];
            this._refs = {}
            this.onSync(prev, [], []);
        }
    };

    a(o) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(o)) {
            let c = this.createItem(o);
            c.patch(o);
            this.add(c);
            return c;
        } else if (Array.isArray(o)) {
            for (let i = 0, n = o.length; i < n; i++) {
                this.a(o[i]);
            }
            return null;
        } else if (this.isItem(o)) {
            this.add(o);
            return o;
        }
    };

    get length() {
        return this._items.length;
    }

    _getRefs() {
        return this._refs;
    }

    getByRef(ref) {
        return this._refs[ref];
    }

    clearRef(ref) {
        delete this._refs[ref];
    }

    setRef(ref, child) {
        this._refs[ref] = child;
    }

    patch(settings) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(settings)) {
            this._setByObject(settings);
        } else if (Array.isArray(settings)) {
            this._setByArray(settings);
        }
    }

    _setByObject(settings) {
        // Overrule settings of known referenced items.
        let refs = this._getRefs();
        let crefs = Object.keys(settings);
        for (let i = 0, n = crefs.length; i < n; i++) {
            let cref = crefs[i];
            let s = settings[cref];

            let c = refs[cref];
            if (!c) {
                if (this.isItem(s)) {
                    // Replace previous item;
                    s.ref = cref;
                    this.add(s);
                } else {
                    // Create new item.
                    c = this.createItem(s);
                    c.ref = cref;
                    c.patch(s);
                    this.add(c);
                }
            } else {
                if (this.isItem(s)) {
                    if (c !== s) {
                        // Replace previous item;
                        let idx = this.getIndex(c);
                        s.ref = cref;
                        this.setAt(s, idx);
                    }
                } else {
                    c.patch(s);
                }
            }
        }
    }

    _equalsArray(array) {
        let same = true;
        if (array.length === this._items.length) {
            for (let i = 0, n = this._items.length; (i < n) && same; i++) {
                same = same && (this._items[i] === array[i]);
            }
        } else {
            same = false;
        }
        return same;
    }

    _setByArray(array) {
        // For performance reasons, first check if the arrays match exactly and bail out if they do.
        if (this._equalsArray(array)) {
            return;
        }

        for (let i = 0, n = this._items.length; i < n; i++) {
            this._items[i].marker = true;
        }

        let refs;
        let newItems = [];
        for (let i = 0, n = array.length; i < n; i++) {
            let s = array[i];
            if (this.isItem(s)) {
                s.marker = false;
                newItems.push(s);
            } else {
                let cref = s.ref;
                let c;
                if (cref) {
                    if (!refs) refs = this._getRefs();
                    c = refs[cref];
                }

                if (!c) {
                    // Create new item.
                    c = this.createItem(s);
                } else {
                    c.marker = false;
                }

                if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(s)) {
                    c.patch(s);
                }

                newItems.push(c);
            }
        }

        this._setItems(newItems);
    }

    _setItems(newItems) {
        let prevItems = this._items;
        this._items = newItems;

        // Remove the items.
        let removed = prevItems.filter(item => {let m = item.marker; delete item.marker; return m});
        let added = newItems.filter(item => (prevItems.indexOf(item) === -1));

        if (removed.length || added.length) {
            // Recalculate refs.
            this._refs = {}
            for (let i = 0, n = this._items.length; i < n; i++) {
                let ref = this._items[i].ref;
                if (ref) {
                    this._refs[ref] = this._items[i];
                }
            }
        }

        this.onSync(removed, added, newItems);
    }

    sort(f) {
        const items = this._items.slice();
        items.sort(f);
        this._setByArray(items);
    }

    onAdd(item, index) {
    }

    onRemove(item, index) {
    }

    onSync(removed, added, order) {
    }

    onSet(item, index, prevItem) {
    }

    onMove(item, fromIndex, toIndex) {
    }

    createItem(object) {
        throw new Error("ObjectList.createItem must create and return a new object");
    }

    isItem(object) {
        return false;
    }

    forEach(f) {
        this.get().forEach(f);
    }

}






/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Shader.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Shader.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Shader)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class Shader {

    constructor(coreContext) {
        this._initialized = false;

        this.ctx = coreContext;

        /**
         * The (enabled) elements that use this shader.
         * @type {Set<ElementCore>}
         */
        this._elements = new Set();
    }

    static create(stage, v) {
        let shader;
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(v)) {
            if (v.type) {
                shader = stage.renderer.createShader(stage.ctx, v);
            } else {
                shader = this.shader;
            }

            if (shader) {
                _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(shader, v);
            }
        } else if (v === null) {
            shader = stage.ctx.renderState.defaultShader;
        } else if (v === undefined) {
            shader = null;
        } else {
            if (v.isShader) {
                if (!stage.renderer.isValidShaderType(v.constructor)) {
                    console.error("[Lightning] Invalid shader type");
                    v = null;
                }
                shader = v;
            } else {
                console.error("[Lightning] Please specify a shader type.");
                return;
            }
        }

        return shader;
    }

    static getWebGL() {
        return undefined;
    }

    static getC2d() {
        return undefined;
    }

    addElement(elementCore) {
        this._elements.add(elementCore);
    }

    removeElement(elementCore) {
        this._elements.delete(elementCore);
        if (!this._elements) {
            this.cleanup();
        }
    }

    redraw() {
        this._elements.forEach(elementCore => {
            elementCore.setHasRenderUpdates(2);
        });
    }

    patch(settings) {
        _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(this, settings);
    }

    useDefault() {
        // Should return true if this shader is configured (using it's properties) to not have any effect.
        // This may allow the render engine to avoid unnecessary shader program switches or even texture copies.
        return false;
    }

    addEmpty() {
        // Draws this shader even if there are no quads to be added.
        // This is handy for custom shaders.
        return false;
    }

    cleanup() {
        // Called when no more enabled elements have this shader.
    }

    get isShader() {
        return true;
    }
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Stage.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Stage.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stage)
/* harmony export */ });
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _renderer_webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/webgl/WebGLRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs");
/* harmony import */ var _renderer_c2d_C2dRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/c2d/C2dRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dRenderer.mjs");
/* harmony import */ var _renderer_spark_SparkRenderer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/spark/SparkRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/spark/SparkRenderer.mjs");
/* harmony import */ var _platforms_PlatformLoader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platforms/PlatformLoader.mjs */ "./node_modules/@lightningjs/core/src/platforms/PlatformLoader.mjs");
/* harmony import */ var _tools_WebGLStateManager_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tools/WebGLStateManager.mjs */ "./node_modules/@lightningjs/core/src/tools/WebGLStateManager.mjs");
/* harmony import */ var _Shader_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/* harmony import */ var _Element_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _TextureManager_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TextureManager.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureManager.mjs");
/* harmony import */ var _TextureThrottler_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TextureThrottler.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureThrottler.mjs");
/* harmony import */ var _core_CoreContext_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/CoreContext.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreContext.mjs");
/* harmony import */ var _animation_TransitionManager_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../animation/TransitionManager.mjs */ "./node_modules/@lightningjs/core/src/animation/TransitionManager.mjs");
/* harmony import */ var _animation_AnimationManager_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../animation/AnimationManager.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationManager.mjs");
/* harmony import */ var _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../textures/RectangleTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Application render tree.
 */










class Stage extends _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(options = {}) {
        super();
        this._setOptions(options);

        this._usedMemory = 0;
        this._lastGcFrame = 0;

        const platformType = Stage.platform ? Stage.platform : _platforms_PlatformLoader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].load(options);
        this.platform = new platformType();

        if (this.platform.init) {
            this.platform.init(this);
        }

        this.gl = null;
        this.c2d = null;

        const context = this.getOption('context');
        if (context) {
            if (context.useProgram) {
                this.gl = context;
            } else {
                this.c2d = context;
            }
        } else {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isWeb && (!Stage.isWebglSupported() || this.getOption('canvas2d'))) {
                this.c2d = this.platform.createCanvasContext(this.getOption('w'), this.getOption('h'));
            } else {
                this.gl = this.platform.createWebGLContext(this.getOption('w'), this.getOption('h'));
            }
        }

        if (this.gl) {
            // Wrap in WebGLStateManager.
            // This prevents unnecessary double WebGL commands from being executed, and allows context switching.
            // Context switching is necessary when reusing the same context for Three.js.
            // Note that the user must make sure that the WebGL context is untouched before creating the application,
            //  when manually passing over a canvas or context in the options.
            _tools_WebGLStateManager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].enable(this.gl, "lightning")
        }

        this._mode = this.gl ? 0 : 1;

        // Override width and height.
        if (this.getCanvas()) {
            this._options.w = this.getCanvas().width;
            this._options.h = this.getCanvas().height;
        }

        if (this._mode === 0) {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark) {
                this._renderer = new _renderer_spark_SparkRenderer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](this);
            } else {
                this._renderer = new _renderer_webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);
            }
        } else {
            this._renderer = new _renderer_c2d_C2dRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this);
        }

        this.setClearColor(this.getOption('clearColor'));

        this.frameCounter = 0;

        this.transitions = new _animation_TransitionManager_mjs__WEBPACK_IMPORTED_MODULE_8__["default"](this);
        this.animations = new _animation_AnimationManager_mjs__WEBPACK_IMPORTED_MODULE_9__["default"](this);

        this.textureManager = new _TextureManager_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](this);
        this.textureThrottler = new _TextureThrottler_mjs__WEBPACK_IMPORTED_MODULE_11__["default"](this);

        this.startTime = 0;
        this.currentTime = 0;
        this.dt = 0;

        // Preload rectangle texture, so that we can skip some border checks for loading textures.
        this.rectangleTexture = new _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_12__["default"](this);
        this.rectangleTexture.load();

        // Never clean up because we use it all the time.
        this.rectangleTexture.source.permanent = true;

        this.ctx = new _core_CoreContext_mjs__WEBPACK_IMPORTED_MODULE_13__["default"](this);

        this._updateSourceTextures = new Set();
    }

    get renderer() {
        return this._renderer;
    }

    static isWebglSupported() {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNode) {
            return true;
        }

        try {
            return !!window.WebGLRenderingContext;
        } catch(e) {
            return false;
        }
    }

    /**
     * Returns the rendering mode.
     * @returns {number}
     *  0: WebGL
     *  1: Canvas2d
     */
    get mode() {
        return this._mode;
    }

    isWebgl() {
        return this.mode === 0;
    }

    isC2d() {
        return this.mode === 1;
    }

    getOption(name) {
        return this._options[name];
    }

    _setOptions(o) {
        this._options = {};

        let opt = (name, def) => {
            let value = o[name];

            if (value === undefined) {
                this._options[name] = def;
            } else {
                this._options[name] = value;
            }
        }

        opt('canvas', null);
        opt('context', null);
        opt('w', 1920);
        opt('h', 1080);
        opt('srcBasePath', null);
        opt('memoryPressure', 24e6);
        opt('bufferMemory', 2e6);
        opt('textRenderIssueMargin', 0);
        opt('fontSharp',{precision:0.6666666667, fontSize: 24})
        opt('clearColor', [0, 0, 0, 0]);
        opt('defaultFontFace', 'sans-serif');
        opt('fixedDt', 0);
        opt('useImageWorker', true);
        opt('autostart', true);
        opt('precision', 1);
        opt('canvas2d', false);
        opt('platform', null);
        opt('readPixelsBeforeDraw', false);
    }

    setApplication(app) {
        this.application = app;
    }

    init() {

        if (this.application.getOption('debug') && this.platform._imageWorker) {
            console.log('[Lightning] Using image worker!');
        }

        if (this.application.getOption('debug') && this.c2d) {
            console.log('[Lightning] Using canvas2d renderer');
        }

        this.application.setAsRoot();
        if (this.getOption('autostart')) {
            this.platform.startLoop();
        }
    }

    destroy() {
        this.platform.stopLoop();
        this.platform.destroy();
        this.ctx.destroy();
        this.textureManager.destroy();
        this._renderer.destroy();
    }

    stop() {
        this.platform.stopLoop();
    }

    resume() {
        this.platform.startLoop();
    }

    get root() {
        return this.application;
    }

    getCanvas() {
        return this._mode ? this.c2d.canvas : this.gl.canvas;
    }

    getRenderPrecision() {
        return this._options.precision;
    }

    /**
     * Marks a texture for updating it's source upon the next drawFrame.
     * @param texture
     */
    addUpdateSourceTexture(texture) {
        if (this._updatingFrame) {
            // When called from the upload loop, we must immediately load the texture in order to avoid a 'flash'.
            texture._performUpdateSource();
        } else {
            this._updateSourceTextures.add(texture);
        }
    }

    removeUpdateSourceTexture(texture) {
        if (this._updateSourceTextures) {
            this._updateSourceTextures.delete(texture);
        }
    }

    hasUpdateSourceTexture(texture) {
        return (this._updateSourceTextures && this._updateSourceTextures.has(texture));
    }

    drawFrame() {
        this.startTime = this.currentTime;
        this.currentTime = this.platform.getHrTime();

        if (this._options.fixedDt) {
            this.dt = this._options.fixedDt;
        } else {
            this.dt = (!this.startTime) ? .02 : .001 * (this.currentTime - this.startTime);
        }

        this.emit('frameStart');

        if (this._updateSourceTextures.size) {
            this._updateSourceTextures.forEach(texture => {
                texture._performUpdateSource();
            });
            this._updateSourceTextures = new Set();
        }

        this.emit('update');

        const changes = this.ctx.hasRenderUpdates();

        // Update may cause textures to be loaded in sync, so by processing them here we may be able to show them
        // during the current frame already.
        this.textureThrottler.processSome();

        if (changes) {
            this._updatingFrame = true;
            this.ctx.update();
            this.ctx.render();
            this._updatingFrame = false;
        }

        this.platform.nextFrame(changes);

        this.emit('frameEnd');

        this.frameCounter++;
    }

    isUpdatingFrame() {
        return this._updatingFrame;
    }

    renderFrame() {
        this.ctx.frame();
    }

    forceRenderUpdate() {
        // Enforce re-rendering.
        if (this.root) {
            this.root.core._parent.setHasRenderUpdates(1);
        }
    }

    setClearColor(clearColor) {
        this.forceRenderUpdate();
        if (clearColor === null) {
            // Do not clear.
            this._clearColor = null;
        } else if (Array.isArray(clearColor)) {
            this._clearColor = clearColor;
        } else {
            this._clearColor = _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_14__["default"].getRgbaComponentsNormalized(clearColor);
        }
    }

    getClearColor() {
        return this._clearColor;
    }

    createElement(settings) {
        if (settings) {
            return this.element(settings);
        } else {
            return new _Element_mjs__WEBPACK_IMPORTED_MODULE_15__["default"](this);
        }
    }

    createShader(settings) {
        return _Shader_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].create(this, settings);
    }

    element(settings) {
        if (settings.isElement) return settings;

        let element;
        if (settings.type) {
            element = new settings.type(this);
        } else {
            element = new _Element_mjs__WEBPACK_IMPORTED_MODULE_15__["default"](this);
        }

        element.patch(settings);

        return element;
    }

    c(settings) {
        return this.element(settings);
    }

    get w() {
        return this._options.w;
    }

    get h() {
        return this._options.h;
    }

    get coordsWidth() {
        return this.w / this._options.precision;
    }

    get coordsHeight() {
        return this.h / this._options.precision;
    }

    addMemoryUsage(delta) {
        this._usedMemory += delta;
        if (this._lastGcFrame !== this.frameCounter) {
            if (this._usedMemory > this.getOption('memoryPressure')) {
                this.gc(false);
                if (this._usedMemory > this.getOption('memoryPressure') - 2e6) {
                    // Too few released. Aggressive cleanup.
                    this.gc(true);
                }
            }
        }
    }

    get usedMemory() {
        return this._usedMemory;
    }

    gc(aggressive) {
        if (this._lastGcFrame !== this.frameCounter) {
            this._lastGcFrame = this.frameCounter;
            const memoryUsageBefore = this._usedMemory;
            this.gcTextureMemory(aggressive);
            this.gcRenderTextureMemory(aggressive);
            this.renderer.gc(aggressive);

            if (this.application.getOption('debug')) {
                console.log(`[Lightning] GC${aggressive ? "[aggressive]" : ""}! Frame ${this._lastGcFrame} Freed ${((memoryUsageBefore - this._usedMemory) / 1e6).toFixed(2)}MP from GPU memory. Remaining: ${(this._usedMemory / 1e6).toFixed(2)}MP`);
                const other = this._usedMemory - this.textureManager.usedMemory - this.ctx.usedMemory;
                console.log(`[Lightning] Textures: ${(this.textureManager.usedMemory / 1e6).toFixed(2)}MP, Render Textures: ${(this.ctx.usedMemory / 1e6).toFixed(2)}MP, Renderer caches: ${(other / 1e6).toFixed(2)}MP`);
            }
        }
    }

    gcTextureMemory(aggressive = false) {
        if (aggressive && this.ctx.root.visible) {
            // Make sure that ALL textures are cleaned;
            this.ctx.root.visible = false;
            this.textureManager.gc();
            this.ctx.root.visible = true;
        } else {
            this.textureManager.gc();
        }
    }

    gcRenderTextureMemory(aggressive = false) {
        if (aggressive && this.root.visible) {
            // Make sure that ALL render textures are cleaned;
            this.root.visible = false;
            this.ctx.freeUnusedRenderTextures(0);
            this.root.visible = true;
        } else {
            this.ctx.freeUnusedRenderTextures(0);
        }
    }

    getDrawingCanvas() {
        return this.platform.getDrawingCanvas();
    }

    update() {
        this.ctx.update()
    }

    addServiceProvider(serviceprovider) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark) {
            this.platform.addServiceProvider(serviceprovider);
        }
    }

    getChildrenByPosition(x, y){
        const children = [];
        this.root.core.update();
        this.root.core.collectAtCoord(x,y,children);

        return children;
    }
}











/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/StageUtils.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StageUtils)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class StageUtils {

    static mergeNumbers(v1, v2, p) {
        return v1 * p + v2 * (1 - p);
    };

    static rgb(r, g, b) {
        return (r << 16) + (g << 8) + b + (255 * 16777216);
    };

    static rgba(r, g, b, a) {
        return (r << 16) + (g << 8) + b + (((a * 255) | 0) * 16777216);
    };

    static getRgbString(color) {
        let r = ((color / 65536) | 0) % 256;
        let g = ((color / 256) | 0) % 256;
        let b = color % 256;
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    };

    static getRgbaString(color) {
        let r = ((color / 65536) | 0) % 256;
        let g = ((color / 256) | 0) % 256;
        let b = color % 256;
        let a = ((color / 16777216) | 0) / 255;
        return 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(4) + ')';
    };

    static getRgbaStringFromArray(color) {
        let r = Math.floor(color[0] * 255);
        let g = Math.floor(color[1] * 255);
        let b = Math.floor(color[2] * 255);
        let a = Math.floor(color[3] * 255) / 255;
        return 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(4) + ')';
    };

    static getRgbaComponentsNormalized(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        let a = ((argb / 16777216) | 0);
        return [r / 255, g / 255, b / 255, a / 255];
    };

    static getRgbComponentsNormalized(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        return [r / 255, g / 255, b / 255];
    };

    static getRgbaComponents(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        let a = ((argb / 16777216) | 0);
        return [r, g, b, a];
    };

    static getArgbNumber(rgba) {
        rgba[0] = Math.max(0, Math.min(255, rgba[0]));
        rgba[1] = Math.max(0, Math.min(255, rgba[1]));
        rgba[2] = Math.max(0, Math.min(255, rgba[2]));
        rgba[3] = Math.max(0, Math.min(255, rgba[3]));
        let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
        if (v < 0) {
            v = 0xFFFFFFFF + v + 1;
        }
        return v;
    };

    static mergeColors(c1, c2, p) {
        let r1 = ((c1 / 65536) | 0) % 256;
        let g1 = ((c1 / 256) | 0) % 256;
        let b1 = c1 % 256;
        let a1 = ((c1 / 16777216) | 0);

        let r2 = ((c2 / 65536) | 0) % 256;
        let g2 = ((c2 / 256) | 0) % 256;
        let b2 = c2 % 256;
        let a2 = ((c2 / 16777216) | 0);

        let r = r1 * p + r2 * (1 - p);
        let g = g1 * p + g2 * (1 - p);
        let b = b1 * p + b2 * (1 - p);
        let a = a1 * p + a2 * (1 - p);

        return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
    };

    static mergeMultiColors(c, p) {
        let r = 0, g = 0, b = 0, a = 0, t = 0;
        let n = c.length;
        for (let i = 0; i < n; i++) {
            let r1 = ((c[i] / 65536) | 0) % 256;
            let g1 = ((c[i] / 256) | 0) % 256;
            let b1 = c[i] % 256;
            let a1 = ((c[i] / 16777216) | 0);
            r += r1 * p[i];
            g += g1 * p[i];
            b += b1 * p[i];
            a += a1 * p[i];
            t += p[i];
        }

        t = 1 / t;
        return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
    };

    static mergeMultiColorsEqual(c) {
        let r = 0, g = 0, b = 0, a = 0, t = 0;
        let n = c.length;
        for (let i = 0; i < n; i++) {
            let r1 = ((c[i] / 65536) | 0) % 256;
            let g1 = ((c[i] / 256) | 0) % 256;
            let b1 = c[i] % 256;
            let a1 = ((c[i] / 16777216) | 0);
            r += r1;
            g += g1;
            b += b1;
            a += a1;
            t += 1.0;
        }

        t = 1 / t;
        return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
    };

    static mergeColorAlpha(c, alpha) {
        let a = ((c / 16777216 | 0) * alpha) | 0;
        return (((((c >> 16) & 0xff) * a) / 255) & 0xff) +
            ((((c & 0xff00) * a) / 255) & 0xff00) +
            (((((c & 0xff) << 16) * a) / 255) & 0xff0000) +
            (a << 24);
    };

    static rad(deg) {
        return deg * (Math.PI / 180);
    };

    static getTimingBezier(a, b, c, d) {
        let xc = 3.0 * a;
        let xb = 3.0 * (c - a) - xc;
        let xa = 1.0 - xc - xb;
        let yc = 3.0 * b;
        let yb = 3.0 * (d - b) - yc;
        let ya = 1.0 - yc - yb;

        return function (time) {
            if (time >= 1.0) {
                return 1;
            }
            if (time <= 0) {
                return 0;
            }

            let t = 0.5, cbx, cbxd, dx;

            for (let it = 0; it < 20; it++) {
                cbx = t * (t * (t * xa + xb) + xc);
                dx = time - cbx;
                if (dx > -1e-8 && dx < 1e-8) {
                    return t * (t * (t * ya + yb) + yc);
                }

                // Cubic bezier derivative.
                cbxd = t * (t * (3 * xa) + 2 * xb) + xc;

                if (cbxd > 1e-10 && cbxd < 1e-10) {
                    // Problematic. Fall back to binary search method.
                    break;
                }

                t += dx / cbxd;
            }

            // Fallback: binary search method. This is more reliable when there are near-0 slopes.
            let minT = 0;
            let maxT = 1;
            for (let it = 0; it < 20; it++) {
                t = 0.5 * (minT + maxT);

                cbx = t * (t * (t * xa + xb) + xc);

                dx = time - cbx;
                if (dx > -1e-8 && dx < 1e-8) {
                    // Solution found!
                    return t * (t * (t * ya + yb) + yc);
                }

                if (dx < 0) {
                    maxT = t;
                } else {
                    minT = t;
                }
            }

        };
    };

    static getTimingFunction(str) {
        switch (str) {
            case "linear":
                return function (time) {
                    return time
                };
            case "ease":
                return StageUtils.getTimingBezier(0.25, 0.1, 0.25, 1.0);
            case "ease-in":
                return StageUtils.getTimingBezier(0.42, 0, 1.0, 1.0);
            case "ease-out":
                return StageUtils.getTimingBezier(0, 0, 0.58, 1.0);
            case "ease-in-out":
                return StageUtils.getTimingBezier(0.42, 0, 0.58, 1.0);
            case "step-start":
                return function () {
                    return 1
                };
            case "step-end":
                return function (time) {
                    return time === 1 ? 1 : 0;
                };
            default:
                let s = "cubic-bezier(";
                if (str && str.indexOf(s) === 0) {
                    let parts = str.substr(s.length, str.length - s.length - 1).split(",");
                    if (parts.length !== 4) {
                        console.warn("[Lightning] Unknown timing function: " + str);

                        // Fallback: use linear.
                        return function (time) {
                            return time
                        };
                    }
                    let a = parseFloat(parts[0]);
                    let b = parseFloat(parts[1]);
                    let c = parseFloat(parts[2]);
                    let d = parseFloat(parts[3]);
                    if (isNaN(a) || isNaN(b) || isNaN(c) || isNaN(d)) {
                        console.warn("[Lightning] Unknown timing function: " + str);
                        // Fallback: use linear.
                        return function (time) {
                            return time
                        };
                    }

                    return StageUtils.getTimingBezier(a, b, c, d);
                } else {
                    console.warn("[Lightning] Unknown timing function: " + str);
                    // Fallback: use linear.
                    return function (time) {
                        return time
                    };
                }
        }
    };

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Texture.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Texture.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Texture {

    /**
     * @param {Stage} stage
     */
    constructor(stage) {
        this.stage = stage;

        this.manager = this.stage.textureManager;

        this.id = Texture.id++;

        /**
         * All enabled elements that use this texture object (either as texture or displayedTexture).
         * @type {Set<Element>}
         */
        this.elements = new Set();

        /**
         * The number of enabled elements that are active.
         * @type {number}
         */
        this._activeCount = 0;

        /**
         * The associated texture source.
         * Should not be changed.
         * @type {TextureSource}
         */
        this._source = null;

        /**
         * A resize mode can be set to cover or contain a certain area.
         * It will reset the texture clipping settings.
         * When manual texture clipping is performed, the resizeMode is reset.
         * @type {{type: string, width: number, height: number}}
         * @private
         */
        this._resizeMode = null;

        /**
         * The texture clipping x-offset.
         * @type {number}
         */
        this._x = 0;

        /**
         * The texture clipping y-offset.
         * @type {number}
         */
        this._y = 0;

        /**
         * The texture clipping width. If 0 then full width.
         * @type {number}
         */
        this._w = 0;

        /**
         * The texture clipping height. If 0 then full height.
         * @type {number}
         */
        this._h = 0;

        /**
         * Render precision (0.5 = fuzzy, 1 = normal, 2 = sharp even when scaled twice, etc.).
         * @type {number}
         * @private
         */
        this._precision = 1;

        /**
         * The (maximum) expected texture source width. Used for within bounds determination while texture is not yet loaded.
         * If not set, 2048 is used by ElementCore.update.
         * @type {number}
         */
        this.mw = 0;

        /**
         * The (maximum) expected texture source height. Used for within bounds determination while texture is not yet loaded.
         * If not set, 2048 is used by ElementCore.update.
         * @type {number}
         */
        this.mh = 0;

        /**
         * Indicates if Texture.prototype.texture uses clipping.
         * @type {boolean}
         */
        this.clipping = false;

        /**
         * Indicates whether this texture must update (when it becomes used again).
         * @type {boolean}
         * @private
         */
        this._mustUpdate = true;

    }

    get source() {
        if (this._mustUpdate || this.stage.hasUpdateSourceTexture(this)) {
            this._performUpdateSource(true);
            this.stage.removeUpdateSourceTexture(this);
        }
        return this._source;
    }

    addElement(v) {
        if (!this.elements.has(v)) {
            this.elements.add(v);

            if (this.elements.size === 1) {
                if (this._source) {
                    this._source.addTexture(this);
                }
            }

            if (v.active) {
                this.incActiveCount();
            }
        }
    }

    removeElement(v) {
        if (this.elements.delete(v)) {
            if (this.elements.size === 0) {
                if (this._source) {
                    this._source.removeTexture(this);
                }
            }

            if (v.active) {
                this.decActiveCount();
            }
        }
    }

    incActiveCount() {
        // Ensure that texture source's activeCount has transferred ownership.
        const source = this.source;

        if (source) {
            this._checkForNewerReusableTextureSource();
        }

        this._activeCount++;
        if (this._activeCount === 1) {
            this.becomesUsed();
        }
    }

    decActiveCount() {
        const source = this.source; // Force updating the source.
        this._activeCount--;
        if (!this._activeCount) {
            this.becomesUnused();
        }
    }

    becomesUsed() {
        if (this.source) {
            this.source.incActiveTextureCount();
        }
    }

    onLoad() {
        if (this._resizeMode) {
            this._applyResizeMode();
        }

        this.elements.forEach(element => {
            if (element.active) {
                element.onTextureSourceLoaded();
            }
        });
    }

    _checkForNewerReusableTextureSource() {
        // When this source became unused and cleaned up, it may have disappeared from the reusable texture map.
        // In the meantime another texture may have been generated loaded with the same lookup id.
        // If this is the case, use that one instead to make sure only one active texture source per lookup id exists.
        const source = this.source;
        if (!source.isLoaded()) {
            const reusable = this._getReusableTextureSource();
            if (reusable && reusable.isLoaded() && (reusable !== source)) {
                this._replaceTextureSource(reusable);
            }
        } else {
            if (this._resizeMode) {
                this._applyResizeMode();
            }
        }
    }

    becomesUnused() {
        if (this.source) {
            this.source.decActiveTextureCount();
        }
    }

    isUsed() {
        return this._activeCount > 0;
    }

    /**
     * Returns the lookup id for the current texture settings, to be able to reuse it.
     * @returns {string|null}
     */
    _getLookupId() {
        // Default: do not reuse texture.
        return null;
    }

    /**
     * Generates a loader function that is able to generate the texture for the current settings of this texture.
     * It should return a function that receives a single callback argument.
     * That callback should be called with the following arguments:
     *   - err
     *   - options: object
     *     - source: ArrayBuffer|WebGlTexture|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap
     *     - w: Number
     *     - h: Number
     *     - permanent: Boolean
     *     - hasAlpha: boolean
     *     - permultiplyAlpha: boolean
     *     - flipBlueRed: boolean
     *     - renderInfo: object
     * The loader itself may return a Function that is called when loading of the texture is cancelled. This can be used
     * to stop fetching an image when it is no longer in element, for example.
     */
    _getSourceLoader() {
        throw new Error("Texture.generate must be implemented.");
    }

    get isValid() {
        return this._getIsValid();
    }

    /**
     * If texture is not 'valid', no source can be created for it.
     * @returns {boolean}
     */
    _getIsValid() {
        return true;
    }

    /**
     * This must be called when the texture source must be re-generated.
     */
    _changed() {
        // If no element is actively using this texture, ignore it altogether.
        if (this.isUsed()) {
            this._updateSource();
        } else {
            this._mustUpdate = true;
        }
    }

    _updateSource() {
        // We delay all updateSource calls to the next drawFrame, so that we can bundle them.
        // Otherwise we may reload a texture more often than necessary, when, for example, patching multiple text
        // properties.
        this.stage.addUpdateSourceTexture(this);
    }

    _performUpdateSource(force = false) {
        // If, in the meantime, the texture was no longer used, just remember that it must update until it becomes used
        // again.
        if (force || this.isUsed()) {
            this._mustUpdate = false;
            let source = this._getTextureSource();
            this._replaceTextureSource(source);
        }
    }

    _getTextureSource() {
        let source = null;
        if (this._getIsValid()) {
            const lookupId = this._getLookupId();
            source = this._getReusableTextureSource(lookupId);
            if (!source) {
                source = this.manager.getTextureSource(this._getSourceLoader(), lookupId);
            }
        }
        return source;
    }

    _getReusableTextureSource(lookupId = this._getLookupId()) {
        if (this._getIsValid()) {
            if (lookupId) {
                return this.manager.getReusableTextureSource(lookupId);
            }
        }
        return null;
    }

    _replaceTextureSource(newSource = null) {
        let oldSource = this._source;

        this._source = newSource;

        if (this.elements.size) {
            if (oldSource) {
                if (this._activeCount) {
                    oldSource.decActiveTextureCount();
                }

                oldSource.removeTexture(this);
            }

            if (newSource) {
                // Must happen before setDisplayedTexture to ensure sprite map texcoords are used.
                newSource.addTexture(this);
                if (this._activeCount) {
                    newSource.incActiveTextureCount();
                }
            }
        }

        if (this.isUsed()) {
            if (newSource) {
                if (newSource.isLoaded()) {

                    // Apply resizeMode
                    if (this._resizeMode) {
                        this._applyResizeMode();
                    }

                    this.elements.forEach(element => {
                        if (element.active) {
                            element._setDisplayedTexture(this);
                        }
                    });
                } else {
                    const loadError = newSource.loadError;
                    if (loadError) {
                        this.elements.forEach(element => {
                            if (element.active) {
                                element.onTextureSourceLoadError(loadError);
                            }
                        });
                    }
                }
            } else {
                this.elements.forEach(element => {
                    if (element.active) {
                        element._setDisplayedTexture(null);
                    }
                });
            }
        }
    }

    load() {
        // Make sure that source is up to date.
        if (this.source) {
            if (!this.isLoaded()) {
                this.source.load(true);
            }
        }
    }

    isLoaded() {
        return this._source && this._source.isLoaded();
    }

    get loadError() {
        return this._source && this._source.loadError;
    }

    free() {
        if (this._source) {
            this._source.free();
        }
    }

    set resizeMode({type = "cover", w = 0, h = 0, clipX = 0.5, clipY = 0.5}) {
        this._resizeMode = {type, w, h, clipX, clipY};
        if (this.isLoaded()) {
            this._applyResizeMode();
        }
    }

    get resizeMode() {
        return this._resizeMode;
    }

    _clearResizeMode() {
        this._resizeMode = null;
    }

    _applyResizeMode() {
        if (this._resizeMode.type === "cover") {
            this._applyResizeCover();
        } else if (this._resizeMode.type === "contain") {
            this._applyResizeContain();
        }
        this._updatePrecision();
        this._updateClipping();
    }

    _applyResizeCover() {
        const scaleX = this._resizeMode.w / this._source.w;
        const scaleY = this._resizeMode.h / this._source.h;
        let scale = Math.max(scaleX, scaleY);
        if (!scale) return;
        this._precision = 1/scale;
        if (scaleX && scaleX < scale) {
            const desiredSize = this._precision * this._resizeMode.w;
            const choppedOffPixels = this._source.w - desiredSize;
            this._x = choppedOffPixels * this._resizeMode.clipX;
            this._w = this._source.w - choppedOffPixels;
        }
        if (scaleY && scaleY < scale) {
            const desiredSize = this._precision * this._resizeMode.h;
            const choppedOffPixels = this._source.h - desiredSize;
            this._y = choppedOffPixels * this._resizeMode.clipY;
            this._h = this._source.h - choppedOffPixels;
        }
    }

    _applyResizeContain() {
        const scaleX = this._resizeMode.w / this._source.w;
        const scaleY = this._resizeMode.h / this._source.h;
        let scale = scaleX;
        if (!scale || scaleY < scale) {
            scale = scaleY;
        }
        if (!scale) return;
        this._precision = 1/scale;
    }

    enableClipping(x, y, w, h) {
        this._clearResizeMode();

        x *= this._precision;
        y *= this._precision;
        w *= this._precision;
        h *= this._precision;
        if (this._x !== x || this._y !== y || this._w !== w || this._h !== h) {
            this._x = x;
            this._y = y;
            this._w = w;
            this._h = h;

            this._updateClipping(true);
        }
    }

    disableClipping() {
        this._clearResizeMode();

        if (this._x || this._y || this._w || this._h) {
            this._x = 0;
            this._y = 0;
            this._w = 0;
            this._h = 0;

            this._updateClipping();
        }
    }

    _updateClipping() {
        this.clipping = !!(this._x || this._y || this._w || this._h);

        let self = this;
        this.elements.forEach(function(element) {
            // Ignore if not the currently displayed texture.
            if (element.displayedTexture === self) {
                element.onDisplayedTextureClippingChanged();
            }
        });
    }

    _updatePrecision() {
        let self = this;
        this.elements.forEach(function(element) {
            // Ignore if not the currently displayed texture.
            if (element.displayedTexture === self) {
                element.onPrecisionChanged();
            }
        });
    }

    getNonDefaults() {
        let nonDefaults = {};
        nonDefaults['type'] = this.constructor.name;
        if (this.x !== 0) nonDefaults['x'] = this.x;
        if (this.y !== 0) nonDefaults['y'] = this.y;
        if (this.w !== 0) nonDefaults['w'] = this.w;
        if (this.h !== 0) nonDefaults['h'] = this.h;
        if (this.precision !== 1) nonDefaults['precision'] = this.precision;
        return nonDefaults;
    }

    get px() {
        return this._x;
    }

    get py() {
        return this._y;
    }

    get pw() {
        return this._w;
    }

    get ph() {
        return this._h;
    }

    get x() {
        return this._x / this._precision;
    }
    set x(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._x !== v) {
            this._x = v;
            this._updateClipping();
        }
    }

    get y() {
        return this._y / this._precision;
    }
    set y(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._y !== v) {
            this._y = v;
            this._updateClipping();
        }
    }

    get w() {
        return this._w / this._precision;
    }

    set w(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._w !== v) {
            this._w = v;
            this._updateClipping();
        }
    }

    get h() {
        return this._h / this._precision;
    }

    set h(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._h !== v) {
            this._h = v;
            this._updateClipping();
        }
    }

    get precision() {
        return this._precision;
    }

    set precision(v) {
        this._clearResizeMode();
        if (this._precision !== v) {
            this._precision = v;
            this._updatePrecision();
        }
    }

    isAutosizeTexture() {
        return true;
    }

    getRenderWidth() {
        if (!this.isAutosizeTexture()) {
            // In case of the rectangle texture, we'd prefer to not cause a 1x1 w,h as it would interfere with flex layout fit-to-contents.
            return 0;
        }

        // If dimensions are unknown (texture not yet loaded), use maximum width as a fallback as render width to allow proper bounds checking.
        return (this._w || (this._source ? this._source.getRenderWidth() - this._x : 0)) / this._precision;
    }

    getRenderHeight() {
        if (!this.isAutosizeTexture()) {
            // In case of the rectangle texture, we'd prefer to not cause a 1x1 w,h as it would interfere with flex layout fit-to-contents.
            return 0;
        }

        return (this._h || (this._source ? this._source.getRenderHeight() - this._y : 0)) / this._precision;
    }

    patch(settings) {
        _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
    }

}

Texture.prototype.isTexture = true;

Texture.id = 0;




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/TextureManager.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/TextureManager.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureManager)
/* harmony export */ });
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureSource.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureSource.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class TextureManager {

    constructor(stage) {
        this.stage = stage;

        /**
         * The currently used amount of texture memory.
         * @type {number}
         */
        this._usedMemory = 0;

        /**
         * All uploaded texture sources.
         * @type {TextureSource[]}
         */
        this._uploadedTextureSources = [];

        /**
         * The texture source lookup id to texture source hashmap.
         * @type {Map<String, TextureSource>}
         */
        this.textureSourceHashmap = new Map();

    }

    get usedMemory() {
        return this._usedMemory;
    }

    destroy() {
        for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
            this._nativeFreeTextureSource(this._uploadedTextureSources[i]);
        }
        
        this.textureSourceHashmap.clear();
        this._usedMemory = 0;
    }

    getReusableTextureSource(id) {
        return this.textureSourceHashmap.get(id);
    }

    getTextureSource(func, id) {
        // Check if texture source is already known.
        let textureSource = id ? this.textureSourceHashmap.get(id) : null;
        if (!textureSource) {
            // Create new texture source.
            textureSource = new _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this, func);

            if (id) {
                textureSource.lookupId = id;
                this.textureSourceHashmap.set(id, textureSource);
            }
        }

        return textureSource;
    }

    uploadTextureSource(textureSource, options) {
        if (textureSource.isLoaded()) return;

        this._addMemoryUsage(textureSource.w * textureSource.h);

        // Load texture.
        const nativeTexture = this._nativeUploadTextureSource(textureSource, options);

        textureSource._nativeTexture = nativeTexture;

        // We attach w and h to native texture (we need it in CoreRenderState._isRenderTextureReusable).
        nativeTexture.w = textureSource.w;
        nativeTexture.h = textureSource.h;

        nativeTexture.update = this.stage.frameCounter;

        this._uploadedTextureSources.push(textureSource);
        
        this.addToLookupMap(textureSource);
    }

    _addMemoryUsage(delta) {
        this._usedMemory += delta;
        this.stage.addMemoryUsage(delta);
    }
    
    addToLookupMap(textureSource) {
        const lookupId = textureSource.lookupId;
        if (lookupId) {
            if (!this.textureSourceHashmap.has(lookupId)) {
                this.textureSourceHashmap.set(lookupId, textureSource);
            }
        }
    }

    gc() {
        this.freeUnusedTextureSources();
        this._cleanupLookupMap();
    }
    
    freeUnusedTextureSources() {
        let remainingTextureSources = [];
        for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
            let ts = this._uploadedTextureSources[i];
            if (ts.allowCleanup()) {
                this._freeManagedTextureSource(ts);
            } else {
                remainingTextureSources.push(ts);
            }
        }

        this._uploadedTextureSources = remainingTextureSources;

        this._cleanupLookupMap();
    }

    _freeManagedTextureSource(textureSource) {
        if (textureSource.isLoaded()) {
            this._nativeFreeTextureSource(textureSource);
            this._addMemoryUsage(-textureSource.w * textureSource.h);
        }

        // Should be reloaded.
        textureSource.loadingSince = null;
    }

    _cleanupLookupMap() {
        // We keep those that still have value (are being loaded or already loaded, or are likely to be reused).
        this.textureSourceHashmap.forEach((textureSource, lookupId) => {
            if (!(textureSource.isLoaded() || textureSource.isLoading()) && !textureSource.isUsed()) {
                this.textureSourceHashmap.delete(lookupId);
            }
        });
    }

    /**
     * Externally free texture source.
     * @param textureSource
     */
    freeTextureSource(textureSource) {
        const index = this._uploadedTextureSources.indexOf(textureSource);
        const managed = (index !== -1);

        if (textureSource.isLoaded()) {
            if (managed) {
                this._addMemoryUsage(-textureSource.w * textureSource.h);
                this._uploadedTextureSources.splice(index, 1);
            }
            this._nativeFreeTextureSource(textureSource);
        }

        // Should be reloaded.
        textureSource.loadingSince = null;
    }

    _nativeUploadTextureSource(textureSource, options) {
        return this.stage.renderer.uploadTextureSource(textureSource, options);
    }

    _nativeFreeTextureSource(textureSource) {
        this.stage.renderer.freeTextureSource(textureSource);
        textureSource.clearNativeTexture();
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/TextureSource.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/TextureSource.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureSource)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class TextureSource {

    constructor(manager, loader = null) {
        this.id = TextureSource.id++;

        this.manager = manager;

        this.stage = manager.stage;

        /**
         * All enabled textures (textures that are used by visible elements).
         * @type {Set<Texture>}
         */
        this.textures = new Set();

        /**
         * The number of active textures (textures that have at least one active element).
         * @type {number}
         * @private
         */
        this._activeTextureCount = 0;

        /**
         * The factory for the source of this texture.
         * @type {Function}
         */
        this.loader = loader;

        /**
         * Identifier for reuse.
         * @type {String}
         */
        this.lookupId = null;

        /**
         * If set, this.is called when the texture source is no longer displayed (this.components.size becomes 0).
         * @type {Function}
         */
        this._cancelCb = null;

        /**
         * Loading since timestamp in millis.
         * @type {number}
         */
        this.loadingSince = 0;

        this.w = 0;
        this.h = 0;

        this._nativeTexture = null;

        /**
         * If true, then this.texture source is never freed from memory during garbage collection.
         * @type {boolean}
         */
        this.permanent = false;

        /**
         * Sub-object with texture-specific rendering information.
         * For images, contains the src property, for texts, contains handy rendering information.
         * @type {Object}
         */
        this.renderInfo = null;

        /**
         * Generated for 'renderToTexture'.
         * @type {boolean}
         * @private
         */
        this._isResultTexture = !this.loader;

        /**
         * Contains the load error, if the texture source could previously not be loaded.
         * @type {object}
         * @private
         */
        this._loadError = null;

        /**
         *  Hold a reference to the javascript variable which contains the texture, this is not required for WebGL in WebBrowsers but is required for Spark runtime.
         * @type {object}
         * @private
         */
        this._imageRef = null;

    }

    get loadError() {
        return this._loadError;
    }

    addTexture(v) {
        if (!this.textures.has(v)) {
            this.textures.add(v);
        }
    }

    removeTexture(v) {
        this.textures.delete(v);
    }

    incActiveTextureCount() {
        this._activeTextureCount++;
        if (this._activeTextureCount === 1) {
            this.becomesUsed();
        }
    }

    decActiveTextureCount() {
        this._activeTextureCount--;
        if (this._activeTextureCount === 0) {
            this.becomesUnused();
        }
    }

    get isResultTexture() {
        return this._isResultTexture;
    }

    set isResultTexture(v) {
        this._isResultTexture = v;
    }

    forEachEnabledElement(cb) {
        this.textures.forEach(texture => {
            texture.elements.forEach(cb);
        });
    }

    hasEnabledElements() {
        return this.textures.size > 0;
    }

    forEachActiveElement(cb) {
        this.textures.forEach(texture => {
            texture.elements.forEach(element => {
                if (element.active) {
                    cb(element);
                }
            });
        });
    }

    getRenderWidth() {
        return this.w;
    }

    getRenderHeight() {
        return this.h;
    }

    allowCleanup() {
        return !this.permanent && !this.isUsed();
    }

    becomesUsed() {
        // Even while the texture is being loaded, make sure it is on the lookup map so that others can reuse it.
        this.load();
    }

    becomesUnused() {
        this.cancel();
    }

    cancel() {
        if (this.isLoading()) {
            if (this._cancelCb) {
                this._cancelCb(this);

                // Clear callback to avoid memory leaks.
                this._cancelCb = null;
            }
            this.loadingSince = 0;
        }
    }

    isLoaded() {
        return !!this._nativeTexture;
    }

    isLoading() {
        return (this.loadingSince > 0);
    }

    isError() {
        return !!this._loadError;
    }

    reload() {
        this.free();
        if (this.isUsed()) {
            this.load();
        }
    }

    load(forceSync = false) {
        // From the moment of loading (when a texture source becomes used by active elements)
        if (this.isResultTexture) {
            // Element result texture source, for which the loading is managed by the core.
            return;
        }

        if (!this._nativeTexture && !this.isLoading()) {
            this.loadingSince = (new Date()).getTime();
            this._cancelCb = this.loader((err, options) => {
                // Ignore loads that come in after a cancel.
                if (this.isLoading()) {
                    // Clear callback to avoid memory leaks.
                    this._cancelCb = null;

                    if (this.manager.stage.destroyed) {
                        // Ignore async load when stage is destroyed.
                        return;
                    }
                    if (err) {
                        // Emit txError.
                        this.onError(err);
                    } else if (options && options.source) {
                        if (!this.stage.isUpdatingFrame() && !forceSync && (options.throttle !== false)) {
                            const textureThrottler = this.stage.textureThrottler;
                            this._cancelCb = textureThrottler.genericCancelCb;
                            textureThrottler.add(this, options);
                        } else {
                            this.processLoadedSource(options);
                        }
                    }
                }
            }, this);
        }
    }

    processLoadedSource(options) {
        this.loadingSince = 0;
        this.setSource(options);
    }

    setSource(options) {
        const source = options.source;

        this.w = source.width || (options && options.w) || 0;
        this.h = source.height || (options && options.h) || 0;

        if (options && options.renderInfo) {
            // Assign to id in cache so that it can be reused.
            this.renderInfo = options.renderInfo;
        }

        this.permanent = !!options.permanent;

        if (options && options.imageRef)
            this._imageRef = options.imageRef;
        if (options && options.flipTextureY) {
            this._flipTextureY = options.flipTextureY;
        } else {
            this._flipTextureY = false;
        }

        if (this._isNativeTexture(source)) {
            // Texture managed by caller.
            this._nativeTexture = source;

            this.w = this.w || source.w;
            this.h = this.h || source.h;

            // WebGLTexture objects are by default;
            this.permanent = options.hasOwnProperty('permanent') ? options.permanent : true;
        } else {
            this.manager.uploadTextureSource(this, options);
        }

        // Must be cleared when reload is succesful.
        this._loadError = null;

        this.onLoad();
    }

    isUsed() {
        return this._activeTextureCount > 0;
    }

    onLoad() {
        if (this.isUsed()) {
            this.textures.forEach(texture => {
                texture.onLoad();
            });
        }
    }

    forceRenderUpdate() {
        // Userland should call this method after changing the nativeTexture manually outside of the framework
        //  (using tex[Sub]Image2d for example).

        if (this._nativeTexture) {
            // Change 'update' flag. This is currently not used by the framework but is handy in userland.
            this._nativeTexture.update = this.stage.frameCounter;
        }

        this.forEachActiveElement(function (element) {
            element.forceRenderUpdate();
        });

    }

    forceUpdateRenderCoords() {
        this.forEachActiveElement(function (element) {
            element._updateTextureCoords();
        });
    }

    get nativeTexture() {
        return this._nativeTexture;
    }

    clearNativeTexture() {
        this._nativeTexture = null;
        //also clear the reference to the texture variable.
        this._imageRef = null;
    }

    /**
     * Used for result textures.
     */
    replaceNativeTexture(newNativeTexture, w, h) {
        let prevNativeTexture = this._nativeTexture;
        // Loaded by core.
        this._nativeTexture = newNativeTexture;
        this.w = w;
        this.h = h;

        if (!prevNativeTexture && this._nativeTexture) {
            this.forEachActiveElement(element => element.onTextureSourceLoaded());
        }

        if (!this._nativeTexture) {
            this.forEachActiveElement(element => element._setDisplayedTexture(null));
        }

        // Dimensions must be updated also on enabled elements, as it may force it to go within bounds.
        this.forEachEnabledElement(element => element._updateDimensions());

        // Notice that the sprite map must never contain render textures.
    }

    onError(e) {
        this._loadError = e;
        this.loadingSince = 0;
        console.error('[Lightning] texture load error', e, this.lookupId);
        this.forEachActiveElement(element => element.onTextureSourceLoadError(e));
    }

    free() {
        if (this.isLoaded()) {
            this.manager.freeTextureSource(this);
        }
    }

    _isNativeTexture(source) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNode) {
            return source.constructor.name === "WebGLTexture";
        }

        if ('WebGLTexture' in window) {
            return source instanceof WebGLTexture;
        }

        return false;
    }

}

TextureSource.prototype.isTextureSource = true;

TextureSource.id = 1;




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/TextureThrottler.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/TextureThrottler.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureThrottler)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Allows throttling of loading texture sources, keeping the app responsive.
 */
class TextureThrottler {

    constructor(stage) {
        this.stage = stage;

        this.genericCancelCb = (textureSource) => {
            this._remove(textureSource);
        };

        this._sources = [];
        this._data = [];
    }

    destroy() {
        this._sources = [];
        this._data = [];
    }

    processSome() {
        if (this._sources.length) {
            const start = Date.now();
            do {
                this._processItem();
            } while(this._sources.length && (Date.now() - start < TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME));
        }
    }

    _processItem() {
        const source = this._sources.pop();
        const data = this._data.pop();
        if (source.isLoading()) {
            source.processLoadedSource(data);
        }
    }

    add(textureSource, data) {
        this._sources.push(textureSource);
        this._data.push(data);
    }

    _remove(textureSource) {
        const index = this._sources.indexOf(textureSource);
        if (index >= 0) {
            this._sources.splice(index, 1);
            this._data.splice(index, 1);
        }
    }

}

TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME = 10;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Utils.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Utils.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Utils)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Utils {

    static isFunction(value) {
        return typeof value === 'function';
    }

    static isNumber(value) {
        return typeof value === 'number';
    }

    static isInteger(value) {
        return (typeof value === 'number' && (value % 1) === 0);
    }

    static isBoolean(value) {
        return value === true || value === false;
    }

    static isString(value) {
        return typeof value === 'string';
    }

    static clone(v) {
        if (Utils.isObjectLiteral(v) || Array.isArray(v)) {
            return Utils.getDeepClone(v);
        } else {
            // Copy by value.
            return v;
        }
    }

    static cloneObjShallow(obj) {
        let keys = Object.keys(obj);
        let clone = {}
        for (let i = 0; i < keys.length; i++) {
            clone[keys[i]] = obj[keys[i]];
        }
        return clone;
    }

    static merge(obj1, obj2) {
        let keys = Object.keys(obj2);
        for (let i = 0; i < keys.length; i++) {
            obj1[keys[i]] = obj2[keys[i]];
        }
        return obj1;
    }

    static isObject(value) {
        let type = typeof value;
        return !!value && (type === 'object' || type === 'function');
    }

    static isPlainObject(value) {
        let type = typeof value;
        return !!value && (type === 'object');
    }

    static isObjectLiteral(value){
        return typeof value === 'object' && value && value.constructor === Object;
    }

    static getArrayIndex(index, arr) {
        return Utils.getModuloIndex(index, arr.length);
    }

    static getModuloIndex(index, len) {
        if (len === 0) return index;
        while (index < 0) {
            index += Math.ceil(-index / len) * len;
        }
        index = index % len;
        return index;
    }

    static getDeepClone(obj) {
        let i, c;
        if (Utils.isFunction(obj)) {
            // Copy functions by reference.
            return obj;
        }
        if (Array.isArray(obj)) {
            c = [];
            let keys = Object.keys(obj);
            for (i = 0; i < keys.length; i++) {
                c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
            }
            return c;
        } else if (Utils.isObject(obj)) {
            c = {}
            let keys = Object.keys(obj);
            for (i = 0; i < keys.length; i++) {
                c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
            }
            return c;
        } else {
            return obj;
        }
    }

    static equalValues(v1, v2) {
        if ((typeof v1) !== (typeof v2)) return false;
        if (Utils.isObjectLiteral(v1)) {
            return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2);
        } else if (Array.isArray(v1)) {
            return Array.isArray(v2) && Utils.equalArrays(v1, v2);
        } else {
            return v1 === v2;
        }
    }

    static equalObjectLiterals(obj1, obj2) {
        let keys1 = Object.keys(obj1);
        let keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) {
            return false;
        }

        for (let i = 0, n = keys1.length; i < n; i++) {
            const k1 = keys1[i];
            const k2 = keys2[i];
            if (k1 !== k2) {
                return false;
            }

            const v1 = obj1[k1];
            const v2 = obj2[k2];

            if (!Utils.equalValues(v1, v2)) {
                return false;
            }
        }

        return true;
    }

    static equalArrays(v1, v2) {
        if (v1.length !== v2.length) {
            return false;
        }
        for (let i = 0, n = v1.length; i < n; i++) {
            if (!this.equalValues(v1[i], v2[i])) {
                return false;
            }
        }

        return true;
    }

    static setToArray(s) {
        let result = [];
        s.forEach(function (value) {
            result.push(value);
        });
        return result;
    }

    static iteratorToArray(iterator) {
        let result = [];
        let iteratorResult = iterator.next();
        while (!iteratorResult.done) {
            result.push(iteratorResult.value);
            iteratorResult = iterator.next();
        }
        return result;
    }

    static isUcChar(charcode) {
        return charcode >= 65 && charcode <= 90;
    }

}

Utils.isWeb = (typeof window !== "undefined") && (typeof sparkscene === "undefined");
Utils.isWPE = Utils.isWeb && (navigator.userAgent.indexOf("WPE") !== -1);
Utils.isSpark = (typeof sparkscene !== "undefined");
Utils.isNode = (typeof window === "undefined") || Utils.isSpark;
Utils.isPS4 = Utils.isWeb && (navigator.userAgent.indexOf("PlayStation 4") !== -1);


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreContext.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreContext.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreContext)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class CoreContext {

    constructor(stage) {
        this.stage = stage;

        this.root = null;

        this.updateTreeOrder = 0;

        this.renderState = this.stage.renderer.createCoreRenderState(this);

        this.renderExec = this.stage.renderer.createCoreRenderExecutor(this);
        this.renderExec.init();

        this._usedMemory = 0;
        this._renderTexturePool = [];

        this._renderTextureId = 1;

        this._zSorts = [];
    }

    get usedMemory() {
        return this._usedMemory;
    }

    destroy() {
        this._renderTexturePool.forEach(texture => this._freeRenderTexture(texture));
        this._usedMemory = 0;
    }

    hasRenderUpdates() {
        return !!this.root._parent._hasRenderUpdates;
    }

    render() {
        // Clear flag to identify if anything changes before the next frame.
        this.root._parent._hasRenderUpdates = 0;

        this._render();
    }

    update() {
        this._update();

        // Due to the boundsVisibility flag feature (and onAfterUpdate hook), it is possible that other elements were
        // changed during the update loop (for example due to the txLoaded event). We process these changes immediately
        // (but not recursively to prevent infinite loops).
        if (this.root._hasUpdates) {
            this._update();
        }

        this._performForcedZSorts();
    }

    /**
     * Certain ElementCore items may be forced to zSort to strip out references to prevent memleaks..
     */
    _performForcedZSorts() {
        const n = this._zSorts.length;
        if (n) {
            // Forced z-sorts (ElementCore may force a z-sort in order to free memory/prevent memory leaks).
            for (let i = 0, n = this._zSorts.length; i < n; i++) {
                if (this._zSorts[i].zSort) {
                    this._zSorts[i].sortZIndexedChildren();
                }
            }
            this._zSorts = [];
        }
    }

    _update() {
        this.updateTreeOrder = 0;

        this.root.update();
    }

    _render() {
        // Obtain a sequence of the quad operations.
        this._fillRenderState();

        if (this.stage.getOption('readPixelsBeforeDraw')) {
            const pixels = new Uint8Array(4);
            const gl = this.stage.gl;
            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        }

        // Now run them with the render executor.
        this._performRender();
    }

    _fillRenderState() {
        this.renderState.reset();
        this.root.render();
        this.renderState.finish();
    }

    _performRender() {
        this.renderExec.execute();
    }

    _addMemoryUsage(delta) {
        this._usedMemory += delta;
        this.stage.addMemoryUsage(delta);
    }

    allocateRenderTexture(w, h) {
        let prec = this.stage.getRenderPrecision();
        let pw = Math.max(1, Math.round(w * prec));
        let ph = Math.max(1, Math.round(h * prec));

        // Search last item first, so that last released render texture is preferred (may cause memory cache benefits).
        const n = this._renderTexturePool.length;
        for (let i = n - 1; i >= 0; i--) {
            const texture = this._renderTexturePool[i];
            // We don't want to reuse the same render textures within the same frame because that will create gpu stalls.
            if (texture.w === pw && texture.h === ph && (texture.update !== this.stage.frameCounter)) {
                texture.f = this.stage.frameCounter;
                this._renderTexturePool.splice(i, 1);
                return texture;
            }
        }

        const texture = this._createRenderTexture(w, h, pw, ph);
        texture.precision = prec;
        return texture;
    }

    releaseRenderTexture(texture) {
        this._renderTexturePool.push(texture);
    }

    freeUnusedRenderTextures(maxAge = 60) {
        // Clean up all textures that are no longer used.
        // This cache is short-lived because it is really just meant to supply running shaders that are
        // updated during a number of frames.
        let limit = this.stage.frameCounter - maxAge;

        this._renderTexturePool = this._renderTexturePool.filter(texture => {
            if (texture.f <= limit) {
                this._freeRenderTexture(texture);
                return false;
            }
            return true;
        });
    }

    _createRenderTexture(w, h, pw, ph) {
        this._addMemoryUsage(pw * ph);

        const texture = this.stage.renderer.createRenderTexture(w, h, pw, ph);
        texture.id = this._renderTextureId++;
        texture.f = this.stage.frameCounter;
        texture.ow = w;
        texture.oh = h;
        texture.w = pw;
        texture.h = ph;

        return texture;
    }

    _freeRenderTexture(nativeTexture) {
        this.stage.renderer.freeRenderTexture(nativeTexture);
        this._addMemoryUsage(-nativeTexture.w * nativeTexture.h);
    }

    copyRenderTexture(renderTexture, nativeTexture, options) {
        this.stage.renderer.copyRenderTexture(renderTexture, nativeTexture, options);
    }

    forceZSort(elementCore) {
        this._zSorts.push(elementCore);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreQuadList)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class CoreQuadList {

    constructor(ctx) {

        this.ctx = ctx;

        this.quadTextures = [];

        this.quadElements = [];
    }

    get length() {
        return this.quadTextures.length;
    }

    reset() {
        this.quadTextures = [];
        this.quadElements = [];
        this.dataLength = 0;
    }

    getElement(index) {
        return this.quadElements[index]._element;
    }

    getElementCore(index) {
        return this.quadElements[index];
    }

    getTexture(index) {
        return this.quadTextures[index];
    }

    getTextureWidth(index) {
        let nativeTexture = this.quadTextures[index];
        if (nativeTexture.w) {
            // Render texture;
            return nativeTexture.w;
        } else {
            return this.quadElements[index]._displayedTextureSource.w;
        }
    }

    getTextureHeight(index) {
        let nativeTexture = this.quadTextures[index];
        if (nativeTexture.h) {
            // Render texture;
            return nativeTexture.h;
        } else {
            return this.quadElements[index]._displayedTextureSource.h;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreQuadOperation)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class CoreQuadOperation {

    constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {

        this.ctx = ctx;
        this.shader = shader;
        this.shaderOwner = shaderOwner;
        this.renderTextureInfo = renderTextureInfo;
        this.scissor = scissor;
        this.index = index;
        this.length = 0;

    }

    get quads() {
        return this.ctx.renderState.quads;
    }

    getTexture(index) {
        return this.quads.getTexture(this.index + index);
    }

    getElementCore(index) {
        return this.quads.getElementCore(this.index + index);
    }

    getElement(index) {
        return this.quads.getElement(this.index + index);
    }

    getElementWidth(index) {
        return this.getElement(index).renderWidth;
    }

    getElementHeight(index) {
        return this.getElement(index).renderHeight;
    }

    getTextureWidth(index) {
        return this.quads.getTextureWidth(this.index + index);
    }

    getTextureHeight(index) {
        return this.quads.getTextureHeight(this.index + index);
    }

    getRenderWidth() {
        if (this.renderTextureInfo) {
            return this.renderTextureInfo.w;
        } else {
            return this.ctx.stage.w;
        }
    }

    getRenderHeight() {
        if (this.renderTextureInfo) {
            return this.renderTextureInfo.h;
        } else {
            return this.ctx.stage.h;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreRenderExecutor)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class CoreRenderExecutor {

    constructor(ctx) {
        this.ctx = ctx;

        this.renderState = ctx.renderState;

        this.gl = this.ctx.stage.gl;
    }

    destroy() {
    }

    _reset() {
        this._bindRenderTexture(null);
        this._setScissor(null);
        this._clearRenderTexture();
    }

    execute() {
        this._reset();

        let qops = this.renderState.quadOperations;

        let i = 0, j = 0, n = qops.length;
        while (i < n) {
            this._processQuadOperation(qops[i]);
            i++;
        }
    }

    _processQuadOperation(quadOperation) {
        if (quadOperation.renderTextureInfo && quadOperation.renderTextureInfo.ignore) {
            // Ignore quad operations when we are 're-using' another texture as the render texture result.
            return;
        }

        this._setupQuadOperation(quadOperation);
        this._execQuadOperation(quadOperation);

    }

    _setupQuadOperation(quadOperation) {
    }

    _execQuadOperation(op) {
        // Set render texture.
        let nativeTexture = op.renderTextureInfo ? op.renderTextureInfo.nativeTexture : null;

        if (this._renderTexture !== nativeTexture) {
            this._bindRenderTexture(nativeTexture);
        }

        if (op.renderTextureInfo && !op.renderTextureInfo.cleared) {
            this._setScissor(null);
            this._clearRenderTexture();
            op.renderTextureInfo.cleared = true;
            this._setScissor(op.scissor);
        } else {
            this._setScissor(op.scissor);
        }

        this._renderQuadOperation(op);
    }

    _renderQuadOperation(op) {
    }

    _bindRenderTexture(renderTexture) {
        this._renderTexture = renderTexture;
    }

    _clearRenderTexture(renderTexture) {
    }

    _setScissor(area) {
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreRenderState)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class CoreRenderState {

    constructor(ctx) {
        this.ctx = ctx;

        this.stage = ctx.stage;

        this.defaultShader = this.stage.renderer.getDefaultShader(ctx);

        this.renderer = ctx.stage.renderer;

        this.quads = this.renderer.createCoreQuadList(ctx);

    }

    reset() {
        this._renderTextureInfo = null;

        this._scissor = null;

        this._shader = null;

        this._shaderOwner = null;

        this._realShader = null;

        this._check = false;

        this.quadOperations = [];

        this._texturizer = null;

        this._texturizerTemporary = false;

        this._quadOperation = null;

        this.quads.reset();

        this._temporaryTexturizers = [];
        
        this._isCachingTexturizer = false;

    }

    get length() {
        return this.quads.quadTextures.length;
    }

    setShader(shader, owner) {
        if (this._shaderOwner !== owner || this._realShader !== shader) {
            // Same shader owner: active shader is also the same.
            // Prevent any shader usage to save performance.

            this._realShader = shader;

            if (shader.useDefault()) {
                // Use the default shader when possible to prevent unnecessary program changes.
                shader = this.defaultShader;
            }
            if (this._shader !== shader || this._shaderOwner !== owner) {
                this._shader = shader;
                this._shaderOwner = owner;
                this._check = true;
            }
        }
    }

    get renderTextureInfo() {
        return this._renderTextureInfo;
    }

    setScissor(area) {
        if (this._scissor !== area) {
            if (area) {
                this._scissor = area;
            } else {
                this._scissor = null;
            }
            this._check = true;
        }
    }

    getScissor() {
        return this._scissor;
    }

    setRenderTextureInfo(renderTextureInfo) {
        if (this._renderTextureInfo !== renderTextureInfo) {
            this._renderTextureInfo = renderTextureInfo;
            this._scissor = null;
            this._check = true;
        }
    }

    /**
     * Sets the texturizer to be drawn during subsequent addQuads.
     * @param {ElementTexturizer} texturizer
     */
    setTexturizer(texturizer, cache = false) {
        this._texturizer = texturizer;
        this._cacheTexturizer = cache;
    }

    set isCachingTexturizer(v) {
        this._isCachingTexturizer = v;
    }

    get isCachingTexturizer() {
        return this._isCachingTexturizer;
    }

    addQuad(elementCore) {
        if (!this._quadOperation) {
            this._createQuadOperation();
        } else if (this._check && this._hasChanges()) {
            this._finishQuadOperation();
            this._check = false;
        }

        let nativeTexture = null;
        if (this._texturizer) {
            nativeTexture = this._texturizer.getResultTexture();

            if (!this._cacheTexturizer) {
                // We can release the temporary texture immediately after finalizing this quad operation.
                this._temporaryTexturizers.push(this._texturizer);
            }
        }

        if (!nativeTexture) {
            nativeTexture = elementCore._displayedTextureSource.nativeTexture;
        }

        if (this._renderTextureInfo) {
            if (this._shader === this.defaultShader && this._renderTextureInfo.empty) {
                // The texture might be reusable under some conditions. We will check them in ElementCore.renderer.
                this._renderTextureInfo.nativeTexture = nativeTexture;
                this._renderTextureInfo.offset = this.length;
            } else {
                // It is not possible to reuse another texture when there is more than one quad.
                this._renderTextureInfo.nativeTexture = null;
            }
            this._renderTextureInfo.empty = false;
        }

        this.quads.quadTextures.push(nativeTexture);
        this.quads.quadElements.push(elementCore);

        this._quadOperation.length++;

        this.renderer.addQuad(this, this.quads, this.length - 1)
    }

    finishedRenderTexture() {
        if (this._renderTextureInfo.nativeTexture) {
            // There was only one texture drawn in this render texture.
            // Check if we can reuse it so that we can optimize out an unnecessary render texture operation.
            // (it should exactly span this render texture).
            if (!this._isRenderTextureReusable()) {
                this._renderTextureInfo.nativeTexture = null;
            }
        }
    }

    _isRenderTextureReusable() {
        const offset = this._renderTextureInfo.offset;
        return (this.quads.quadTextures[offset].w === this._renderTextureInfo.w) &&
            (this.quads.quadTextures[offset].h === this._renderTextureInfo.h) &&
            this.renderer.isRenderTextureReusable(this, this._renderTextureInfo)
    }

    _hasChanges() {
        let q = this._quadOperation;
        if (this._shader !== q.shader) return true;
        if (this._shaderOwner !== q.shaderOwner) return true;
        if (this._renderTextureInfo !== q.renderTextureInfo) return true;
        if (this._scissor !== q.scissor) {
            if ((this._scissor[0] !== q.scissor[0]) || (this._scissor[1] !== q.scissor[1]) || (this._scissor[2] !== q.scissor[2]) || (this._scissor[3] !== q.scissor[3])) {
                return true;
            }
        }

        return false;
    }

    _finishQuadOperation(create = true) {
        if (this._quadOperation) {
            if (this._quadOperation.length || this._shader.addEmpty()) {
                if (!this._quadOperation.scissor || ((this._quadOperation.scissor[2] > 0) && (this._quadOperation.scissor[3] > 0))) {
                    // Ignore empty clipping regions.
                    this.quadOperations.push(this._quadOperation);
                }
            }

            if (this._temporaryTexturizers.length) {
                for (let i = 0, n = this._temporaryTexturizers.length; i < n; i++) {
                    // We can now reuse these render-to-textures in subsequent stages.
                    // Huge performance benefit when filtering (fast blur).
                    this._temporaryTexturizers[i].releaseRenderTexture();
                }
                this._temporaryTexturizers = [];
            }

            this._quadOperation = null;
        }

        if (create) {
            this._createQuadOperation();
        }
    }

    _createQuadOperation() {
        this._quadOperation = this.renderer.createCoreQuadOperation(
            this.ctx,
            this._shader,
            this._shaderOwner,
            this._renderTextureInfo,
            this._scissor,
            this.length
        );
        this._check = false;
    }

    finish() {
        if (this._quadOperation) {
            // Add remaining.
            this._finishQuadOperation(false);
        }

        this.renderer.finishRenderState(this);
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementCore)
/* harmony export */ });
/* harmony import */ var _flex_FlexTarget_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../flex/FlexTarget.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexTarget.mjs");
/* harmony import */ var _ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ElementTexturizer.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs");
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ElementCore {

    constructor(element) {
        this._element = element;

        this.ctx = element.stage.ctx;

        // The memory layout of the internal variables is affected by their position in the constructor.
        // It boosts performance to order them by usage of cpu-heavy functions (renderSimple and update).

        this._recalc = 0;

        this._parent = null;

        this._onUpdate = null;

        this._pRecalc = 0;

        this._worldContext = new ElementCoreContext();

        this._hasUpdates = false;

        this._localAlpha = 1;

        this._onAfterCalcs = null;

        this._onAfterUpdate = null;

        // All local translation/transform updates: directly propagated from x/y/w/h/scale/whatever.
        this._localPx = 0;
        this._localPy = 0;

        this._localTa = 1;
        this._localTb = 0;
        this._localTc = 0;
        this._localTd = 1;

        this._isComplex = false;

        this._dimsUnknown = false;

        this._clipping = false;

        // Used by both update and render.
        this._zSort = false;

        this._outOfBounds = 0;

        /**
         * The texture source to be displayed.
         * @type {TextureSource}
         */
        this._displayedTextureSource = null;

        this._zContextUsage = 0;

        this._children = null;

        this._hasRenderUpdates = 0;

        this._zIndexedChildren = null;

        this._renderContext = this._worldContext;

        this.renderState = this.ctx.renderState;

        this._scissor = null;

        // The ancestor ElementCore that owns the inherited shader. Null if none is active (default shader).
        this._shaderOwner = null;


        this._updateTreeOrder = 0;

        this._colorUl = this._colorUr = this._colorBl = this._colorBr = 0xFFFFFFFF;

        this._x = 0;
        this._y = 0;
        this._w = 0;
        this._h = 0;

        this._optFlags = 0;
        this._funcX = null;
        this._funcY = null;
        this._funcW = null;
        this._funcH = null;

        this._scaleX = 1;
        this._scaleY = 1;
        this._pivotX = 0.5;
        this._pivotY = 0.5;
        this._mountX = 0;
        this._mountY = 0;
        this._rotation = 0;

        this._alpha = 1;
        this._visible = true;

        this._ulx = 0;
        this._uly = 0;
        this._brx = 1;
        this._bry = 1;

        this._zIndex = 0;
        this._forceZIndexContext = false;
        this._zParent = null;

        this._isRoot = false;

        /**
         * Iff true, during zSort, this element should be 're-sorted' because either:
         * - zIndex did chang
         * - zParent did change
         * - element was moved in the render tree
         * @type {boolean}
         */
        this._zIndexResort = false;

        this._shader = null;

        // Element is rendered on another texture.
        this._renderToTextureEnabled = false;

        this._texturizer = null;

        this._useRenderToTexture = false;

        this._boundsMargin = null;

        this._recBoundsMargin = null;

        this._withinBoundsMargin = false;

        this._viewport = null;

        this._clipbox = true;

        this.render = this._renderSimple;

        this._layout = null;
    }

    get offsetX() {
        if (this._funcX) {
            return this._funcX;
        } else {
            if (this.hasFlexLayout()) {
                return this._layout.originalX;
            } else {
                return this._x;
            }
        }
    }

    set offsetX(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(v)) {
            this.funcX = v;
        } else {
            this._disableFuncX();
            if (this.hasFlexLayout()) {
                this.x += (v - this._layout.originalX);
                this._layout.setOriginalXWithoutUpdatingLayout(v);
            } else {
                this.x = v;
            }
        }
    }

    get x() {
        return this._x;
    }

    set x(v) {
        if (v !== this._x) {
            this._updateLocalTranslateDelta(v - this._x, 0);
            this._x = v;
        }
    }

    get funcX() {
        return (this._optFlags & 1 ? this._funcX : null);
    }

    set funcX(v) {
        if (this._funcX !== v) {
            this._optFlags |= 1;
            this._funcX = v;
            if (this.hasFlexLayout()) {
                this._layout.setOriginalXWithoutUpdatingLayout(0);
                this.layout.forceLayout();
            } else {
                this._x = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    _disableFuncX() {
        this._optFlags = this._optFlags & (0xFFFF - 1);
        this._funcX = null;
    }

    get offsetY() {
        if (this._funcY) {
            return this._funcY;
        } else {
            if (this.hasFlexLayout()) {
                return this._layout.originalY;
            } else {
                return this._y;
            }
        }
    }

    set offsetY(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(v)) {
            this.funcY = v;
        } else {
            this._disableFuncY();
            if (this.hasFlexLayout()) {
                this.y += (v - this._layout.originalY);
                this._layout.setOriginalYWithoutUpdatingLayout(v);
            } else {
                this.y = v;
            }
        }
    }

    get y() {
        return this._y;
    }

    set y(v) {
        if (v !== this._y) {
            this._updateLocalTranslateDelta(0, v - this._y);
            this._y = v;
        }
    }

    get funcY() {
        return (this._optFlags & 2 ? this._funcY : null);
    }

    set funcY(v) {
        if (this._funcY !== v) {
            this._optFlags |= 2;
            this._funcY = v;
            if (this.hasFlexLayout()) {
                this._layout.setOriginalYWithoutUpdatingLayout(0);
                this.layout.forceLayout();
            } else {
                this._y = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    _disableFuncY() {
        this._optFlags = this._optFlags & (0xFFFF - 2);
        this._funcY = null;
    }

    get funcW() {
        return (this._optFlags & 4 ? this._funcW : null);
    }

    set funcW(v) {
        if (this._funcW !== v) {
            this._optFlags |= 4;
            this._funcW = v;
            if (this.hasFlexLayout()) {
                this._layout._originalWidth = 0;
                this.layout.changedDimensions(true, false);
            } else {
                this._w = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    disableFuncW() {
        this._optFlags = this._optFlags & (0xFFFF - 4);
        this._funcW = null;
    }

    get funcH() {
        return (this._optFlags & 8 ? this._funcH : null);
    }

    set funcH(v) {
        if (this._funcH !== v) {
            this._optFlags |= 8;
            this._funcH = v;
            if (this.hasFlexLayout()) {
                this._layout._originalHeight = 0;
                this.layout.changedDimensions(false, true);
            } else {
                this._h = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    disableFuncH() {
        this._optFlags = this._optFlags & (0xFFFF - 8);
        this._funcH = null;
    }

    get w() {
        return this._w;
    }

    getRenderWidth() {
        if (this.hasFlexLayout()) {
            return this._layout.originalWidth;
        } else {
            return this._w;
        }
    }

    get h() {
        return this._h;
    }

    getRenderHeight() {
        if (this.hasFlexLayout()) {
            return this._layout.originalHeight;
        } else {
            return this._h;
        }
    }

    get scaleX() {
        return this._scaleX;
    }

    set scaleX(v) {
        if (this._scaleX !== v) {
            this._scaleX = v;
            this._updateLocalTransform();
        }
    }

    get scaleY() {
        return this._scaleY;
    }

    set scaleY(v) {
        if (this._scaleY !== v) {
            this._scaleY = v;
            this._updateLocalTransform();
        }
    }

    get scale() {
        return this.scaleX;
    }

    set scale(v) {
        if (this._scaleX !== v || this._scaleY !== v) {
            this._scaleX = v;
            this._scaleY = v;
            this._updateLocalTransform();
        }
    }

    get pivotX() {
        return this._pivotX;
    }

    set pivotX(v) {
        if (this._pivotX !== v) {
            this._pivotX = v;
            this._updateLocalTranslate();
        }
    }

    get pivotY() {
        return this._pivotY;
    }

    set pivotY(v) {
        if (this._pivotY !== v) {
            this._pivotY = v;
            this._updateLocalTranslate();
        }
    }

    get pivot() {
        return this._pivotX;
    }

    set pivot(v) {
        if (this._pivotX !== v || this._pivotY !== v) {
            this._pivotX = v;
            this._pivotY = v;
            this._updateLocalTranslate();
        }
    }

    get mountX() {
        return this._mountX;
    }

    set mountX(v) {
        if (this._mountX !== v) {
            this._mountX = v;
            this._updateLocalTranslate();
        }
    }

    get mountY() {
        return this._mountY;
    }

    set mountY(v) {
        if (this._mountY !== v) {
            this._mountY = v;
            this._updateLocalTranslate();
        }
    }

    get mount() {
        return this._mountX;
    }

    set mount(v) {
        if (this._mountX !== v || this._mountY !== v) {
            this._mountX = v;
            this._mountY = v;
            this._updateLocalTranslate();
        }
    }

    get rotation() {
        return this._rotation;
    }

    set rotation(v) {
        if (this._rotation !== v) {
            this._rotation = v;
            this._updateLocalTransform();
        }
    }

    get alpha() {
        return this._alpha;
    }

    set alpha(v) {
        // Account for rounding errors.
        v = (v > 1 ? 1 : (v < 1e-14 ? 0 : v));
        if (this._alpha !== v) {
            let prev = this._alpha;
            this._alpha = v;
            this._updateLocalAlpha();
            if ((prev === 0) !== (v === 0)) {
                this._element._updateEnabledFlag();
            }
        }
    }

    get visible() {
        return this._visible;
    }

    set visible(v) {
        if (this._visible !== v) {
            this._visible = v;
            this._updateLocalAlpha();
            this._element._updateEnabledFlag();

            if (this.hasFlexLayout()) {
                this.layout.setVisible(v);
            }
        }
    }

    _updateLocalTransform() {
        if (this._rotation !== 0 && this._rotation % (2 * Math.PI)) {
            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
            let _sr = Math.sin(this._rotation);
            let _cr = Math.cos(this._rotation);

            this._setLocalTransform(
                _cr * this._scaleX,
                -_sr * this._scaleY,
                _sr * this._scaleX,
                _cr * this._scaleY
            );
        } else {
            this._setLocalTransform(
                this._scaleX,
                0,
                0,
                this._scaleY
            );
        }
        this._updateLocalTranslate();
    };

    _updateLocalTranslate() {
        this._recalcLocalTranslate();
        this._triggerRecalcTranslate();
    };

    _recalcLocalTranslate() {
        let pivotXMul = this._pivotX * this._w;
        let pivotYMul = this._pivotY * this._h;
        let px = this._x - (pivotXMul * this._localTa + pivotYMul * this._localTb) + pivotXMul;
        let py = this._y - (pivotXMul * this._localTc + pivotYMul * this._localTd) + pivotYMul;
        px -= this._mountX * this._w;
        py -= this._mountY * this._h;
        this._localPx = px;
        this._localPy = py;
    }

    _updateLocalTranslateDelta(dx, dy) {
        this._addLocalTranslate(dx, dy);
    };

    _updateLocalAlpha() {
        this._setLocalAlpha(this._visible ? this._alpha : 0);
    };

    /**
     * @param {number} type
     * 0: no updates
     * 1: re-invoke shader
     * 3: re-create render texture and re-invoke shader
     */
    setHasRenderUpdates(type) {
        if (this._worldContext.alpha) {
            // Ignore if 'world invisible'. Render updates will be reset to 3 for every element that becomes visible.
            let p = this;
            p._hasRenderUpdates = Math.max(type, p._hasRenderUpdates);
            while ((p = p._parent) && (p._hasRenderUpdates !== 3)) {
                p._hasRenderUpdates = 3;
            }
        }
    }

    /**
     * @param {Number} type
     *   1: alpha
     *   2: translate
     *   4: transform
     * 128: becomes visible
     * 256: flex layout updated
     */
    _setRecalc(type) {
        this._recalc |= type;

        this._setHasUpdates();

        // Any changes in descendants should trigger texture updates.
        if (this._parent) {
            this._parent.setHasRenderUpdates(3);
        }
    }

    _setHasUpdates() {
        let p = this;
        while (p && !p._hasUpdates) {
            p._hasUpdates = true;
            p = p._parent;
        }
    }

    getParent() {
        return this._parent;
    }

    setParent(parent) {
        if (parent !== this._parent) {
            let prevIsZContext = this.isZContext();
            let prevParent = this._parent;
            this._parent = parent;

            // Notify flex layout engine.
            if (this._layout || (parent && parent.isFlexContainer())) {
                this.layout.setParent(prevParent, parent);
            }

            if (prevParent) {
                // When elements are deleted, the render texture must be re-rendered.
                prevParent.setHasRenderUpdates(3);
            }

            this._setRecalc(1 + 2 + 4);

            if (this._parent) {
                // Force parent to propagate hasUpdates flag.
                this._parent._setHasUpdates();
            }

            if (this._zIndex === 0) {
                this.setZParent(parent);
            } else {
                this.setZParent(parent ? parent.findZContext() : null);
            }

            if (prevIsZContext !== this.isZContext()) {
                if (!this.isZContext()) {
                    this.disableZContext();
                } else {
                    this.enableZContext(prevParent.findZContext());
                }
            }

            // Tree order did change: even if zParent stays the same, we must resort.
            this._zIndexResort = true;
            if (this._zParent) {
                this._zParent.enableZSort();
            }

            if (!this._shader) {
                let newShaderOwner = parent && !parent._renderToTextureEnabled ? parent._shaderOwner : null;
                if (newShaderOwner !== this._shaderOwner) {
                    this.setHasRenderUpdates(1);
                    this._setShaderOwnerRecursive(newShaderOwner);
                }
            }
        }
    };

    enableZSort(force = false) {
        if (!this._zSort && this._zContextUsage > 0) {
            this._zSort = true;
            if (force) {
                // ZSort must be done, even if this element is invisible.
                // This is done to prevent memory leaks when removing element from inactive render branches.
                this.ctx.forceZSort(this);
            }
        }
    }

    addChildAt(index, child) {
        if (!this._children) this._children = [];
        this._children.splice(index, 0, child);
        child.setParent(this);
    };

    setChildAt(index, child) {
        if (!this._children) this._children = [];
        this._children[index].setParent(null);
        this._children[index] = child;
        child.setParent(this);
    }

    removeChildAt(index) {
        let child = this._children[index];
        this._children.splice(index, 1);
        child.setParent(null);
    };

    removeChildren() {
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i].setParent(null);
            }

            this._children.splice(0);

            if (this._zIndexedChildren) {
                this._zIndexedChildren.splice(0);
            }
        }
    };

    syncChildren(removed, added, order) {
        this._children = order;
        for (let i = 0, n = removed.length; i < n; i++) {
            removed[i].setParent(null);
        }
        for (let i = 0, n = added.length; i < n; i++) {
            added[i].setParent(this);
        }
    }

    moveChild(fromIndex, toIndex) {
        let c = this._children[fromIndex];
        this._children.splice(fromIndex, 1);
        this._children.splice(toIndex, 0, c);

        // Tree order changed: must resort!;
        this._zIndexResort = true;
        if (this._zParent) {
            this._zParent.enableZSort();
        }
    }

    _setLocalTransform(a, b, c, d) {
        this._setRecalc(4);
        this._localTa = a;
        this._localTb = b;
        this._localTc = c;
        this._localTd = d;

        // We also regard negative scaling as a complex case, so that we can optimize the non-complex case better.
        this._isComplex = (b !== 0) || (c !== 0) || (a < 0) || (d < 0);
    };

    _addLocalTranslate(dx, dy) {
        this._localPx += dx;
        this._localPy += dy;
        this._triggerRecalcTranslate();
    }

    _setLocalAlpha(a) {
        if (!this._worldContext.alpha && ((this._parent && this._parent._worldContext.alpha) && a)) {
            // Element is becoming visible. We need to force update.
            this._setRecalc(1 + 128);
        } else {
            this._setRecalc(1);
        }

        if (a < 1e-14) {
            // Tiny rounding errors may cause failing visibility tests.
            a = 0;
        }

        this._localAlpha = a;
    };

    setDimensions(w, h, isEstimate = this._dimsUnknown) {
        // In case of an estimation, the update loop should perform different bound checks.
        this._dimsUnknown = isEstimate;

        if (this.hasFlexLayout()) {
            this._layout.originalWidth = w;
            this._layout.originalHeight = h;
        } else {
            if (this._w !== w || this._h !== h) {
                this._updateDimensions(w, h);
                return true;
            }
        }
        return false;
    };

    _updateDimensions(w, h) {
        if (this._w !== w || this._h !== h) {
            this._w = w;
            this._h = h;

            this._triggerRecalcTranslate();

            if (this._texturizer) {
                this._texturizer.releaseRenderTexture();
                this._texturizer.updateResultTexture();
            }
            // Due to width/height change: update the translation vector.
            this._updateLocalTranslate();
        }
    }

    setTextureCoords(ulx, uly, brx, bry) {
        this.setHasRenderUpdates(3);

        this._ulx = ulx;
        this._uly = uly;
        this._brx = brx;
        this._bry = bry;
    };

    get displayedTextureSource() {
        return this._displayedTextureSource;
    }

    setDisplayedTextureSource(textureSource) {
        this.setHasRenderUpdates(3);
        this._displayedTextureSource = textureSource;
    };

    get isRoot() {
        return this._isRoot;
    }

    setAsRoot() {
        // Use parent dummy.
        this._parent = new ElementCore(this._element);

        // After setting root, make sure it's updated.
        this._parent._hasRenderUpdates = 3;
        this._parent._hasUpdates = true;

        // Root is, and will always be, the primary zContext.
        this._isRoot = true;

        this.ctx.root = this;

        // Set scissor area of 'fake parent' to stage's viewport.
        this._parent._viewport = [0, 0, this.ctx.stage.coordsWidth, this.ctx.stage.coordsHeight];
        this._parent._scissor = this._parent._viewport;

        // When recBoundsMargin is null, the defaults are used (100 for all sides).
        this._parent._recBoundsMargin = null;

        this._setRecalc(1 + 2 + 4);
    };

    isAncestorOf(c) {
        let p = c;
        while (p = p._parent) {
            if (this === p) {
                return true;
            }
        }
        return false;
    };

    isZContext() {
        return (this._forceZIndexContext || this._renderToTextureEnabled || this._zIndex !== 0 || this._isRoot || !this._parent);
    };

    findZContext() {
        if (this.isZContext()) {
            return this;
        } else {
            return this._parent.findZContext();
        }
    };

    setZParent(newZParent) {
        if (this._zParent !== newZParent) {
            if (this._zParent !== null) {
                if (this._zIndex !== 0) {
                    this._zParent.decZContextUsage();
                }

                // We must filter out this item upon the next resort.
                this._zParent.enableZSort();
            }

            if (newZParent !== null) {
                let hadZContextUsage = (newZParent._zContextUsage > 0);

                // @pre: new parent's children array has already been modified.
                if (this._zIndex !== 0) {
                    newZParent.incZContextUsage();
                }

                if (newZParent._zContextUsage > 0) {
                    if (!hadZContextUsage && (this._parent === newZParent)) {
                        // This child was already in the children list.
                        // Do not add double.
                    } else {
                        // Add new child to array.
                        newZParent._zIndexedChildren.push(this);
                    }

                    // Order should be checked.
                    newZParent.enableZSort();
                }
            }

            this._zParent = newZParent;

            // Newly added element must be marked for resort.
            this._zIndexResort = true;
        }
    };

    incZContextUsage() {
        this._zContextUsage++;
        if (this._zContextUsage === 1) {
            if (!this._zIndexedChildren) {
                this._zIndexedChildren = [];
            }
            if (this._children) {
                // Copy.
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._zIndexedChildren.push(this._children[i]);
                }
                // Initially, children are already sorted properly (tree order).
                this._zSort = false;
            }
        }
    };

    decZContextUsage() {
        this._zContextUsage--;
        if (this._zContextUsage === 0) {
            this._zSort = false;
            this._zIndexedChildren.splice(0);
        }
    };

    get zIndex() {
        return this._zIndex;
    }

    set zIndex(zIndex) {
        if (this._zIndex !== zIndex) {
            this.setHasRenderUpdates(1);

            let newZParent = this._zParent;

            let prevIsZContext = this.isZContext();
            if (zIndex === 0 && this._zIndex !== 0) {
                if (this._parent === this._zParent) {
                    if (this._zParent) {
                        this._zParent.decZContextUsage();
                    }
                } else {
                    newZParent = this._parent;
                }
            } else if (zIndex !== 0 && this._zIndex === 0) {
                newZParent = this._parent ? this._parent.findZContext() : null;
                if (newZParent === this._zParent) {
                    if (this._zParent) {
                        this._zParent.incZContextUsage();
                        this._zParent.enableZSort();
                    }
                }
            } else if (zIndex !== this._zIndex) {
                if (this._zParent && this._zParent._zContextUsage) {
                    this._zParent.enableZSort();
                }
            }

            if (newZParent !== this._zParent) {
                this.setZParent(null);
            }

            this._zIndex = zIndex;

            if (newZParent !== this._zParent) {
                this.setZParent(newZParent);
            }

            if (prevIsZContext !== this.isZContext()) {
                if (!this.isZContext()) {
                    this.disableZContext();
                } else {
                    this.enableZContext(this._parent.findZContext());
                }
            }

            // Make sure that resort is done.
            this._zIndexResort = true;
            if (this._zParent) {
                this._zParent.enableZSort();
            }
        }
    };

    get forceZIndexContext() {
        return this._forceZIndexContext;
    }

    set forceZIndexContext(v) {
        this.setHasRenderUpdates(1);

        let prevIsZContext = this.isZContext();
        this._forceZIndexContext = v;

        if (prevIsZContext !== this.isZContext()) {
            if (!this.isZContext()) {
                this.disableZContext();
            } else {
                this.enableZContext(this._parent.findZContext());
            }
        }
    };

    enableZContext(prevZContext) {
        if (prevZContext && prevZContext._zContextUsage > 0) {
            // Transfer from upper z context to this z context.
            const results = this._getZIndexedDescs();
            results.forEach((c) => {
                if (this.isAncestorOf(c) && c._zIndex !== 0) {
                    c.setZParent(this);
                }
            });
        }
    }

    _getZIndexedDescs() {
        const results = [];
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i]._getZIndexedDescsRec(results);
            }
        }
        return results;
    }

    _getZIndexedDescsRec(results) {
        if (this._zIndex) {
            results.push(this);
        } else if (this._children && !this.isZContext()) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i]._getZIndexedDescsRec(results);
            }
        }
    }

    disableZContext() {
        // Transfer from this z context to upper z context.
        if (this._zContextUsage > 0) {
            let newZParent = this._parent.findZContext();

            // Make sure that z-indexed children are up to date (old ones removed).
            if (this._zSort) {
                this.sortZIndexedChildren();
            }

            this._zIndexedChildren.slice().forEach(function (c) {
                if (c._zIndex !== 0) {
                    c.setZParent(newZParent);
                }
            });
        }
    };

    get colorUl() {
        return this._colorUl;
    }

    set colorUl(color) {
        if (this._colorUl !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorUl = color;
        }
    }

    get colorUr() {
        return this._colorUr;
    }

    set colorUr(color) {
        if (this._colorUr !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorUr = color;
        }
    };

    get colorBl() {
        return this._colorBl;
    }

    set colorBl(color) {
        if (this._colorBl !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorBl = color;
        }
    };

    get colorBr() {
        return this._colorBr;
    }

    set colorBr(color) {
        if (this._colorBr !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorBr = color;
        }
    };


    set onUpdate(f) {
        this._onUpdate = f;
        this._setRecalc(7);
    }

    set onAfterUpdate(f) {
        this._onAfterUpdate = f;
        this._setRecalc(7);
    }

    set onAfterCalcs(f) {
        this._onAfterCalcs = f;
        this._setRecalc(7);
    }

    get shader() {
        return this._shader;
    }

    set shader(v) {
        this.setHasRenderUpdates(1);

        let prevShader = this._shader;
        this._shader = v;
        if (!v && prevShader) {
            // Disabled shader.
            let newShaderOwner = (this._parent && !this._parent._renderToTextureEnabled ? this._parent._shaderOwner : null);
            this._setShaderOwnerRecursive(newShaderOwner);
        } else if (v) {
            // Enabled shader.
            this._setShaderOwnerRecursive(this);
        }
    }

    get activeShader() {
        return this._shaderOwner ? this._shaderOwner.shader : this.renderState.defaultShader;
    }

    get activeShaderOwner() {
        return this._shaderOwner;
    }

    get clipping() {
        return this._clipping;
    }

    set clipping(v) {
        if (this._clipping !== v) {
            this._clipping = v;

            // Force update of scissor by updating translate.
            // Alpha must also be updated because the scissor area may have been empty.
            this._setRecalc(1 + 2);
        }
    }

    get clipbox() {
        return this._clipbox;
    }

    set clipbox(v) {
        // In case of out-of-bounds element, all children will also be ignored.
        // It will save us from executing the update/render loops for those.
        // The optimization will be used immediately during the next frame.
        this._clipbox = v;
    }

    _setShaderOwnerRecursive(elementCore) {
        this._shaderOwner = elementCore;

        if (this._children && !this._renderToTextureEnabled) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                let c = this._children[i];
                if (!c._shader) {
                    c._setShaderOwnerRecursive(elementCore);
                    c._hasRenderUpdates = 3;
                }
            }
        }
    };

    _setShaderOwnerChildrenRecursive(elementCore) {
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                let c = this._children[i];
                if (!c._shader) {
                    c._setShaderOwnerRecursive(elementCore);
                    c._hasRenderUpdates = 3;
                }
            }
        }
    };

    _hasRenderContext() {
        return this._renderContext !== this._worldContext;
    }

    get renderContext() {
        return this._renderContext;
    }

    updateRenderToTextureEnabled() {
        // Enforce texturizer initialisation.
        let v = this.texturizer._enabled;

        if (v) {
            this._enableRenderToTexture();
        } else {
            this._disableRenderToTexture();
            this._texturizer.releaseRenderTexture();
        }
    }

    _enableRenderToTexture() {
        if (!this._renderToTextureEnabled) {
            let prevIsZContext = this.isZContext();

            this._renderToTextureEnabled = true;

            this._renderContext = new ElementCoreContext();

            // If render to texture is active, a new shader context is started.
            this._setShaderOwnerChildrenRecursive(null);

            if (!prevIsZContext) {
                // Render context forces z context.
                this.enableZContext(this._parent ? this._parent.findZContext() : null);
            }

            this.setHasRenderUpdates(3);

            // Make sure that the render coordinates get updated.
            this._setRecalc(7);

            this.render = this._renderAdvanced;
        }
    }

    _disableRenderToTexture() {
        if (this._renderToTextureEnabled) {
            this._renderToTextureEnabled = false;

            this._setShaderOwnerChildrenRecursive(this._shaderOwner);

            this._renderContext = this._worldContext;

            if (!this.isZContext()) {
                this.disableZContext();
            }

            // Make sure that the render coordinates get updated.
            this._setRecalc(7);

            this.setHasRenderUpdates(3);

            this.render = this._renderSimple;
        }
    }

    isWhite() {
        return (this._colorUl === 0xFFFFFFFF) && (this._colorUr === 0xFFFFFFFF) && (this._colorBl === 0xFFFFFFFF) && (this._colorBr === 0xFFFFFFFF);
    }

    hasSimpleTexCoords() {
        return (this._ulx === 0) && (this._uly === 0) && (this._brx === 1) && (this._bry === 1);
    }

    _stashTexCoords() {
        this._stashedTexCoords = [this._ulx, this._uly, this._brx, this._bry];
        this._ulx = 0;
        this._uly = 0;
        this._brx = 1;
        this._bry = 1;
    }

    _unstashTexCoords() {
        this._ulx = this._stashedTexCoords[0];
        this._uly = this._stashedTexCoords[1];
        this._brx = this._stashedTexCoords[2];
        this._bry = this._stashedTexCoords[3];
        this._stashedTexCoords = null;
    }

    _stashColors() {
        this._stashedColors = [this._colorUl, this._colorUr, this._colorBr, this._colorBl];
        this._colorUl = 0xFFFFFFFF;
        this._colorUr = 0xFFFFFFFF;
        this._colorBr = 0xFFFFFFFF;
        this._colorBl = 0xFFFFFFFF;
    }

    _unstashColors() {
        this._colorUl = this._stashedColors[0];
        this._colorUr = this._stashedColors[1];
        this._colorBr = this._stashedColors[2];
        this._colorBl = this._stashedColors[3];
        this._stashedColors = null;
    }

    isVisible() {
        return (this._localAlpha > 1e-14);
    };

    get outOfBounds() {
        return this._outOfBounds;
    }

    set boundsMargin(v) {

        /**
         *  null: inherit from parent.
         *  number[4]: specific margins: left, top, right, bottom.
         */
        this._boundsMargin = v ? v.slice() : null;

        // We force recalc in order to set all boundsMargin recursively during the next update.
        this._triggerRecalcTranslate();
    }

    get boundsMargin() {
        return this._boundsMargin;
    }

    update() {
        this._recalc |= this._parent._pRecalc;

        if (this._layout && this._layout.isEnabled()) {
            if (this._recalc & 256) {
                this._layout.layoutFlexTree();
            }
        } else if ((this._recalc & 2) && this._optFlags) {
            this._applyRelativeDimFuncs();
        }

        if (this._onUpdate) {
            // Block all 'upwards' updates when changing things in this branch.
            this._hasUpdates = true;
            this._onUpdate(this.element, this);
        }

        const pw = this._parent._worldContext;
        let w = this._worldContext;
        const visible = (pw.alpha && this._localAlpha);

        /**
         * We must update if:
         * - branch contains updates (even when invisible because it may contain z-indexed descendants)
         * - there are (inherited) updates and this branch is visible
         * - this branch becomes invisible (descs may be z-indexed so we must update all alpha values)
         */
        if (this._hasUpdates || (this._recalc && visible) || (w.alpha && !visible)) {
            let recalc = this._recalc;

            // Update world coords/alpha.
            if (recalc & 1) {
                if (!w.alpha && visible) {
                    // Becomes visible.
                    this._hasRenderUpdates = 3;
                }
                w.alpha = pw.alpha * this._localAlpha;

                if (w.alpha < 1e-14) {
                    // Tiny rounding errors may cause failing visibility tests.
                    w.alpha = 0;
                }
            }

            if (recalc & 6) {
                w.px = pw.px + this._localPx * pw.ta;
                w.py = pw.py + this._localPy * pw.td;
                if (pw.tb !== 0) w.px += this._localPy * pw.tb;
                if (pw.tc !== 0) w.py += this._localPx * pw.tc;
            }

            if (recalc & 4) {
                w.ta = this._localTa * pw.ta;
                w.tb = this._localTd * pw.tb;
                w.tc = this._localTa * pw.tc;
                w.td = this._localTd * pw.td;

                if (this._isComplex) {
                    w.ta += this._localTc * pw.tb;
                    w.tb += this._localTb * pw.ta;
                    w.tc += this._localTc * pw.td;
                    w.td += this._localTb * pw.tc;
                }
            }

            // Update render coords/alpha.
            const pr = this._parent._renderContext;
            if (this._parent._hasRenderContext()) {
                const init = this._renderContext === this._worldContext;
                if (init) {
                    // First render context build: make sure that it is fully initialized correctly.
                    // Otherwise, if we get into bounds later, the render context would not be initialized correctly.
                    this._renderContext = new ElementCoreContext();
                }

                const r = this._renderContext;

                // Update world coords/alpha.
                if (init || (recalc & 1)) {
                    r.alpha = pr.alpha * this._localAlpha;

                    if (r.alpha < 1e-14) {
                        r.alpha = 0;
                    }
                }

                if (init || (recalc & 6)) {
                    r.px = pr.px + this._localPx * pr.ta;
                    r.py = pr.py + this._localPy * pr.td;
                    if (pr.tb !== 0) r.px += this._localPy * pr.tb;
                    if (pr.tc !== 0) r.py += this._localPx * pr.tc;
                }

                if (init) {
                    // We set the recalc toggle, because we must make sure that the scissor is updated.
                    recalc |= 2;
                }

                if (init || (recalc & 4)) {
                    r.ta = this._localTa * pr.ta;
                    r.tb = this._localTd * pr.tb;
                    r.tc = this._localTa * pr.tc;
                    r.td = this._localTd * pr.td;

                    if (this._isComplex) {
                        r.ta += this._localTc * pr.tb;
                        r.tb += this._localTb * pr.ta;
                        r.tc += this._localTc * pr.td;
                        r.td += this._localTb * pr.tc;
                    }
                }
            } else {
                this._renderContext = this._worldContext;
            }

            if (this.ctx.updateTreeOrder === -1) {
                this.ctx.updateTreeOrder = this._updateTreeOrder + 1;
            } else {
                this._updateTreeOrder = this.ctx.updateTreeOrder++;
            }

            // Determine whether we must use a 'renderTexture'.
            const useRenderToTexture = this._renderToTextureEnabled && this._texturizer.mustRenderToTexture();
            if (this._useRenderToTexture !== useRenderToTexture) {
                // Coords must be changed.
                this._recalc |= 2 + 4;

                // Scissor may change: force update.
                recalc |= 2;

                if (!this._useRenderToTexture) {
                    // We must release the texture.
                    this._texturizer.release();
                }
            }
            this._useRenderToTexture = useRenderToTexture;

            const r = this._renderContext;

            const bboxW = this._dimsUnknown ? 2048 : this._w;
            const bboxH = this._dimsUnknown ? 2048 : this._h;

            // Calculate a bbox for this element.
            let sx, sy, ex, ey;
            const rComplex = (r.tb !== 0) || (r.tc !== 0) || (r.ta < 0) || (r.td < 0);
            if (rComplex) {
                sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
            } else {
                sx = r.px;
                ex = r.px + r.ta * bboxW;
                sy = r.py;
                ey = r.py + r.td * bboxH;
            }

            if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                // If we are dealing with a non-identity matrix, we must extend the bbox so that withinBounds and
                //  scissors will include the complete range of (positive) dimensions up to ,lh.
                const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                const ny = this._x * pr.tc + this._y * pr.td + pr.py;
                if (nx < sx) sx = nx;
                if (ny < sy) sy = ny;
                if (nx > ex) ex = nx;
                if (ny > ey) ey = ny;
            }

            if (recalc & 6 || !this._scissor /* initial */) {
                // Determine whether we must 'clip'.
                if (this._clipping && r.isSquare()) {
                    // If the parent renders to a texture, it's scissor should be ignored;
                    const area = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                    if (area) {
                        // Merge scissor areas.
                        const lx = Math.max(area[0], sx);
                        const ly = Math.max(area[1], sy);
                        this._scissor = [
                            lx,
                            ly,
                            Math.min(area[2] + area[0], ex) - lx,
                            Math.min(area[3] + area[1], ey) - ly
                        ];
                    } else {
                        this._scissor = [sx, sy, ex - sx, ey - sy];
                    }
                } else {
                    // No clipping: reuse parent scissor.
                    this._scissor = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                }
            }

            // Calculate the outOfBounds margin.
            if (this._boundsMargin) {
                this._recBoundsMargin = this._boundsMargin;
            } else {
                this._recBoundsMargin = this._parent._recBoundsMargin;
            }

            if (this._onAfterCalcs) {
                // After calcs may change render coords, scissor and/or recBoundsMargin.
                if (this._onAfterCalcs(this.element)) {
                    // Recalculate bbox.
                    if (rComplex) {
                        sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                        ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                        sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                        ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                    } else {
                        sx = r.px;
                        ex = r.px + r.ta * bboxW;
                        sy = r.py;
                        ey = r.py + r.td * bboxH;
                    }

                    if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                        const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                        const ny = this._x * pr.tc + this._y * pr.td + pr.py;
                        if (nx < sx) sx = nx;
                        if (ny < sy) sy = ny;
                        if (nx > ex) ex = nx;
                        if (ny > ey) ey = ny;
                    }
                }
            }

            if (this._parent._outOfBounds === 2) {
                // Inherit parent out of boundsness.
                this._outOfBounds = 2;

                if (this._withinBoundsMargin) {
                    this._withinBoundsMargin = false;
                    this.element._disableWithinBoundsMargin();
                }
            } else {
                if (recalc & 6) {
                    // Recheck if element is out-of-bounds (all settings that affect this should enable recalc bit 2 or 4).
                    this._outOfBounds = 0;
                    let withinMargin = true;

                    // Offscreens are always rendered as long as the parent is within bounds.
                    if (!this._renderToTextureEnabled || !this._texturizer || !this._texturizer.renderOffscreen) {
                        if (this._scissor && (this._scissor[2] <= 0 || this._scissor[3] <= 0)) {
                            // Empty scissor area.
                            this._outOfBounds = 2;
                        } else {
                            // Use bbox to check out-of-boundness.
                            if ((this._scissor[0] > ex) ||
                                (this._scissor[1] > ey) ||
                                (sx > (this._scissor[0] + this._scissor[2])) ||
                                (sy > (this._scissor[1] + this._scissor[3]))
                            ) {
                                this._outOfBounds = 1;
                            }

                            if (this._outOfBounds) {
                                if (this._clipping || this._useRenderToTexture || (this._clipbox && (bboxW && bboxH))) {
                                    this._outOfBounds = 2;
                                }
                            }
                        }

                        withinMargin = (this._outOfBounds === 0);
                        if (!withinMargin) {
                            // Re-test, now with margins.
                            if (this._recBoundsMargin) {
                                withinMargin = !((ex < this._scissor[0] - this._recBoundsMargin[2]) ||
                                    (ey < this._scissor[1] - this._recBoundsMargin[3]) ||
                                    (sx > this._scissor[0] + this._scissor[2] + this._recBoundsMargin[0]) ||
                                    (sy > this._scissor[1] + this._scissor[3] + this._recBoundsMargin[1]));
                            } else {
                                withinMargin = !((ex < this._scissor[0] - 100) ||
                                    (ey < this._scissor[1] - 100) ||
                                    (sx > this._scissor[0] + this._scissor[2] + 100) ||
                                    (sy > this._scissor[1] + this._scissor[3] + 100));
                            }
                            if (withinMargin && this._outOfBounds === 2) {
                                // Children must be visited because they may contain elements that are within margin, so must be visible.
                                this._outOfBounds = 1;
                            }
                        }
                    }

                    if (this._withinBoundsMargin !== withinMargin) {
                        this._withinBoundsMargin = withinMargin;

                        if (this._withinBoundsMargin) {
                            // This may update things (txLoaded events) in the element itself, but also in descendants and ancestors.

                            // Changes in ancestors should be executed during the next call of the stage update. But we must
                            // take care that the _recalc and _hasUpdates flags are properly registered. That's why we clear
                            // both before entering the children, and use _pRecalc to transfer inherited updates instead of
                            // _recalc directly.

                            // Changes in descendants are automatically executed within the current update loop, though we must
                            // take care to not update the hasUpdates flag unnecessarily in ancestors. We achieve this by making
                            // sure that the hasUpdates flag of this element is turned on, which blocks it for ancestors.
                            this._hasUpdates = true;

                            const recalc = this._recalc;
                            this._recalc = 0;
                            this.element._enableWithinBoundsMargin();

                            if (this._recalc) {
                                // This element needs to be re-updated now, because we want the dimensions (and other changes) to be updated.
                                return this.update();
                            }

                            this._recalc = recalc;
                        } else {
                            this.element._disableWithinBoundsMargin();
                        }
                    }
                }
            }

            if (this._useRenderToTexture) {
                // Set viewport necessary for children scissor calculation.
                if (this._viewport) {
                    this._viewport[2] = bboxW;
                    this._viewport[3] = bboxH;
                } else {
                    this._viewport = [0, 0, bboxW, bboxH];
                }
            }

            // Filter out bits that should not be copied to the children (currently all are).
            this._pRecalc = (this._recalc & 135);

            // Clear flags so that future updates are properly detected.
            this._recalc = 0;
            this._hasUpdates = false;

            if (this._outOfBounds < 2) {
                if (this._useRenderToTexture) {
                    if (this._worldContext.isIdentity()) {
                        // Optimization.
                        // The world context is already identity: use the world context as render context to prevents the
                        // ancestors from having to update the render context.
                        this._renderContext = this._worldContext;
                    } else {
                        // Temporarily replace the render coord attribs by the identity matrix.
                        // This allows the children to calculate the render context.
                        this._renderContext = ElementCoreContext.IDENTITY;
                    }
                }

                if (this._children) {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        this._children[i].update();
                    }
                }

                if (this._useRenderToTexture) {
                    this._renderContext = r;
                }
            } else {
                if (this._children) {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._hasUpdates) {
                            this._children[i].update();
                        } else {
                            // Make sure we don't lose the 'inherited' updates.
                            this._children[i]._recalc |= this._pRecalc;
                            this._children[i].updateOutOfBounds();
                        }
                    }
                }
            }

            if (this._onAfterUpdate) {
                this._onAfterUpdate(this.element);
            }
        } else {
            if (this.ctx.updateTreeOrder === -1 || this._updateTreeOrder >= this.ctx.updateTreeOrder) {
                // If new tree order does not interfere with the current (gaps allowed) there's no need to traverse the branch.
                this.ctx.updateTreeOrder = -1;
            } else {
                this.updateTreeOrder();
            }
        }
    }

    _applyRelativeDimFuncs() {
        if (this._optFlags & 1) {
            const x = this._funcX(this._parent.w);
            if (x !== this._x) {
                this._localPx += (x - this._x);
                this._x = x;
            }
        }
        if (this._optFlags & 2) {
            const y = this._funcY(this._parent.h);
            if (y !== this._y) {
                this._localPy += (y - this._y);
                this._y = y;
            }
        }

        let changedDims = false;
        if (this._optFlags & 4) {
            const w = this._funcW(this._parent.w);
            if (w !== this._w) {
                this._w = w;
                changedDims = true;
            }
        }
        if (this._optFlags & 8) {
            const h = this._funcH(this._parent.h);
            if (h !== this._h) {
                this._h = h;
                changedDims = true;
            }
        }

        if (changedDims) {
            // Recalc mount, scale position.
            this._recalcLocalTranslate();

            this.element.onDimensionsChanged(this._w, this._h);
        }
    }

    updateOutOfBounds() {
        // Propagate outOfBounds flag to descendants (necessary because of z-indexing).
        // Invisible elements are not drawn anyway. When alpha is updated, so will _outOfBounds.
        if (this._outOfBounds !== 2 && this._renderContext.alpha > 0) {

            // Inherit parent out of boundsness.
            this._outOfBounds = 2;

            if (this._withinBoundsMargin) {
                this._withinBoundsMargin = false;
                this.element._disableWithinBoundsMargin();
            }

            if (this._children) {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._children[i].updateOutOfBounds();
                }
            }
        }
    }

    updateTreeOrder() {
        if (this._localAlpha && (this._outOfBounds !== 2)) {
            this._updateTreeOrder = this.ctx.updateTreeOrder++;

            if (this._children) {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._children[i].updateTreeOrder();
                }
            }
        }
    }

    _renderSimple() {
        this._hasRenderUpdates = 0;

        if (this._zSort) {
            this.sortZIndexedChildren();
        }

        if (this._outOfBounds < 2 && this._renderContext.alpha) {
            let renderState = this.renderState;

            if ((this._outOfBounds === 0) && this._displayedTextureSource) {
                renderState.setShader(this.activeShader, this._shaderOwner);
                renderState.setScissor(this._scissor);
                this.renderState.addQuad(this);
            }

            // Also add children to the VBO.
            if (this._children) {
                if (this._zContextUsage) {
                    for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                        this._zIndexedChildren[i].render();
                    }
                } else {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._zIndex === 0) {
                            // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                            this._children[i].render();
                        }

                    }
                }
            }
        }
    }

    _renderAdvanced() {
        const hasRenderUpdates = this._hasRenderUpdates;

        // We must clear the hasRenderUpdates flag before rendering, because updating result textures in combination
        // with z-indexing may trigger render updates on a render branch that is 'half done'.
        // We need to ensure that the full render branch is marked for render updates, not only half (leading to freeze).
        this._hasRenderUpdates = 0;

        if (this._zSort) {
            this.sortZIndexedChildren();
        }

        if (this._outOfBounds < 2 && this._renderContext.alpha) {
            let renderState = this.renderState;

            let mustRenderChildren = true;
            let renderTextureInfo;
            let prevRenderTextureInfo;
            if (this._useRenderToTexture) {
                if (this._w === 0 || this._h === 0) {
                    // Ignore this branch and don't draw anything.
                    return;
                } else if (!this._texturizer.hasRenderTexture() || (hasRenderUpdates >= 3)) {
                    // Switch to default shader for building up the render texture.
                    renderState.setShader(renderState.defaultShader, this);

                    prevRenderTextureInfo = renderState.renderTextureInfo;

                    renderTextureInfo = {
                        nativeTexture: null,
                        offset: 0,  // Set by CoreRenderState.
                        w: this._w,
                        h: this._h,
                        empty: true,
                        cleared: false,
                        ignore: false,
                        cache: false
                    };

                    if (this._texturizer.hasResultTexture() || (!renderState.isCachingTexturizer && (hasRenderUpdates < 3))) {
                        /**
                         * We don't always cache render textures.
                         *
                         * The rule is, that caching for a specific render texture is only enabled if:
                         * - There is a result texture to be updated.
                         * - There were no render updates -within the contents- since last frame (ElementCore.hasRenderUpdates < 3)
                         * - AND there are no ancestors that are being cached during this frame (CoreRenderState.isCachingTexturizer)
                         *   If an ancestor is cached anyway, it's probably not necessary to keep deeper caches. If the top level is to
                         *   change while a lower one is not, that lower level will be cached instead.
                         *
                         * In case of the fast blur element, this prevents having to cache all blur levels and stages, saving a huge amount
                         * of GPU memory!
                         *
                         * Especially when using multiple stacked layers of the same dimensions that are RTT this will have a very
                         * noticable effect on performance as less render textures need to be allocated.
                         */
                        renderTextureInfo.cache = true;
                        renderState.isCachingTexturizer = true;
                    }

                    if (!this._texturizer.hasResultTexture()) {
                        // We can already release the current texture to the pool, as it will be rebuild anyway.
                        // In case of multiple layers of 'filtering', this may save us from having to create one
                        //  render-to-texture layer.
                        // Notice that we don't do this when there is a result texture, as any other element may rely on
                        //  that result texture being filled.
                        this._texturizer.releaseRenderTexture();
                    }

                    renderState.setRenderTextureInfo(renderTextureInfo);
                    renderState.setScissor(null);

                    if (this._displayedTextureSource) {
                        let r = this._renderContext;

                        // Use an identity context for drawing the displayed texture to the render texture.
                        this._renderContext = ElementCoreContext.IDENTITY;

                        // Add displayed texture source in local coordinates.
                        this.renderState.addQuad(this);

                        this._renderContext = r;
                    }
                } else {
                    mustRenderChildren = false;
                }
            } else {
                if ((this._outOfBounds === 0) && this._displayedTextureSource) {
                    renderState.setShader(this.activeShader, this._shaderOwner);
                    renderState.setScissor(this._scissor);
                    this.renderState.addQuad(this);
                }
            }

            // Also add children to the VBO.
            if (mustRenderChildren && this._children) {
                if (this._zContextUsage) {
                    for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                        this._zIndexedChildren[i].render();
                    }
                } else {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._zIndex === 0) {
                            // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                            this._children[i].render();
                        }
                    }
                }
            }

            if (this._useRenderToTexture) {
                let updateResultTexture = false;
                if (mustRenderChildren) {
                    // Finished refreshing renderTexture.
                    renderState.finishedRenderTexture();

                    // If nothing was rendered, we store a flag in the texturizer and prevent unnecessary
                    //  render-to-texture and filtering.
                    this._texturizer.empty = renderTextureInfo.empty;

                    if (renderTextureInfo.empty) {
                        // We ignore empty render textures and do not draw the final quad.

                        // The following cleans up memory and enforces that the result texture is also cleared.
                        this._texturizer.releaseRenderTexture();
                    } else if (renderTextureInfo.nativeTexture) {
                        // If nativeTexture is set, we can reuse that directly instead of creating a new render texture.
                        this._texturizer.reuseTextureAsRenderTexture(renderTextureInfo.nativeTexture);

                        renderTextureInfo.ignore = true;
                    } else {
                        if (this._texturizer.renderTextureReused) {
                            // Quad operations must be written to a render texture actually owned.
                            this._texturizer.releaseRenderTexture();
                        }
                        // Just create the render texture.
                        renderTextureInfo.nativeTexture = this._texturizer.getRenderTexture();
                    }

                    // Restore the parent's render texture.
                    renderState.setRenderTextureInfo(prevRenderTextureInfo);

                    updateResultTexture = true;
                }

                if (!this._texturizer.empty) {
                    let resultTexture = this._texturizer.getResultTexture();
                    if (updateResultTexture) {
                        if (resultTexture) {
                            // Logging the update frame can be handy for userland.
                            resultTexture.update = renderState.stage.frameCounter;
                        }
                        this._texturizer.updateResultTexture();
                    }

                    if (!this._texturizer.renderOffscreen) {
                        // Render result texture to the actual render target.
                        renderState.setShader(this.activeShader, this._shaderOwner);
                        renderState.setScissor(this._scissor);

                        // If no render texture info is set, the cache can be reused.
                        const cache = !renderTextureInfo || renderTextureInfo.cache;

                        renderState.setTexturizer(this._texturizer, cache);
                        this._stashTexCoords();
                        if (!this._texturizer.colorize) this._stashColors();
                        this.renderState.addQuad(this, true);
                        if (!this._texturizer.colorize) this._unstashColors();
                        this._unstashTexCoords();
                        renderState.setTexturizer(null);
                    }
                }
            }

            if (renderTextureInfo && renderTextureInfo.cache) {
                // Allow siblings to cache.
                renderState.isCachingTexturizer = false;
            }
        }
    }

    get zSort() {
        return this._zSort;
    }

    sortZIndexedChildren() {
        /**
         * We want to avoid resorting everything. Instead, we do a single pass of the full array:
         * - filtering out elements with a different zParent than this (were removed)
         * - filtering out, but also gathering (in a temporary array) the elements that have zIndexResort flag
         * - then, finally, we merge-sort both the new array and the 'old' one
         * - element may have been added 'double', so when merge-sorting also check for doubles.
         * - if the old one is larger (in size) than it should be, splice off the end of the array.
         */

        const n = this._zIndexedChildren.length;
        let ptr = 0;
        const a = this._zIndexedChildren;

        // Notice that items may occur multiple times due to z-index changing.
        const b = [];
        for (let i = 0; i < n; i++) {
            if (a[i]._zParent === this) {
                if (a[i]._zIndexResort) {
                    b.push(a[i]);
                } else {
                    if (ptr !== i) {
                        a[ptr] = a[i];
                    }
                    ptr++;
                }
            }
        }

        const m = b.length;
        if (m) {
            for (let j = 0; j < m; j++) {
                b[j]._zIndexResort = false;
            }

            b.sort(ElementCore.sortZIndexedChildren);
            const n = ptr;
            if (!n) {
                ptr = 0;
                let j = 0;
                do {
                    a[ptr++] = b[j++];
                } while (j < m);

                if (a.length > ptr) {
                    // Slice old (unnecessary) part off array.
                    a.splice(ptr);
                }
            } else {
                // Merge-sort arrays;
                ptr = 0;
                let i = 0;
                let j = 0;
                const mergeResult = [];
                do {
                    const v = (a[i]._zIndex === b[j]._zIndex ? a[i]._updateTreeOrder - b[j]._updateTreeOrder : a[i]._zIndex - b[j]._zIndex);

                    const add = v > 0 ? b[j++] : a[i++];

                    if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                        mergeResult[ptr++] = add;
                    }

                    if (i >= n) {
                        do {
                            const add = b[j++];
                            if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                                mergeResult[ptr++] = add;
                            }
                        } while (j < m);
                        break;
                    } else if (j >= m) {
                        do {
                            const add = a[i++];
                            if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                                mergeResult[ptr++] = add;
                            }
                        } while (i < n);
                        break;
                    }
                } while (true);

                this._zIndexedChildren = mergeResult;
            }
        } else {
            if (a.length > ptr) {
                // Slice old (unnecessary) part off array.
                a.splice(ptr);
            }
        }

        this._zSort = false;
    };

    get localTa() {
        return this._localTa;
    };

    get localTb() {
        return this._localTb;
    };

    get localTc() {
        return this._localTc;
    };

    get localTd() {
        return this._localTd;
    };

    get element() {
        return this._element;
    }

    get renderUpdates() {
        return this._hasRenderUpdates;
    }

    get texturizer() {
        if (!this._texturizer) {
            this._texturizer = new _ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);
        }
        return this._texturizer;
    }

    getCornerPoints() {
        let w = this._worldContext;

        return [
            w.px,
            w.py,
            w.px + this._w * w.ta,
            w.py + this._w * w.tc,
            w.px + this._w * w.ta + this._h * w.tb,
            w.py + this._w * w.tc + this._h * w.td,
            w.px + this._h * w.tb,
            w.py + this._h * w.td
        ];
    };

    getRenderTextureCoords(relX, relY) {
        let r = this._renderContext;
        return [
            r.px + r.ta * relX + r.tb * relY,
            r.py + r.tc * relX + r.td * relY
        ];
    }

    getAbsoluteCoords(relX, relY) {
        let w = this._renderContext;
        return [
            w.px + w.ta * relX + w.tb * relY,
            w.py + w.tc * relX + w.td * relY
        ];
    }

    collectAtCoord(x, y, children) {
        // return when branch is hidden
        if (this._renderContext.alpha === 0) {
            return;
        }

        if (this.inBound(x, y)) {
            if (this._scissor) {
                if (this.inScissor()) {
                    children.push(this);
                }
            } else {
                children.push(this);
            }
        }

        if (this._children) {
            const j = this._children.length;
            for (let i = 0; i < j; i++) {
                this._children[i].collectAtCoord(x, y, children);
            }
        }

        return children.sort(ElementCore.sortZIndexedChildren);
    }

    inBound(tx, ty) {
        const c = this.getCornerPoints();
        return tx > c[0] && tx < c[2] && ty > c[1] && ty < c[7];
    }

    inScissor() {
        const sc = this._scissor;
        const c = this.getCornerPoints();

        return c[2] >= sc[0] && c[0] <= sc[0] + sc[2] && c[7] >= sc[1] && c[1] <= sc[1] + sc[3];
    }

    get layout() {
        this._ensureLayout();
        return this._layout;
    }

    get flex() {
        return this._layout ? this._layout.flex : null;
    }

    set flex(v) {
        this.layout.flex = v;
    }

    get flexItem() {
        return this._layout ? this._layout.flexItem : null;
    }

    set flexItem(v) {
        this.layout.flexItem = v;
    }

    isFlexItem() {
        return !!this._layout && this._layout.isFlexItemEnabled();
    }

    isFlexContainer() {
        return !!this._layout && this._layout.isFlexEnabled();
    }

    enableFlexLayout() {
        this._ensureLayout();
    }

    _ensureLayout() {
        if (!this._layout) {
            this._layout = new _flex_FlexTarget_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        }
    }

    disableFlexLayout() {
        this._triggerRecalcTranslate();
    }

    hasFlexLayout() {
        return (this._layout && this._layout.isEnabled());
    }

    setLayout(x, y, w, h) {
        this.x = x;
        this.y = y;
        this._updateDimensions(w, h);
    }

    triggerLayout() {
        this._setRecalc(256);
    }

    _triggerRecalcTranslate() {
        this._setRecalc(2);
    }

}

class ElementCoreContext {

    constructor() {
        this.alpha = 1;

        this.px = 0;
        this.py = 0;

        this.ta = 1;
        this.tb = 0;
        this.tc = 0;
        this.td = 1;
    }

    isIdentity() {
        return this.alpha === 1 &&
            this.px === 0 &&
            this.py === 0 &&
            this.ta === 1 &&
            this.tb === 0 &&
            this.tc === 0 &&
            this.td === 1;
    }

    isSquare() {
        return this.tb === 0 && this.tc === 0;
    }

}

ElementCoreContext.IDENTITY = new ElementCoreContext();
ElementCore.sortZIndexedChildren = function (a, b) {
    return (a._zIndex === b._zIndex ? a._updateTreeOrder - b._updateTreeOrder : a._zIndex - b._zIndex);
};





/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementTexturizer)
/* harmony export */ });
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../TextureSource.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureSource.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ElementTexturizer {

    constructor(elementCore) {

        this._element = elementCore.element;
        this._core = elementCore;

        this.ctx = this._core.ctx;

        this._enabled = false;
        this.lazy = false;
        this._colorize = false;

        this._renderTexture = null;

        this._renderTextureReused = false;

        this._resultTextureSource = null;

        this._renderOffscreen = false;

        this.empty = false;
    }

    get enabled() {
        return this._enabled;
    }

    set enabled(v) {
        this._enabled = v;
        this._core.updateRenderToTextureEnabled();
    }

    get renderOffscreen() {
        return this._renderOffscreen;
    }

    set renderOffscreen(v) {
        this._renderOffscreen = v;
        this._core.setHasRenderUpdates(1);

        // This enforces rechecking the 'within bounds'.
        this._core._setRecalc(6);
    }

    get colorize() {
        return this._colorize;
    }

    set colorize(v) {
        if (this._colorize !== v) {
            this._colorize = v;

            // Only affects the finally drawn quad.
            this._core.setHasRenderUpdates(1);
        }
    }

    _getTextureSource() {
        if (!this._resultTextureSource) {
            this._resultTextureSource = new _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this._element.stage.textureManager);
            this.updateResultTexture();
        }
        return this._resultTextureSource;
    }

    hasResultTexture() {
        return !!this._resultTextureSource;
    }

    resultTextureInUse() {
        return this._resultTextureSource && this._resultTextureSource.hasEnabledElements();
    }

    updateResultTexture() {
        let resultTexture = this.getResultTexture();
        if (this._resultTextureSource) {
            if (this._resultTextureSource.nativeTexture !== resultTexture) {
                let w = resultTexture ? resultTexture.w : 0;
                let h = resultTexture ? resultTexture.h : 0;
                this._resultTextureSource.replaceNativeTexture(resultTexture, w, h);
            }

            // Texture will be updated: all elements using the source need to be updated as well.
            this._resultTextureSource.forEachEnabledElement(element => {
                element._updateDimensions();
                element.core.setHasRenderUpdates(3);
            });
        }
    }

    mustRenderToTexture() {
        // Check if we must really render as texture.
        if (this._enabled && !this.lazy) {
            return true;
        } else if (this._enabled && this.lazy && this._core._hasRenderUpdates < 3) {
            // Static-only: if renderToTexture did not need to update during last drawn frame, generate it as a cache.
            return true;
        }
        return false;
    }

    deactivate() {
        this.release();
    }

    get renderTextureReused() {
        return this._renderTextureReused;
    }

    release() {
        this.releaseRenderTexture();
    }

    releaseRenderTexture() {
        if (this._renderTexture) {
            if (!this._renderTextureReused) {
                this.ctx.releaseRenderTexture(this._renderTexture);
            }
            this._renderTexture = null;
            this._renderTextureReused = false;
            this.updateResultTexture();
        }
    }

    // Reuses the specified texture as the render texture (in ancestor).
    reuseTextureAsRenderTexture(nativeTexture) {
        if (this._renderTexture !== nativeTexture) {
            this.releaseRenderTexture();
            this._renderTexture = nativeTexture;
            this._renderTextureReused = true;
        }
    }

    hasRenderTexture() {
        return !!this._renderTexture;
    }

    getRenderTexture() {
        if (!this._renderTexture) {
            this._renderTexture = this.ctx.allocateRenderTexture(this._core._w, this._core._h);
            this._renderTextureReused = false;
        }
        return this._renderTexture;
    }

    getResultTexture() {
        return this._renderTexture;
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/sdk/package.json":
/*!****************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/package.json ***!
  \****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"@lightningjs/sdk","version":"4.8.1","license":"Apache-2.0","scripts":{"postinstall":"node ./scripts/postinstall.js","lint":"eslint \'**/*.js\'","release":"npm publish --access public"},"lint-staged":{"*.js":["eslint --fix"],"src/startApp.js":["rollup -c ./rollup.config.js"]},"husky":{"hooks":{"pre-commit":"lint-staged"}},"dependencies":{"@babel/polyfill":"^7.11.5","@lightningjs/core":"*","@michieljs/execute-as-promise":"^1.0.0","deepmerge":"^4.2.2","localCookie":"github:WebPlatformForEmbedded/localCookie","shelljs":"^0.8.4","url-polyfill":"^1.1.10","whatwg-fetch":"^3.0.0"},"devDependencies":{"@babel/core":"^7.11.6","@babel/plugin-transform-parameters":"^7.10.5 ","@babel/plugin-transform-spread":"^7.11.0","@babel/preset-env":"^7.11.5","babel-eslint":"^10.1.0","eslint":"^7.10.0","eslint-config-prettier":"^6.12.0","eslint-plugin-prettier":"^3.1.4","husky":"^4.3.0","lint-staged":"^10.4.0","prettier":"^1.19.1","rollup":"^1.32.1","rollup-plugin-babel":"^4.4.0"},"repository":{"type":"git","url":"git@github.com:rdkcentral/Lightning-SDK.git"},"bugs":{"url":"https://github.com/rdkcentral/Lightning-SDK/issues"}}');

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"pt3-firebolt_hello_world-mock","version":"1.0.0","description":"","scripts":{"build":"webpack","dev":"cross-env NODE_ENV=development webpack serve"},"dependencies":{"@firebolt-js/sdk":"^0.6.0","@lightningjs/sdk":"^4.6.1"},"devDependencies":{"@babel/core":"^7.14.5","@babel/preset-env":"^7.14.5","copy-webpack-plugin":"^10.2.4","cross-env":"^7.0.3","html-webpack-plugin":"^5.5.0","pug":">=3.0.1","pug-loader":"^2.4.0","webpack":"^5.68.0","webpack-cli":"^4.9.2","webpack-dev-server":"^4.7.4"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*************************!*\
  !*** ./public/index.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/sdk */ "./node_modules/@lightningjs/sdk/index.js");
/* harmony import */ var _src_App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/App */ "./src/App.js");
/* harmony import */ var _src_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/settings */ "./src/settings.js");
/*
* Copyright 2021 Comcast Cable Communications Management, LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* SPDX-License-Identifier: Apache-2.0
*/






// launch the application with custom settings
const app = (0,_lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Launch)(_src_App__WEBPACK_IMPORTED_MODULE_1__.App, _src_settings__WEBPACK_IMPORTED_MODULE_2__.appSettings, _src_settings__WEBPACK_IMPORTED_MODULE_2__.platformSettings, _src_settings__WEBPACK_IMPORTED_MODULE_2__.appData);

// append the canvas to the dom
document.body.appendChild(app.stage.getCanvas());

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsZ0NBQWdDO0FBQ2hDLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQW1CO0FBQ3JELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7O0FBSUE7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQSxxREFBcUQsZUFBZTtBQUNwRTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDs7QUFFQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEOztBQUVBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTs7OztBQUlBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTs7QUFFQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7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Q0EsaUJBQWlCLHFEQUFVO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLHFEQUFVO0FBQzFCO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLHFEQUFVO0FBQzFCO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLHFEQUFVO0FBQzFCO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FB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QUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0RBQVM7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7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QTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBV2tCO0FBQzRCO0FBQ0U7QUFDRjtBQUNuQjtBQUNTO0FBQ1g7QUFDZ0I7QUFDWTtBQUNOOztBQUUvQztBQUNBLFVBQVU7QUFDVjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087O0FBRVA7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087O0FBRVA7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087O0FBRVA7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0Q0FBSTtBQUNSO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFFBQVEsc0JBQXNCOztBQUU5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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYyw0Q0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7O0FBRTVCO0FBQ1I7QUFDQTs7QUFFSztBQUN5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QTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUVBQWUsbUVBQWM7QUFDN0I7QUFDQSxLQUFLLHdEQUFtQjtBQUN4QixNQUFNLHdEQUFtQjtBQUN6QixNQUFNLHdEQUFtQjtBQUN6Qjs7QUFFQTs7QUFFQSxnQkFBZ0IsaURBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQzVjRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdURBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHVEQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQSxhQUFhLHVEQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQUs7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUZBQWE7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRDs7QUFFdEMsNEJBQTRCLGtFQUFTOztBQUVwRDtBQUNBOztBQUVBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9DO0FBQ0k7QUFDUTs7QUFFakM7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGdCQUFnQiwwREFBYTtBQUM3QixpRUFBaUUsMERBQWE7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxzREFBSTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isc0RBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBUztBQUNqQjs7QUFFQTtBQUNBLGdCQUFnQixzREFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFTO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsc0RBQVM7QUFDeEI7O0FBRUE7QUFDQSxlQUFlLHNEQUFTO0FBQ3hCOztBQUVBO0FBQ0EsZUFBZSxzREFBUztBQUN4Qjs7QUFFQTtBQUNBLGVBQWUsc0RBQVM7QUFDeEI7O0FBRUE7QUFDQSxlQUFlLHNEQUFTO0FBQ3hCOztBQUVBO0FBQ0EsZUFBZSxzREFBUztBQUN4Qjs7QUFFQTtBQUNBLGVBQWUsc0RBQVM7QUFDeEI7O0FBRUE7QUFDQSxlQUFlLHNEQUFTO0FBQ3hCOztBQUVBO0FBQ0EsZUFBZSxzREFBUztBQUN4Qjs7QUFFQTtBQUNBLGVBQWUsc0RBQVM7QUFDeEI7O0FBRUE7QUFDQSxlQUFlLHNEQUFTO0FBQ3hCOztBQUVBO0FBQ0EsZUFBZSxzREFBUztBQUN4Qjs7QUFFQTtBQUNBLGVBQWUsc0RBQVM7QUFDeEI7O0FBRUE7QUFDQSxlQUFlLHNEQUFTO0FBQ3hCOztBQUVBO0FBQ0EsZUFBZSxzREFBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isc0RBQVM7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDVjtBQUNFOztBQUV4QztBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QiwwREFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVE7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFTO0FBQzVDO0FBQ0E7QUFDQSxtQ0FBbUMsc0RBQVM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNwZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0Q7O0FBRXpDOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0JBQStCOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ2U7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsNERBQVU7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFlBQVksc0RBQUk7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQzs7Ozs7Ozs7Ozs7Ozs7OztBQzNFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0RDs7QUFFN0MsOEJBQThCLG1FQUFZOztBQUV6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0U7O0FBRXZELG1DQUFtQyx3RUFBaUI7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RTtBQUNyQjtBQUNWOztBQUUxQixvQ0FBb0MseUVBQWtCOztBQUVyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDRCQUE0Qiw0REFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFLO0FBQ3BCOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ1U7QUFDRTtBQUNFO0FBQ1Y7QUFDaEI7QUFDRDtBQUNzQjs7QUFFOUMsMEJBQTBCLHFEQUFROztBQUVqRDtBQUNBOztBQUVBLCtCQUErQixrRUFBa0I7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtFQUFhO0FBQ2hDOztBQUVBO0FBQ0EsZUFBZSxzREFBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsNERBQWU7QUFDbEM7O0FBRUE7QUFDQSxtQkFBbUIsaUVBQW9CO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLGtFQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0VBQWU7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkM7O0FBRTVCLHdCQUF3Qix3REFBTTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNFQUFlO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFlBQVksdURBQUs7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLHVEQUFLO0FBQ2hDLDRCQUE0Qix1REFBSzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwRDtBQUNmOztBQUU1QiwwQkFBMEIsd0RBQU07O0FBRS9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQywrREFBa0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDZSw0QkFBNEIsMERBQWE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEM7QUFDSTs7QUFFakMsaUNBQWlDLDBEQUFhOztBQUU3RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2Qzs7QUFFOUIsNEJBQTRCLHdEQUFXOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4RDtBQUNkOztBQUVoRDtBQUNBO0FBQ0E7QUFDZSw4QkFBOEIsMERBQWE7O0FBRTFEO0FBQ0E7O0FBRUEsaUNBQWlDLGtFQUFZOztBQUU3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixZQUFZOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVqQyw0QkFBNEIsMERBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFakMseUJBQXlCLDBEQUFhOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQywwREFBYTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWpDLDhCQUE4QiwwREFBYTs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWpDLDRCQUE0QiwwREFBYTs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFakMsK0JBQStCLDBEQUFhOztBQUUzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFakMsOEJBQThCLDBEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBEQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDtBQUNOOztBQUVqQyw0QkFBNEIsMERBQWE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qiw0REFBVTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsWUFBWTs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWpDLGdDQUFnQywwREFBYTs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNlLDZCQUE2QiwwREFBYTs7QUFFekQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWpDLGlDQUFpQywwREFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDtBQUNNOztBQUV2QyxtQ0FBbUMsMERBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDREQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsNERBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEO0FBQ007O0FBRXZDLHFDQUFxQywwREFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsNERBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEO0FBQ0s7O0FBRXRDLDRCQUE0QiwwREFBYTs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDREQUFVO0FBQzdELDZEQUE2RCw0REFBVTtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLDBEQUFhOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDtBQUNNOztBQUV2Qyw2QkFBNkIsMERBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDREQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVqQyw2QkFBNkIsMERBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFLO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx1REFBSztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLCtDQUErQztBQUMzRiwyQ0FBMkMsK0NBQStDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLGlCQUFpQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDLzVCakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0RBQUs7QUFDbEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxnQkFBZ0Isa0RBQUs7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRWdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUwQztBQUNPO0FBQ25COztBQUVFO0FBQ2U7QUFDYjs7QUFFbkI7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQiw2REFBVzs7QUFFckM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrREFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxrREFBSztBQUNqQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsaURBQUk7QUFDcEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZCw4QkFBOEIsbUVBQWE7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGtEQUFLO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGtEQUFLO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrREFBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLGtEQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsbURBQW1ELE9BQU8sbUJBQW1CLHVCQUF1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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3JSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksa0RBQUs7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFZ0M7Ozs7Ozs7Ozs7Ozs7OztBQ3pZaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2U7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDbE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2U7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUUsT0FBTztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1EOztBQUVwQzs7QUFFZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksa0RBQUs7QUFDakI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksa0RBQUs7QUFDakI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0Q7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7QUNudUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlEOztBQUVsQzs7QUFFZjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsMERBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUMzS0E7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEM7O0FBRVQ7QUFDd0M7O0FBRXpFO0FBQ0EsWUFBWSx3REFBTSxDQUFDLHlDQUFHLEVBQUUsc0RBQVcsRUFBRSwyREFBZ0IsRUFBRSxrREFBTzs7QUFFOUQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BmaXJlYm9sdC1qcy9zZGsvZGlzdC9maXJlYm9sdC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL0Fkcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9BcHBsaWNhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9BdWRpb1BsYXllci9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Db2xvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvQ29sb3JzL3V0aWxzLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL0Zwc0NvdW50ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvSW1nL1NjYWxlZEltYWdlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9JbWcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvS2V5Ym9hcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvTGFuZ3VhZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvTGF1bmNoL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL0xpZ2h0bmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Mb2NhbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvTG9nL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL01lZGlhUGxheWVyL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL01ldGFkYXRhL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL01ldHJpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUGluL2RpYWxvZy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9QaW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUHJvZmlsZS9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Qcm9maWxlL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUHJvZmlsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9QdXJjaGFzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9SZWdpc3RyeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvYmFzZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUm91dGVyL21vZGVsL1JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUm91dGVyL21vZGVsL1JvdXRlLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci90cmFuc2l0aW9ucy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvY29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvZW1pdC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvaGlzdG9yeS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvbG9hZGVyLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy9wcm92aWRlci5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvcmVnZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUm91dGVyL3V0aWxzL3JlZ2lzdGVyLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy9yb3V0ZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvcm91dGVyLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy93aWRnZXRzLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1NldHRpbmdzL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1N0b3JhZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVFYvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVFYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVmVyc2lvbkxhYmVsL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1ZpZGVvUGxheWVyL1ZpZGVvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9WaWRlb1BsYXllci9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVmlkZW9QbGF5ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvaGVscGVycy9hdXRvU2V0dXBNaXhpbi5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9oZWxwZXJzL2Vhc2VFeGVjdXRpb24uanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvaGVscGVycy9zZXF1ZW5jZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbWljaGllbGpzL2V4ZWN1dGUtYXMtcHJvbWlzZS9zcmMvZXhlY3V0ZS1hcy1wcm9taXNlLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9sb2NhbENvb2tpZS9tb2R1bGUvbG9jYWxDb29raWUuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9zcmMvQXBwLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vc3JjL015QnV0dG9uLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vc3JjL3NldHRpbmdzLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9FdmVudEVtaXR0ZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hbmltYXRpb24vQW5pbWF0aW9uLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbkFjdGlvblNldHRpbmdzLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbk1hbmFnZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hbmltYXRpb24vQW5pbWF0aW9uU2V0dGluZ3MubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hbmltYXRpb24vVHJhbnNpdGlvbi5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2FuaW1hdGlvbi9UcmFuc2l0aW9uTWFuYWdlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2FuaW1hdGlvbi9UcmFuc2l0aW9uU2V0dGluZ3MubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hcHBsaWNhdGlvbi9BcHBsaWNhdGlvbi5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2FwcGxpY2F0aW9uL0NvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2FwcGxpY2F0aW9uL1N0YXRlTWFjaGluZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2NvbXBvbmVudHMvQmxvb21Db21wb25lbnQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9jb21wb25lbnRzL0JvcmRlckNvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2NvbXBvbmVudHMvRmFzdEJsdXJDb21wb25lbnQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9jb21wb25lbnRzL0xpc3RDb21wb25lbnQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9jb21wb25lbnRzL1Ntb290aFNjYWxlQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9GbGV4Q29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9GbGV4SXRlbS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvRmxleFRhcmdldC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvRmxleFV0aWxzLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9sYXlvdXQvQ29udGVudEFsaWduZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9GbGV4TGF5b3V0Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9sYXlvdXQvSXRlbUNvb3JkaW5hdGVzVXBkYXRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvbGF5b3V0L0xpbmVMYXlvdXRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvbGF5b3V0L1NwYWNpbmdDYWxjdWxhdG9yLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9sYXlvdXQvbGluZS9JdGVtQWxpZ25lci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvbGF5b3V0L2xpbmUvSXRlbVBvc2l0aW9uZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9saW5lL0xpbmVMYXlvdXQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9saW5lL1NpemVHcm93ZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9saW5lL1NpemVTaHJpbmtlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2xpZ2h0bmluZy5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3BsYXRmb3Jtcy9QbGF0Zm9ybUxvYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3BsYXRmb3Jtcy9icm93c2VyL0ltYWdlV29ya2VyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcGxhdGZvcm1zL2Jyb3dzZXIvV2ViUGxhdGZvcm0ubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9SZW5kZXJlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL2MyZC9DMmRDb3JlUXVhZExpc3QubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9jMmQvQzJkQ29yZVF1YWRPcGVyYXRpb24ubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9jMmQvQzJkQ29yZVJlbmRlckV4ZWN1dG9yLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvYzJkL0MyZFJlbmRlcmVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvYzJkL0MyZFNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL2MyZC9DMmRUZXh0dXJlVGludE1hbmFnZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9jMmQvc2hhZGVycy9CbHVyU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvYzJkL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL2NvbW1vbi9zaGFkZXJzL0dyYXlzY2FsZVNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3NwYXJrL1NwYXJrUmVuZGVyZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9zcGFyay9zaGFkZXJzL1NwYXJrU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvV2ViR0xDb3JlUXVhZExpc3QubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9XZWJHTENvcmVRdWFkT3BlcmF0aW9uLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvV2ViR0xDb3JlUmVuZGVyRXhlY3V0b3IubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvV2ViR0xTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9XZWJHTFNoYWRlclByb2dyYW0ubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0JveEJsdXJTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0NpcmN1bGFyUHVzaFNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvRGl0aGVyaW5nU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9GYWRlT3V0U2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9Ib2xlU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9JbnZlcnNpb25TaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0xpZ2h0M2RTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0xpbmVhckJsdXJTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL01hZ25pZmllclNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvT3V0bGluZVNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvUGVyc3BlY3RpdmVTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1BpeGVsYXRlU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9SYWRpYWxGaWx0ZXJTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1JhZGlhbEdyYWRpZW50U2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9Sb3VuZGVkUmVjdGFuZ2xlU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9TcGlubmVyU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9TcGlubmVyU2hhZGVyMi5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVmlnbmV0dGVTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9IdG1sVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL0ltYWdlVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL05vaXNlVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL1JlY3RhbmdsZVRleHR1cmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9Tb3VyY2VUZXh0dXJlLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdGV4dHVyZXMvU3RhdGljQ2FudmFzVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL1N0YXRpY1RleHR1cmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9UZXh0VGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL1RleHRUZXh0dXJlUmVuZGVyZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9UZXh0VGV4dHVyZVJlbmRlcmVyQWR2YW5jZWQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90b29scy9NdWx0aVNwbGluZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3Rvb2xzL09iak1lcmdlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3Rvb2xzL09iamVjdExpc3RQcm94eS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3Rvb2xzL09iamVjdExpc3RXcmFwcGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdG9vbHMvVG9vbHMubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90b29scy9XZWJHTFN0YXRlTWFuYWdlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvRWxlbWVudC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvRWxlbWVudENoaWxkTGlzdC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvT2JqZWN0TGlzdC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9TdGFnZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvU3RhZ2VVdGlscy5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvVGV4dHVyZU1hbmFnZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL1RleHR1cmVTb3VyY2UubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL1RleHR1cmVUaHJvdHRsZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL1V0aWxzLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9jb3JlL0NvcmVDb250ZXh0Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9jb3JlL0NvcmVRdWFkTGlzdC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvY29yZS9Db3JlUXVhZE9wZXJhdGlvbi5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvY29yZS9Db3JlUmVuZGVyRXhlY3V0b3IubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL2NvcmUvQ29yZVJlbmRlclN0YXRlLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9jb3JlL0VsZW1lbnRDb3JlLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9jb3JlL0VsZW1lbnRUZXh0dXJpemVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vcHVibGljL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKiovIC8vIFRoZSByZXF1aXJlIHNjb3BlXG4vKioqKioqLyB2YXIgX193ZWJwYWNrX3JlcXVpcmVfXyA9IHt9O1xuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyAoKCkgPT4ge1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIFwieXFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFjY2Vzc2liaWxpdHkpLFxuICBcIm1SXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBY2NvdW50KSxcbiAgXCJaTFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWR2ZXJ0aXNpbmcpLFxuICBcIlZ5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBdXRoZW50aWNhdGlvbiksXG4gIFwiQVNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERldmljZSksXG4gIFwiUEdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERpc2NvdmVyeSksXG4gIFwieldcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEV2ZW50cyksXG4gIFwiTjFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEtleWJvYXJkKSxcbiAgXCJGd1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTGlmZWN5Y2xlKSxcbiAgXCJXSFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9jYWxpemF0aW9uKSxcbiAgXCJaYlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9nKSxcbiAgXCJDM1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTWV0cmljcyksXG4gIFwiYUVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBhcmFtZXRlcnMpLFxuICBcInQ0XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQbGF0Zm9ybSksXG4gIFwiTlpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFByb2ZpbGUpLFxuICBcIl9GXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTZWNvbmRTY3JlZW4pLFxuICBcIlpyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTZXR0aW5ncylcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvUHJvcC9Nb2NrUHJvcHMuanNcblxuXG5jb25zdCBtb2NrcyA9IHt9XG5cbmZ1bmN0aW9uIG1vY2sobW9kdWxlLCBtZXRob2QsIGFyZ3MsIGRlZikge1xuICBjb25zdCBmdWxsTWV0aG9kID0gYCR7bW9kdWxlfS4ke21ldGhvZH1gXG4gIGlmICgoYXJncyA9PSBudWxsKSB8fCAoYXJncy5sZW5ndGggPT09IDApKSB7XG4gICAgLy8gZ2V0XG4gICAgY29uc3QgcnYgPSBtb2Nrc1tmdWxsTWV0aG9kXSAmJiBtb2Nrc1tmdWxsTWV0aG9kXS52YWx1ZSA/IG1vY2tzW2Z1bGxNZXRob2RdLnZhbHVlIDogZGVmXG4gICAgcmV0dXJuIHJ2XG4gIH0gZWxzZSB7XG4gICAgLy8gc2V0XG4gICAgbGV0IG1vY2tNZXRob2QgPSBtb2Nrc1tmdWxsTWV0aG9kXVxuICAgIGlmIChtb2NrTWV0aG9kID09IG51bGwpIHtcbiAgICAgIG1vY2tNZXRob2QgPSB7XG4gICAgICAgIHN1YnNjcmliZXJzOiBbXVxuICAgICAgfVxuICAgIH1cbiAgICBtb2Nrc1tmdWxsTWV0aG9kXSA9IG1vY2tNZXRob2RcbiAgICBtb2NrTWV0aG9kLnZhbHVlID0gYXJnc1swXS52YWx1ZVxuICAgIFRyYW5zcG9ydF9tb2NrLmV2ZW50KG1vZHVsZSwgbWV0aG9kICsgJ0NoYW5nZWQnLCB7XG4gICAgICB2YWx1ZTogYXJnc1swXS52YWx1ZVxuICAgIH0pXG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNb2NrUHJvcHMgPSAoe1xuICBtb2NrOiBtb2NrXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9BY2Nlc3NpYmlsaXR5L2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBkZWZhdWx0cyA9ICh7XG5cbiAgICBjbG9zZWRDYXB0aW9uczoge1xuICBcImVuYWJsZWRcIjogdHJ1ZSxcbiAgXCJzdHlsZXNcIjoge1xuICAgIFwiZm9udEZhbWlseVwiOiBcIk1vbm9zcGFjZSBzYW5zLXNlcmlmXCIsXG4gICAgXCJmb250U2l6ZVwiOiAxLFxuICAgIFwiZm9udENvbG9yXCI6IFwiI2ZmZmZmZlwiLFxuICAgIFwiZm9udEVkZ2VcIjogXCJub25lXCIsXG4gICAgXCJmb250RWRnZUNvbG9yXCI6IFwiIzdGN0Y3RlwiLFxuICAgIFwiZm9udE9wYWNpdHlcIjogMTAwLFxuICAgIFwiYmFja2dyb3VuZENvbG9yXCI6IFwiIzAwMDAwMFwiLFxuICAgIFwiYmFja2dyb3VuZE9wYWNpdHlcIjogMTAwLFxuICAgIFwidGV4dEFsaWduXCI6IFwiY2VudGVyXCIsXG4gICAgXCJ0ZXh0QWxpZ25WZXJ0aWNhbFwiOiBcIm1pZGRsZVwiXG4gIH1cbn0sXG5cbiAgICBjbG9zZWRDYXB0aW9uc1NldHRpbmdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnYWNjZXNzaWJpbGl0eScsICdjbG9zZWRDYXB0aW9uc1NldHRpbmdzJywgYXJndW1lbnRzLCB7XG4gIFwiZW5hYmxlZFwiOiB0cnVlLFxuICBcInN0eWxlc1wiOiB7XG4gICAgXCJmb250RmFtaWx5XCI6IFwiTW9ub3NwYWNlIHNhbnMtc2VyaWZcIixcbiAgICBcImZvbnRTaXplXCI6IDEsXG4gICAgXCJmb250Q29sb3JcIjogXCIjZmZmZmZmXCIsXG4gICAgXCJmb250RWRnZVwiOiBcIm5vbmVcIixcbiAgICBcImZvbnRFZGdlQ29sb3JcIjogXCIjN0Y3RjdGXCIsXG4gICAgXCJmb250T3BhY2l0eVwiOiAxMDAsXG4gICAgXCJiYWNrZ3JvdW5kQ29sb3JcIjogXCIjMDAwMDAwXCIsXG4gICAgXCJiYWNrZ3JvdW5kT3BhY2l0eVwiOiAxMDAsXG4gICAgXCJ0ZXh0QWxpZ25cIjogXCJjZW50ZXJcIixcbiAgICBcInRleHRBbGlnblZlcnRpY2FsXCI6IFwibWlkZGxlXCJcbiAgfVxufSkgfSxcblxuICAgIHZvaWNlR3VpZGFuY2U6IHtcbiAgXCJlbmFibGVkXCI6IHRydWUsXG4gIFwic3BlZWRcIjogNVxufSxcblxuICAgIHZvaWNlR3VpZGFuY2VTZXR0aW5nczogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2FjY2Vzc2liaWxpdHknLCAndm9pY2VHdWlkYW5jZVNldHRpbmdzJywgYXJndW1lbnRzLCB7XG4gIFwiZW5hYmxlZFwiOiB0cnVlLFxuICBcInNwZWVkXCI6IDVcbn0pIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0FjY291bnQvZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFjY291bnRfZGVmYXVsdHMgPSAoe1xuXG4gICAgaWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdhY2NvdW50JywgJ2lkJywgYXJndW1lbnRzLCBcIjEyM1wiKSB9LFxuXG4gICAgdWlkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnYWNjb3VudCcsICd1aWQnLCBhcmd1bWVudHMsIFwiZWU2NzIzYjgtN2FiMy00NjJjLThkOTMtZGJmNjEyMjc5OThlXCIpIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0FkdmVydGlzaW5nL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBZHZlcnRpc2luZ19kZWZhdWx0cyA9ICh7XG5cbiAgICBjb25maWc6IHtcbiAgXCJhZFNlcnZlclVybFwiOiBcImh0dHA6Ly9kZW1vLnYuZndtcm0ubmV0L2FkL3AvMVwiLFxuICBcImFkU2VydmVyVXJsVGVtcGxhdGVcIjogXCJodHRwOi8vZGVtby52LmZ3bXJtLm5ldC9hZC9wLzE/ZmxhZz0rc2x0cCtleHZ0K3NsY2IrZW1jcithbWNiK2FldGkmcHJvZj0xMjM0NTpjYWZfYWxsaW5vbmVfcHJvZmlsZSAmbnc9MTIzNDUmbW9kZT1saXZlJnZkdXI9MTIzJmNhaWQ9YTExMDUyMzAxOCZhc253PTM3MjQ2NCZjc2lkPWdtb3R0X2lvc190YWJsZXRfd2F0Y2hfbGl2ZV9FU1BOVSZzc253PTM3MjQ2NCZ2aXA9MTk4LjIwNS45Mi4xJnJlc3A9dm1hcDEmbWV0cj0xMDMxJnB2cm49MTIzNDUmdnBybj0xMjM0NSZ2Y2lkPTFYMENlN0wzeFJXbFRlTmhjN2JyOFElM0QlM0RcIixcbiAgXCJhZE5ldHdvcmtJZFwiOiBcIjUxOTE3OFwiLFxuICBcImFkUHJvZmlsZUlkXCI6IFwiMTIzNDU6Y2FmX2FsbGlub25lX3Byb2ZpbGVcIixcbiAgXCJhZFNpdGVTZWN0aW9uSWRcIjogXCJjYWZfYWxsaW5vbmVfcHJvZmlsZV9zZWN0aW9uXCIsXG4gIFwiYWRPcHRPdXRcIjogdHJ1ZSxcbiAgXCJwcml2YWN5RGF0YVwiOiBcImV3MEtJQ0FpY0dSMElqb2dJbWRrY0RwMk1TSXNEUW9nSUNKMWMxOXdjbWwyWVdONUlqb2dJakV0VGkwaUxBMEtJQ0FpYkcxMElqb2dJakVpSUEwS2ZRMEtcIixcbiAgXCJpZmFWYWx1ZVwiOiBcIjAxMjM0NTY3LTg5QUItQ0RFRi1HSDAxLTIzNDU2Nzg5QUJDRFwiLFxuICBcImlmYVwiOiBcImV3b2dJQ0oyWVd4MVpTSTZJQ0l3TVRJek5EVTJOeTA0T1VGQ0xVTkVSVVl0UjBnd01TMHlNelExTmpjNE9VRkNRMFFpTEFvZ0lDSnBabUZmZEhsd1pTSTZJQ0p6YzNCcFpDSXNDaUFnSW14dGRDSTZJQ0l3SWdwOUNnPT1cIixcbiAgXCJhcHBOYW1lXCI6IFwiRnV0dXJlVG9kYXlcIixcbiAgXCJhcHBCdW5kbGVJZFwiOiBcIkZ1dHVyZVRvZGF5LmNvbWNhc3RcIixcbiAgXCJkaXN0cmlidXRvckFwcElkXCI6IFwiMTAwMVwiLFxuICBcImRldmljZUFkQXR0cmlidXRlc1wiOiBcImV3b2dJQ0ppYjBGMGRISnBZblYwWlhOR2IzSlNaWFpUYUdGeVpVbGtJam9nSWpFeU16UWlDbjA9XCIsXG4gIFwiY29wcGFcIjogMCxcbiAgXCJhdXRoZW50aWNhdGlvbkVudGl0eVwiOiBcIjYwZjcyNDc1MjgxY2ZiYTM4NTI0MTNiZDUzZTk1N2Y2XCJcbn0sXG5cbiAgICBwb2xpY3k6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdhZHZlcnRpc2luZycsICdwb2xpY3knLCBhcmd1bWVudHMsIHtcbiAgXCJza2lwUmVzdHJpY3Rpb25cIjogXCJhZHNVbndhdGNoZWRcIixcbiAgXCJsaW1pdEFkVHJhY2tpbmdcIjogZmFsc2Vcbn0pIH0sXG5cbiAgICBhZHZlcnRpc2luZ0lkOiB7XG4gIFwiaWZhXCI6IFwiMDEyMzQ1NjctODlBQi1DREVGLUdIMDEtMjM0NTY3ODlBQkNEXCIsXG4gIFwiaWZhX3R5cGVcIjogXCJpZGZhXCIsXG4gIFwibG10XCI6IFwiMFwiXG59LFxuXG4gICAgZGV2aWNlQXR0cmlidXRlczoge30sXG5cbiAgICBhcHBCdW5kbGVJZDogXCJvcGVyYXRvci5hcHBcIlxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvQXV0aGVudGljYXRpb24vZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEF1dGhlbnRpY2F0aW9uX2RlZmF1bHRzID0gKHtcblxuICAgIHRva2VuOiB7XG4gIFwidmFsdWVcIjogXCJleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKemRXSWlPaUl4TWpNME5UWTNPRGt3SWl3aWJtRnRaU0k2SWtwdmFHNGdSRzlsSWl3aWFXRjBJam94TlRFMk1qTTVNREl5ZlEuU2ZsS3h3UkpTTWVLS0YyUVQ0ZndwTWVKZjM2UE9rNnlKVl9hZFFzc3c1Y1wiLFxuICBcImV4cGlyZXNcIjogXCIyMDIyLTA0LTIzVDE4OjI1OjQzLjUxMVpcIixcbiAgXCJ0eXBlXCI6IFwicGxhdGZvcm1cIlxufVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvRGV2aWNlL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBEZXZpY2VfZGVmYXVsdHMgPSAoe1xuXG4gICAgaWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAnaWQnLCBhcmd1bWVudHMsIFwiMTIzXCIpIH0sXG5cbiAgICBkaXN0cmlidXRvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdkaXN0cmlidXRvcicsIGFyZ3VtZW50cywgXCJDb21wYW55XCIpIH0sXG5cbiAgICBwbGF0Zm9ybTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdwbGF0Zm9ybScsIGFyZ3VtZW50cywgXCJXUEVcIikgfSxcblxuICAgIHVpZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICd1aWQnLCBhcmd1bWVudHMsIFwiZWU2NzIzYjgtN2FiMy00NjJjLThkOTMtZGJmNjEyMjc5OThlXCIpIH0sXG5cbiAgICB0eXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ3R5cGUnLCBhcmd1bWVudHMsIFwiU1RCXCIpIH0sXG5cbiAgICBtb2RlbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdtb2RlbCcsIGFyZ3VtZW50cywgXCJ4aTZcIikgfSxcblxuICAgIHNrdTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdza3UnLCBhcmd1bWVudHMsIFwiQVgwNjFBRUlcIikgfSxcblxuICAgIG1ha2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAnbWFrZScsIGFyZ3VtZW50cywgXCJBcnJpc1wiKSB9LFxuXG4gICAgdmVyc2lvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICd2ZXJzaW9uJywgYXJndW1lbnRzLCB7XG4gIFwic2RrXCI6IHtcbiAgICBcIm1ham9yXCI6IDAsXG4gICAgXCJtaW5vclwiOiA1LFxuICAgIFwicGF0Y2hcIjogMCxcbiAgICBcInJlYWRhYmxlXCI6IFwiRmlyZWJvbHQgSlMgU0RLIHYwLjUuMFwiXG4gIH0sXG4gIFwib3NcIjoge1xuICAgIFwibWFqb3JcIjogMCxcbiAgICBcIm1pbm9yXCI6IDEsXG4gICAgXCJwYXRjaFwiOiAwLFxuICAgIFwicmVhZGFibGVcIjogXCJGaXJlYm9sdCBPUyB2MC4xLjBcIlxuICB9LFxuICBcImRlYnVnXCI6IFwiXCJcbn0pIH0sXG5cbiAgICBoZGNwOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ2hkY3AnLCBhcmd1bWVudHMsIHtcbiAgXCJoZGNwMS40XCI6IHRydWUsXG4gIFwiaGRjcDIuMlwiOiB0cnVlXG59KSB9LFxuXG4gICAgaGRyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ2hkcicsIGFyZ3VtZW50cywge1xuICBcImhkcjEwXCI6IHRydWUsXG4gIFwiaGRyMTBQbHVzXCI6IHRydWUsXG4gIFwiZG9sYnlWaXNpb25cIjogdHJ1ZSxcbiAgXCJobGdcIjogdHJ1ZVxufSkgfSxcblxuICAgIGF1ZGlvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ2F1ZGlvJywgYXJndW1lbnRzLCB7XG4gIFwic3RlcmVvXCI6IHRydWUsXG4gIFwiZG9sYnlEaWdpdGFsNS4xXCI6IHRydWUsXG4gIFwiZG9sYnlEaWdpdGFsNS4xK1wiOiB0cnVlLFxuICBcImRvbGJ5QXRtb3NcIjogdHJ1ZVxufSkgfSxcblxuICAgIHNjcmVlblJlc29sdXRpb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAnc2NyZWVuUmVzb2x1dGlvbicsIGFyZ3VtZW50cywgW1xuICAxOTIwLFxuICAxMDgwXG5dKSB9LFxuXG4gICAgdmlkZW9SZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ3ZpZGVvUmVzb2x1dGlvbicsIGFyZ3VtZW50cywgW1xuICAxOTIwLFxuICAxMDgwXG5dKSB9LFxuXG4gICAgbmFtZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICduYW1lJywgYXJndW1lbnRzLCBcIkxpdmluZyBSb29tXCIpIH0sXG5cbiAgICBuZXR3b3JrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ25ldHdvcmsnLCBhcmd1bWVudHMsIHtcbiAgXCJzdGF0ZVwiOiBcImNvbm5lY3RlZFwiLFxuICBcInR5cGVcIjogXCJ3aWZpXCJcbn0pIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0Rpc2NvdmVyeS9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRGlzY292ZXJ5X2RlZmF1bHRzID0gKHtcblxuICAgIHBvbGljeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2Rpc2NvdmVyeScsICdwb2xpY3knLCBhcmd1bWVudHMsIHtcbiAgXCJlbmFibGVSZWNvbW1lbmRhdGlvbnNcIjogdHJ1ZSxcbiAgXCJzaGFyZVdhdGNoSGlzdG9yeVwiOiB0cnVlLFxuICBcInJlbWVtYmVyV2F0Y2hlZFByb2dyYW1zXCI6IHRydWVcbn0pIH0sXG5cbiAgICBlbnRpdHlJbmZvOiB0cnVlLFxuXG4gICAgcHVyY2hhc2VkQ29udGVudDogdHJ1ZSxcblxuICAgIHdhdGNoZWQ6IHRydWUsXG5cbiAgICB3YXRjaE5leHQ6IHRydWUsXG5cbiAgICBlbnRpdGxlbWVudHM6IHRydWUsXG5cbiAgICBsYXVuY2g6IHRydWUsXG5cbiAgICBzaWduSW46IHRydWUsXG5cbiAgICBzaWduT3V0OiB0cnVlXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9LZXlib2FyZC9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS2V5Ym9hcmRfZGVmYXVsdHMgPSAoe1xuXG4gICAgZW1haWw6IFwidXNlckBkb21haW4uY29tXCIsXG5cbiAgICBwYXNzd29yZDogXCJhYmMxMjNcIixcblxuICAgIHN0YW5kYXJkOiBcIkxpdmluZyBSb29tXCJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9nbG9iYWwuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxubGV0IGdcblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuXHRnID0gc2VsZjtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ZyA9IHdpbmRvdztcbn0gZWxzZSB7XG5cdGcgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufSBcblxuY29uc3QgZ2xvYmFsID0gZ1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRyYW5zcG9ydF9nbG9iYWwgPSAoZ2xvYmFsKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9MaWZlY3ljbGUvZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5sZXQgaW5hY3RpdmUgPSB7XCJzdGF0ZVwiOlwiaW5hY3RpdmVcIixcInByZXZpb3VzXCI6XCJpbml0aWFsaXppbmdcIn1cbmxldCBmb3JlZ3JvdW5kID0ge1wic3RhdGVcIjpcImZvcmVncm91bmRcIixcInByZXZpb3VzXCI6XCJpbmFjdGl2ZVwifVxubGV0IGJhY2tncm91bmQgPSB7XCJzdGF0ZVwiOlwiYmFja2dyb3VuZFwiLFwicHJldmlvdXNcIjpcImZvcmVncm91bmRcIn1cbmxldCBzdXNwZW5kZWQgPSB7XCJzdGF0ZVwiOlwic3VzcGVuZGVkXCIsXCJwcmV2aW91c1wiOlwiaW5hY3RpdmVcIn1cbmxldCB1bmxvYWRpbmcgPSB7XCJzdGF0ZVwiOlwidW5sb2FkaW5nXCIsXCJwcmV2aW91c1wiOlwiaW5hY3RpdmVcIn1cblxuY29uc3QgZW1pdCA9ICh2YWx1ZSkgPT4ge1xuICB2YWx1ZS5wcmV2aW91cyA9IExpZmVjeWNsZS5zdGF0ZSgpXG4gIFRyYW5zcG9ydF9tb2NrLmV2ZW50KCdMaWZlY3ljbGUnLCB2YWx1ZS5zdGF0ZSwgdmFsdWUpXG59XG5cbmNvbnN0IGF1dG9tYXRpb24gPSBUcmFuc3BvcnRfZ2xvYmFsICYmIFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdCA/ICEhVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LmF1dG9tYXRpb24gOiBmYWxzZVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExpZmVjeWNsZV9kZWZhdWx0cyA9ICh7XG4gIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICBpbmFjdGl2ZS5wcmV2aW91cyA9ICdpbml0aWFsaXppbmcnXG4gICAgc2V0VGltZW91dCgoKSA9PiBlbWl0KGluYWN0aXZlKSwgYXV0b21hdGlvbiA/IDEgOiA1MDApXG4gICAgZm9yZWdyb3VuZC5wcmV2aW91cyA9ICdpbmFjdGl2ZSdcbiAgICBzZXRUaW1lb3V0KCgpID0+IGVtaXQoZm9yZWdyb3VuZCksIGF1dG9tYXRpb24gPyAyIDogMTAwMClcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgbGV0IHJlYXNvbiA9IHBhcmFtcy5yZWFzb25cbiAgICBpZiAocmVhc29uID09PSBMaWZlY3ljbGUuQ2xvc2VSZWFzb24uUkVNT1RFX0JVVFRPTikge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBlbWl0KGluYWN0aXZlKSwgYXV0b21hdGlvbiA/IDEgOiA1MDApXG4gICAgfVxuICAgIGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoTGlmZWN5Y2xlLkNsb3NlUmVhc29uKS5pbmNsdWRlcyhyZWFzb24pKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGVtaXQoaW5hY3RpdmUpLCBhdXRvbWF0aW9uID8gMSA6IDUwMClcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gZW1pdCh1bmxvYWRpbmcpLCBhdXRvbWF0aW9uID8gMiA6IDEwMDApXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IExpZmVjeWNsZS5maW5pc2hlZCgpLCBhdXRvbWF0aW9uID8gMzogMzAwMClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBcIkludmFsaWQgY2xvc2UgcmVhc29uXCJcbiAgICB9XG4gIH0sXG5cbiAgZmluaXNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChUcmFuc3BvcnRfZ2xvYmFsLmxvY2F0aW9uKVxuICAgICAgVHJhbnNwb3J0X2dsb2JhbC5sb2NhdGlvbi5ocmVmID0gXCJhYm91dDpibGFua1wiXG4gIH0sXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0xvY2FsaXphdGlvbi9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTG9jYWxpemF0aW9uX2RlZmF1bHRzID0gKHtcblxuICAgIGxvY2FsaXR5OiBcIlBoaWxhZGVscGhpYVwiLFxuXG4gICAgcG9zdGFsQ29kZTogXCIxOTEwM1wiLFxuXG4gICAgY291bnRyeUNvZGU6IFwiVVNcIixcblxuICAgIGxhbmd1YWdlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnbG9jYWxpemF0aW9uJywgJ2xhbmd1YWdlJywgYXJndW1lbnRzLCBcImVuXCIpIH0sXG5cbiAgICBsb2NhbGU6IFwiZW4tVVNcIixcblxuICAgIGxhdGxvbjogW1xuICAzOS45NTQ5LFxuICA3NS4xNjk5XG5dLFxuXG4gICAgYWRkaXRpb25hbEluZm86IHt9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9NZXRyaWNzL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNZXRyaWNzX2RlZmF1bHRzID0gKHtcblxuICAgIHJlYWR5OiB0cnVlLFxuXG4gICAgc2lnbkluOiB0cnVlLFxuXG4gICAgc2lnbk91dDogdHJ1ZSxcblxuICAgIHN0YXJ0Q29udGVudDogdHJ1ZSxcblxuICAgIHN0b3BDb250ZW50OiB0cnVlLFxuXG4gICAgcGFnZTogdHJ1ZSxcblxuICAgIGFjdGlvbjogdHJ1ZSxcblxuICAgIGVycm9yOiB0cnVlLFxuXG4gICAgbWVkaWFMb2FkU3RhcnQ6IHRydWUsXG5cbiAgICBtZWRpYVBsYXk6IHRydWUsXG5cbiAgICBtZWRpYVBsYXlpbmc6IHRydWUsXG5cbiAgICBtZWRpYVBhdXNlOiB0cnVlLFxuXG4gICAgbWVkaWFXYWl0aW5nOiB0cnVlLFxuXG4gICAgbWVkaWFQcm9ncmVzczogdHJ1ZSxcblxuICAgIG1lZGlhU2Vla2luZzogdHJ1ZSxcblxuICAgIG1lZGlhU2Vla2VkOiB0cnVlLFxuXG4gICAgbWVkaWFSYXRlQ2hhbmdlOiB0cnVlLFxuXG4gICAgbWVkaWFSZW5kaXRpb25DaGFuZ2U6IHRydWUsXG5cbiAgICBtZWRpYUVuZGVkOiB0cnVlXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9QYXJhbWV0ZXJzL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQYXJhbWV0ZXJzX2RlZmF1bHRzID0gKHtcblxuICAgIGluaXRpYWxpemF0aW9uOiB7XG4gIFwibG10XCI6IDAsXG4gIFwidXNfcHJpdmFjeVwiOiBcIjEtWS1cIixcbiAgXCJkaXNjb3ZlcnlcIjoge1xuICAgIFwibmF2aWdhdGVUb1wiOiB7XG4gICAgICBcImFjdGlvblwiOiBcImVudGl0eVwiLFxuICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgXCJlbnRpdHlJZFwiOiBcImFiY1wiLFxuICAgICAgICBcImVudGl0eVR5cGVcIjogXCJwcm9ncmFtXCIsXG4gICAgICAgIFwicHJvZ3JhbVR5cGVcIjogXCJtb3ZpZVwiXG4gICAgICB9LFxuICAgICAgXCJjb250ZXh0XCI6IHtcbiAgICAgICAgXCJzb3VyY2VcIjogXCJ2b2ljZVwiXG4gICAgICB9XG4gICAgfVxuICB9XG59XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9Qcm9maWxlL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQcm9maWxlX2RlZmF1bHRzID0gKHtcblxuICAgIGFwcHJvdmVDb250ZW50UmF0aW5nOiBmYWxzZSxcblxuICAgIGFwcHJvdmVQdXJjaGFzZTogZmFsc2UsXG5cbiAgICBmbGFnczoge1xuICBcInVzZXJFeHBlcmllbmNlXCI6IFwiMTAwMFwiXG59XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9TZWNvbmRTY3JlZW4vZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNlY29uZFNjcmVlbl9kZWZhdWx0cyA9ICh7XG5cbiAgICBwcm90b2NvbHM6IHtcbiAgXCJkaWFsMS43XCI6IHRydWVcbn0sXG5cbiAgICBkZXZpY2U6IFwiZGV2aWNlLWlkXCIsXG5cbiAgICBmcmllbmRseU5hbWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdzZWNvbmRzY3JlZW4nLCAnZnJpZW5kbHlOYW1lJywgYXJndW1lbnRzLCBcIkxpdmluZyBSb29tXCIpIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1BsYXRmb3JtL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQbGF0Zm9ybV9kZWZhdWx0cyA9ICh7XG4gIGxvY2FsaXphdGlvbjogTG9jYWxpemF0aW9uX2RlZmF1bHRzLFxuICBkZXZpY2U6IERldmljZV9kZWZhdWx0cyxcbiAgYWNjZXNzaWJpbGl0eTogZGVmYXVsdHMsXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9tb2NrLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmxldCBsaXN0ZW5lclxuY29uc3Qgc2V0TW9ja0xpc3RlbmVyID0gZnVuYyA9PiB7IGxpc3RlbmVyID0gZnVuYyB9XG5cbmxldCBtb2NrX21vY2sgPSB7XG4gIGFjY2Vzc2liaWxpdHk6IGRlZmF1bHRzLFxuICBhY2NvdW50OiBBY2NvdW50X2RlZmF1bHRzLFxuICBhZHZlcnRpc2luZzogQWR2ZXJ0aXNpbmdfZGVmYXVsdHMsXG4gIGF1dGhlbnRpY2F0aW9uOiBBdXRoZW50aWNhdGlvbl9kZWZhdWx0cyxcbiAgZGV2aWNlOiBEZXZpY2VfZGVmYXVsdHMsXG4gIGRpc2NvdmVyeTogRGlzY292ZXJ5X2RlZmF1bHRzLFxuICBrZXlib2FyZDogS2V5Ym9hcmRfZGVmYXVsdHMsXG4gIGxpZmVjeWNsZTogTGlmZWN5Y2xlX2RlZmF1bHRzLFxuICBsb2NhbGl6YXRpb246IExvY2FsaXphdGlvbl9kZWZhdWx0cyxcbiAgbWV0cmljczogTWV0cmljc19kZWZhdWx0cyxcbiAgcGFyYW1ldGVyczogUGFyYW1ldGVyc19kZWZhdWx0cyxcbiAgcHJvZmlsZTogUHJvZmlsZV9kZWZhdWx0cyxcbiAgc2Vjb25kc2NyZWVuOiBTZWNvbmRTY3JlZW5fZGVmYXVsdHMsXG4gIHBsYXRmb3JtOiBQbGF0Zm9ybV9kZWZhdWx0cyxcbn1cblxubGV0IGNhbGxiYWNrXG5sZXQgdGVzdEhhcm5lc3NcblxuaWYgKFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdCAmJiBUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQudGVzdEhhcm5lc3MpIHtcbiAgdGVzdEhhcm5lc3MgPSBUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQudGVzdEhhcm5lc3Ncbn1cblxuZnVuY3Rpb24gc2VuZChtZXNzYWdlKSB7XG4gIGxldCBqc29uID0gSlNPTi5wYXJzZShtZXNzYWdlKVxuICBsZXQgW21vZHVsZSwgbWV0aG9kXSA9IGpzb24ubWV0aG9kLnNwbGl0KCcuJylcblxuICBpZiAodGVzdEhhcm5lc3MgJiYgdGVzdEhhcm5lc3Mub25TZW5kKSB7XG4gICAgdGVzdEhhcm5lc3Mub25TZW5kKG1vZHVsZSwgbWV0aG9kLCBqc29uLnBhcmFtcywganNvbi5pZClcbiAgfVxuXG4gIC8vIHN0b3JlIHRoZSBJRCBvZiB0aGUgZmlyc3QgbGlzdGVuIGZvciBlYWNoIGV2ZW50XG4gIC8vIFRPRE86IHdoYXQgYWJvdXQgd2lsZCBjYXJkcz9cbiAgbGV0IHJlc3VsdFxuICB0cnkge1xuICAgIHJlc3VsdCA9IGdldFJlc3VsdChqc29uLm1ldGhvZCwganNvbi5wYXJhbXMpXG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeSh7IFxuICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICBlcnJvcjoge1xuICAgICAgICBjb2RlOiAtMzI2MDIsXG4gICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBwYXJhbXMgKHRoaXMgaXMgYSBtb2NrIGVycm9yIGZyb20gdGhlIG1vY2sgdHJhbnNwb3J0IGxheWVyKVwiXG4gICAgICB9LFxuICAgICAgaWQ6IGpzb24uaWRcbiAgICB9KSkpXG4gIH1cblxuICBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHsgXG4gICAganNvbnJwYzogJzIuMCcsXG4gICAgcmVzdWx0OiByZXN1bHQsXG4gICAgaWQ6IGpzb24uaWRcbiAgfSkpKVxufVxuXG5mdW5jdGlvbiByZWNlaXZlKF9jYWxsYmFjaykge1xuICBjYWxsYmFjayA9IF9jYWxsYmFja1xuXG4gIGlmICh0ZXN0SGFybmVzcyAmJiAodHlwZW9mIHRlc3RIYXJuZXNzLmluaXRpYWxpemUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgdGVzdEhhcm5lc3MuaW5pdGlhbGl6ZSh7XG4gICAgICBlbWl0OiBtb2NrX2V2ZW50LFxuICAgICAgbGlzdGVuOiBmdW5jdGlvbiguLi5hcmdzKSB7IGxpc3RlbmVyKC4uLmFyZ3MpIH0sXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtb2NrX2V2ZW50KG1vZHVsZSwgZXZlbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gT2JqZWN0LmVudHJpZXMoVHJhbnNwb3J0LmdldEV2ZW50TWFwKCkpLmZpbmQoKFtrLCB2XSkgPT4gdi50b0xvd2VyQ2FzZSgpID09PSBtb2R1bGUudG9Mb3dlckNhc2UoKSArICcuJyArIGV2ZW50LnRvTG93ZXJDYXNlKCkpXG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGxldCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICBpZDogbGlzdGVuZXJbMF0sXG4gICAgICByZXN1bHQ6IHZhbHVlXG4gICAgfSlcbiAgICBjYWxsYmFjayhtZXNzYWdlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRvdEdyYWIob2JqID0ge30sIGtleSkge1xuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJylcbiAgbGV0IHJlZiA9IG9ialxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICByZWYgPSByZWZba2V5c1tpXV0gfHwge31cbiAgfVxuICByZXR1cm4gcmVmXG59XG5cbmZ1bmN0aW9uIGdldFJlc3VsdChtZXRob2QsIHBhcmFtcykge1xuICBsZXQgYXBpID0gZG90R3JhYihtb2NrX21vY2ssIG1ldGhvZClcblxuICBpZiAobWV0aG9kLm1hdGNoKC9eW2EtekEtWl0rXFwub25bQS1aYS16XSskLykpIHtcbiAgICBhcGkgPSB7XG4gICAgICBldmVudDogbWV0aG9kLFxuICAgICAgbGlzdGVuaW5nOiB0cnVlXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBhcGkgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFyYW1zID09IG51bGwgPyBhcGkoKSA6IGFwaShwYXJhbXMpXG4gIH0gZWxzZSByZXR1cm4gYXBpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVHJhbnNwb3J0X21vY2sgPSAoe1xuICBzZW5kOiBzZW5kLFxuICByZWNlaXZlOiByZWNlaXZlLFxuICBldmVudDogbW9ja19ldmVudFxufSk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9xdWV1ZS5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5jbGFzcyBRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcbiAgICB0aGlzLl9xdWV1ZSA9IFtdXG4gIH1cblxuICBzZW5kIChqc29uKSB7XG4gICAgdGhpcy5fcXVldWUucHVzaChqc29uKVxuICB9XG5cbiAgcmVjZWl2ZSAoX2NhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBfY2FsbGJhY2tcbiAgfVxuXG4gIGZsdXNoICh0cmFuc3BvcnQpIHtcbiAgICB0cmFuc3BvcnQucmVjZWl2ZSh0aGlzLl9jYWxsYmFjaylcbiAgICB0aGlzLl9xdWV1ZS5mb3JFYWNoKGl0ZW0gPT4gdHJhbnNwb3J0LnNlbmQoaXRlbSkpXG4gIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1NldHRpbmdzL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmNvbnN0IHNldHRpbmdzID0ge31cbmNvbnN0IHN1YnNjcmliZXJzID0ge31cblxuY29uc3QgaW5pdFNldHRpbmdzID0gKGFwcFNldHRpbmdzLCBwbGF0Zm9ybVNldHRpbmdzKSA9PiB7XG4gIHNldHRpbmdzWydhcHAnXSA9IGFwcFNldHRpbmdzXG4gIHNldHRpbmdzWydwbGF0Zm9ybSddID0ge1xuICAgIGxvZ0xldmVsOiAnV0FSTicsXG4gICAgLi4ucGxhdGZvcm1TZXR0aW5nc1xuICB9XG4gIHNldHRpbmdzWyd1c2VyJ10gPSB7fVxufVxuXG5jb25zdCBwdWJsaXNoID0gKGtleSwgdmFsdWUpID0+IHtcbiAgc3Vic2NyaWJlcnNba2V5XSAmJiBzdWJzY3JpYmVyc1trZXldLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKHZhbHVlKSlcbn1cblxuY29uc3QgU2V0dGluZ3NfZG90R3JhYiA9IChvYmogPSB7fSwga2V5KSA9PiB7XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBvYmogPSBvYmpba2V5c1tpXV0gPSBvYmpba2V5c1tpXV0gIT09IHVuZGVmaW5lZCA/IG9ialtrZXlzW2ldXSA6IHt9XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnID8gKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID8gb2JqIDogdW5kZWZpbmVkKSA6IG9ialxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNldHRpbmdzID0gKHtcbiAgZ2V0KHR5cGUsIGtleSwgZmFsbGJhY2sgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB2YWwgPSBTZXR0aW5nc19kb3RHcmFiKHNldHRpbmdzW3R5cGVdLCBrZXkpXG4gICAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogZmFsbGJhY2tcbiAgfSxcbiAgaGFzKHR5cGUsIGtleSkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0KHR5cGUsIGtleSlcbiAgfSxcbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBzZXR0aW5nc1sndXNlciddW2tleV0gPSB2YWx1ZVxuICAgIHB1Ymxpc2goa2V5LCB2YWx1ZSlcbiAgfSxcbiAgc3Vic2NyaWJlKGtleSwgY2FsbGJhY2spIHtcbiAgICBzdWJzY3JpYmVyc1trZXldID0gc3Vic2NyaWJlcnNba2V5XSB8fCBbXVxuICAgIHN1YnNjcmliZXJzW2tleV0ucHVzaChjYWxsYmFjaylcbiAgfSxcbiAgdW5zdWJzY3JpYmUoa2V5LCBjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY29uc3QgaW5kZXggPSBzdWJzY3JpYmVyc1trZXldICYmIHN1YnNjcmliZXJzW2tleV0uZmluZEluZGV4KGNiID0+IGNiID09PSBjYWxsYmFjaylcbiAgICAgIGluZGV4ID4gLTEgJiYgc3Vic2NyaWJlcnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrZXkgaW4gc3Vic2NyaWJlcnMpIHtcbiAgICAgICAgc3Vic2NyaWJlcnNba2V5XSA9IFtdXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjbGVhclN1YnNjcmliZXJzKCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN1YnNjcmliZXJzKSkge1xuICAgICAgZGVsZXRlIHN1YnNjcmliZXJzW2tleV1cbiAgICB9XG4gIH0sXG4gIHNldExvZ0xldmVsIChsb2dMZXZlbCkge1xuICAgIHNldHRpbmdzLnBsYXRmb3JtLmxvZ0xldmVsID0gbG9nTGV2ZWxcbiAgfSxcbiAgZ2V0TG9nTGV2ZWwgKCkge1xuICAgIHJldHVybiBzZXR0aW5ncy5wbGF0Zm9ybS5sb2dMZXZlbFxuICB9XG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9MZWdhY3lUcmFuc3BvcnQuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuY2xhc3MgTGVnYWN5VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3IgKGJyaWRnZSkge1xuICAgIHRoaXMuYnJpZGdlID0gYnJpZGdlXG4gIH1cblxuICBzZW5kIChtc2cpIHtcbiAgICB0aGlzLmJyaWRnZS5KU01lc3NhZ2VDaGFuZ2VkKG1zZywgKCkgPT4ge30pXG4gIH1cblxuICByZWNlaXZlIChjYWxsYmFjaykge1xuICAgIHdpbmRvdy4kYmFkZ2VyID0gd2luZG93LiRiYWRnZXIgfHwge31cbiAgICAvKiogSG9sZCBvbiB0byByZWFsICRiYWRnZXIgY2FsbGJhY2sgYW5kIGV2ZW50IG1ldGhvZHMgc28gdGhleSBjYW4gYmUgY2FsbGVkIGZvciBub24tanNvbnJwYyBtZXNzYWdlcyAqL1xuICAgIGNvbnN0IGJhZGdlckNhbGxiYWNrID0gd2luZG93LiRiYWRnZXIuY2FsbGJhY2sgPyB3aW5kb3cuJGJhZGdlci5jYWxsYmFjay5iaW5kKHdpbmRvdy4kYmFkZ2VyKSA6IG51bGxcbiAgICBjb25zdCBiYWRnZXJFdmVudCA9IHdpbmRvdy4kYmFkZ2VyLmV2ZW50ID8gd2luZG93LiRiYWRnZXIuZXZlbnQuYmluZCh3aW5kb3cuJGJhZGdlcikgOiBudWxsXG4gICAgd2luZG93LiRiYWRnZXIuY2FsbGJhY2sgPSAocGlkLCBzdWNjZXNzLCBqc29uKSA9PiB7XG4gICAgICBpZiAoanNvbi5qc29ucnBjKSB7XG4gICAgICAgIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KGpzb24pKVxuICAgICAgfSBlbHNlIGlmIChiYWRnZXJDYWxsYmFjaykge1xuICAgICAgICBiYWRnZXJDYWxsYmFjayhwaWQsIHN1Y2Nlc3MsIGpzb24pXG4gICAgICB9XG4gICAgfVxuICAgIHdpbmRvdy4kYmFkZ2VyLmV2ZW50ID0gKGhhbmRsZXJJZCwganNvbikgPT4ge1xuICAgICAgaWYgKGpzb24uanNvbnJwYykge1xuICAgICAgICBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShqc29uKSlcbiAgICAgIH0gZWxzZSBpZiAoYmFkZ2VyRXZlbnQpIHtcbiAgICAgICAgYmFkZ2VyRXZlbnQoaGFuZGxlcklkLCBqc29uKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBpc0xlZ2FjeSAodHJhbnNwb3J0KSB7XG4gICAgcmV0dXJuIExlZ2FjeVRyYW5zcG9ydC5pc1hSRVByb3h5KHRyYW5zcG9ydCkgfHwgKCh0cmFuc3BvcnQuc2VuZCA9PT0gdW5kZWZpbmVkKSAmJiAodHJhbnNwb3J0LkpTTWVzc2FnZUNoYW5nZWQpKVxuICB9XG5cbiAgc3RhdGljIGlzWFJFUHJveHkgKHRyYW5zcG9ydCkge1xuICAgIC8qKiBTZXQgdG9wIGJveGVzIHJ1bm5pbmcgWFJFIGhhcyBhIFwiUHJveHlcIiB0cmFuc3BvcnRcbiAgICAgKiBuYXRpdmUgb2JqZWN0IHRoYXQgaW50ZXJjZXB0cyBBTEwgbWV0aG9kIGNhbGxzLCBzbyB3ZVxuICAgICAqIGNhbm5vdCB0ZXN0IGZvciB0cmFuc3BvcnQuc2VuZCBleGlzdGVuY2UgYmVjYXVzZSBpdCB3aWxsIHJldHVybiB0cnVlXG4gICAgICogZXZlbiB0aG91Z2ggaXQgYWN0dWFsbHkgaXMgbm90IHN1cHBvcnRlZC4gQ2hlY2sgaWYgc29tZSBvYnNjdXJlIG1ldGhvZFxuICAgICAqIG5hbWUgbGlrZSBcInByb3h5T2JqZWN0VGVzdFwiIGlzIGRlZmluZWQuIElmIGl0IGlzIHRoZW4gd2Uga25vdyB3ZSBhcmUgdXNpbmcgYVxuICAgICAqIFByb3h5IG9iamVjdCBhbmQgdGh1cyBpcyBsZWdhY3kgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIHJldHVybiB0cmFuc3BvcnQucHJveHlPYmplY3RUZXN0ICE9PSB1bmRlZmluZWRcbiAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvVHJhbnNwb3J0L1dlYnNvY2tldFRyYW5zcG9ydC5qc1xuY29uc3QgTUFYX1FVRVVFRF9NRVNTQUdFUyA9IDEwMFxuXG5jbGFzcyBXZWJzb2NrZXRUcmFuc3BvcnQge1xuICBjb25zdHJ1Y3RvciAoZW5kcG9pbnQpIHtcbiAgICB0aGlzLl9lbmRwb2ludCA9IGVuZHBvaW50XG4gICAgdGhpcy5fd3MgPSBudWxsXG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLl9xdWV1ZSA9IFtdXG4gICAgdGhpcy5fY2FsbGJhY2tzID0gW11cbiAgfVxuXG4gIHNlbmQgKG1zZykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKVxuXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fd3Muc2VuZChtc2cpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPCBNQVhfUVVFVUVEX01FU1NBR0VTKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2gobXNnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlY2VpdmUgKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuXG4gICAgdGhpcy5fY29ubmVjdCgpXG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG4gIH1cblxuICBfbm90aWZ5Q2FsbGJhY2tzIChtZXNzYWdlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fY2FsbGJhY2tzW2ldKG1lc3NhZ2UpLCAxKVxuICAgIH1cbiAgfVxuXG4gIF9jb25uZWN0ICgpIHtcbiAgICBpZiAodGhpcy5fd3MpIHJldHVyblxuICAgIHRoaXMuX3dzID0gbmV3IFdlYlNvY2tldCh0aGlzLl9lbmRwb2ludClcbiAgICB0aGlzLl93cy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbWVzc2FnZSA9PiB7XG4gICAgICB0aGlzLl9ub3RpZnlDYWxsYmFja3MobWVzc2FnZS5kYXRhKVxuICAgIH0pXG4gICAgdGhpcy5fd3MuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBtZXNzYWdlID0+IHtcbiAgICB9KVxuICAgIHRoaXMuX3dzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbWVzc2FnZSA9PiB7XG4gICAgICB0aGlzLl93cyA9IG51bGxcbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgfSlcbiAgICB0aGlzLl93cy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgbWVzc2FnZSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3dzLnNlbmQodGhpcy5fcXVldWVbaV0pXG4gICAgICB9XG4gICAgICB0aGlzLl9xdWV1ZSA9IFtdXG4gICAgfSlcbiAgfVxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuXG5cbmNvbnN0IExFR0FDWV9UUkFOU1BPUlRfU0VSVklDRV9OQU1FID0gJ2NvbS5jb21jYXN0LkJyaWRnZU9iamVjdF8xJ1xubGV0IG1vZHVsZUluc3RhbmNlID0gbnVsbFxuXG5jb25zdCBpc0V2ZW50U3VjY2VzcyA9IHggPT4geCAmJiAodHlwZW9mIHguZXZlbnQgPT09ICdzdHJpbmcnKSAmJiAodHlwZW9mIHgubGlzdGVuaW5nID09PSAnYm9vbGVhbicpXG5cbmNsYXNzIFRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9wcm9taXNlcyA9IFtdXG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbFxuICAgIHRoaXMuX2lkID0gMVxuICAgIHRoaXMuX2V2ZW50RW1pdHRlcnMgPSBbXVxuICAgIHRoaXMuX2V2ZW50TWFwID0ge31cbiAgICB0aGlzLl9xdWV1ZSA9IG5ldyBRdWV1ZSgpXG4gICAgdGhpcy5fZGVwcmVjYXRlZCA9IHt9XG4gICAgdGhpcy5pc01vY2sgPSBmYWxzZVxuICB9XG5cbiAgc3RhdGljIGFkZEV2ZW50RW1pdHRlciAoZW1pdHRlcikge1xuICAgIFRyYW5zcG9ydC5nZXQoKS5fZXZlbnRFbWl0dGVycy5wdXNoKGVtaXR0ZXIpXG4gIH1cblxuICBzdGF0aWMgcmVnaXN0ZXJEZXByZWNhdGVkTWV0aG9kIChtb2R1bGUsIG1ldGhvZCwgYWx0ZXJuYXRpdmUpIHtcbiAgICBUcmFuc3BvcnQuZ2V0KCkuX2RlcHJlY2F0ZWRbbW9kdWxlLnRvTG93ZXJDYXNlKCkgKyAnLicgKyBtZXRob2QudG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICBhbHRlcm5hdGl2ZTogYWx0ZXJuYXRpdmUgfHwgJydcbiAgICB9XG4gIH1cblxuICBfZW5kcG9pbnQgKCkge1xuICAgIGlmIChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQgJiYgVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LmVuZHBvaW50KSB7XG4gICAgICByZXR1cm4gVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LmVuZHBvaW50XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdHJ1Y3RUcmFuc3BvcnRMYXllciAoKSB7XG4gICAgbGV0IHRyYW5zcG9ydFxuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5fZW5kcG9pbnQoKVxuICAgIGlmIChlbmRwb2ludCAmJiAoZW5kcG9pbnQuc3RhcnRzV2l0aCgnd3M6Ly8nKSB8fCBlbmRwb2ludC5zdGFydHNXaXRoKCd3c3M6Ly8nKSkpIHtcbiAgICAgIHRyYW5zcG9ydCA9IG5ldyBXZWJzb2NrZXRUcmFuc3BvcnQoZW5kcG9pbnQpXG4gICAgICB0cmFuc3BvcnQucmVjZWl2ZSh0aGlzLnJlY2VpdmVIYW5kbGVyLmJpbmQodGhpcykpXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHR5cGVvZiBUcmFuc3BvcnRfZ2xvYmFsLlNlcnZpY2VNYW5hZ2VyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgVHJhbnNwb3J0X2dsb2JhbC5TZXJ2aWNlTWFuYWdlciAmJlxuICAgICAgVHJhbnNwb3J0X2dsb2JhbC5TZXJ2aWNlTWFuYWdlci52ZXJzaW9uXG4gICAgKSB7XG4gICAgICAvLyBXaXJlIHVwIHRoZSBxdWV1ZVxuICAgICAgdHJhbnNwb3J0ID0gdGhpcy5fcXVldWVcbiAgICAgIC8vIGdldCB0aGUgZGVmYXVsdCBicmlkZ2Ugc2VydmljZSwgYW5kIGZsdXNoIHRoZSBxdWV1ZVxuICAgICAgVHJhbnNwb3J0X2dsb2JhbC5TZXJ2aWNlTWFuYWdlci5nZXRTZXJ2aWNlRm9ySmF2YVNjcmlwdChMRUdBQ1lfVFJBTlNQT1JUX1NFUlZJQ0VfTkFNRSwgc2VydmljZSA9PiB7XG4gICAgICAgIGlmIChMZWdhY3lUcmFuc3BvcnQuaXNMZWdhY3koc2VydmljZSkpIHtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBuZXcgTGVnYWN5VHJhbnNwb3J0KHNlcnZpY2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gc2VydmljZVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0TGF5ZXIodHJhbnNwb3J0KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc01vY2sgPSB0cnVlXG4gICAgICB0cmFuc3BvcnQgPSBUcmFuc3BvcnRfbW9ja1xuICAgICAgdHJhbnNwb3J0LnJlY2VpdmUodGhpcy5yZWNlaXZlSGFuZGxlci5iaW5kKHRoaXMpKVxuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0XG4gIH1cblxuICBzZXRUcmFuc3BvcnRMYXllciAodGwpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0bFxuICAgIHRoaXMuX3F1ZXVlLmZsdXNoKHRsKVxuICB9XG5cbiAgc3RhdGljIHNlbmQgKG1vZHVsZSwgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICAvKiogVHJhbnNwb3J0IHNpbmdsZXRvbiBhY3Jvc3MgYWxsIFNES3MgdG8ga2VlcCBzaW5nbGUgaWQgbWFwICovXG4gICAgcmV0dXJuIFRyYW5zcG9ydC5nZXQoKS5fc2VuZChtb2R1bGUsIG1ldGhvZCwgcGFyYW1zKVxuICB9XG5cbiAgX3NlbmQgKG1vZHVsZSwgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcHJvbWlzZXNbdGhpcy5faWRdID0ge31cbiAgICAgIHRoaXMuX3Byb21pc2VzW3RoaXMuX2lkXS5wcm9taXNlID0gdGhpc1xuICAgICAgdGhpcy5fcHJvbWlzZXNbdGhpcy5faWRdLnJlc29sdmUgPSByZXNvbHZlXG4gICAgICB0aGlzLl9wcm9taXNlc1t0aGlzLl9pZF0ucmVqZWN0ID0gcmVqZWN0XG5cbiAgICAgIGNvbnN0IGRlcHJlY2F0ZWQgPSB0aGlzLl9kZXByZWNhdGVkW21vZHVsZS50b0xvd2VyQ2FzZSgpICsgJy4nICsgbWV0aG9kLnRvTG93ZXJDYXNlKCldXG4gICAgICBpZiAoZGVwcmVjYXRlZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6ICR7bW9kdWxlfS4ke21ldGhvZH0oKSBpcyBkZXByZWNhdGVkLiBgICsgZGVwcmVjYXRlZC5hbHRlcm5hdGl2ZSlcbiAgICAgIH1cblxuICAgICAgLy8gc3RvcmUgdGhlIElEIG9mIHRoZSBmaXJzdCBsaXN0ZW4gZm9yIGVhY2ggZXZlbnRcbiAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgd2lsZCBjYXJkcz9cbiAgICAgIGlmIChtZXRob2QubWF0Y2goL15vbltBLVpdLykpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5saXN0ZW4pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudE1hcFt0aGlzLl9pZF0gPSBtb2R1bGUudG9Mb3dlckNhc2UoKSArICcuJyArIG1ldGhvZFsyXS50b0xvd2VyQ2FzZSgpICsgbWV0aG9kLnN1YnN0cigzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2V2ZW50TWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRNYXBba2V5XSA9PT0gbW9kdWxlLnRvTG93ZXJDYXNlKCkgKyAnLicgKyBtZXRob2RbMl0udG9Mb3dlckNhc2UoKSArIG1ldGhvZC5zdWJzdHIoMykpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IGpzb24gPSB7IGpzb25ycGM6ICcyLjAnLCBtZXRob2Q6IG1vZHVsZSArICcuJyArIG1ldGhvZCwgcGFyYW1zOiBwYXJhbXMsIGlkOiB0aGlzLl9pZCB9XG4gICAgdGhpcy5faWQrK1xuXG4gICAgY29uc3QgbXNnID0gSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICBpZiAoU2V0dGluZ3MuZ2V0TG9nTGV2ZWwoKSA9PT0gJ0RFQlVHJykge1xuICAgICAgY29uc29sZS5kZWJ1ZygnU2VuZGluZyBtZXNzYWdlIHRvIHRyYW5zcG9ydDogJyArIG1zZylcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNwb3J0LnNlbmQobXNnKVxuXG4gICAgcmV0dXJuIHBcbiAgfVxuXG4gIHN0YXRpYyBnZXRFdmVudE1hcCAoKSB7XG4gICAgcmV0dXJuIFRyYW5zcG9ydC5nZXQoKS5fZXZlbnRNYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB3ZSBoYXZlIGEgZ2xvYmFsIHRyYW5zcG9ydCwgdXNlIHRoYXQuIE90aGVyd2lzZSwgdXNlIHRoZSBtb2R1bGUtc2NvcGVkIHRyYW5zcG9ydCBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge1RyYW5zcG9ydH1cbiAgICovXG4gIHN0YXRpYyBnZXQgKCkge1xuICAgIHJldHVybiBUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQudHJhbnNwb3J0ID8gVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LnRyYW5zcG9ydCA6IG1vZHVsZUluc3RhbmNlXG4gIH1cblxuICByZWNlaXZlSGFuZGxlciAobWVzc2FnZSkge1xuICAgIGlmIChTZXR0aW5ncy5nZXRMb2dMZXZlbCgpID09PSAnREVCVUcnKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gdHJhbnNwb3J0OiAnICsgbWVzc2FnZSlcbiAgICB9XG4gICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UobWVzc2FnZSlcbiAgICBjb25zdCBwID0gdGhpcy5fcHJvbWlzZXNbanNvbi5pZF1cblxuICAgIGlmIChwKSB7XG4gICAgICBpZiAoanNvbi5lcnJvcikgcC5yZWplY3QoanNvbi5lcnJvcilcbiAgICAgIGVsc2Uge1xuICAgICAgICBwLnJlc29sdmUoanNvbi5yZXN1bHQpXG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5fcHJvbWlzZXNbanNvbi5pZF1cbiAgICB9XG5cbiAgICAvLyBldmVudCByZXNwb25zZXMgbmVlZCB0byBiZSBlbWl0dGVkLCBldmVuIGFmdGVyIHRoZSBsaXN0ZW4gY2FsbCBpcyByZXNvbHZlZFxuICAgIGlmICh0aGlzLl9ldmVudE1hcFtqc29uLmlkXSAmJiAhaXNFdmVudFN1Y2Nlc3MoanNvbi5yZXN1bHQpKSB7XG4gICAgICBjb25zdCBtb2R1bGVldmVudCA9IHRoaXMuX2V2ZW50TWFwW2pzb24uaWRdXG4gICAgICBpZiAobW9kdWxlZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVycy5mb3JFYWNoKGVtaXQgPT4ge1xuICAgICAgICAgIGVtaXQobW9kdWxlZXZlbnQuc3BsaXQoJy4nKVswXSwgbW9kdWxlZXZlbnQuc3BsaXQoJy4nKVsxXSwganNvbi5yZXN1bHQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5pdCAoKSB7XG4gICAgaW5pdFNldHRpbmdzKHt9LCB7IGxvZzogdHJ1ZSB9KVxuICAgIHRoaXMuX3F1ZXVlLnJlY2VpdmUodGhpcy5yZWNlaXZlSGFuZGxlci5iaW5kKHRoaXMpKVxuICAgIGlmIChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQpIHtcbiAgICAgIGlmIChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQubW9ja1RyYW5zcG9ydExheWVyID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaXNNb2NrID0gdHJ1ZVxuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydExheWVyKFRyYW5zcG9ydF9tb2NrKVxuICAgICAgfSBlbHNlIGlmIChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQuZ2V0VHJhbnNwb3J0TGF5ZXIpIHtcbiAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnRMYXllcihUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQuZ2V0VHJhbnNwb3J0TGF5ZXIoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydCA9PSBudWxsKSB7XG4gICAgICB0aGlzLl90cmFuc3BvcnQgPSB0aGlzLmNvbnN0cnVjdFRyYW5zcG9ydExheWVyKClcbiAgICB9XG4gIH1cbn1cblxuLyoqIFNldCB1cCBzaW5nbGV0b24gYW5kIGluaXRpYWxpemUgaXQgKi9cblRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdCA9IFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdCB8fCB7fVxuaWYgKChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQudHJhbnNwb3J0ID09IG51bGwpICYmIChtb2R1bGVJbnN0YW5jZSA9PSBudWxsKSkge1xuICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0KClcbiAgdHJhbnNwb3J0LmluaXQoKVxuICBpZiAodHJhbnNwb3J0LmlzTW9jaykge1xuICAgIC8qKiBXZSBzaG91bGQgdXNlIHRoZSBtb2NrIHRyYW5zcG9ydCBidWlsdCB3aXRoIHRoZSBTREssIG5vdCBhIGdsb2JhbCAqL1xuICAgIG1vZHVsZUluc3RhbmNlID0gdHJhbnNwb3J0XG4gIH0gZWxzZSB7XG4gICAgVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0ID0gVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0IHx8IHt9XG4gICAgVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LnRyYW5zcG9ydCA9IHRyYW5zcG9ydFxuICB9XG4gIFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdC5zZXRUcmFuc3BvcnRMYXllciA9IHRyYW5zcG9ydC5zZXRUcmFuc3BvcnRMYXllci5iaW5kKHRyYW5zcG9ydClcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0V2ZW50cy9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5sZXQgbGlzdGVuZXJJZCA9IDBcblxuLy8gaG9sZHMgYSBtYXAgb2YgJHttb2R1bGV9LiR7ZXZlbnR9ID0+IGxpc3RlbmVySWQsIGUuZy4gY2FsbGJhY2sgbWV0aG9kIGlkXG4vLyBub3RlIHRoYXQgb25lIGNhbGxiYWNrIGNhbiBsaXN0ZW4gdG8gbXVsdGlwbGUgZXZlbnRzLCBlLmcuICdkaXNjb3ZlcnkuKidcbmNvbnN0IGxpc3RlbmVycyA9IHt9XG5cbi8vIGhvbGRzIGEgbWFwIG9mICR7bW9kdWxlfS4ke2V2ZW50fSA9PiBUcmFuc3BvcnQuc2VuZCBjYWxscyAob25seSBjYWxsZWQgb25jZSBwZXIgZXZlbnQpXG4vLyBub3RlIHRoYXQgdGhlIGtleXMgaGVyZSBNVVNUIE5PVCBjb250YWluIHdpbGQgY2FyZHNcbmNvbnN0IGVuYWJsZWRFdmVudHMgPSB7fVxuXG5jb25zdCBvbmNlcnMgPSBbXVxuY29uc3QgdmFsaWRFdmVudHMgPSB7fVxubGV0IHRyYW5zcG9ydEluaXRpYWxpemVkID0gZmFsc2VcblxuY29uc3QgRXZlbnRzX2VtaXQgPSAobW9kdWxlLCBldmVudCwgdmFsdWUpID0+IHtcbiAgY2FsbENhbGxiYWNrcyhsaXN0ZW5lcnNbbW9kdWxlICsgJy4qJ10sIFtldmVudCwgdmFsdWVdKVxuICBjYWxsQ2FsbGJhY2tzKGxpc3RlbmVyc1ttb2R1bGUgKyAnLicgKyBldmVudF0sIFt2YWx1ZV0pXG59XG5cbmNvbnN0IHJlZ2lzdGVyRXZlbnRzID0gKG1vZHVsZSwgZXZlbnRzKSA9PiB7XG4gIHZhbGlkRXZlbnRzW21vZHVsZS50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50cy5jb25jYXQoKVxufVxuXG5jb25zdCBjYWxsQ2FsbGJhY2tzID0gKGNicywgYXJncykgPT4ge1xuICBjYnMgJiZcbiAgICBPYmplY3Qua2V5cyhjYnMpLmZvckVhY2gobGlzdGVuZXJJZCA9PiB7XG4gICAgICBsZXQgY2FsbGJhY2sgPSBjYnNbbGlzdGVuZXJJZF1cbiAgICAgIGlmIChvbmNlcnMuaW5kZXhPZihwYXJzZUludChsaXN0ZW5lcklkKSkgPj0gMCkge1xuICAgICAgICBvbmNlcnMuc3BsaWNlKG9uY2Vycy5pbmRleE9mKHBhcnNlSW50KGxpc3RlbmVySWQpKSwgMSlcbiAgICAgICAgZGVsZXRlIGNic1tsaXN0ZW5lcklkXVxuICAgICAgfVxuICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncylcbiAgICB9KVxufVxuXG5jb25zdCBkb0xpc3RlbiA9IGZ1bmN0aW9uKG1vZHVsZSwgZXZlbnQsIGNhbGxiYWNrLCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05vIHZhbGlkIGNhbGxiYWNrIGZ1bmN0aW9uIHByb3ZpZGVkLicpXG4gIH0gZWxzZSB7XG4gICAgaWYgKG1vZHVsZSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05vIHZhbGlkIG1vZHVsZSBuYW1lIHByb3ZpZGVkJylcbiAgICB9XG5cbiAgICBsZXQgZXZlbnRzID0gKGV2ZW50ID09PSAnKicgPyB2YWxpZEV2ZW50c1ttb2R1bGVdIDogW2V2ZW50XSkgLy8gZXhwbG9kZXMgd2lsZGNhcmRzIGludG8gYW4gYXJyYXlcbiAgICBsZXQgcHJvbWlzZXMgPSBbXVxuICAgIGNvbnN0IGtleSA9IG1vZHVsZSArICcuJyArIGV2ZW50IC8vIHRoaXMgbWlnaHQgYmUgYSB3aWxkY2FyZCwgZS5nLiAnbGlmZWN5Y2xlLionXG4gICAgbGlzdGVuZXJJZCsrXG4gICAgbGlzdGVuZXJzW2tleV0gPSBsaXN0ZW5lcnNba2V5XSB8fCB7fVxuICAgIGxpc3RlbmVyc1trZXldWycnK2xpc3RlbmVySWRdID0gY2FsbGJhY2tcblxuICAgIGlmIChvbmNlKSB7XG4gICAgICBvbmNlcnMucHVzaChsaXN0ZW5lcklkKVxuICAgIH1cblxuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIC8vIENoZWNrIGVhY2ggZXZlbnQsIGFuZCBvbmx5IHR1cm4gb24gZXZlbnRzIChub3Qgd2lsZGNhcmRzKSB0aGF0IGFyZSBvZmZcbiAgICAgIGlmICghZW5hYmxlZEV2ZW50c1ttb2R1bGUgKyAnLicgKyBldmVudF0pIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICBUcmFuc3BvcnQuc2VuZChtb2R1bGUsICdvbicgKyBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc3Vic3RyKDEpLCB7IGxpc3RlbjogdHJ1ZSB9KVxuICAgICAgICApXG4gICAgICAgIGVuYWJsZWRFdmVudHNbbW9kdWxlICsgJy4nICsgZXZlbnRdID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0XG4gICAgbGV0IHAgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHJlc29sdmUgPSByZXNcbiAgICAgIHJlamVjdCA9IHJlalxuICAgIH0pXG5cbiAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihyZXNwb25zZXMgPT4ge1xuICAgICAgICByZXNvbHZlKGxpc3RlbmVySWQpXG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIC8vIFByb21pc2UuYWxsIHJlamVjdHMgaWYgYXQgbGVhc3Qgb25lIHByb21pc2UgcmVqZWN0cy4uLiB3ZSBkb24ndCB3YW50IHRoYXQgYmVoYXZpb3IgaGVyZVxuICAgICAgICAvLyBUT0RPOiBEbyBzb21ldGhpbmcgYmV0dGVyIHRoYW4gZmFpbCBzaWxlbnRseVxuICAgICAgICBpZiAoZXZlbnQgPT09ICcqJykge1xuICAgICAgICAgIHJlc29sdmUobGlzdGVuZXJJZClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzb2x2ZShsaXN0ZW5lcklkKVxuICAgIH1cblxuICAgIHJldHVybiBwXG4gIH1cbn1cblxuY29uc3QgZ2V0TGlzdGVuQXJncyA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgY29uc3QgY2FsbGJhY2sgPSBhcmdzLnBvcCgpXG4gIGNvbnN0IG1vZHVsZSA9IGFyZ3NbMF0udG9Mb3dlckNhc2UoKSB8fCAnKidcbiAgY29uc3QgZXZlbnQgPSBhcmdzWzFdIHx8ICcqJ1xuICByZXR1cm4gW21vZHVsZSwgZXZlbnQsIGNhbGxiYWNrXVxufVxuXG5jb25zdCBvbmNlID0gZnVuY3Rpb24oLi4uYXJncykge1xuICBjb25zdCBbbW9kdWxlLCBldmVudCwgY2FsbGJhY2tdID0gZ2V0TGlzdGVuQXJncyguLi5hcmdzKVxuICByZXR1cm4gZG9MaXN0ZW4obW9kdWxlLCBldmVudCwgY2FsbGJhY2ssIHRydWUpXG59XG5cbmNvbnN0IGxpc3RlbiA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgaW5pdCgpXG4gIGNvbnN0IFttb2R1bGUsIGV2ZW50LCBjYWxsYmFja10gPSBnZXRMaXN0ZW5BcmdzKC4uLmFyZ3MpXG4gIHJldHVybiBkb0xpc3Rlbihtb2R1bGUsIGV2ZW50LCBjYWxsYmFjaywgZmFsc2UpXG59XG5cbmNvbnN0IGluaXQgPSAoKSA9PiB7XG4gIGlmICghdHJhbnNwb3J0SW5pdGlhbGl6ZWQpIHtcbiAgICBUcmFuc3BvcnQuYWRkRXZlbnRFbWl0dGVyKEV2ZW50c19lbWl0KVxuICAgIHNldE1vY2tMaXN0ZW5lcihsaXN0ZW4pXG4gICAgdHJhbnNwb3J0SW5pdGlhbGl6ZWQgPSB0cnVlXG4gIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBFdmVudHMgPSAoe1xuICBsaXN0ZW46IGxpc3RlbixcbiAgb25jZTogb25jZSxcbiAgLy8gVE9ETzogY2xlYXIgbmVlZHMgdG8gZ28gdGhyb3VnaCBUcmFuc3BvcnQgTGF5ZXJcbiAgY2xlYXIobW9kdWxlT3JJZCA9IGZhbHNlLCBldmVudCA9IGZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVPcklkID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3Qgc2VhcmNoSWQgPSBtb2R1bGVPcklkLnRvU3RyaW5nKClcbiAgICAgIE9iamVjdC5rZXlzKGxpc3RlbmVycykuZXZlcnkoa2V5ID0+IHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1trZXldW3NlYXJjaElkXSkge1xuICAgICAgICAgIC8vIGRlbGV0ZSBjYWxsYmFja1xuICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNba2V5XVtzZWFyY2hJZF1cbiAgICAgICAgICAvLyBkZWxldGUgdGhlIHdob2xlIG5hbWVzcGFjZSBpZiBpdCB3YXMgdGhlIG9ubHkgY2FsbGJhY2tcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobGlzdGVuZXJzW2tleV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1trZXldXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW1vZHVsZU9ySWQgJiYgIWV2ZW50KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGxpc3RlbmVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNba2V5XVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghZXZlbnQpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobGlzdGVuZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgaWYgKGtleS5pbmRleE9mKG1vZHVsZU9ySWQudG9Mb3dlckNhc2UoKSkgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNba2V5XVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbbW9kdWxlT3JJZCArICcuJyArIGV2ZW50XVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYnJvYWRjYXN0KGV2ZW50LCB2YWx1ZSkge1xuICAgIEV2ZW50c19lbWl0KCdhcHAnLCBldmVudCwgdmFsdWUpXG4gIH0sXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1Byb3AvaW5kZXguanNcblxuXG5cbmZ1bmN0aW9uIHByb3AobW9kdWxlTmFtZSwga2V5LCBhcmdzLCBpbW11dGFibGUsIHJlYWRvbmx5KSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGdldHRlclxuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZChtb2R1bGVOYW1lLCBrZXkpXG4gIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBzdWJzY3JpYmVcbiAgICBpZiAoaW1tdXRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdWJzY3JpYmUgdG8gYW4gaW1tdXRhYmxlIHByb3BlcnR5JylcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50cy5saXN0ZW4obW9kdWxlTmFtZSwga2V5ICsgJ0NoYW5nZWQnLCBhcmdzWzBdKVxuICB9IGVsc2Uge1xuICAgIC8vIHNldHRlclxuICAgIGlmIChpbW11dGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBhIHZhbHVlIHRvIGFuIGltbXV0YWJsZSBwcm9wZXJ0eScpXG4gICAgfVxuICAgIGlmIChyZWFkb25seSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IGEgdmFsdWUgdG8gYSByZWFkb25seSBwcm9wZXJ0eScpXG4gICAgfVxuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZChtb2R1bGVOYW1lLCBrZXksIHtcbiAgICAgIHZhbHVlOiBhcmdzWzBdXG4gICAgfSlcbiAgfVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFByb3AgPSAoe1xuICBwcm9wOiBwcm9wXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9BY2Nlc3NpYmlsaXR5L2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdBY2Nlc3NpYmlsaXR5JywgT2JqZWN0LnZhbHVlcyhbXCJjbG9zZWRDYXB0aW9uc1NldHRpbmdzQ2hhbmdlZFwiLFwidm9pY2VHdWlkYW5jZVNldHRpbmdzQ2hhbmdlZFwiXSkpXG5cblRyYW5zcG9ydC5yZWdpc3RlckRlcHJlY2F0ZWRNZXRob2QoJ0FjY2Vzc2liaWxpdHknLCAnY2xvc2VkQ2FwdGlvbnMnLCAnVXNlIEFjY2Vzc2liaWxpdHkuY2xvc2VkQ2FwdGlvbnNTZXR0aW5ncygpIGluc3RlYWQuJylcblRyYW5zcG9ydC5yZWdpc3RlckRlcHJlY2F0ZWRNZXRob2QoJ0FjY2Vzc2liaWxpdHknLCAndm9pY2VHdWlkYW5jZScsICdVc2UgQWNjZXNzaWJpbGl0eS52b2ljZUd1aWRhbmNlU2V0dGluZ3MoKSBpbnN0ZWFkLicpXG5cblxuZnVuY3Rpb24gY2xvc2VkQ2FwdGlvbnMoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnYWNjZXNzaWJpbGl0eScsICdjbG9zZWRDYXB0aW9ucycsIHsgIH0pXG59XG5mdW5jdGlvbiBjbG9zZWRDYXB0aW9uc1NldHRpbmdzKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdhY2Nlc3NpYmlsaXR5JywgICdjbG9zZWRDYXB0aW9uc1NldHRpbmdzJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gdm9pY2VHdWlkYW5jZSgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdhY2Nlc3NpYmlsaXR5JywgJ3ZvaWNlR3VpZGFuY2UnLCB7ICB9KVxufVxuZnVuY3Rpb24gdm9pY2VHdWlkYW5jZVNldHRpbmdzKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdhY2Nlc3NpYmlsaXR5JywgICd2b2ljZUd1aWRhbmNlU2V0dGluZ3MnLCBhcmd1bWVudHMsIGZhbHNlLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBBY2Nlc3NpYmlsaXR5X2xpc3RlbiguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMubGlzdGVuKCdhY2Nlc3NpYmlsaXR5JywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIEFjY2Vzc2liaWxpdHlfb25jZSguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMub25jZSgnYWNjZXNzaWJpbGl0eScsIC4uLmFyZ3MpXG59XG5cbmZ1bmN0aW9uIGNsZWFyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5jbGVhcignYWNjZXNzaWJpbGl0eScsIC4uLmFyZ3MpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQWNjZXNzaWJpbGl0eSA9ICh7XG5cbiAgZXZlbnRzOiB7XG4gICAgY2xvc2VkQ2FwdGlvbnNTZXR0aW5nc0NoYW5nZWQ6J2Nsb3NlZENhcHRpb25zU2V0dGluZ3NDaGFuZ2VkJyxcbiAgICB2b2ljZUd1aWRhbmNlU2V0dGluZ3NDaGFuZ2VkOid2b2ljZUd1aWRhbmNlU2V0dGluZ3NDaGFuZ2VkJ1xuICB9LFxuY2xvc2VkQ2FwdGlvbnMsXG4gIGNsb3NlZENhcHRpb25zU2V0dGluZ3MsXG4gIHZvaWNlR3VpZGFuY2UsXG4gIHZvaWNlR3VpZGFuY2VTZXR0aW5ncyxcbiAgbGlzdGVuOiBBY2Nlc3NpYmlsaXR5X2xpc3RlbixcbiAgb25jZTogQWNjZXNzaWJpbGl0eV9vbmNlLFxuICBjbGVhclxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvQWNjb3VudC9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuZnVuY3Rpb24gaWQoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2FjY291bnQnLCAgJ2lkJywgYXJndW1lbnRzLCB0cnVlLCB0cnVlKVxufVxuZnVuY3Rpb24gdWlkKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdhY2NvdW50JywgICd1aWQnLCBhcmd1bWVudHMsIHRydWUsIHRydWUpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQWNjb3VudCA9ICh7XG5cbmlkLFxuICB1aWRcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0FkdmVydGlzaW5nL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdBZHZlcnRpc2luZycsIE9iamVjdC52YWx1ZXMoW1wicG9saWN5Q2hhbmdlZFwiXSkpXG5cblxuXG5mdW5jdGlvbiBjb25maWcob3B0aW9ucykge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2FkdmVydGlzaW5nJywgJ2NvbmZpZycsIHsgb3B0aW9ucyB9KVxufVxuZnVuY3Rpb24gcG9saWN5KCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdhZHZlcnRpc2luZycsICAncG9saWN5JywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gYWR2ZXJ0aXNpbmdJZCgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdhZHZlcnRpc2luZycsICdhZHZlcnRpc2luZ0lkJywgeyAgfSlcbn1cblxuZnVuY3Rpb24gZGV2aWNlQXR0cmlidXRlcygpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdhZHZlcnRpc2luZycsICdkZXZpY2VBdHRyaWJ1dGVzJywgeyAgfSlcbn1cblxuZnVuY3Rpb24gYXBwQnVuZGxlSWQoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnYWR2ZXJ0aXNpbmcnLCAnYXBwQnVuZGxlSWQnLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBBZHZlcnRpc2luZ19saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3RlbignYWR2ZXJ0aXNpbmcnLCAuLi5hcmdzKVxufSBcblxuZnVuY3Rpb24gQWR2ZXJ0aXNpbmdfb25jZSguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMub25jZSgnYWR2ZXJ0aXNpbmcnLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBBZHZlcnRpc2luZ19jbGVhciguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMuY2xlYXIoJ2FkdmVydGlzaW5nJywgLi4uYXJncylcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBZHZlcnRpc2luZyA9ICh7XG5cbiAgZXZlbnRzOiB7XG4gICAgcG9saWN5Q2hhbmdlZDoncG9saWN5Q2hhbmdlZCdcbiAgfSxcblxuICBTa2lwUmVzdHJpY3Rpb246IHtcbiAgICBOT05FOiAnbm9uZScsXG4gICAgQURTX1VOV0FUQ0hFRDogJ2Fkc1Vud2F0Y2hlZCcsXG4gICAgQURTX0FMTDogJ2Fkc0FsbCcsXG4gICAgQUxMOiAnYWxsJ1xuICB9LFxuXG5jb25maWcsXG4gIHBvbGljeSxcbiAgYWR2ZXJ0aXNpbmdJZCxcbiAgZGV2aWNlQXR0cmlidXRlcyxcbiAgYXBwQnVuZGxlSWQsXG4gIGxpc3RlbjogQWR2ZXJ0aXNpbmdfbGlzdGVuLFxuICBvbmNlOiBBZHZlcnRpc2luZ19vbmNlLFxuICBjbGVhcjogQWR2ZXJ0aXNpbmdfY2xlYXJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0F1dGhlbnRpY2F0aW9uL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5mdW5jdGlvbiB0b2tlbih0eXBlLCBvcHRpb25zKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnYXV0aGVudGljYXRpb24nLCAndG9rZW4nLCB7IHR5cGUsIG9wdGlvbnMgfSlcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBdXRoZW50aWNhdGlvbiA9ICh7XG5cblxuICBUb2tlblR5cGU6IHtcbiAgICBQTEFURk9STTogJ3BsYXRmb3JtJyxcbiAgICBERVZJQ0U6ICdkZXZpY2UnLFxuICAgIERJU1RSSUJVVE9SOiAnZGlzdHJpYnV0b3InXG4gIH0sXG5cbnRva2VuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9EZXZpY2UvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cblxucmVnaXN0ZXJFdmVudHMoJ0RldmljZScsIE9iamVjdC52YWx1ZXMoW1wiZGV2aWNlTmFtZUNoYW5nZWRcIixcImhkY3BDaGFuZ2VkXCIsXCJoZHJDaGFuZ2VkXCIsXCJhdWRpb0NoYW5nZWRcIixcInNjcmVlblJlc29sdXRpb25DaGFuZ2VkXCIsXCJ2aWRlb1Jlc29sdXRpb25DaGFuZ2VkXCIsXCJuYW1lQ2hhbmdlZFwiLFwibmV0d29ya0NoYW5nZWRcIl0pKVxuXG5UcmFuc3BvcnQucmVnaXN0ZXJEZXByZWNhdGVkTWV0aG9kKCdEZXZpY2UnLCAnb25EZXZpY2VOYW1lQ2hhbmdlZCcsICdVc2UgRGV2aWNlLm5hbWUoKSBpbnN0ZWFkLicpXG5cbmZ1bmN0aW9uIHZlcnNpb24oKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSggKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgVHJhbnNwb3J0LnNlbmQoJ2RldmljZScsICd2ZXJzaW9uJykudGhlbiggdiA9PiB7XG4gICAgICAgICAgdiA9IHYgfHwge31cbiAgICAgICAgICB2LnNkayA9IHYuc2RrIHx8IHt9XG4gICAgICAgICAgdi5zZGsubWFqb3IgPSBwYXJzZUludCgnMCcpXG4gICAgICAgICAgdi5zZGsubWlub3IgPSBwYXJzZUludCgnNicpXG4gICAgICAgICAgdi5zZGsucGF0Y2ggPSBwYXJzZUludCgnMCcpXG4gICAgICAgICAgdi5zZGsucmVhZGFibGUgPSAnVGhlIEZpcmVib2x0IEpTIFNESydcbiAgICAgICAgICByZXNvbHZlKHYpICAgIFxuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIERldmljZV9pZCgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGV2aWNlJywgICdpZCcsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIGRpc3RyaWJ1dG9yKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ2Rpc3RyaWJ1dG9yJywgYXJndW1lbnRzLCB0cnVlLCB0cnVlKVxufVxuZnVuY3Rpb24gcGxhdGZvcm0oKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAncGxhdGZvcm0nLCBhcmd1bWVudHMsIHRydWUsIHRydWUpXG59XG5mdW5jdGlvbiBEZXZpY2VfdWlkKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ3VpZCcsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIHR5cGUoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAndHlwZScsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIG1vZGVsKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ21vZGVsJywgYXJndW1lbnRzLCB0cnVlLCB0cnVlKVxufVxuZnVuY3Rpb24gc2t1KCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ3NrdScsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIG1ha2UoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAnbWFrZScsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIGhkY3AoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAnaGRjcCcsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5mdW5jdGlvbiBoZHIoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAnaGRyJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIGF1ZGlvKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ2F1ZGlvJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIHNjcmVlblJlc29sdXRpb24oKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAnc2NyZWVuUmVzb2x1dGlvbicsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5mdW5jdGlvbiB2aWRlb1Jlc29sdXRpb24oKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAndmlkZW9SZXNvbHV0aW9uJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIERldmljZV9uYW1lKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ25hbWUnLCBhcmd1bWVudHMsIGZhbHNlLCB0cnVlKVxufVxuZnVuY3Rpb24gbmV0d29yaygpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGV2aWNlJywgICduZXR3b3JrJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gRGV2aWNlX2xpc3RlbiguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMubGlzdGVuKCdkZXZpY2UnLCAuLi5hcmdzKVxufSBcblxuZnVuY3Rpb24gRGV2aWNlX29uY2UoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLm9uY2UoJ2RldmljZScsIC4uLmFyZ3MpXG59XG5cbmZ1bmN0aW9uIERldmljZV9jbGVhciguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMuY2xlYXIoJ2RldmljZScsIC4uLmFyZ3MpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRGV2aWNlID0gKHtcblxuICBldmVudHM6IHtcbiAgICBkZXZpY2VOYW1lQ2hhbmdlZDonZGV2aWNlTmFtZUNoYW5nZWQnLFxuICAgIGhkY3BDaGFuZ2VkOidoZGNwQ2hhbmdlZCcsXG4gICAgaGRyQ2hhbmdlZDonaGRyQ2hhbmdlZCcsXG4gICAgYXVkaW9DaGFuZ2VkOidhdWRpb0NoYW5nZWQnLFxuICAgIHNjcmVlblJlc29sdXRpb25DaGFuZ2VkOidzY3JlZW5SZXNvbHV0aW9uQ2hhbmdlZCcsXG4gICAgdmlkZW9SZXNvbHV0aW9uQ2hhbmdlZDondmlkZW9SZXNvbHV0aW9uQ2hhbmdlZCcsXG4gICAgbmFtZUNoYW5nZWQ6J25hbWVDaGFuZ2VkJyxcbiAgICBuZXR3b3JrQ2hhbmdlZDonbmV0d29ya0NoYW5nZWQnXG4gIH0sXG5cbiAgTmV0d29ya1R5cGU6IHtcbiAgICBXSUZJOiAnd2lmaScsXG4gICAgRVRIRVJORVQ6ICdldGhlcm5ldCcsXG4gICAgSFlCUklEOiAnaHlicmlkJ1xuICB9LFxuXG5cbiAgTmV0d29ya1N0YXRlOiB7XG4gICAgQ09OTkVDVEVEOiAnY29ubmVjdGVkJyxcbiAgICBESVNDT05ORUNURUQ6ICdkaXNjb25uZWN0ZWQnXG4gIH0sXG5cblxuICBBdWRpb1Byb2ZpbGU6IHtcbiAgICBTVEVSRU86ICdzdGVyZW8nLFxuICAgIERPTEJZX0RJR0lUQUxfNV8xOiAnZG9sYnlEaWdpdGFsNS4xJyxcbiAgICBET0xCWV9ESUdJVEFMXzdfMTogJ2RvbGJ5RGlnaXRhbDcuMScsXG4gICAgRE9MQllfRElHSVRBTF81XzFfUExVUzogJ2RvbGJ5RGlnaXRhbDUuMSsnLFxuICAgIERPTEJZX0RJR0lUQUxfN18xX1BMVVM6ICdkb2xieURpZ2l0YWw3LjErJyxcbiAgICBET0xCWV9BVE1PUzogJ2RvbGJ5QXRtb3MnXG4gIH0sXG5cblxuICB2ZXJzaW9uLFxuaWQ6IERldmljZV9pZCxcbiAgZGlzdHJpYnV0b3IsXG4gIHBsYXRmb3JtLFxuICB1aWQ6IERldmljZV91aWQsXG4gIHR5cGUsXG4gIG1vZGVsLFxuICBza3UsXG4gIG1ha2UsXG4gIGhkY3AsXG4gIGhkcixcbiAgYXVkaW8sXG4gIHNjcmVlblJlc29sdXRpb24sXG4gIHZpZGVvUmVzb2x1dGlvbixcbiAgbmFtZTogRGV2aWNlX25hbWUsXG4gIG5ldHdvcmssXG4gIGxpc3RlbjogRGV2aWNlX2xpc3RlbixcbiAgb25jZTogRGV2aWNlX29uY2UsXG4gIGNsZWFyOiBEZXZpY2VfY2xlYXJcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvTWV0cmljcy9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuZnVuY3Rpb24gcmVhZHkoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdyZWFkeScsIHt9KVxufVxuXG5mdW5jdGlvbiBzaWduSW4oKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdzaWduSW4nLCB7fSlcbn1cblxuZnVuY3Rpb24gc2lnbk91dCgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ3NpZ25PdXQnLCB7fSlcbn1cblxuXG5cbmZ1bmN0aW9uIHN0YXJ0Q29udGVudChlbnRpdHlJZCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnc3RhcnRDb250ZW50JywgeyBlbnRpdHlJZCB9KVxufVxuXG5mdW5jdGlvbiBzdG9wQ29udGVudChlbnRpdHlJZCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnc3RvcENvbnRlbnQnLCB7IGVudGl0eUlkIH0pXG59XG5cbmZ1bmN0aW9uIHBhZ2UocGFnZUlkKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdwYWdlJywgeyBwYWdlSWQgfSlcbn1cblxuZnVuY3Rpb24gYWN0aW9uKGNhdGVnb3J5LCB0eXBlLCBwYXJhbWV0ZXJzKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdhY3Rpb24nLCB7IGNhdGVnb3J5LCB0eXBlLCBwYXJhbWV0ZXJzIH0pXG59XG5cbmZ1bmN0aW9uIGVycm9yKHR5cGUsIGNvZGUsIGRlc2NyaXB0aW9uLCB2aXNpYmxlLCBwYXJhbWV0ZXJzKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdlcnJvcicsIHsgdHlwZSwgY29kZSwgZGVzY3JpcHRpb24sIHZpc2libGUsIHBhcmFtZXRlcnMgfSlcbn1cblxuZnVuY3Rpb24gbWVkaWFMb2FkU3RhcnQoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhTG9hZFN0YXJ0JywgeyBlbnRpdHlJZCB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYVBsYXkoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhUGxheScsIHsgZW50aXR5SWQgfSlcbn1cblxuZnVuY3Rpb24gbWVkaWFQbGF5aW5nKGVudGl0eUlkKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdtZWRpYVBsYXlpbmcnLCB7IGVudGl0eUlkIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhUGF1c2UoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhUGF1c2UnLCB7IGVudGl0eUlkIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhV2FpdGluZyhlbnRpdHlJZCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFXYWl0aW5nJywgeyBlbnRpdHlJZCB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYVByb2dyZXNzKGVudGl0eUlkLCBwcm9ncmVzcykge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFQcm9ncmVzcycsIHsgZW50aXR5SWQsIHByb2dyZXNzIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhU2Vla2luZyhlbnRpdHlJZCwgdGFyZ2V0KSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdtZWRpYVNlZWtpbmcnLCB7IGVudGl0eUlkLCB0YXJnZXQgfSlcbn1cblxuZnVuY3Rpb24gbWVkaWFTZWVrZWQoZW50aXR5SWQsIHBvc2l0aW9uKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdtZWRpYVNlZWtlZCcsIHsgZW50aXR5SWQsIHBvc2l0aW9uIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhUmF0ZUNoYW5nZShlbnRpdHlJZCwgcmF0ZSkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFSYXRlQ2hhbmdlJywgeyBlbnRpdHlJZCwgcmF0ZSB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYVJlbmRpdGlvbkNoYW5nZShlbnRpdHlJZCwgYml0cmF0ZSwgd2lkdGgsIGhlaWdodCwgcHJvZmlsZSkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFSZW5kaXRpb25DaGFuZ2UnLCB7IGVudGl0eUlkLCBiaXRyYXRlLCB3aWR0aCwgaGVpZ2h0LCBwcm9maWxlIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhRW5kZWQoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhRW5kZWQnLCB7IGVudGl0eUlkIH0pXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTWV0cmljcyA9ICh7XG5cblxuICBFcnJvclR5cGU6IHtcbiAgICBORVRXT1JLOiAnbmV0d29yaycsXG4gICAgTUVESUE6ICdtZWRpYScsXG4gICAgUkVTVFJJQ1RJT046ICdyZXN0cmljdGlvbicsXG4gICAgRU5USVRMRU1FTlQ6ICdlbnRpdGxlbWVudCcsXG4gICAgT1RIRVI6ICdvdGhlcidcbiAgfSxcblxuc3RhcnRDb250ZW50LFxuICBzdG9wQ29udGVudCxcbiAgcGFnZSxcbiAgYWN0aW9uLFxuICBlcnJvcixcbiAgbWVkaWFMb2FkU3RhcnQsXG4gIG1lZGlhUGxheSxcbiAgbWVkaWFQbGF5aW5nLFxuICBtZWRpYVBhdXNlLFxuICBtZWRpYVdhaXRpbmcsXG4gIG1lZGlhUHJvZ3Jlc3MsXG4gIG1lZGlhU2Vla2luZyxcbiAgbWVkaWFTZWVrZWQsXG4gIG1lZGlhUmF0ZUNoYW5nZSxcbiAgbWVkaWFSZW5kaXRpb25DaGFuZ2UsXG4gIG1lZGlhRW5kZWRcbn0pO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9EaXNjb3ZlcnkvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cblxucmVnaXN0ZXJFdmVudHMoJ0Rpc2NvdmVyeScsIE9iamVjdC52YWx1ZXMoW1wibmF2aWdhdGVUb1wiLFwicG9saWN5Q2hhbmdlZFwiXSkpXG5cblxuZnVuY3Rpb24gRGlzY292ZXJ5X3BvbGljeSgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGlzY292ZXJ5JywgICdwb2xpY3knLCBhcmd1bWVudHMsIGZhbHNlLCB0cnVlKVxufVxuXG5sZXQgZW50aXR5SW5mb0hhc0NhbGxiYWNrID0gZmFsc2VcblxuZnVuY3Rpb24gZW50aXR5SW5mbyAoZGF0YSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGVudGl0eUluZm9IYXNDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5ub3QgcmVnaXN0ZXIgbW9yZSB0aGFuIG9uZSBlbnRpdHlJbmZvIGhhbmRsZXIuJylcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3VtZW50c1swXVxuICAgIGVudGl0eUluZm9IYXNDYWxsYmFjayA9IHRydWVcbiAgICByZXR1cm4gRXZlbnRzLmxpc3RlbignZGlzY292ZXJ5JywgJ3B1bGxFbnRpdHlJbmZvJywgKHJlcXVlc3QpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2socmVxdWVzdC5wYXJhbWV0ZXJzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogcmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICB9XG4gICAgICAgICAgVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdlbnRpdHlJbmZvJywgcGFyYW1zKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIEVycm9yJ1xuICAgICAgICAgICAgSW50ZXJuYWxNZXRyaWNzLnNkay5lcnJvcihgRmFpbGVkIHRvIHNlbmQgZW50aXR5SW5mbyBwdWxsIHJlc3BvbnNlIHRocm91Z2ggVHJhbnNwb3J0IExheWVyOiAke21zZ31gLCBwYXJzZUludChlcnJvci5jb2RlKSB8fCA1MDAsIGZhbHNlLCByZXF1ZXN0LnBhcmFtZXRlcnMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgPyBlcnJvciA6IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gRXJyb3InXG4gICAgICAgICAgSW50ZXJuYWxNZXRyaWNzLnNkay5lcnJvcihgQXBwICdlbnRpdHlJbmZvJyBjYWxsYmFjayBmYWlsZWQ6ICR7bXNnfWAsIHBhcnNlSW50KGVycm9yLmNvZGUpIHx8IDUwMCwgZmFsc2UsIHJlcXVlc3QucGFyYW1ldGVycylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIEVycm9yJ1xuICAgICAgICBJbnRlcm5hbE1ldHJpY3Muc2RrLmVycm9yKGBBcHAgJ2VudGl0eUluZm8nIGNhbGxiYWNrIGZhaWxlZDogJHttc2d9YCwgcGFyc2VJbnQoZXJyb3IuY29kZSkgfHwgNTAwLCBmYWxzZSwgcmVxdWVzdC5wYXJhbWV0ZXJzKVxuICAgIH1cbiAgICB9KVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnZGlzY292ZXJ5JywgJ2VudGl0eUluZm8nLCB7IGRhdGEgfSlcbiAgfVxufVxuXG5sZXQgcHVyY2hhc2VkQ29udGVudEhhc0NhbGxiYWNrID0gZmFsc2VcblxuZnVuY3Rpb24gcHVyY2hhc2VkQ29udGVudCAoZGF0YSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHB1cmNoYXNlZENvbnRlbnRIYXNDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5ub3QgcmVnaXN0ZXIgbW9yZSB0aGFuIG9uZSBwdXJjaGFzZWRDb250ZW50IGhhbmRsZXIuJylcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3VtZW50c1swXVxuICAgIHB1cmNoYXNlZENvbnRlbnRIYXNDYWxsYmFjayA9IHRydWVcbiAgICByZXR1cm4gRXZlbnRzLmxpc3RlbignZGlzY292ZXJ5JywgJ3B1bGxQdXJjaGFzZWRDb250ZW50JywgKHJlcXVlc3QpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2socmVxdWVzdC5wYXJhbWV0ZXJzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogcmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICB9XG4gICAgICAgICAgVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdwdXJjaGFzZWRDb250ZW50JywgcGFyYW1zKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIEVycm9yJ1xuICAgICAgICAgICAgSW50ZXJuYWxNZXRyaWNzLnNkay5lcnJvcihgRmFpbGVkIHRvIHNlbmQgcHVyY2hhc2VkQ29udGVudCBwdWxsIHJlc3BvbnNlIHRocm91Z2ggVHJhbnNwb3J0IExheWVyOiAke21zZ31gLCBwYXJzZUludChlcnJvci5jb2RlKSB8fCA1MDAsIGZhbHNlLCByZXF1ZXN0LnBhcmFtZXRlcnMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgPyBlcnJvciA6IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gRXJyb3InXG4gICAgICAgICAgSW50ZXJuYWxNZXRyaWNzLnNkay5lcnJvcihgQXBwICdwdXJjaGFzZWRDb250ZW50JyBjYWxsYmFjayBmYWlsZWQ6ICR7bXNnfWAsIHBhcnNlSW50KGVycm9yLmNvZGUpIHx8IDUwMCwgZmFsc2UsIHJlcXVlc3QucGFyYW1ldGVycylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIEVycm9yJ1xuICAgICAgICBJbnRlcm5hbE1ldHJpY3Muc2RrLmVycm9yKGBBcHAgJ3B1cmNoYXNlZENvbnRlbnQnIGNhbGxiYWNrIGZhaWxlZDogJHttc2d9YCwgcGFyc2VJbnQoZXJyb3IuY29kZSkgfHwgNTAwLCBmYWxzZSwgcmVxdWVzdC5wYXJhbWV0ZXJzKVxuICAgIH1cbiAgICB9KVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnZGlzY292ZXJ5JywgJ3B1cmNoYXNlZENvbnRlbnQnLCB7IGRhdGEgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXRjaGVkKGVudGl0eUlkLCBwcm9ncmVzcywgY29tcGxldGVkLCB3YXRjaGVkT24pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdkaXNjb3ZlcnknLCAnd2F0Y2hlZCcsIGFyZ3VtZW50c1swXSlcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICd3YXRjaGVkJywgeyBlbnRpdHlJZCwgcHJvZ3Jlc3MsIGNvbXBsZXRlZCwgd2F0Y2hlZE9uIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gd2F0Y2hOZXh0KHRpdGxlLCBpZGVudGlmaWVycywgZXhwaXJlcywgaW1hZ2VzKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnZGlzY292ZXJ5JywgJ3dhdGNoTmV4dCcsIHsgdGl0bGUsIGlkZW50aWZpZXJzLCBleHBpcmVzLCBpbWFnZXMgfSlcbn1cblxuZnVuY3Rpb24gZW50aXRsZW1lbnRzKGVudGl0bGVtZW50cykge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdlbnRpdGxlbWVudHMnLCB7IGVudGl0bGVtZW50cyB9KVxufVxuXG5mdW5jdGlvbiBsYXVuY2goYXBwSWQsIGludGVudCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdsYXVuY2gnLCB7IGFwcElkLCBpbnRlbnQgfSlcbn1cblxuXG5cbmZ1bmN0aW9uIERpc2NvdmVyeV9zaWduSW4oZW50aXRsZW1lbnRzKSB7XG4gICAgY29uc3QgcCA9IFRyYW5zcG9ydC5zZW5kKCdkaXNjb3ZlcnknLCAnc2lnbkluJywgeyBlbnRpdGxlbWVudHMgfSlcbiAgICBcbiAgICBwLnRoZW4oXyA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoXyA9PiB7XG4gICAgICAgICAgICBzaWduSW4oZW50aXRsZW1lbnRzKVxuICAgICAgICB9KSAgICBcbiAgICB9KVxuXG4gICAgcmV0dXJuIHBcbn1cblxuXG5cbmZ1bmN0aW9uIERpc2NvdmVyeV9zaWduT3V0KCkge1xuICAgIGNvbnN0IHAgPSBUcmFuc3BvcnQuc2VuZCgnZGlzY292ZXJ5JywgJ3NpZ25PdXQnLCB7ICB9KVxuICAgIFxuICAgIHAudGhlbihfID0+IHtcbiAgICAgICAgc2V0VGltZW91dChfID0+IHtcbiAgICAgICAgICAgIHNpZ25PdXQoKVxuICAgICAgICB9KSAgICBcbiAgICB9KVxuXG4gICAgcmV0dXJuIHBcbn1cblxuZnVuY3Rpb24gRGlzY292ZXJ5X2xpc3RlbiguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMubGlzdGVuKCdkaXNjb3ZlcnknLCAuLi5hcmdzKVxufSBcblxuZnVuY3Rpb24gRGlzY292ZXJ5X29uY2UoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLm9uY2UoJ2Rpc2NvdmVyeScsIC4uLmFyZ3MpXG59XG5cbmZ1bmN0aW9uIERpc2NvdmVyeV9jbGVhciguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMuY2xlYXIoJ2Rpc2NvdmVyeScsIC4uLmFyZ3MpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRGlzY292ZXJ5ID0gKHtcblxuICBldmVudHM6IHtcbiAgICBuYXZpZ2F0ZVRvOiduYXZpZ2F0ZVRvJyxcbiAgICBwb2xpY3lDaGFuZ2VkOidwb2xpY3lDaGFuZ2VkJ1xuICB9LFxucG9saWN5OiBEaXNjb3ZlcnlfcG9saWN5LFxuICBlbnRpdHlJbmZvLFxuICBwdXJjaGFzZWRDb250ZW50LFxuICB3YXRjaGVkLFxuICB3YXRjaE5leHQsXG4gIGVudGl0bGVtZW50cyxcbiAgbGF1bmNoLFxuICBzaWduSW46IERpc2NvdmVyeV9zaWduSW4sXG4gIHNpZ25PdXQ6IERpc2NvdmVyeV9zaWduT3V0LFxuICBsaXN0ZW46IERpc2NvdmVyeV9saXN0ZW4sXG4gIG9uY2U6IERpc2NvdmVyeV9vbmNlLFxuICBjbGVhcjogRGlzY292ZXJ5X2NsZWFyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9LZXlib2FyZC9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuZnVuY3Rpb24gZW1haWwodHlwZSwgbWVzc2FnZSkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2tleWJvYXJkJywgJ2VtYWlsJywgeyB0eXBlLCBtZXNzYWdlIH0pXG59XG5cbmZ1bmN0aW9uIEtleWJvYXJkX3Bhc3N3b3JkKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdrZXlib2FyZCcsICdwYXNzd29yZCcsIHsgbWVzc2FnZSB9KVxufVxuXG5mdW5jdGlvbiBzdGFuZGFyZChtZXNzYWdlKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgna2V5Ym9hcmQnLCAnc3RhbmRhcmQnLCB7IG1lc3NhZ2UgfSlcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLZXlib2FyZCA9ICh7XG5cblxuICBFbWFpbFVzYWdlOiB7XG4gICAgU0lHTl9JTjogJ3NpZ25JbicsXG4gICAgU0lHTl9VUDogJ3NpZ25VcCdcbiAgfSxcblxuZW1haWwsXG4gIHBhc3N3b3JkOiBLZXlib2FyZF9wYXNzd29yZCxcbiAgc3RhbmRhcmRcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0xpZmVjeWNsZS9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxucmVnaXN0ZXJFdmVudHMoJ0xpZmVjeWNsZScsIE9iamVjdC52YWx1ZXMoW1wiaW5hY3RpdmVcIixcImZvcmVncm91bmRcIixcImJhY2tncm91bmRcIixcInN1c3BlbmRlZFwiLFwidW5sb2FkaW5nXCJdKSlcblxuXG5jb25zdCBzdG9yZSA9IHtcbiAgX2N1cnJlbnQ6ICdpbml0aWFsaXppbmcnLFxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFxuICB9XG59XG5cbkV2ZW50cy5saXN0ZW4oJ0xpZmVjeWNsZScsIChldmVudCwgdmFsdWUpID0+IHtcbiAgc3RvcmUuX2N1cnJlbnQgPSBldmVudFxufSlcblxuXG47XG5cbmZ1bmN0aW9uIExpZmVjeWNsZV9yZWFkeSgpIHtcbiAgICBjb25zdCBwID0gVHJhbnNwb3J0LnNlbmQoJ2xpZmVjeWNsZScsICdyZWFkeScsIHsgIH0pXG4gICAgXG4gICAgcC50aGVuKF8gPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KF8gPT4ge1xuICAgICAgICAgICAgcmVhZHkoKVxuICAgICAgICB9KSAgICBcbiAgICB9KVxuXG4gICAgcmV0dXJuIHBcbn1cblxuZnVuY3Rpb24gTGlmZWN5Y2xlX2Nsb3NlKHJlYXNvbikge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xpZmVjeWNsZScsICdjbG9zZScsIHsgcmVhc29uIH0pXG59XG5cbmZ1bmN0aW9uIExpZmVjeWNsZV9saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3RlbignbGlmZWN5Y2xlJywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIExpZmVjeWNsZV9vbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5vbmNlKCdsaWZlY3ljbGUnLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBMaWZlY3ljbGVfY2xlYXIoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmNsZWFyKCdsaWZlY3ljbGUnLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBzdGF0ZSgpIHtcbiAgcmV0dXJuIHN0b3JlLmN1cnJlbnRcbn1cblxuZnVuY3Rpb24gZmluaXNoZWQoKSB7XG4gIGlmIChzdG9yZS5jdXJyZW50ID09PSAndW5sb2FkaW5nJykge1xuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbGlmZWN5Y2xlJywgJ2ZpbmlzaGVkJylcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyAnQ2Fubm90IGNhbGwgZmluaXNoZWQoKSBleGNlcHQgd2hlbiBpbiB0aGUgdW5sb2FkaW5nIHRyYW5zaXRpb24nXG4gIH1cbn1cblxuLy8gcHVibGljIEFQSVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMaWZlY3ljbGUgPSAoe1xuXG4gIGV2ZW50czoge1xuICAgIGluYWN0aXZlOidpbmFjdGl2ZScsXG4gICAgZm9yZWdyb3VuZDonZm9yZWdyb3VuZCcsXG4gICAgYmFja2dyb3VuZDonYmFja2dyb3VuZCcsXG4gICAgc3VzcGVuZGVkOidzdXNwZW5kZWQnLFxuICAgIHVubG9hZGluZzondW5sb2FkaW5nJ1xuICB9LFxuXG5cbiAgTGlmZWN5Y2xlU3RhdGU6IHtcbiAgICBJTklUSUFMSVpJTkc6ICdpbml0aWFsaXppbmcnLFxuICAgIElOQUNUSVZFOiAnaW5hY3RpdmUnLFxuICAgIEJBQ0tHUk9VTkQ6ICdiYWNrZ3JvdW5kJyxcbiAgICBGT1JFR1JPVU5EOiAnZm9yZWdyb3VuZCcsXG4gICAgU1VTUEVOREVEOiAnc3VzcGVuZGVkJyxcbiAgICBVTkxPQURJTkc6ICd1bmxvYWRpbmcnXG4gIH0sXG5cblxuICBDbG9zZVJlYXNvbjoge1xuICAgIFJFTU9URV9CVVRUT046ICdyZW1vdGVCdXR0b24nLFxuICAgIFVTRVJfRVhJVDogJ3VzZXJFeGl0JyxcbiAgICBFUlJPUjogJ2Vycm9yJ1xuICB9LFxuXG5cbiAgc3RhdGUsXG4gIGZpbmlzaGVkLFxuXG5yZWFkeTogTGlmZWN5Y2xlX3JlYWR5LFxuICBjbG9zZTogTGlmZWN5Y2xlX2Nsb3NlLFxuICBsaXN0ZW46IExpZmVjeWNsZV9saXN0ZW4sXG4gIG9uY2U6IExpZmVjeWNsZV9vbmNlLFxuICBjbGVhcjogTGlmZWN5Y2xlX2NsZWFyICBcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvTG9jYWxpemF0aW9uL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdMb2NhbGl6YXRpb24nLCBPYmplY3QudmFsdWVzKFtcImxhbmd1YWdlQ2hhbmdlZFwiXSkpXG5cblxuXG5mdW5jdGlvbiBsb2NhbGl0eSgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdsb2NhbGl6YXRpb24nLCAnbG9jYWxpdHknLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBwb3N0YWxDb2RlKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xvY2FsaXphdGlvbicsICdwb3N0YWxDb2RlJywgeyAgfSlcbn1cblxuZnVuY3Rpb24gY291bnRyeUNvZGUoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbG9jYWxpemF0aW9uJywgJ2NvdW50cnlDb2RlJywgeyAgfSlcbn1cbmZ1bmN0aW9uIGxhbmd1YWdlKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdsb2NhbGl6YXRpb24nLCAgJ2xhbmd1YWdlJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gbG9jYWxlKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xvY2FsaXphdGlvbicsICdsb2NhbGUnLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBsYXRsb24oKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbG9jYWxpemF0aW9uJywgJ2xhdGxvbicsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGFkZGl0aW9uYWxJbmZvKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xvY2FsaXphdGlvbicsICdhZGRpdGlvbmFsSW5mbycsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIExvY2FsaXphdGlvbl9saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3RlbignbG9jYWxpemF0aW9uJywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIExvY2FsaXphdGlvbl9vbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5vbmNlKCdsb2NhbGl6YXRpb24nLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBMb2NhbGl6YXRpb25fY2xlYXIoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmNsZWFyKCdsb2NhbGl6YXRpb24nLCAuLi5hcmdzKVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExvY2FsaXphdGlvbiA9ICh7XG5cbiAgZXZlbnRzOiB7XG4gICAgbGFuZ3VhZ2VDaGFuZ2VkOidsYW5ndWFnZUNoYW5nZWQnXG4gIH0sXG5sb2NhbGl0eSxcbiAgcG9zdGFsQ29kZSxcbiAgY291bnRyeUNvZGUsXG4gIGxhbmd1YWdlLFxuICBsb2NhbGUsXG4gIGxhdGxvbixcbiAgYWRkaXRpb25hbEluZm8sXG4gIGxpc3RlbjogTG9jYWxpemF0aW9uX2xpc3RlbixcbiAgb25jZTogTG9jYWxpemF0aW9uX29uY2UsXG4gIGNsZWFyOiBMb2NhbGl6YXRpb25fY2xlYXJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1BhcmFtZXRlcnMvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGluaXRpYWxpemF0aW9uKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ3BhcmFtZXRlcnMnLCAnaW5pdGlhbGl6YXRpb24nLCB7ICB9KVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFBhcmFtZXRlcnMgPSAoe1xuXG5pbml0aWFsaXphdGlvblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvUHJvZmlsZS9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuZnVuY3Rpb24gYXBwcm92ZUNvbnRlbnRSYXRpbmcoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgncHJvZmlsZScsICdhcHByb3ZlQ29udGVudFJhdGluZycsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGFwcHJvdmVQdXJjaGFzZSgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdwcm9maWxlJywgJ2FwcHJvdmVQdXJjaGFzZScsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGZsYWdzKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ3Byb2ZpbGUnLCAnZmxhZ3MnLCB7ICB9KVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFByb2ZpbGUgPSAoe1xuXG5hcHByb3ZlQ29udGVudFJhdGluZyxcbiAgYXBwcm92ZVB1cmNoYXNlLFxuICBmbGFnc1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvU2Vjb25kU2NyZWVuL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdTZWNvbmRTY3JlZW4nLCBPYmplY3QudmFsdWVzKFtcImxhdW5jaFJlcXVlc3RcIixcImNsb3NlUmVxdWVzdFwiLFwiZnJpZW5kbHlOYW1lQ2hhbmdlZFwiXSkpXG5cblxuXG5mdW5jdGlvbiBwcm90b2NvbHMoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnc2Vjb25kc2NyZWVuJywgJ3Byb3RvY29scycsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGRldmljZSh0eXBlKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnc2Vjb25kc2NyZWVuJywgJ2RldmljZScsIHsgdHlwZSB9KVxufVxuZnVuY3Rpb24gZnJpZW5kbHlOYW1lKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdzZWNvbmRzY3JlZW4nLCAgJ2ZyaWVuZGx5TmFtZScsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5cbmZ1bmN0aW9uIFNlY29uZFNjcmVlbl9saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3Rlbignc2Vjb25kc2NyZWVuJywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIFNlY29uZFNjcmVlbl9vbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5vbmNlKCdzZWNvbmRzY3JlZW4nLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBTZWNvbmRTY3JlZW5fY2xlYXIoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmNsZWFyKCdzZWNvbmRzY3JlZW4nLCAuLi5hcmdzKVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNlY29uZFNjcmVlbiA9ICh7XG5cbiAgZXZlbnRzOiB7XG4gICAgbGF1bmNoUmVxdWVzdDonbGF1bmNoUmVxdWVzdCcsXG4gICAgY2xvc2VSZXF1ZXN0OidjbG9zZVJlcXVlc3QnLFxuICAgIGZyaWVuZGx5TmFtZUNoYW5nZWQ6J2ZyaWVuZGx5TmFtZUNoYW5nZWQnXG4gIH0sXG5wcm90b2NvbHMsXG4gIGRldmljZSxcbiAgZnJpZW5kbHlOYW1lLFxuICBsaXN0ZW46IFNlY29uZFNjcmVlbl9saXN0ZW4sXG4gIG9uY2U6IFNlY29uZFNjcmVlbl9vbmNlLFxuICBjbGVhcjogU2Vjb25kU2NyZWVuX2NsZWFyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9QbGF0Zm9ybS9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuLy8gcHVibGljIEFQSVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQbGF0Zm9ybSA9ICh7XG4gIExvY2FsaXphdGlvbjogTG9jYWxpemF0aW9uLFxuICBEZXZpY2U6IERldmljZSxcbiAgQWNjZXNzaWJpbGl0eTogQWNjZXNzaWJpbGl0eSxcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvTG9nL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5jb25zdCBwcmVwTG9nID0gKHR5cGUsIGFyZ3MpID0+IHtcbiAgY29uc3QgY29sb3JzID0ge1xuICAgIEluZm86ICdncmVlbicsXG4gICAgRGVidWc6ICdncmF5JyxcbiAgICBXYXJuOiAnb3JhbmdlJyxcbiAgICBFcnJvcjogJ3JlZCcsXG4gIH1cblxuICBhcmdzID0gQXJyYXkuZnJvbShhcmdzKVxuICByZXR1cm4gW1xuICAgICclYycgKyAoYXJncy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyA/IGFyZ3Muc2hpZnQoKSA6IHR5cGUpLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yOiAnICsgY29sb3JzW3R5cGVdICsgJzsgY29sb3I6IHdoaXRlOyBwYWRkaW5nOiAycHggNHB4OyBib3JkZXItcmFkaXVzOiAycHgnLFxuICAgIGFyZ3MsXG4gIF1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMb2cgPSAoe1xuICBpbmZvKCkge1xuICAgIFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnbG9nJykgJiYgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgcHJlcExvZygnSW5mbycsIGFyZ3VtZW50cykpXG4gIH0sXG4gIGRlYnVnKCkge1xuICAgIFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnbG9nJykgJiYgY29uc29sZS5kZWJ1Zy5hcHBseShjb25zb2xlLCBwcmVwTG9nKCdEZWJ1ZycsIGFyZ3VtZW50cykpXG4gIH0sXG4gIGVycm9yKCkge1xuICAgIFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnbG9nJykgJiYgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBwcmVwTG9nKCdFcnJvcicsIGFyZ3VtZW50cykpXG4gIH0sXG4gIHdhcm4oKSB7XG4gICAgU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdsb2cnKSAmJiBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgcHJlcExvZygnV2FybicsIGFyZ3VtZW50cykpXG4gIH0sXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWNjZXNzaWJpbGl0eSA9IF9fd2VicGFja19leHBvcnRzX18ueXE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FjY291bnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm1SO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BZHZlcnRpc2luZyA9IF9fd2VicGFja19leHBvcnRzX18uWkw7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0F1dGhlbnRpY2F0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5WeTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGV2aWNlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5BUztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGlzY292ZXJ5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QRztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRXZlbnRzID0gX193ZWJwYWNrX2V4cG9ydHNfXy56VztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fS2V5Ym9hcmQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk4xO1xudmFyIF9fd2VicGFja19leHBvcnRzX19MaWZlY3ljbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkZ3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Mb2NhbGl6YXRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLldIO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Mb2cgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlpiO1xudmFyIF9fd2VicGFja19leHBvcnRzX19NZXRyaWNzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5DMztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGFyYW1ldGVycyA9IF9fd2VicGFja19leHBvcnRzX18uYUU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BsYXRmb3JtID0gX193ZWJwYWNrX2V4cG9ydHNfXy50NDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUHJvZmlsZSA9IF9fd2VicGFja19leHBvcnRzX18uTlo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NlY29uZFNjcmVlbiA9IF9fd2VicGFja19leHBvcnRzX18uX0Y7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NldHRpbmdzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5acjtcbmV4cG9ydCB7IF9fd2VicGFja19leHBvcnRzX19BY2Nlc3NpYmlsaXR5IGFzIEFjY2Vzc2liaWxpdHksIF9fd2VicGFja19leHBvcnRzX19BY2NvdW50IGFzIEFjY291bnQsIF9fd2VicGFja19leHBvcnRzX19BZHZlcnRpc2luZyBhcyBBZHZlcnRpc2luZywgX193ZWJwYWNrX2V4cG9ydHNfX0F1dGhlbnRpY2F0aW9uIGFzIEF1dGhlbnRpY2F0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fRGV2aWNlIGFzIERldmljZSwgX193ZWJwYWNrX2V4cG9ydHNfX0Rpc2NvdmVyeSBhcyBEaXNjb3ZlcnksIF9fd2VicGFja19leHBvcnRzX19FdmVudHMgYXMgRXZlbnRzLCBfX3dlYnBhY2tfZXhwb3J0c19fS2V5Ym9hcmQgYXMgS2V5Ym9hcmQsIF9fd2VicGFja19leHBvcnRzX19MaWZlY3ljbGUgYXMgTGlmZWN5Y2xlLCBfX3dlYnBhY2tfZXhwb3J0c19fTG9jYWxpemF0aW9uIGFzIExvY2FsaXphdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX0xvZyBhcyBMb2csIF9fd2VicGFja19leHBvcnRzX19NZXRyaWNzIGFzIE1ldHJpY3MsIF9fd2VicGFja19leHBvcnRzX19QYXJhbWV0ZXJzIGFzIFBhcmFtZXRlcnMsIF9fd2VicGFja19leHBvcnRzX19QbGF0Zm9ybSBhcyBQbGF0Zm9ybSwgX193ZWJwYWNrX2V4cG9ydHNfX1Byb2ZpbGUgYXMgUHJvZmlsZSwgX193ZWJwYWNrX2V4cG9ydHNfX1NlY29uZFNjcmVlbiBhcyBTZWNvbmRTY3JlZW4sIF9fd2VicGFja19leHBvcnRzX19TZXR0aW5ncyBhcyBTZXR0aW5ncyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJlYm9sdC5qcy5tYXAiLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgbG5nIGZyb20gJy4vc3JjL2xpZ2h0bmluZy5tanMnO1xuZXhwb3J0IGRlZmF1bHQgbG5nO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBBZHMgfSBmcm9tICcuL3NyYy9BZHMnXG5leHBvcnQgeyBBcHBEYXRhIH0gZnJvbSAnLi9zcmMvQXBwbGljYXRpb24nXG5leHBvcnQgeyBkZWZhdWx0IGFzIEFwcGxpY2F0aW9uIH0gZnJvbSAnLi9zcmMvQXBwbGljYXRpb24nXG5leHBvcnQgeyBkZWZhdWx0IGFzIEF1ZGlvUGxheWVyIH0gZnJvbSAnLi9zcmMvQXVkaW9QbGF5ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbG9ycyB9IGZyb20gJy4vc3JjL0NvbG9ycydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW1nIH0gZnJvbSAnLi9zcmMvSW1nJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBLZXlib2FyZCB9IGZyb20gJy4vc3JjL0tleWJvYXJkJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMYXVuY2ggfSBmcm9tICcuL3NyYy9MYXVuY2gnXG5leHBvcnQgeyBkZWZhdWx0IGFzIExpZ2h0bmluZyB9IGZyb20gJy4vc3JjL0xpZ2h0bmluZydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9jYWxlIH0gZnJvbSAnLi9zcmMvTG9jYWxlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMYW5ndWFnZSB9IGZyb20gJy4vc3JjL0xhbmd1YWdlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMb2cgfSBmcm9tICcuL3NyYy9Mb2cnXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1lZGlhUGxheWVyIH0gZnJvbSAnLi9zcmMvTWVkaWFQbGF5ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1ldHJpY3MgfSBmcm9tICcuL3NyYy9NZXRyaWNzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQaW4gfSBmcm9tICcuL3NyYy9QaW4nXG5leHBvcnQgeyBkZWZhdWx0IGFzIFByb2ZpbGUgfSBmcm9tICcuL3NyYy9Qcm9maWxlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQdXJjaGFzZSB9IGZyb20gJy4vc3JjL1B1cmNoYXNlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWdpc3RyeSB9IGZyb20gJy4vc3JjL1JlZ2lzdHJ5J1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSb3V0ZXIgfSBmcm9tICcuL3NyYy9Sb3V0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNldHRpbmdzIH0gZnJvbSAnLi9zcmMvU2V0dGluZ3MnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0b3JhZ2UgfSBmcm9tICcuL3NyYy9TdG9yYWdlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUViB9IGZyb20gJy4vc3JjL1RWJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBVdGlscyB9IGZyb20gJy4vc3JjL1V0aWxzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBWaWRlb1BsYXllciB9IGZyb20gJy4vc3JjL1ZpZGVvUGxheWVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNZXRhZGF0YSB9IGZyb20gJy4vc3JjL01ldGFkYXRhJ1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExvZyBmcm9tICcuLi9Mb2cnXG5pbXBvcnQgeyBtZWRpYVVybCB9IGZyb20gJy4uL1ZpZGVvUGxheWVyJ1xuXG5sZXQgY29uc3VtZXJcblxubGV0IGdldEFkcyA9ICgpID0+IHtcbiAgLy8gdG9kbzogZW5hYmxlIHNvbWUgZGVmYXVsdCBhZHMgZHVyaW5nIGRldmVsb3BtZW50LCBtYXliZSBmcm9tIHRoZSBzZXR0aW5ncy5qc29uXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgIHByZXJvbGxzOiBbXSxcbiAgICBtaWRyb2xsczogW10sXG4gICAgcG9zdHJvbGxzOiBbXSxcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRBZHMgPSBjb25maWcgPT4ge1xuICBpZiAoY29uZmlnLmdldEFkcykge1xuICAgIGdldEFkcyA9IGNvbmZpZy5nZXRBZHNcbiAgfVxufVxuXG5jb25zdCBzdGF0ZSA9IHtcbiAgYWN0aXZlOiBmYWxzZSxcbn1cblxuY29uc3QgcGxheVNsb3QgPSAoc2xvdCA9IFtdKSA9PiB7XG4gIHJldHVybiBzbG90LnJlZHVjZSgocHJvbWlzZSwgYWQpID0+IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiBwbGF5QWQoYWQpXG4gICAgfSlcbiAgfSwgUHJvbWlzZS5yZXNvbHZlKG51bGwpKVxufVxuXG5jb25zdCBwbGF5QWQgPSBhZCA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBpZiAoc3RhdGUuYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgTG9nLmluZm8oJ0FkJywgJ1NraXBwaW5nIGFkZCBkdWUgdG8gaW5hY3RpdmUgc3RhdGUnKVxuICAgICAgcmV0dXJuIHJlc29sdmUoKVxuICAgIH1cbiAgICAvLyBpcyBpdCBzYWZlIHRvIHJlbHkgb24gdmlkZW9wbGF5ZXIgcGx1Z2luIGFscmVhZHkgY3JlYXRlZCB0aGUgdmlkZW8gdGFnP1xuICAgIGNvbnN0IHZpZGVvRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKVswXVxuICAgIHZpZGVvRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICB2aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICB2aWRlb0VsLnNyYyA9IG1lZGlhVXJsKGFkLnVybClcbiAgICB2aWRlb0VsLmxvYWQoKVxuXG4gICAgbGV0IHRpbWVFdmVudHMgPSBudWxsXG4gICAgbGV0IHRpbWVvdXRcblxuICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2goaGFuZGxlciA9PlxuICAgICAgICB2aWRlb0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlciwgaGFuZGxlcnNbaGFuZGxlcl0pXG4gICAgICApXG4gICAgICByZXNvbHZlKClcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBwbGF5KCkge1xuICAgICAgICBMb2cuaW5mbygnQWQnLCAnUGxheSBhZCcsIGFkLnVybClcbiAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ1BsYXknLCBhZClcbiAgICAgICAgc2VuZEJlYWNvbihhZC5jYWxsYmFja3MsICdkZWZhdWx0SW1wcmVzc2lvbicpXG4gICAgICB9LFxuICAgICAgZW5kZWQoKSB7XG4gICAgICAgIGZpcmVPbkNvbnN1bWVyKCdFbmRlZCcsIGFkKVxuICAgICAgICBzZW5kQmVhY29uKGFkLmNhbGxiYWNrcywgJ2NvbXBsZXRlJylcbiAgICAgICAgY2xlYW51cCgpXG4gICAgICB9LFxuICAgICAgdGltZXVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aW1lRXZlbnRzICYmIHZpZGVvRWwuZHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgd2hlbiB0byBmaXJlIHRoZSB0aW1lIGJhc2VkIGV2ZW50cyAobm93IHRoYXQgZHVyYXRpb24gaXMga25vd24pXG4gICAgICAgICAgdGltZUV2ZW50cyA9IHtcbiAgICAgICAgICAgIGZpcnN0UXVhcnRpbGU6IHZpZGVvRWwuZHVyYXRpb24gLyA0LFxuICAgICAgICAgICAgbWlkUG9pbnQ6IHZpZGVvRWwuZHVyYXRpb24gLyAyLFxuICAgICAgICAgICAgdGhpcmRRdWFydGlsZTogKHZpZGVvRWwuZHVyYXRpb24gLyA0KSAqIDMsXG4gICAgICAgICAgfVxuICAgICAgICAgIExvZy5pbmZvKCdBZCcsICdDYWxjdWxhdGVkIHF1YXJ0aWxlcyB0aW1lcycsIHsgdGltZUV2ZW50cyB9KVxuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aW1lRXZlbnRzICYmXG4gICAgICAgICAgdGltZUV2ZW50cy5maXJzdFF1YXJ0aWxlICYmXG4gICAgICAgICAgdmlkZW9FbC5jdXJyZW50VGltZSA+PSB0aW1lRXZlbnRzLmZpcnN0UXVhcnRpbGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ0ZpcnN0UXVhcnRpbGUnLCBhZClcbiAgICAgICAgICBkZWxldGUgdGltZUV2ZW50cy5maXJzdFF1YXJ0aWxlXG4gICAgICAgICAgc2VuZEJlYWNvbihhZC5jYWxsYmFja3MsICdmaXJzdFF1YXJ0aWxlJylcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZUV2ZW50cyAmJiB0aW1lRXZlbnRzLm1pZFBvaW50ICYmIHZpZGVvRWwuY3VycmVudFRpbWUgPj0gdGltZUV2ZW50cy5taWRQb2ludCkge1xuICAgICAgICAgIGZpcmVPbkNvbnN1bWVyKCdNaWRQb2ludCcsIGFkKVxuICAgICAgICAgIGRlbGV0ZSB0aW1lRXZlbnRzLm1pZFBvaW50XG4gICAgICAgICAgc2VuZEJlYWNvbihhZC5jYWxsYmFja3MsICdtaWRQb2ludCcpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRpbWVFdmVudHMgJiZcbiAgICAgICAgICB0aW1lRXZlbnRzLnRoaXJkUXVhcnRpbGUgJiZcbiAgICAgICAgICB2aWRlb0VsLmN1cnJlbnRUaW1lID49IHRpbWVFdmVudHMudGhpcmRRdWFydGlsZVxuICAgICAgICApIHtcbiAgICAgICAgICBmaXJlT25Db25zdW1lcignVGhpcmRRdWFydGlsZScsIGFkKVxuICAgICAgICAgIGRlbGV0ZSB0aW1lRXZlbnRzLnRoaXJkUXVhcnRpbGVcbiAgICAgICAgICBzZW5kQmVhY29uKGFkLmNhbGxiYWNrcywgJ3RoaXJkUXVhcnRpbGUnKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RhbGxlZCgpIHtcbiAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ1N0YWxsZWQnLCBhZClcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNsZWFudXAoKVxuICAgICAgICB9LCA1MDAwKSAvLyBtYWtlIHRpbWVvdXQgY29uZmlndXJhYmxlXG4gICAgICB9LFxuICAgICAgY2FucGxheSgpIHtcbiAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgIH0sXG4gICAgICBlcnJvcigpIHtcbiAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ0Vycm9yJywgYWQpXG4gICAgICAgIGNsZWFudXAoKVxuICAgICAgfSxcbiAgICAgIC8vIHRoaXMgZG9lc24ndCB3b3JrIHJlbGlhYmx5IG9uIHNreSBib3gsIG1vdmVkIGxvZ2ljIHRvIHRpbWVVcGRhdGUgZXZlbnRcbiAgICAgIC8vIGxvYWRlZG1ldGFkYXRhKCkge1xuICAgICAgLy8gICAvLyBjYWxjdWxhdGUgd2hlbiB0byBmaXJlIHRoZSB0aW1lIGJhc2VkIGV2ZW50cyAobm93IHRoYXQgZHVyYXRpb24gaXMga25vd24pXG4gICAgICAvLyAgIHRpbWVFdmVudHMgPSB7XG4gICAgICAvLyAgICAgZmlyc3RRdWFydGlsZTogdmlkZW9FbC5kdXJhdGlvbiAvIDQsXG4gICAgICAvLyAgICAgbWlkUG9pbnQ6IHZpZGVvRWwuZHVyYXRpb24gLyAyLFxuICAgICAgLy8gICAgIHRoaXJkUXVhcnRpbGU6ICh2aWRlb0VsLmR1cmF0aW9uIC8gNCkgKiAzLFxuICAgICAgLy8gICB9XG4gICAgICAvLyB9LFxuICAgICAgYWJvcnQoKSB7XG4gICAgICAgIGNsZWFudXAoKVxuICAgICAgfSxcbiAgICAgIC8vIHRvZG86IHBhdXNlLCByZXN1bWUsIG11dGUsIHVubXV0ZSBiZWFjb25zXG4gICAgfVxuICAgIC8vIGFkZCBhbGwgbGlzdGVuZXJzXG4gICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2goaGFuZGxlciA9PiB2aWRlb0VsLmFkZEV2ZW50TGlzdGVuZXIoaGFuZGxlciwgaGFuZGxlcnNbaGFuZGxlcl0pKVxuXG4gICAgdmlkZW9FbC5wbGF5KClcbiAgfSlcbn1cblxuY29uc3Qgc2VuZEJlYWNvbiA9IChjYWxsYmFja3MsIGV2ZW50KSA9PiB7XG4gIGlmIChjYWxsYmFja3MgJiYgY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgIExvZy5pbmZvKCdBZCcsICdTZW5kaW5nIGJlYWNvbicsIGV2ZW50LCBjYWxsYmFja3NbZXZlbnRdKVxuICAgIHJldHVybiBjYWxsYmFja3NbZXZlbnRdLnJlZHVjZSgocHJvbWlzZSwgdXJsKSA9PiB7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKCgpID0+XG4gICAgICAgIGZldGNoKHVybClcbiAgICAgICAgICAvLyBhbHdheXMgcmVzb2x2ZSwgYWxzbyBpbiBjYXNlIG9mIGEgZmV0Y2ggZXJyb3IgKHNvIHdlIGRvbid0IGJsb2NrIGZpcmluZyB0aGUgcmVzdCBvZiB0aGUgYmVhY29ucyBmb3IgdGhpcyBldmVudClcbiAgICAgICAgICAvLyBub3RlOiBmb3IgZmV0Y2ggZmFpbGVkIGh0dHAgcmVzcG9uc2VzIGRvbid0IHRocm93IGFuIEVycm9yIDopXG4gICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgIGZpcmVPbkNvbnN1bWVyKCdCZWFjb24nICsgZXZlbnQgKyAnU2VudCcpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaXJlT25Db25zdW1lcignQmVhY29uJyArIGV2ZW50ICsgJ0ZhaWxlZCcgKyByZXNwb25zZS5zdGF0dXMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICAgICAgICB9KVxuICAgICAgKVxuICAgIH0sIFByb21pc2UucmVzb2x2ZShudWxsKSlcbiAgfSBlbHNlIHtcbiAgICBMb2cuaW5mbygnQWQnLCAnTm8gY2FsbGJhY2sgZm91bmQgZm9yICcgKyBldmVudClcbiAgfVxufVxuXG5jb25zdCBmaXJlT25Db25zdW1lciA9IChldmVudCwgYXJncykgPT4ge1xuICBpZiAoY29uc3VtZXIpIHtcbiAgICBjb25zdW1lci5maXJlKCckYWQnICsgZXZlbnQsIGFyZ3MpXG4gICAgY29uc3VtZXIuZmlyZSgnJGFkRXZlbnQnLCBldmVudCwgYXJncylcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldChjb25maWcsIHZpZGVvUGxheWVyQ29uc3VtZXIpIHtcbiAgICBpZiAoY29uZmlnLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcHJlcm9sbHMoKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICBjb25zdW1lciA9IHZpZGVvUGxheWVyQ29uc3VtZXJcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIExvZy5pbmZvKCdBZCcsICdTdGFydGluZyBzZXNzaW9uJylcbiAgICAgIGdldEFkcyhjb25maWcpLnRoZW4oYWRzID0+IHtcbiAgICAgICAgTG9nLmluZm8oJ0FkJywgJ0FQSSByZXN1bHQnLCBhZHMpXG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIHByZXJvbGxzKCkge1xuICAgICAgICAgICAgaWYgKGFkcy5wcmVyb2xsKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZSA9IHRydWVcbiAgICAgICAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ1ByZXJvbGxTbG90SW1wcmVzc2lvbicsIGFkcylcbiAgICAgICAgICAgICAgc2VuZEJlYWNvbihhZHMucHJlcm9sbC5jYWxsYmFja3MsICdzbG90SW1wcmVzc2lvbicpXG4gICAgICAgICAgICAgIHJldHVybiBwbGF5U2xvdChhZHMucHJlcm9sbC5hZHMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZpcmVPbkNvbnN1bWVyKCdQcmVyb2xsU2xvdEVuZCcsIGFkcylcbiAgICAgICAgICAgICAgICBzZW5kQmVhY29uKGFkcy5wcmVyb2xsLmNhbGxiYWNrcywgJ3Nsb3RFbmQnKVxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZSA9IGZhbHNlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1pZHJvbGxzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3N0cm9sbHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuICBjYW5jZWwoKSB7XG4gICAgTG9nLmluZm8oJ0FkJywgJ0NhbmNlbCBBZCcpXG4gICAgc3RhdGUuYWN0aXZlID0gZmFsc2VcbiAgfSxcbiAgc3RvcCgpIHtcbiAgICBMb2cuaW5mbygnQWQnLCAnU3RvcCBBZCcpXG4gICAgc3RhdGUuYWN0aXZlID0gZmFsc2VcbiAgICAvLyBmaXhtZTogZHVwbGljYXRpb25cbiAgICBjb25zdCB2aWRlb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJylbMF1cbiAgICB2aWRlb0VsLnBhdXNlKClcbiAgICB2aWRlb0VsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJylcbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJ1xuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi9MaWdodG5pbmcnXG5pbXBvcnQgTG9jYWxlIGZyb20gJy4uL0xvY2FsZSdcbmltcG9ydCBNZXRyaWNzIGZyb20gJy4uL01ldHJpY3MnXG5pbXBvcnQgVmVyc2lvbkxhYmVsIGZyb20gJy4uL1ZlcnNpb25MYWJlbCdcbmltcG9ydCBGcHNDb3VudGVyIGZyb20gJy4uL0Zwc0NvdW50ZXInXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcbmltcG9ydCB7IGluaXRMYW5ndWFnZSB9IGZyb20gJy4uL0xhbmd1YWdlJ1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL1V0aWxzJ1xuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL1JlZ2lzdHJ5J1xuaW1wb3J0IHsgaW5pdENvbG9ycyB9IGZyb20gJy4uL0NvbG9ycydcblxuaW1wb3J0IHBhY2thZ2VJbmZvIGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbidcblxuZXhwb3J0IGxldCBBcHBJbnN0YW5jZVxuZXhwb3J0IGxldCBBcHBEYXRhXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBzdGFnZTogeyB3OiAxOTIwLCBoOiAxMDgwLCBjbGVhckNvbG9yOiAweDAwMDAwMDAwLCBjYW52YXMyZDogZmFsc2UgfSxcbiAgZGVidWc6IGZhbHNlLFxuICBkZWZhdWx0Rm9udEZhY2U6ICdSb2JvdG9SZWd1bGFyJyxcbiAga2V5czoge1xuICAgIDg6ICdCYWNrJyxcbiAgICAxMzogJ0VudGVyJyxcbiAgICAyNzogJ01lbnUnLFxuICAgIDM3OiAnTGVmdCcsXG4gICAgMzg6ICdVcCcsXG4gICAgMzk6ICdSaWdodCcsXG4gICAgNDA6ICdEb3duJyxcbiAgICAxNzQ6ICdDaGFubmVsRG93bicsXG4gICAgMTc1OiAnQ2hhbm5lbFVwJyxcbiAgICAxNzg6ICdTdG9wJyxcbiAgICAyNTA6ICdQbGF5UGF1c2UnLFxuICAgIDE5MTogJ1NlYXJjaCcsIC8vIFVzZSBcIi9cIiBmb3Iga2V5Ym9hcmRcbiAgICA0MDk6ICdTZWFyY2gnLFxuICB9LFxufVxuXG5jb25zdCBjdXN0b21Gb250RmFjZXMgPSBbXVxuXG5jb25zdCBmb250TG9hZGVyID0gKGZvbnRzLCBzdG9yZSkgPT5cbiAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZvbnRzXG4gICAgICAubWFwKCh7IGZhbWlseSwgdXJsLCB1cmxzLCBkZXNjcmlwdG9ycyB9KSA9PiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNyYyA9IHVybHNcbiAgICAgICAgICA/IHVybHMubWFwKHVybCA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiAndXJsKCcgKyB1cmwgKyAnKSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgOiAndXJsKCcgKyB1cmwgKyAnKSdcbiAgICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgRm9udEZhY2UoZmFtaWx5LCBzcmMsIGRlc2NyaXB0b3JzIHx8IHt9KVxuICAgICAgICBzdG9yZS5wdXNoKGZvbnRGYWNlKVxuICAgICAgICBMb2cuaW5mbygnTG9hZGluZyBmb250JywgZmFtaWx5KVxuICAgICAgICBkb2N1bWVudC5mb250cy5hZGQoZm9udEZhY2UpXG4gICAgICAgIHJldHVybiBmb250RmFjZS5sb2FkKClcbiAgICAgIH0pXG4gICAgICAucmVkdWNlKChwcm9taXNlLCBtZXRob2QpID0+IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiBtZXRob2QoKSlcbiAgICAgIH0sIFByb21pc2UucmVzb2x2ZShudWxsKSlcbiAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAuY2F0Y2gocmVqZWN0KVxuICB9KVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihBcHAsIGFwcERhdGEsIHBsYXRmb3JtU2V0dGluZ3MpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBwbGF0Zm9ybVNldHRpbmdzXG5cbiAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgIGRlZmF1bHRPcHRpb25zLnN0YWdlWyd3J10gPSB3aWR0aFxuICAgIGRlZmF1bHRPcHRpb25zLnN0YWdlWydoJ10gPSBoZWlnaHRcbiAgICBkZWZhdWx0T3B0aW9ucy5zdGFnZVsncHJlY2lzaW9uJ10gPSB3aWR0aCAvIDE5MjBcbiAgfVxuXG4gIC8vIHN1cHBvcnQgZm9yIDcyMHAgYnJvd3NlclxuICBpZiAoIXdpZHRoICYmICFoZWlnaHQgJiYgd2luZG93LmlubmVySGVpZ2h0ID09PSA3MjApIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5zdGFnZVsndyddID0gMTI4MFxuICAgIGRlZmF1bHRPcHRpb25zLnN0YWdlWydoJ10gPSA3MjBcbiAgICBkZWZhdWx0T3B0aW9ucy5zdGFnZVsncHJlY2lzaW9uJ10gPSAxMjgwIC8gMTkyMFxuICB9XG5cbiAgcmV0dXJuIGNsYXNzIEFwcGxpY2F0aW9uIGV4dGVuZHMgTGlnaHRuaW5nLkFwcGxpY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICBjb25zdCBjb25maWcgPSBEZWVwbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpXG4gICAgICAvLyBEZWVwbWVyZ2UgYnJlYWtzIEhUTUxDYW52YXNFbGVtZW50LCBzbyByZXN0b3JlIHRoZSBwYXNzZWQgaW4gY2FudmFzLlxuICAgICAgaWYgKG9wdGlvbnMuc3RhZ2UuY2FudmFzKSB7XG4gICAgICAgIGNvbmZpZy5zdGFnZS5jYW52YXMgPSBvcHRpb25zLnN0YWdlLmNhbnZhc1xuICAgICAgfVxuICAgICAgc3VwZXIoY29uZmlnKVxuICAgICAgdGhpcy5jb25maWcgPSBjb25maWdcbiAgICB9XG5cbiAgICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdzogMTkyMCxcbiAgICAgICAgaDogMTA4MCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0dXAoKSB7XG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMubG9hZEZvbnRzKChBcHAuY29uZmlnICYmIEFwcC5jb25maWcuZm9udHMpIHx8IChBcHAuZ2V0Rm9udHMgJiYgQXBwLmdldEZvbnRzKCkpIHx8IFtdKSxcbiAgICAgICAgLy8gdG8gYmUgZGVwcmVjYXRlZFxuICAgICAgICBMb2NhbGUubG9hZCgoQXBwLmNvbmZpZyAmJiBBcHAuY29uZmlnLmxvY2FsZSkgfHwgKEFwcC5nZXRMb2NhbGUgJiYgQXBwLmdldExvY2FsZSgpKSksXG4gICAgICAgIEFwcC5sYW5ndWFnZSAmJiB0aGlzLmxvYWRMYW5ndWFnZShBcHAubGFuZ3VhZ2UoKSksXG4gICAgICAgIEFwcC5jb2xvcnMgJiYgdGhpcy5sb2FkQ29sb3JzKEFwcC5jb2xvcnMoKSksXG4gICAgICBdKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgTWV0cmljcy5hcHAubG9hZGVkKClcblxuICAgICAgICAgIEFwcERhdGEgPSBhcHBEYXRhXG5cbiAgICAgICAgICBBcHBJbnN0YW5jZSA9IHRoaXMuc3RhZ2UuYyh7XG4gICAgICAgICAgICByZWY6ICdBcHAnLFxuICAgICAgICAgICAgdHlwZTogQXBwLFxuICAgICAgICAgICAgekluZGV4OiAxLFxuICAgICAgICAgICAgZm9yY2VaSW5kZXhDb250ZXh0OiAhIXBsYXRmb3JtU2V0dGluZ3Muc2hvd1ZlcnNpb24gfHwgISFwbGF0Zm9ybVNldHRpbmdzLnNob3dGcHMsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHRoaXMuY2hpbGRMaXN0LmEoQXBwSW5zdGFuY2UpXG5cbiAgICAgICAgICB0aGlzLl9yZWZvY3VzKClcblxuICAgICAgICAgIExvZy5pbmZvKCdBcHAgdmVyc2lvbicsIHRoaXMuY29uZmlnLnZlcnNpb24pXG4gICAgICAgICAgTG9nLmluZm8oJ1NESyB2ZXJzaW9uJywgcGFja2FnZUluZm8udmVyc2lvbilcblxuICAgICAgICAgIGlmIChwbGF0Zm9ybVNldHRpbmdzLnNob3dWZXJzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTGlzdC5hKHtcbiAgICAgICAgICAgICAgcmVmOiAnVmVyc2lvbkxhYmVsJyxcbiAgICAgICAgICAgICAgdHlwZTogVmVyc2lvbkxhYmVsLFxuICAgICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLmNvbmZpZy52ZXJzaW9uLFxuICAgICAgICAgICAgICBzZGtWZXJzaW9uOiBwYWNrYWdlSW5mby52ZXJzaW9uLFxuICAgICAgICAgICAgICB6SW5kZXg6IDEsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwbGF0Zm9ybVNldHRpbmdzLnNob3dGcHMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRMaXN0LmEoe1xuICAgICAgICAgICAgICByZWY6ICdGcHNDb3VudGVyJyxcbiAgICAgICAgICAgICAgdHlwZTogRnBzQ291bnRlcixcbiAgICAgICAgICAgICAgekluZGV4OiAxLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdXBlci5fc2V0dXAoKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcilcbiAgICB9XG5cbiAgICBfaGFuZGxlQmFjaygpIHtcbiAgICAgIHRoaXMuY2xvc2VBcHAoKVxuICAgIH1cblxuICAgIF9oYW5kbGVFeGl0KCkge1xuICAgICAgdGhpcy5jbG9zZUFwcCgpXG4gICAgfVxuXG4gICAgY2xvc2VBcHAoKSB7XG4gICAgICBMb2cuaW5mbygnU2lnbmFsaW5nIEFwcCBDbG9zZScpXG5cbiAgICAgIGlmIChwbGF0Zm9ybVNldHRpbmdzLm9uQ2xvc2UgJiYgdHlwZW9mIHBsYXRmb3JtU2V0dGluZ3Mub25DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwbGF0Zm9ybVNldHRpbmdzLm9uQ2xvc2UoLi4uYXJndW1lbnRzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICBMb2cuaW5mbygnQ2xvc2luZyBBcHAnKVxuXG4gICAgICBTZXR0aW5ncy5jbGVhclN1YnNjcmliZXJzKClcbiAgICAgIFJlZ2lzdHJ5LmNsZWFyKClcblxuICAgICAgdGhpcy5jaGlsZExpc3QucmVtb3ZlKHRoaXMudGFnKCdBcHAnKSlcbiAgICAgIHRoaXMuY2xlYW51cEZvbnRzKClcbiAgICAgIC8vIGZvcmNlIHRleHR1cmUgZ2FyYmFnZSBjb2xsZWN0XG4gICAgICB0aGlzLnN0YWdlLmdjKClcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgbG9hZEZvbnRzKGZvbnRzKSB7XG4gICAgICByZXR1cm4gcGxhdGZvcm1TZXR0aW5ncy5mb250TG9hZGVyICYmIHR5cGVvZiBwbGF0Zm9ybVNldHRpbmdzLmZvbnRMb2FkZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwbGF0Zm9ybVNldHRpbmdzLmZvbnRMb2FkZXIoZm9udHMsIGN1c3RvbUZvbnRGYWNlcylcbiAgICAgICAgOiBmb250TG9hZGVyKGZvbnRzLCBjdXN0b21Gb250RmFjZXMpXG4gICAgfVxuXG4gICAgY2xlYW51cEZvbnRzKCkge1xuICAgICAgaWYgKCdkZWxldGUnIGluIGRvY3VtZW50LmZvbnRzKSB7XG4gICAgICAgIGN1c3RvbUZvbnRGYWNlcy5mb3JFYWNoKGZvbnRGYWNlID0+IHtcbiAgICAgICAgICBMb2cuaW5mbygnUmVtb3ZpbmcgZm9udCcsIGZvbnRGYWNlLmZhbWlseSlcbiAgICAgICAgICBkb2N1bWVudC5mb250cy5kZWxldGUoZm9udEZhY2UpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMb2cuaW5mbygnTm8gc3VwcG9ydCBmb3IgcmVtb3ZpbmcgbWFudWFsbHktYWRkZWQgZm9udHMnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRMYW5ndWFnZShjb25maWcpIHtcbiAgICAgIGxldCBmaWxlID0gVXRpbHMuYXNzZXQoJ3RyYW5zbGF0aW9ucy5qc29uJylcbiAgICAgIGxldCBsYW5ndWFnZSA9IGNvbmZpZ1xuXG4gICAgICBpZiAodHlwZW9mIGxhbmd1YWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBsYW5ndWFnZSA9IGNvbmZpZy5sYW5ndWFnZSB8fCBudWxsXG4gICAgICAgIGZpbGUgPSBjb25maWcuZmlsZSB8fCBmaWxlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbml0TGFuZ3VhZ2UoZmlsZSwgbGFuZ3VhZ2UpXG4gICAgfVxuXG4gICAgbG9hZENvbG9ycyhjb25maWcpIHtcbiAgICAgIGxldCBmaWxlID0gVXRpbHMuYXNzZXQoJ2NvbG9ycy5qc29uJylcbiAgICAgIGlmIChjb25maWcgJiYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSkge1xuICAgICAgICBmaWxlID0gY29uZmlnXG4gICAgICB9XG4gICAgICByZXR1cm4gaW5pdENvbG9ycyhmaWxlKVxuICAgIH1cblxuICAgIHNldCBmb2N1cyh2KSB7XG4gICAgICB0aGlzLl9mb2N1c3NlZCA9IHZcbiAgICAgIHRoaXMuX3JlZm9jdXMoKVxuICAgIH1cblxuICAgIF9nZXRGb2N1c2VkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZvY3Vzc2VkIHx8IHRoaXMudGFnKCdBcHAnKVxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXVkaW9QbGF5ZXIge31cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMb2cgZnJvbSAnLi4vTG9nJ1xuaW1wb3J0IHsgbWVyZ2VDb2xvcnMsIGNhbGN1bGF0ZUFscGhhLCBpc09iamVjdCwgaXNTdHJpbmcsIGFyZ2JUb0hTTEEsIGhzbGFUb0FSR0IgfSBmcm9tICcuL3V0aWxzLmpzJ1xuXG5sZXQgY29sb3JzID0ge1xuICB3aGl0ZTogJyNmZmZmZmYnLFxuICBibGFjazogJyMwMDAwMDAnLFxuICByZWQ6ICcjZmYwMDAwJyxcbiAgZ3JlZW46ICcjMDBmZjAwJyxcbiAgYmx1ZTogJyMwMDAwZmYnLFxuICB5ZWxsb3c6ICcjZmVmZjAwJyxcbiAgY3lhbjogJyMwMGZlZmYnLFxuICBtYWdlbnRhOiAnI2ZmMDBmZicsXG59XG5cbmNvbnN0IG5vcm1hbGl6ZWRDb2xvcnMgPSB7XG4gIC8vc3RvcmUgZm9yIG5vcm1hbGl6ZWQgY29sb3JzXG59XG5cbmNvbnN0IGFkZENvbG9ycyA9IChjb2xvcnNUb0FkZCwgdmFsdWUpID0+IHtcbiAgaWYgKGlzT2JqZWN0KGNvbG9yc1RvQWRkKSkge1xuICAgIC8vIGNsZWFuIHVwIG5vcm1hbGl6ZWRDb2xvcnMgaWYgdGhleSBleGlzdCBpbiB0aGUgdG8gYmUgYWRkZWQgY29sb3JzXG4gICAgT2JqZWN0LmtleXMoY29sb3JzVG9BZGQpLmZvckVhY2goY29sb3IgPT4gY2xlYW5VcE5vcm1hbGl6ZWRDb2xvcnMoY29sb3IpKVxuICAgIGNvbG9ycyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbG9ycywgY29sb3JzVG9BZGQpXG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcoY29sb3JzVG9BZGQpICYmIHZhbHVlKSB7XG4gICAgY2xlYW5VcE5vcm1hbGl6ZWRDb2xvcnMoY29sb3JzVG9BZGQpXG4gICAgY29sb3JzW2NvbG9yc1RvQWRkXSA9IHZhbHVlXG4gIH1cbn1cblxuY29uc3QgY2xlYW5VcE5vcm1hbGl6ZWRDb2xvcnMgPSBjb2xvciA9PiB7XG4gIGZvciAobGV0IGMgaW4gbm9ybWFsaXplZENvbG9ycykge1xuICAgIGlmIChjLmluZGV4T2YoY29sb3IpID4gLTEpIHtcbiAgICAgIGRlbGV0ZSBub3JtYWxpemVkQ29sb3JzW2NdXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbml0Q29sb3JzID0gZmlsZSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBmaWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgYWRkQ29sb3JzKGZpbGUpXG4gICAgICByZXNvbHZlKClcbiAgICB9XG4gICAgZmV0Y2goZmlsZSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICBhZGRDb2xvcnMoanNvbilcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAnQ29sb3JzIGZpbGUgJyArIGZpbGUgKyAnIG5vdCBmb3VuZCdcbiAgICAgICAgTG9nLmVycm9yKGVycm9yKVxuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9KVxuICB9KVxufVxuXG5jb25zdCBub3JtYWxpemVDb2xvclRvQVJHQiA9IGNvbG9yID0+IHtcbiAgbGV0IHRhcmdldENvbG9yID0gbm9ybWFsaXplZENvbG9yc1tjb2xvcl0gfHwgY29sb3JzW2NvbG9yXSB8fCBjb2xvclxuICBpZiAoIXRhcmdldENvbG9yKSB7XG4gICAgdGFyZ2V0Q29sb3IgPSBjb2xvclxuICB9XG4gIGNvbnN0IGNoZWNrID0gL14jKFswLTlBLUZdezN9fFswLTlBLUZdezZ9KSQvaVxuICBpZiAoaXNTdHJpbmcodGFyZ2V0Q29sb3IpICYmIGNoZWNrLnRlc3QodGFyZ2V0Q29sb3IpKSB7XG4gICAgbGV0IGhleCA9IGNoZWNrLmV4ZWModGFyZ2V0Q29sb3IpWzFdXG4gICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICAgIGhleCA9IGhleFxuICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgIC5tYXAodmFsdWUgPT4ge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSArIHZhbHVlXG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcnKVxuICAgIH1cbiAgICB0YXJnZXRDb2xvciA9IGAweGZmJHtoZXh9YCAqIDFcbiAgfVxuICBpZiAoIW5vcm1hbGl6ZWRDb2xvcnNbY29sb3JdKSB7XG4gICAgbm9ybWFsaXplZENvbG9yc1tjb2xvcl0gPSB0YXJnZXRDb2xvclxuICB9XG4gIHJldHVybiB0YXJnZXRDb2xvciB8fCAweGZmZmZmZmZmXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbG9yID0+IHtcbiAgcmV0dXJuIENvbG9yLmdlbmVyYXRlKGNvbG9yKVxufVxuXG5jb25zdCBDb2xvciA9IHtcbiAgY29sb3I6IG51bGwsXG4gIGdlbmVyYXRlOiBmdW5jdGlvbih2YWx1ZSA9IHRoaXMuY29sb3IpIHtcbiAgICBpZiAobm9ybWFsaXplZENvbG9yc1t2YWx1ZV0pIHtcbiAgICAgIHRoaXMuY29sb3IgPSBub3JtYWxpemVkQ29sb3JzW3ZhbHVlXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbG9yID0gbm9ybWFsaXplQ29sb3JUb0FSR0IodmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclxuICB9LFxuICBhbHBoYTogZnVuY3Rpb24ocGVyY2VudGFnZSkge1xuICAgIHRoaXMuY29sb3IgPSBjYWxjdWxhdGVBbHBoYSh0aGlzLmNvbG9yLCBNYXRoLmFicyhwZXJjZW50YWdlKSlcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICBkYXJrZXIocGVyY2VudGFnZSkge1xuICAgIGNvbnN0IGhzbCA9IGFyZ2JUb0hTTEEodGhpcy5jb2xvcilcbiAgICBoc2wubCA9IGhzbC5sICogKDEgLSBwZXJjZW50YWdlKVxuICAgIHRoaXMuY29sb3IgPSBoc2xhVG9BUkdCKGhzbClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICBsaWdodGVyKHBlcmNlbnRhZ2UpIHtcbiAgICBjb25zdCBoc2wgPSBhcmdiVG9IU0xBKHRoaXMuY29sb3IpXG4gICAgaHNsLmwgPSBoc2wubCArICgxIC0gaHNsLmwpICogcGVyY2VudGFnZVxuICAgIHRoaXMuY29sb3IgPSBoc2xhVG9BUkdCKGhzbClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICBzYXR1cmF0aW9uKHBlcmNlbnRhZ2UpIHtcbiAgICBjb25zdCBoc2wgPSBhcmdiVG9IU0xBKHRoaXMuY29sb3IpXG4gICAgaHNsLnMgPSBwZXJjZW50YWdlXG4gICAgdGhpcy5jb2xvciA9IGhzbGFUb0FSR0IoaHNsKVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIGxpZ2h0bmVzcyhwZXJjZW50YWdlKSB7XG4gICAgY29uc3QgaHNsID0gYXJnYlRvSFNMQSh0aGlzLmNvbG9yKVxuICAgIGhzbC5sID0gcGVyY2VudGFnZVxuICAgIHRoaXMuY29sb3IgPSBoc2xhVG9BUkdCKGhzbClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICBodWUoZGVncmVlcykge1xuICAgIGNvbnN0IGhzbCA9IGFyZ2JUb0hTTEEodGhpcy5jb2xvcilcbiAgICBoc2wuaCA9IGRlZ3JlZXNcbiAgICB0aGlzLmNvbG9yID0gaHNsYVRvQVJHQihoc2wpXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgbWl4KGFyZ2IsIHApIHtcbiAgICB0aGlzLmNvbG9yID0gbWVyZ2VDb2xvcnModGhpcy5jb2xvciwgYXJnYiwgcClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gdiA9PiB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbFxufVxuXG5leHBvcnQgY29uc3QgaXNTdHJpbmcgPSB2ID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJ1xufVxuXG5leHBvcnQgY29uc3QgZ2V0UmdiYUNvbXBvbmVudHMgPSBhcmdiID0+IHtcbiAgcmV0dXJuIHtcbiAgICByOiAoKGFyZ2IgLyA2NTUzNikgfCAwKSAlIDI1NixcbiAgICBnOiAoKGFyZ2IgLyAyNTYpIHwgMCkgJSAyNTYsXG4gICAgYjogKGFyZ2IgKiAxKSAlIDI1NixcbiAgICBhOiAoYXJnYiAvIDE2Nzc3MjE2KSB8IDAsXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxpbWl0V2l0aGluUmFuZ2UgPSAobnVtLCBtaW4sIG1heCkgPT4ge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpXG59XG5cbmV4cG9ydCBjb25zdCBtZXJnZUNvbG9ycyA9IChjMSwgYzIsIHApID0+IHtcbiAgbGV0IHIxID0gKChjMSAvIDY1NTM2KSB8IDApICUgMjU2XG4gIGxldCBnMSA9ICgoYzEgLyAyNTYpIHwgMCkgJSAyNTZcbiAgbGV0IGIxID0gYzEgJSAyNTZcbiAgbGV0IGExID0gKGMxIC8gMTY3NzcyMTYpIHwgMFxuICBsZXQgcjIgPSAoKGMyIC8gNjU1MzYpIHwgMCkgJSAyNTZcbiAgbGV0IGcyID0gKChjMiAvIDI1NikgfCAwKSAlIDI1NlxuICBsZXQgYjIgPSBjMiAlIDI1NlxuICBsZXQgYTIgPSAoYzIgLyAxNjc3NzIxNikgfCAwXG4gIGxldCByID0gcjEgKiBwICsgcjIgKiAoMSAtIHApXG4gIGxldCBnID0gZzEgKiBwICsgZzIgKiAoMSAtIHApXG4gIGxldCBiID0gYjEgKiBwICsgYjIgKiAoMSAtIHApXG4gIGxldCBhID0gYTEgKiBwICsgYTIgKiAoMSAtIHApXG4gIHJldHVybiBNYXRoLnJvdW5kKGEpICogMTY3NzcyMTYgKyBNYXRoLnJvdW5kKHIpICogNjU1MzYgKyBNYXRoLnJvdW5kKGcpICogMjU2ICsgTWF0aC5yb3VuZChiKVxufVxuXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlQWxwaGEgPSAoYXJnYiwgcCkgPT4ge1xuICBpZiAocCA+IDEpIHtcbiAgICBwIC89IDEwMFxuICB9IGVsc2UgaWYgKHAgPCAwKSB7XG4gICAgcCA9IDBcbiAgfVxuICBsZXQgciA9ICgoYXJnYiAvIDY1NTM2KSB8IDApICUgMjU2XG4gIGxldCBnID0gKChhcmdiIC8gMjU2KSB8IDApICUgMjU2XG4gIGxldCBiID0gYXJnYiAlIDI1NlxuICByZXR1cm4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiICsgKChwICogMjU1KSB8IDApICogMTY3NzcyMTZcbn1cblxuZXhwb3J0IGNvbnN0IG1lcmdlQ29sb3JBbHBoYSA9IChjLCBhbHBoYSkgPT4ge1xuICBsZXQgYSA9ICgoKGMgLyAxNjc3NzIxNikgfCAwKSAqIGFscGhhKSB8IDBcbiAgcmV0dXJuIChcbiAgICAoKCgoKGMgPj4gMTYpICYgMHhmZikgKiBhKSAvIDI1NSkgJiAweGZmKSArXG4gICAgKCgoKGMgJiAweGZmMDApICogYSkgLyAyNTUpICYgMHhmZjAwKSArXG4gICAgKCgoKChjICYgMHhmZikgPDwgMTYpICogYSkgLyAyNTUpICYgMHhmZjAwMDApICtcbiAgICAoYSA8PCAyNClcbiAgKVxufVxuXG5jb25zdCBnZXRBcmdiTnVtYmVyID0gcmdiYSA9PiB7XG4gIHJnYmFbMF0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbMF0pKVxuICByZ2JhWzFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzFdKSlcbiAgcmdiYVsyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVsyXSkpXG4gIHJnYmFbM10gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbM10pKVxuICBsZXQgdiA9ICgocmdiYVszXSB8IDApIDw8IDI0KSArICgocmdiYVswXSB8IDApIDw8IDE2KSArICgocmdiYVsxXSB8IDApIDw8IDgpICsgKHJnYmFbMl0gfCAwKVxuICBpZiAodiA8IDApIHtcbiAgICB2ID0gMHhmZmZmZmZmZiArIHYgKyAxXG4gIH1cbiAgcmV0dXJuIHZcbn1cblxuZXhwb3J0IGNvbnN0IGFyZ2JUb0hzdmEgPSBhcmdiID0+IHtcbiAgY29uc3QgY29sb3IgPSBnZXRSZ2JhQ29tcG9uZW50cyhhcmdiKVxuICBsZXQgciA9IGNvbG9yLnIgLyAyNTVcbiAgbGV0IGcgPSBjb2xvci5nIC8gMjU1XG4gIGxldCBiID0gY29sb3IuYiAvIDI1NVxuICBsZXQgaCA9IDBcbiAgbGV0IHMgPSAwXG5cbiAgY29uc3QgY01heCA9IE1hdGgubWF4KHIsIGcsIGIpXG4gIGNvbnN0IGNNaW4gPSBNYXRoLm1pbihyLCBnLCBiKVxuICBjb25zdCBkZWx0YSA9IGNNYXggLSBjTWluXG5cbiAgLy9jYWxjdWxhdGUgaHVlXG4gIGlmIChkZWx0YSA8IDAuMDAwMDEpIHtcbiAgICBoID0gMFxuICB9IGVsc2UgaWYgKGNNYXggIT09IDAgfHwgY01pbiAhPT0gMCkge1xuICAgIGlmIChyID09PSBjTWF4KSB7XG4gICAgICBoID0gKDYwICogKChnIC0gYikgLyBkZWx0YSkgKyAzNjApICUgMzYwXG4gICAgfSBlbHNlIGlmIChnID09PSBjTWF4KSB7XG4gICAgICBoID0gKDYwICogKChiIC0gcikgLyBkZWx0YSkgKyAxMjApICUgMzYwXG4gICAgfSBlbHNlIGlmIChiID09PSBjTWF4KSB7XG4gICAgICBoID0gKDYwICogKChyIC0gZykgLyBkZWx0YSkgKyAyNDApICUgMzYwXG4gICAgfVxuICB9XG5cbiAgLy9jYWxjIHNhdHVyYXRpb25cbiAgaWYgKGNNYXggPiAwKSB7XG4gICAgcyA9IGRlbHRhIC8gY01heFxuICB9XG4gIHJldHVybiB7XG4gICAgaCxcbiAgICBzLFxuICAgIHY6IGNNYXgsXG4gICAgYTogY29sb3IuYSAvIDI1NSxcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaHN2YVRvQXJnYiA9IGNvbG9yID0+IHtcbiAgY29uc3QgaCA9IGNvbG9yLmhcbiAgY29uc3QgYyA9IGNvbG9yLnYgKiBjb2xvci5zXG4gIGNvbnN0IG0gPSBjb2xvci52IC0gY1xuICBjb25zdCB4ID0gYyAqICgxLjAgLSBNYXRoLmFicygoKGggLyA2MCkgJSAyKSAtIDEpKVxuICBsZXQgciA9IDBcbiAgbGV0IGcgPSAwXG4gIGxldCBiID0gMFxuXG4gIGlmICgwIDw9IGggJiYgaCA8IDYwKSB7XG4gICAgciA9IGNcbiAgICBnID0geFxuICB9IGVsc2UgaWYgKDYwIDw9IGggJiYgaCA8IDEyMCkge1xuICAgIHIgPSB4XG4gICAgZyA9IGNcbiAgfSBlbHNlIGlmICgxMjAgPD0gaCAmJiBoIDwgMTgwKSB7XG4gICAgZyA9IGNcbiAgICBiID0geFxuICB9IGVsc2UgaWYgKDE4MCA8PSBoICYmIGggPCAyNDApIHtcbiAgICBnID0geFxuICAgIGIgPSBjXG4gIH0gZWxzZSBpZiAoMjQwIDw9IGggJiYgaCA8IDMwMCkge1xuICAgIHIgPSB4XG4gICAgYiA9IGNcbiAgfSBlbHNlIGlmICgzMDAgPD0gaCAmJiBoIDwgMzYwKSB7XG4gICAgciA9IGNcbiAgICBiID0geFxuICB9XG5cbiAgciA9IE1hdGgucm91bmQoKHIgKyBtKSAqIDI1NS4wKVxuICBnID0gTWF0aC5yb3VuZCgoZyArIG0pICogMjU1LjApXG4gIGIgPSBNYXRoLnJvdW5kKChiICsgbSkgKiAyNTUuMClcbiAgcmV0dXJuIGdldEFyZ2JOdW1iZXIoW3IsIGcsIGIsIGNvbG9yLmEgKiAyNTVdKVxufVxuXG5leHBvcnQgY29uc3QgYXJnYlRvSFNMQSA9IGFyZ2IgPT4ge1xuICBjb25zdCBjb2wgPSBnZXRSZ2JhQ29tcG9uZW50cyhhcmdiKVxuICBjb25zdCByID0gY29sLnIgLyAyNTVcbiAgY29uc3QgZyA9IGNvbC5nIC8gMjU1XG4gIGNvbnN0IGIgPSBjb2wuYiAvIDI1NVxuXG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpXG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpXG5cbiAgbGV0IGggPSAwXG4gIGxldCBzID0gMFxuICBjb25zdCBsID0gKG1pbiArIG1heCkgKiAwLjVcbiAgaWYgKGwgPiAwKSB7XG4gICAgY29uc3QgbWF4TWluID0gbWF4IC0gbWluXG4gICAgaWYgKG1heE1pbiA+IDApIHtcbiAgICAgIGNvbnN0IHIyID0gKG1heCAtIHIpIC8gbWF4TWluXG4gICAgICBjb25zdCBnMiA9IChtYXggLSBnKSAvIG1heE1pblxuICAgICAgY29uc3QgYjIgPSAobWF4IC0gYikgLyBtYXhNaW5cbiAgICAgIGlmIChsIDwgMC41KSB7XG4gICAgICAgIHMgPSBtYXggKyBtaW5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSAyIC0gbWF4IC0gbWluXG4gICAgICB9XG5cbiAgICAgIGlmIChyID09PSBtYXggJiYgZyA9PT0gbWluKSB7XG4gICAgICAgIGggPSA1LjAgKyBiMlxuICAgICAgfSBlbHNlIGlmIChyID09PSBtYXgpIHtcbiAgICAgICAgaCA9IDEuMCAtIGcyXG4gICAgICB9IGVsc2UgaWYgKGcgPT09IG1heCAmJiBiID09PSBtaW4pIHtcbiAgICAgICAgaCA9IDEuMCArIHIyXG4gICAgICB9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuICAgICAgICBoID0gMy4wIC0gYjJcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gbWF4KSB7XG4gICAgICAgIGggPSAzLjAgKyBnMlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IDUuMCAtIHIyXG4gICAgICB9XG4gICAgICBoID0gaCAvIDZcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaDogaCAlIDEsIHMsIGwsIGE6IGNvbC5hIH1cbn1cblxuZXhwb3J0IGNvbnN0IGhzbGFUb0FSR0IgPSBoc2xhID0+IHtcbiAgbGV0IHIgPSAxXG4gIGxldCBnID0gMVxuICBsZXQgYiA9IDFcblxuICBsZXQgaCA9IGhzbGEuaFxuICBsZXQgcyA9IGhzbGEuc1xuICBsZXQgbCA9IGhzbGEubFxuXG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMVxuICB9XG4gIGxldCBtYXggPSAwXG4gIGlmIChsIDw9IDAuNSkge1xuICAgIG1heCA9IGwgKiAoMS4wICsgcylcbiAgfSBlbHNlIHtcbiAgICBtYXggPSBsICsgcyAtIGwgKiBzXG4gIH1cblxuICBpZiAobWF4ID4gMCkge1xuICAgIGggKj0gNi4wXG4gICAgY29uc3QgbWluID0gbCArIGwgLSBtYXhcbiAgICBjb25zdCBtaW5NYXggPSAobWF4IC0gbWluKSAvIG1heFxuICAgIGNvbnN0IHNleHRhbnQgPSBNYXRoLmZsb29yKGgpXG4gICAgY29uc3QgZnJhY3QgPSBoIC0gc2V4dGFudFxuICAgIGNvbnN0IG1pbk1heEZyYWN0ID0gbWF4ICogbWluTWF4ICogZnJhY3RcbiAgICBjb25zdCBtaWQxID0gbWluICsgbWluTWF4RnJhY3RcbiAgICBjb25zdCBtaWQyID0gbWF4IC0gbWluTWF4RnJhY3RcblxuICAgIGlmIChzZXh0YW50ID09PSAwKSB7XG4gICAgICByID0gbWF4XG4gICAgICBnID0gbWlkMVxuICAgICAgYiA9IG1pblxuICAgIH1cbiAgICBpZiAoc2V4dGFudCA9PT0gMSkge1xuICAgICAgciA9IG1pZDJcbiAgICAgIGcgPSBtYXhcbiAgICAgIGIgPSBtaW5cbiAgICB9XG4gICAgaWYgKHNleHRhbnQgPT09IDIpIHtcbiAgICAgIHIgPSBtaW5cbiAgICAgIGcgPSBtYXhcbiAgICAgIGIgPSBtaWQxXG4gICAgfVxuICAgIGlmIChzZXh0YW50ID09PSAzKSB7XG4gICAgICByID0gbWluXG4gICAgICBnID0gbWlkMlxuICAgICAgYiA9IG1heFxuICAgIH1cbiAgICBpZiAoc2V4dGFudCA9PT0gNCkge1xuICAgICAgciA9IG1pZDFcbiAgICAgIGcgPSBtaW5cbiAgICAgIGIgPSBtYXhcbiAgICB9XG4gICAgaWYgKHNleHRhbnQgPT09IDUpIHtcbiAgICAgIHIgPSBtYXhcbiAgICAgIGcgPSBtaW5cbiAgICAgIGIgPSBtaWQyXG4gICAgfVxuICB9XG4gIHJldHVybiBnZXRBcmdiTnVtYmVyKFtNYXRoLmZsb29yKHIgKiAyNTUpLCBNYXRoLmZsb29yKGcgKiAyNTUpLCBNYXRoLmZsb29yKGIgKiAyNTUpLCBoc2xhLmFdKVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi9MaWdodG5pbmcnXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZwc0luZGljYXRvciBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWN0OiB0cnVlLFxuICAgICAgY29sb3I6IDB4ZmZmZmZmZmYsXG4gICAgICB0ZXh0dXJlOiBMaWdodG5pbmcuVG9vbHMuZ2V0Um91bmRSZWN0KDgwLCA4MCwgNDApLFxuICAgICAgaDogODAsXG4gICAgICB3OiA4MCxcbiAgICAgIHg6IDEwMCxcbiAgICAgIHk6IDEwMCxcbiAgICAgIG1vdW50OiAxLFxuICAgICAgQmFja2dyb3VuZDoge1xuICAgICAgICB4OiAzLFxuICAgICAgICB5OiAzLFxuICAgICAgICB0ZXh0dXJlOiBMaWdodG5pbmcuVG9vbHMuZ2V0Um91bmRSZWN0KDcyLCA3MiwgMzYpLFxuICAgICAgICBjb2xvcjogMHhmZjAwODAwMCxcbiAgICAgIH0sXG4gICAgICBDb3VudGVyOiB7XG4gICAgICAgIHc6IHcgPT4gdyxcbiAgICAgICAgaDogaCA9PiBoLFxuICAgICAgICB5OiAxMCxcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIGZvbnRTaXplOiAzMixcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIFRleHQ6IHtcbiAgICAgICAgdzogdyA9PiB3LFxuICAgICAgICBoOiBoID0+IGgsXG4gICAgICAgIHk6IDQ4LFxuICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgZm9udFNpemU6IDE1LFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdGV4dDogJ0ZQUycsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIF9zZXR1cCgpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLntcbiAgICAgICAgbG9nOiBmYWxzZSxcbiAgICAgICAgaW50ZXJ2YWw6IDUwMCxcbiAgICAgICAgdGhyZXNob2xkOiAxLFxuICAgICAgfSxcbiAgICAgIC4uLlNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnc2hvd0ZwcycpLFxuICAgIH1cblxuICAgIHRoaXMuZnBzID0gMFxuICAgIHRoaXMubGFzdEZwcyA9IHRoaXMuZnBzIC0gdGhpcy5jb25maWcudGhyZXNob2xkXG5cbiAgICBjb25zdCBmcHNDYWxjdWxhdG9yID0gKCkgPT4ge1xuICAgICAgdGhpcy5mcHMgPSB+figxIC8gdGhpcy5zdGFnZS5kdClcbiAgICB9XG4gICAgdGhpcy5zdGFnZS5vbignZnJhbWVTdGFydCcsIGZwc0NhbGN1bGF0b3IpXG4gICAgdGhpcy5zdGFnZS5vZmYoJ2ZyYW1lc3RhcnQnLCBmcHNDYWxjdWxhdG9yKVxuICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLnNob3dGcHMuYmluZCh0aGlzKSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpXG4gIH1cblxuICBfZmlyc3RBY3RpdmUoKSB7XG4gICAgdGhpcy5zaG93RnBzKClcbiAgfVxuXG4gIF9kZXRhY2goKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuICB9XG5cbiAgc2hvd0ZwcygpIHtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5sYXN0RnBzIC0gdGhpcy5mcHMpIDw9IHRoaXMuY29uZmlnLnRocmVzaG9sZCkgcmV0dXJuXG4gICAgdGhpcy5sYXN0RnBzID0gdGhpcy5mcHNcbiAgICAvLyBncmVlblxuICAgIGxldCBiZ0NvbG9yID0gMHhmZjAwODAwMFxuICAgIC8vIG9yYW5nZVxuICAgIGlmICh0aGlzLmZwcyA8PSA0MCAmJiB0aGlzLmZwcyA+IDIwKSBiZ0NvbG9yID0gMHhmZmZmYTUwMFxuICAgIC8vIHJlZFxuICAgIGVsc2UgaWYgKHRoaXMuZnBzIDw9IDIwKSBiZ0NvbG9yID0gMHhmZmZmMDAwMFxuXG4gICAgdGhpcy50YWcoJ0JhY2tncm91bmQnKS5zZXRTbW9vdGgoJ2NvbG9yJywgYmdDb2xvcilcbiAgICB0aGlzLnRhZygnQ291bnRlcicpLnRleHQgPSBgJHt0aGlzLmZwc31gXG5cbiAgICB0aGlzLmNvbmZpZy5sb2cgJiYgTG9nLmluZm8oJ0ZQUycsIHRoaXMuZnBzKVxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGlnaHRuaW5nIGZyb20gJy4uL0xpZ2h0bmluZydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhbGVkSW1hZ2VUZXh0dXJlIGV4dGVuZHMgTGlnaHRuaW5nLnRleHR1cmVzLkltYWdlVGV4dHVyZSB7XG4gIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgc3VwZXIoc3RhZ2UpXG4gICAgdGhpcy5fc2NhbGluZ09wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLnJlc2l6ZU1vZGUgPSB0aGlzLl9zY2FsaW5nT3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIF9nZXRMb29rdXBJZCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fc3JjfS0ke3RoaXMuX3NjYWxpbmdPcHRpb25zLnR5cGV9LSR7dGhpcy5fc2NhbGluZ09wdGlvbnMud30tJHt0aGlzLl9zY2FsaW5nT3B0aW9ucy5ofWBcbiAgfVxuXG4gIGdldE5vbkRlZmF1bHRzKCkge1xuICAgIGNvbnN0IG9iaiA9IHN1cGVyLmdldE5vbkRlZmF1bHRzKClcbiAgICBpZiAodGhpcy5fc3JjKSB7XG4gICAgICBvYmouc3JjID0gdGhpcy5fc3JjXG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL1V0aWxzJ1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuaW1wb3J0IFNjYWxlZEltYWdlVGV4dHVyZSBmcm9tICcuL1NjYWxlZEltYWdlVGV4dHVyZSdcblxuZXhwb3J0IGRlZmF1bHQgKGltYWdlVXJsLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGltYWdlU2VydmVyVXJsID0gU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdpbWFnZVNlcnZlclVybCcpXG5cbiAgLy8gbWFrZSBhbmQgcmV0dXJuIFNjYWxlZEltYWdlVGV4dHVyZVxuICBjb25zdCBtYWtlID0gb3B0aW9ucyA9PiB7XG4gICAgLy8gbG9jYWwgYXNzZXQsIHdyYXAgaXQgaW4gVXRpbHMuYXNzZXQoKVxuICAgIGlmICghL14oPzpodHRwcz86KT9cXC9cXC8vaS50ZXN0KGltYWdlVXJsKSkge1xuICAgICAgaW1hZ2VVcmwgPSBVdGlscy5hc3NldChpbWFnZVVybClcbiAgICB9XG5cbiAgICAvLyBvbmx5IHBhc3MgdG8gaW1hZ2Ugc2VydmVyIGlmIGltYWdlU2VydmVyVXJsIGlzIGNvbmZpZ3VyZWRcbiAgICAvLyBhbmQgaWYgdGhlIGFzc2V0IGlzbid0IGxvY2FsIHRvIHRoZSBhcHAgKGkuZS4gaGFzIHNhbWUgb3JpZ2luKVxuICAgIGlmIChpbWFnZVNlcnZlclVybCAmJiBpbWFnZVVybC5pbmRleE9mKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pID09PSAtMSkge1xuICAgICAgaW1hZ2VVcmwgPSBVdGlscy5lbnN1cmVVcmxXaXRoUHJvdG9jb2woXG4gICAgICAgIGltYWdlU2VydmVyVXJsICsgJz8nICsgVXRpbHMubWFrZVF1ZXJ5U3RyaW5nKGltYWdlVXJsLCBvcHRpb25zKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaWdodG5pbmcgd2lsbCBoYW5kbGUgdGhlIHJlc2l6aW5nIGFuZCBoYXMgb25seSAyIGZsYXZvdXJzIChjb3ZlciBhbmQgY29udGFpbilcbiAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdjcm9wJykgb3B0aW9ucy50eXBlID0gJ2NvdmVyJ1xuICAgICAgZWxzZSBvcHRpb25zLnR5cGUgPSAnY29udGFpbidcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogU2NhbGVkSW1hZ2VUZXh0dXJlLFxuICAgICAgc3JjOiBpbWFnZVVybCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2Ugb3B0aW9ucyB3aXRoIGRlZmF1bHRcbiAgY29uc3Qgc2V0T3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi57XG4gICAgICAgIHR5cGU6ICdjb250YWluJyxcbiAgICAgICAgdzogMCxcbiAgICAgICAgaDogMCxcbiAgICAgIH0sXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH1cbiAgICBjb25zdCBpbWFnZVF1YWxpdHkgPSBNYXRoLm1heChcbiAgICAgIDAuMSxcbiAgICAgIE1hdGgubWluKDEsIChwYXJzZUZsb2F0KFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnaW1hZ2UucXVhbGl0eScpKSB8fCAxMDApIC8gMTAwKVxuICAgIClcblxuICAgIG9wdGlvbnMudyA9IG9wdGlvbnMudyAqIGltYWdlUXVhbGl0eVxuICAgIG9wdGlvbnMuaCA9IG9wdGlvbnMuaCAqIGltYWdlUXVhbGl0eVxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICAvLyBpZiBvcHRpb25zIGFyZSBwYXNzZWQsIHJldHVybiBzY2FsZWQgaW1hZ2UgcmlnaHQgYXdheVxuICBpZiAob3B0aW9ucykge1xuICAgIHJldHVybiBtYWtlKHNldE9wdGlvbnMob3B0aW9ucykpXG4gIH1cblxuICAvLyBvdGhlcndpc2UgcmV0dXJuICdjaGFpbmVkJyBmdW5jdGlvbnNcbiAgcmV0dXJuIHtcbiAgICAvLyBvZmZpY2lhbCBhcGlcbiAgICBleGFjdDogKHcsIGgpID0+IG1ha2Uoc2V0T3B0aW9ucyh7IHR5cGU6ICdleGFjdCcsIHcsIGggfSkpLFxuICAgIGxhbmRzY2FwZTogdyA9PiBtYWtlKHNldE9wdGlvbnMoeyB0eXBlOiAnbGFuZHNjYXBlJywgdyB9KSksXG4gICAgcG9ydHJhaXQ6IGggPT4gbWFrZShzZXRPcHRpb25zKHsgdHlwZTogJ3BvcnRyYWl0JywgaCB9KSksXG4gICAgY292ZXI6ICh3LCBoKSA9PiBtYWtlKHNldE9wdGlvbnMoeyB0eXBlOiAnY292ZXInLCB3LCBoIH0pKSxcbiAgICBjb250YWluOiAodywgaCkgPT4gbWFrZShzZXRPcHRpb25zKHsgdHlwZTogJ2NvbnRhaW4nLCB3LCBoIH0pKSxcbiAgICBvcmlnaW5hbDogKCkgPT4gbWFrZShzZXRPcHRpb25zKHsgdHlwZTogJ2NvbnRhaW4nIH0pKSxcblxuICAgIC8vIHRvZG86IGFkZCBwb3NpdGlvbmluZyAtIGkuZS4gdG9wLCBib3R0b20sIGNlbnRlciwgbGVmdCBldGMuXG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHt9XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcbmltcG9ydCBVdGlscyBmcm9tICcuLi9VdGlscydcblxubGV0IG1ldGEgPSB7fVxubGV0IHRyYW5zbGF0aW9ucyA9IHt9XG5sZXQgbGFuZ3VhZ2UgPSBudWxsXG5sZXQgZGljdGlvbmFyeSA9IG51bGxcblxuZXhwb3J0IGNvbnN0IGluaXRMYW5ndWFnZSA9IChmaWxlLCBsYW5ndWFnZSA9IG51bGwpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmZXRjaChmaWxlKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLnRoZW4oanNvbiA9PiB7XG4gICAgICAgIHNldFRyYW5zbGF0aW9ucyhqc29uKVxuICAgICAgICAvLyBzZXQgbGFuZ3VhZ2UgKGRpcmVjdGx5IG9yIGluIGEgcHJvbWlzZSlcbiAgICAgICAgdHlwZW9mIGxhbmd1YWdlID09PSAnb2JqZWN0JyAmJiAndGhlbicgaW4gbGFuZ3VhZ2UgJiYgdHlwZW9mIGxhbmd1YWdlLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IGxhbmd1YWdlXG4gICAgICAgICAgICAgIC50aGVuKGxhbmcgPT5cbiAgICAgICAgICAgICAgICBzZXRMYW5ndWFnZShsYW5nKVxuICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgIExvZy5lcnJvcihlKVxuICAgICAgICAgICAgICAgIHJlamVjdChlKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIDogc2V0TGFuZ3VhZ2UobGFuZ3VhZ2UpXG4gICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAnTGFuZ3VhZ2UgZmlsZSAnICsgZmlsZSArICcgbm90IGZvdW5kJ1xuICAgICAgICBMb2cuZXJyb3IoZXJyb3IpXG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0pXG4gIH0pXG59XG5cbmNvbnN0IHNldFRyYW5zbGF0aW9ucyA9IG9iaiA9PiB7XG4gIGlmICgnbWV0YScgaW4gb2JqKSB7XG4gICAgbWV0YSA9IHsgLi4ub2JqLm1ldGEgfVxuICAgIGRlbGV0ZSBvYmoubWV0YVxuICB9XG4gIHRyYW5zbGF0aW9ucyA9IG9ialxufVxuXG5jb25zdCBnZXRMYW5ndWFnZSA9ICgpID0+IHtcbiAgcmV0dXJuIGxhbmd1YWdlXG59XG5cbmNvbnN0IHNldExhbmd1YWdlID0gbG5nID0+IHtcbiAgbGFuZ3VhZ2UgPSBudWxsXG4gIGRpY3Rpb25hcnkgPSBudWxsXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAobG5nIGluIHRyYW5zbGF0aW9ucykge1xuICAgICAgbGFuZ3VhZ2UgPSBsbmdcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCdtYXAnIGluIG1ldGEgJiYgbG5nIGluIG1ldGEubWFwICYmIG1ldGEubWFwW2xuZ10gaW4gdHJhbnNsYXRpb25zKSB7XG4gICAgICAgIGxhbmd1YWdlID0gbWV0YS5tYXBbbG5nXVxuICAgICAgfSBlbHNlIGlmICgnZGVmYXVsdCcgaW4gbWV0YSAmJiBtZXRhLmRlZmF1bHQgaW4gdHJhbnNsYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID1cbiAgICAgICAgICAnVHJhbnNsYXRpb25zIGZvciBMYW5ndWFnZSAnICtcbiAgICAgICAgICBsYW5ndWFnZSArXG4gICAgICAgICAgJyBub3QgZm91bmQuIFVzaW5nIGRlZmF1bHQgbGFuZ3VhZ2UgJyArXG4gICAgICAgICAgbWV0YS5kZWZhdWx0XG4gICAgICAgIExvZy53YXJuKGVycm9yKVxuICAgICAgICBsYW5ndWFnZSA9IG1ldGEuZGVmYXVsdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAnVHJhbnNsYXRpb25zIGZvciBMYW5ndWFnZSAnICsgbGFuZ3VhZ2UgKyAnIG5vdCBmb3VuZC4nXG4gICAgICAgIExvZy5lcnJvcihlcnJvcilcbiAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgTG9nLmluZm8oJ1NldHRpbmcgbGFuZ3VhZ2UgdG8nLCBsYW5ndWFnZSlcblxuICAgICAgY29uc3QgdHJhbnNsYXRpb25zT2JqID0gdHJhbnNsYXRpb25zW2xhbmd1YWdlXVxuICAgICAgaWYgKHR5cGVvZiB0cmFuc2xhdGlvbnNPYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGRpY3Rpb25hcnkgPSB0cmFuc2xhdGlvbnNPYmpcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmFuc2xhdGlvbnNPYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IFV0aWxzLmFzc2V0KHRyYW5zbGF0aW9uc09iailcblxuICAgICAgICBmZXRjaCh1cmwpXG4gICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgLy8gc2F2ZSB0aGUgdHJhbnNsYXRpb25zIGZvciB0aGlzIGxhbmd1YWdlICh0byBwcmV2ZW50IGxvYWRpbmcgdHdpY2UpXG4gICAgICAgICAgICB0cmFuc2xhdGlvbnNbbGFuZ3VhZ2VdID0ganNvblxuICAgICAgICAgICAgZGljdGlvbmFyeSA9IGpzb25cbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSAnRXJyb3Igd2hpbGUgZmV0Y2hpbmcgJyArIHVybFxuICAgICAgICAgICAgTG9nLmVycm9yKGVycm9yLCBlKVxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHRyYW5zbGF0ZShrZXkpIHtcbiAgICBsZXQgcmVwbGFjZW1lbnRzID0gWy4uLmFyZ3VtZW50c10uc2xpY2UoMSlcblxuICAgIC8vIG5vIHJlcGxhY2VtZW50cyBzbyBqdXN0IHRyYW5zbGF0ZWQgc3RyaW5nXG4gICAgaWYgKHJlcGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAoZGljdGlvbmFyeSAmJiBkaWN0aW9uYXJ5W2tleV0pIHx8IGtleVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVwbGFjZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgcmVwbGFjZW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXBsYWNlbWVudHMgPSByZXBsYWNlbWVudHMucG9wKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKFxuICAgICAgICAvLyBtYXBzIGFycmF5IGlucHV0IHRvIGFuIG9iamVjdCB7MDogJ2l0ZW0xJywgMTogJ2l0ZW0yJ31cbiAgICAgICAgQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudHMpID8gT2JqZWN0LmFzc2lnbih7fSwgcmVwbGFjZW1lbnRzKSA6IHJlcGxhY2VtZW50c1xuICAgICAgKS5yZWR1Y2UoKHRleHQsIHJlcGxhY2VtZW50S2V5KSA9PiB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoXG4gICAgICAgICAgbmV3IFJlZ0V4cCgne1xcXFxzPycgKyByZXBsYWNlbWVudEtleSArICdcXFxccz99JywgJ2cnKSxcbiAgICAgICAgICByZXBsYWNlbWVudHNbcmVwbGFjZW1lbnRLZXldXG4gICAgICAgIClcbiAgICAgIH0sIChkaWN0aW9uYXJ5ICYmIGRpY3Rpb25hcnlba2V5XSkgfHwga2V5KVxuICAgIH1cbiAgfSxcblxuICB0cmFuc2xhdGlvbnMob2JqKSB7XG4gICAgc2V0VHJhbnNsYXRpb25zKG9iailcbiAgfSxcblxuICBzZXQobGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gc2V0TGFuZ3VhZ2UobGFuZ3VhZ2UpXG4gIH0sXG5cbiAgZ2V0KCkge1xuICAgIHJldHVybiBnZXRMYW5ndWFnZSgpXG4gIH0sXG5cbiAgYXZhaWxhYmxlKCkge1xuICAgIGNvbnN0IGxhbmd1YWdlS2V5cyA9IE9iamVjdC5rZXlzKHRyYW5zbGF0aW9ucylcbiAgICByZXR1cm4gbGFuZ3VhZ2VLZXlzLm1hcChrZXkgPT4gKHsgY29kZToga2V5LCBuYW1lOiAobWV0YS5uYW1lcyAmJiBtZXRhLm5hbWVzW2tleV0pIHx8IGtleSB9KSlcbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGluaXRVdGlscyB9IGZyb20gJy4uL1V0aWxzJ1xuaW1wb3J0IHsgaW5pdFByb2ZpbGUgfSBmcm9tICcuLi9Qcm9maWxlJ1xuaW1wb3J0IHsgaW5pdE1ldHJpY3MgfSBmcm9tICcuLi9NZXRyaWNzJ1xuaW1wb3J0IHsgaW5pdFNldHRpbmdzIH0gZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgeyBpbml0TWVkaWFQbGF5ZXIgfSBmcm9tICcuLi9NZWRpYVBsYXllcidcbmltcG9ydCB7IGluaXRWaWRlb1BsYXllciB9IGZyb20gJy4uL1ZpZGVvUGxheWVyJ1xuaW1wb3J0IHsgaW5pdFN0b3JhZ2UgfSBmcm9tICcuLi9TdG9yYWdlJ1xuaW1wb3J0IHsgaW5pdEFkcyB9IGZyb20gJy4uL0FkcydcbmltcG9ydCB7IGluaXRSb3V0ZXIgfSBmcm9tICcuLi9Sb3V0ZXInXG5pbXBvcnQgeyBpbml0VFYgfSBmcm9tICcuLi9UVidcbmltcG9ydCB7IGluaXRQdXJjaGFzZSB9IGZyb20gJy4uL1B1cmNoYXNlJ1xuaW1wb3J0IHsgaW5pdFBpbiB9IGZyb20gJy4uL1BpbidcbmltcG9ydCB7IGluaXRNZXRhZGF0YSB9IGZyb20gJy4uL01ldGFkYXRhJ1xuaW1wb3J0IEFwcGxpY2F0aW9uIGZyb20gJy4uL0FwcGxpY2F0aW9uJ1xuXG5leHBvcnQgbGV0IEFwcGxpY2F0aW9uSW5zdGFuY2VcblxuZXhwb3J0IGRlZmF1bHQgKEFwcCwgYXBwU2V0dGluZ3MsIHBsYXRmb3JtU2V0dGluZ3MsIGFwcERhdGEpID0+IHtcbiAgaW5pdFNldHRpbmdzKGFwcFNldHRpbmdzLCBwbGF0Zm9ybVNldHRpbmdzKVxuICBpbml0TWV0YWRhdGEoYXBwU2V0dGluZ3MpXG5cbiAgaW5pdFV0aWxzKHBsYXRmb3JtU2V0dGluZ3MpXG4gIGluaXRTdG9yYWdlKClcbiAgLy8gSW5pdGlhbGl6ZSBwbHVnaW5zXG4gIGlmIChwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMpIHtcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucHJvZmlsZSAmJiBpbml0UHJvZmlsZShwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucHJvZmlsZSlcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMubWV0cmljcyAmJiBpbml0TWV0cmljcyhwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMubWV0cmljcylcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMubWVkaWFQbGF5ZXIgJiYgaW5pdE1lZGlhUGxheWVyKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy5tZWRpYVBsYXllcilcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMubWVkaWFQbGF5ZXIgJiYgaW5pdFZpZGVvUGxheWVyKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy5tZWRpYVBsYXllcilcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMuYWRzICYmIGluaXRBZHMocGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLmFkcylcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucm91dGVyICYmIGluaXRSb3V0ZXIocGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLnJvdXRlcilcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMudHYgJiYgaW5pdFRWKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy50dilcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucHVyY2hhc2UgJiYgaW5pdFB1cmNoYXNlKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy5wdXJjaGFzZSlcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucGluICYmIGluaXRQaW4ocGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLnBpbilcbiAgfVxuXG4gIGNvbnN0IGFwcCA9IEFwcGxpY2F0aW9uKEFwcCwgYXBwRGF0YSwgcGxhdGZvcm1TZXR0aW5ncylcbiAgQXBwbGljYXRpb25JbnN0YW5jZSA9IG5ldyBhcHAoYXBwU2V0dGluZ3MpXG4gIHJldHVybiBBcHBsaWNhdGlvbkluc3RhbmNlXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGlnaHRuaW5nIGZyb20gJ0BsaWdodG5pbmdqcy9jb3JlJ1xuZXhwb3J0IGRlZmF1bHQgTGlnaHRuaW5nXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFNpbXBsZSBtb2R1bGUgZm9yIGxvY2FsaXphdGlvbiBvZiBzdHJpbmdzLlxuICpcbiAqIEhvdyB0byB1c2U6XG4gKiAxLiBDcmVhdGUgbG9jYWxpemF0aW9uIGZpbGUgd2l0aCBmb2xsb3dpbmcgSlNPTiBmb3JtYXQ6XG4gKiB7XG4gKiAgIFwiZW5cIiA6e1xuICogICAgIFwiaG93XCI6IFwiSG93IGRvIHlvdSB3YW50IHlvdXIgZWdnIHRvZGF5P1wiLFxuICogICAgIFwiYm9pbGVkRWdnXCI6IFwiQm9pbGVkIGVnZ1wiLFxuICogICAgIFwic29mdEJvaWxlZEVnZ1wiOiBcIlNvZnQtYm9pbGVkIGVnZ1wiLFxuICogICAgIFwiY2hvaWNlXCI6IFwiSG93IHRvIGNob29zZSB0aGUgZWdnXCIsXG4gKiAgICAgXCJidXlRdWVzdGlvblwiOiBcIkknZCBsaWtlIHRvIGJ1eSB7MH0gZWdncywgezF9IGRvbGxhcnMgZWFjaC5cIlxuICogICB9LFxuICpcbiAqICAgXCJpdFwiOiB7XG4gKiAgICAgXCJob3dcIjogXCJDb21lIHZ1b2kgaWwgdHVvIHVvdm8gb2dnaT9cIixcbiAqICAgICBcImJvaWxlZEVnZ1wiOiBcIlVvdm8gc29kb1wiLFxuICogICAgIFwic29mdEJvaWxlZEVnZ1wiOiBcIlVvdm8gYWxsYSBjb3F1ZVwiLFxuICogICAgIFwiY2hvaWNlXCI6IFwiQ29tZSBzY2VnbGllcmUgbCd1b3ZvXCIsXG4gKiAgICAgXCJidXlRdWVzdGlvblwiOiBcIk1pIHBpYWNlcmViYmUgY29tcHJhcmUgezB9IHVvdmEsIHsxfSBkb2xsYXJpIGNpYXNjdW5hLlwiXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAyLiBVc2UgTG9jYWxlJ3MgbW9kdWxlIGxvYWQgbWV0aG9kLCBzcGVjaWZ5aW5nIHBhdGggdG8geW91ciBsb2NhbGl6YXRpb24gZmlsZSBhbmQgc2V0IGNob3NlbiBsYW5ndWFnZSwgZS5nLjpcbiAqICAgID4gTG9jYWxlLmxvYWQoJ3N0YXRpYy9sb2NhbGUvbG9jYWxlLmpzb24nKTtcbiAqICAgID4gTG9jYWxlLnNldExhbmd1YWdlKCdlbicpO1xuICpcbiAqIDMuIFVzZSBsb2NhbGl6YXRpb24gc3RyaW5nczpcbiAqICAgID4gY29uc29sZS5sb2coTG9jYWxlLnRyLmhvdyk7XG4gKiAgICBIb3cgZG8geW91IHdhbnQgeW91ciBlZ2cgdG9kYXk/XG4gKiAgICA+IGNvbnNvbGUubG9nKExvY2FsZS50ci5ib2lsZWRFZ2cpO1xuICogICAgQm9pbGVkIGVnZ1xuICpcbiAqIDQuIFN0cmluZyBmb3JtYXR0aW5nXG4gKiAgICA+IGNvbnNvbGUubG9nKExvY2FsZS50ci5idXlRdWVzdGlvbi5mb3JtYXQoMTAsIDAuNSkpO1xuICogICAgSSdkIGxpa2UgdG8gYnV5IDEwIGVnZ3MsIDAuNSBkb2xsYXJzIGVhY2guXG4gKi9cblxuaW1wb3J0IExvZyBmcm9tICcuLi9Mb2cnXG5cbmxldCB3YXJuZWQgPSBmYWxzZVxuY29uc3QgZGVwcmVjYXRlZCA9IChmb3JjZSA9IGZhbHNlKSA9PiB7XG4gIGlmIChmb3JjZSA9PT0gdHJ1ZSB8fCB3YXJuZWQgPT09IGZhbHNlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgW1xuICAgICAgICBcIlRoZSAnTG9jYWxlJy1wbHVnaW4gaW4gdGhlIExpZ2h0bmluZy1TREsgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcy5cIixcbiAgICAgICAgXCJQbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyAnTGFuZ3VhZ2UnLXBsdWdpbiBpbnN0ZWFkLlwiLFxuICAgICAgICAnaHR0cHM6Ly9yZGtjZW50cmFsLmdpdGh1Yi5pby9MaWdodG5pbmctU0RLLyMvcGx1Z2lucy9sYW5ndWFnZScsXG4gICAgICBdLmpvaW4oJ1xcblxcbicpXG4gICAgKVxuICB9XG4gIHdhcm5lZCA9IHRydWVcbn1cbmNsYXNzIExvY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX19lbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0cmFuc2xhdGlvbiBvYmplY3QgZnJvbSBleHRlcm5hbCBqc29uIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdG8gcmVzb3VyY2UuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBsb2FkKHBhdGgpIHtcbiAgICBpZiAoIXRoaXMuX19lbmFibGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCBmZXRjaChwYXRoKVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgICAgIC50aGVuKHJlc3AgPT4ge1xuICAgICAgICB0aGlzLmxvYWRGcm9tT2JqZWN0KHJlc3ApXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbGFuZ3VhZ2UgdXNlZCBieSBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYW5nXG4gICAqL1xuICBzZXRMYW5ndWFnZShsYW5nKSB7XG4gICAgZGVwcmVjYXRlZCgpXG4gICAgdGhpcy5fX2VuYWJsZWQgPSB0cnVlXG4gICAgdGhpcy5sYW5ndWFnZSA9IGxhbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHJlZmVyZW5jZSB0byB0cmFuc2xhdGlvbiBvYmplY3QgZm9yIGN1cnJlbnQgbGFuZ3VhZ2UuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCB0cigpIHtcbiAgICBkZXByZWNhdGVkKHRydWUpXG4gICAgcmV0dXJuIHRoaXMuX190ck9ialt0aGlzLmxhbmd1YWdlXVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRyYW5zbGF0aW9uIG9iamVjdCBmcm9tIGV4aXN0aW5nIG9iamVjdCAoYmluZHMgZXhpc3Rpbmcgb2JqZWN0KS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyT2JqXG4gICAqL1xuICBsb2FkRnJvbU9iamVjdCh0ck9iaikge1xuICAgIGRlcHJlY2F0ZWQoKVxuICAgIGNvbnN0IGZhbGxiYWNrTGFuZ3VhZ2UgPSAnZW4nXG4gICAgaWYgKE9iamVjdC5rZXlzKHRyT2JqKS5pbmRleE9mKHRoaXMubGFuZ3VhZ2UpID09PSAtMSkge1xuICAgICAgTG9nLndhcm4oJ05vIHRyYW5zbGF0aW9ucyBmb3VuZCBmb3I6ICcgKyB0aGlzLmxhbmd1YWdlKVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRyT2JqKS5pbmRleE9mKGZhbGxiYWNrTGFuZ3VhZ2UpID4gLTEpIHtcbiAgICAgICAgTG9nLndhcm4oJ1VzaW5nIGZhbGxiYWNrIGxhbmd1YWdlOiAnICsgZmFsbGJhY2tMYW5ndWFnZSlcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGZhbGxiYWNrTGFuZ3VhZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gJ05vIHRyYW5zbGF0aW9ucyBmb3VuZCBmb3IgZmFsbGJhY2sgbGFuZ3VhZ2U6ICcgKyBmYWxsYmFja0xhbmd1YWdlXG4gICAgICAgIExvZy5lcnJvcihlcnJvcilcbiAgICAgICAgdGhyb3cgRXJyb3IoZXJyb3IpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fX3RyT2JqID0gdHJPYmpcbiAgICBmb3IgKGNvbnN0IGxhbmcgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9fdHJPYmopKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0ciBvZiBPYmplY3Qua2V5cyhsYW5nKSkge1xuICAgICAgICBsYW5nW3N0cl0gPSBuZXcgTG9jYWxpemVkU3RyaW5nKGxhbmdbc3RyXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRlbmRlZCBzdHJpbmcgY2xhc3MgdXNlZCBmb3IgbG9jYWxpemF0aW9uLlxuICovXG5jbGFzcyBMb2NhbGl6ZWRTdHJpbmcgZXh0ZW5kcyBTdHJpbmcge1xuICAvKipcbiAgICogUmV0dXJucyBmb3JtYXR0ZWQgTG9jYWxpemVkU3RyaW5nLlxuICAgKiBSZXBsYWNlcyBlYWNoIHBsYWNlaG9sZGVyIHZhbHVlIChlLmcuIHswfSwgezF9KSB3aXRoIGNvcnJlc3BvbmRpbmcgYXJndW1lbnQuXG4gICAqXG4gICAqIEUuZy46XG4gICAqID4gbmV3IExvY2FsaXplZFN0cmluZygnezB9IGFuZCB7MX0gYW5kIHswfScpLmZvcm1hdCgnQScsICdCJyk7XG4gICAqIEEgYW5kIEIgYW5kIEFcbiAgICpcbiAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIExpc3Qgb2YgYXJndW1lbnRzIGZvciBwbGFjZWhvbGRlcnMuXG4gICAqL1xuICBmb3JtYXQoLi4uYXJncykge1xuICAgIGNvbnN0IHN1YiA9IGFyZ3MucmVkdWNlKChzdHJpbmcsIGFyZywgaW5kZXgpID0+IHN0cmluZy5zcGxpdChgeyR7aW5kZXh9fWApLmpvaW4oYXJnKSwgdGhpcylcbiAgICByZXR1cm4gbmV3IExvY2FsaXplZFN0cmluZyhzdWIpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IExvY2FsZSgpXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5cbmNvbnN0IHByZXBMb2cgPSAodHlwZSwgYXJncykgPT4ge1xuICBjb25zdCBjb2xvcnMgPSB7XG4gICAgSW5mbzogJ2dyZWVuJyxcbiAgICBEZWJ1ZzogJ2dyYXknLFxuICAgIFdhcm46ICdvcmFuZ2UnLFxuICAgIEVycm9yOiAncmVkJyxcbiAgfVxuXG4gIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3MpXG4gIHJldHVybiBbXG4gICAgJyVjJyArIChhcmdzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnID8gYXJncy5zaGlmdCgpIDogdHlwZSksXG4gICAgJ2JhY2tncm91bmQtY29sb3I6ICcgKyBjb2xvcnNbdHlwZV0gKyAnOyBjb2xvcjogd2hpdGU7IHBhZGRpbmc6IDJweCA0cHg7IGJvcmRlci1yYWRpdXM6IDJweCcsXG4gICAgYXJncyxcbiAgXVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluZm8oKSB7XG4gICAgU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdsb2cnKSAmJiBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBwcmVwTG9nKCdJbmZvJywgYXJndW1lbnRzKSlcbiAgfSxcbiAgZGVidWcoKSB7XG4gICAgU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdsb2cnKSAmJiBjb25zb2xlLmRlYnVnLmFwcGx5KGNvbnNvbGUsIHByZXBMb2coJ0RlYnVnJywgYXJndW1lbnRzKSlcbiAgfSxcbiAgZXJyb3IoKSB7XG4gICAgU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdsb2cnKSAmJiBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIHByZXBMb2coJ0Vycm9yJywgYXJndW1lbnRzKSlcbiAgfSxcbiAgd2FybigpIHtcbiAgICBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ2xvZycpICYmIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBwcmVwTG9nKCdXYXJuJywgYXJndW1lbnRzKSlcbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMaWdodG5pbmcgZnJvbSAnLi4vTGlnaHRuaW5nJ1xuaW1wb3J0IE1ldHJpY3MgZnJvbSAnLi4vTWV0cmljcydcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcbmltcG9ydCBMb2cgZnJvbSAnLi4vTG9nJ1xuXG5jb25zdCBldmVudHMgPSBbXG4gICd0aW1ldXBkYXRlJyxcbiAgJ2Vycm9yJyxcbiAgJ2VuZGVkJyxcbiAgJ2xvYWRlZGRhdGEnLFxuICAnY2FucGxheScsXG4gICdwbGF5JyxcbiAgJ3BsYXlpbmcnLFxuICAncGF1c2UnLFxuICAnbG9hZHN0YXJ0JyxcbiAgJ3NlZWtpbmcnLFxuICAnc2Vla2VkJyxcbiAgJ2VuY3J5cHRlZCcsXG5dXG5cbmxldCBtZWRpYVVybCA9IHVybCA9PiB1cmxcblxuZXhwb3J0IGNvbnN0IGluaXRNZWRpYVBsYXllciA9IGNvbmZpZyA9PiB7XG4gIGlmIChjb25maWcubWVkaWFVcmwpIHtcbiAgICBtZWRpYVVybCA9IGNvbmZpZy5tZWRpYVVybFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lZGlhcGxheWVyIGV4dGVuZHMgTGlnaHRuaW5nLkNvbXBvbmVudCB7XG4gIF9jb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5fc2tpcFJlbmRlclRvVGV4dHVyZSA9IGZhbHNlXG4gICAgdGhpcy5fbWV0cmljcyA9IG51bGxcbiAgICB0aGlzLl90ZXh0dXJlTW9kZSA9IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAndGV4dHVyZU1vZGUnKSB8fCBmYWxzZVxuICAgIExvZy5pbmZvKCdUZXh0dXJlIG1vZGU6ICcgKyB0aGlzLl90ZXh0dXJlTW9kZSlcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBbXG4gICAgICAgIFwiVGhlICdNZWRpYVBsYXllcictcGx1Z2luIGluIHRoZSBMaWdodG5pbmctU0RLIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMuXCIsXG4gICAgICAgIFwiUGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgJ1ZpZGVvUGxheWVyJy1wbHVnaW4gaW5zdGVhZC5cIixcbiAgICAgICAgJ2h0dHBzOi8vcmRrY2VudHJhbC5naXRodWIuaW8vTGlnaHRuaW5nLVNESy8jL3BsdWdpbnMvdmlkZW9wbGF5ZXInLFxuICAgICAgXS5qb2luKCdcXG5cXG4nKVxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFZpZGVvOiB7XG4gICAgICAgIFZpZGVvV3JhcDoge1xuICAgICAgICAgIFZpZGVvVGV4dHVyZToge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwaXZvdDogMC41LFxuICAgICAgICAgICAgdGV4dHVyZTogeyB0eXBlOiBMaWdodG5pbmcudGV4dHVyZXMuU3RhdGljVGV4dHVyZSwgb3B0aW9uczoge30gfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICBzZXQgc2tpcFJlbmRlclRvVGV4dHVyZSh2KSB7XG4gICAgdGhpcy5fc2tpcFJlbmRlclRvVGV4dHVyZSA9IHZcbiAgfVxuXG4gIGdldCB0ZXh0dXJlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZU1vZGVcbiAgfVxuXG4gIGdldCB2aWRlb1ZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnKCdWaWRlbycpXG4gIH1cblxuICBfaW5pdCgpIHtcbiAgICAvL3JlLXVzZSB2aWRlb3RhZyBpZiBhbHJlYWR5IHRoZXJlXG4gICAgY29uc3QgdmlkZW9FbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKVxuICAgIGlmICh2aWRlb0VscyAmJiB2aWRlb0Vscy5sZW5ndGggPiAwKSB0aGlzLnZpZGVvRWwgPSB2aWRlb0Vsc1swXVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy52aWRlb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgICAgdGhpcy52aWRlb0VsLnNldEF0dHJpYnV0ZSgnaWQnLCAndmlkZW8tcGxheWVyJylcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS56SW5kZXggPSAnMSdcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB0aGlzLnZpZGVvRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxMDAlJylcbiAgICAgIHRoaXMudmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxMDAlJylcblxuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSB0aGlzLnRleHR1cmVNb2RlID8gJ2hpZGRlbicgOiAndmlzaWJsZSdcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy52aWRlb0VsKVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0dXJlTW9kZSAmJiAhdGhpcy5fc2tpcFJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgdGhpcy5fY3JlYXRlVmlkZW9UZXh0dXJlKClcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXVxuICB9XG5cbiAgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBlID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX21ldHJpY3MgJiYgdGhpcy5fbWV0cmljc1tldmVudF0gJiYgdHlwZW9mIHRoaXMuX21ldHJpY3NbZXZlbnRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fbWV0cmljc1tldmVudF0oeyBjdXJyZW50VGltZTogdGhpcy52aWRlb0VsLmN1cnJlbnRUaW1lIH0pXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maXJlKGV2ZW50LCB7IHZpZGVvRWxlbWVudDogdGhpcy52aWRlb0VsLCBldmVudDogZSB9KVxuICAgICAgfVxuICAgICAgdGhpcy5ldmVudEhhbmRsZXJzLnB1c2goaGFuZGxlcilcbiAgICAgIHRoaXMudmlkZW9FbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKVxuICAgIH0pXG4gIH1cblxuICBfZGVyZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBMb2cuaW5mbygnRGVyZWdpc3RlcmluZyBldmVudCBsaXN0ZW5lcnMgTWVkaWFQbGF5ZXInKVxuICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCwgaW5kZXgpID0+IHtcbiAgICAgIHRoaXMudmlkZW9FbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmV2ZW50SGFuZGxlcnNbaW5kZXhdKVxuICAgIH0pXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW11cbiAgfVxuXG4gIF9hdHRhY2goKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKVxuICB9XG5cbiAgX2RldGFjaCgpIHtcbiAgICB0aGlzLl9kZXJlZ2lzdGVyTGlzdGVuZXJzKClcbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIF9jcmVhdGVWaWRlb1RleHR1cmUoKSB7XG4gICAgY29uc3Qgc3RhZ2UgPSB0aGlzLnN0YWdlXG5cbiAgICBjb25zdCBnbCA9IHN0YWdlLmdsXG4gICAgY29uc3QgZ2xUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUilcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpXG5cbiAgICB0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zID0geyBzb3VyY2U6IGdsVGV4dHVyZSwgdzogdGhpcy52aWRlb0VsLndpZHRoLCBoOiB0aGlzLnZpZGVvRWwuaGVpZ2h0IH1cbiAgfVxuXG4gIF9zdGFydFVwZGF0aW5nVmlkZW9UZXh0dXJlKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmVNb2RlICYmICF0aGlzLl9za2lwUmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICBjb25zdCBzdGFnZSA9IHRoaXMuc3RhZ2VcbiAgICAgIGlmICghdGhpcy5fdXBkYXRlVmlkZW9UZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZpZGVvVGV4dHVyZSA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5zb3VyY2UgJiYgdGhpcy52aWRlb0VsLnZpZGVvV2lkdGggJiYgdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gc3RhZ2UuZ2xcblxuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuXG4gICAgICAgICAgICAvLyBXaGVuIEJSMl9QQUNLQUdFX0dTVDFfUExVR0lOU19CQURfUExVR0lOX0RFQlVHVVRJTFMgaXMgbm90IHNldCBpbiBXUEUsIHdlYmtpdERlY29kZWRGcmFtZUNvdW50IHdpbGwgbm90IGJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIC8vIFdlJ2xsIGZhbGxiYWNrIHRvIGZpeGVkIDMwZnBzIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIGNvbnN0IGZyYW1lQ291bnQgPSB0aGlzLnZpZGVvRWwud2Via2l0RGVjb2RlZEZyYW1lQ291bnRcblxuICAgICAgICAgICAgY29uc3QgbXVzdFVwZGF0ZSA9IGZyYW1lQ291bnRcbiAgICAgICAgICAgICAgPyB0aGlzLl9sYXN0RnJhbWUgIT09IGZyYW1lQ291bnRcbiAgICAgICAgICAgICAgOiB0aGlzLl9sYXN0VGltZSA8IGN1cnJlbnRUaW1lIC0gMzBcblxuICAgICAgICAgICAgaWYgKG11c3RVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGFzdFRpbWUgPSBjdXJyZW50VGltZVxuICAgICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSBmcmFtZUNvdW50XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5zb3VyY2UpXG4gICAgICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSlcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudmlkZW9FbClcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSB0aGlzLnZpZGVvRWwud2Via2l0RGVjb2RlZEZyYW1lQ291bnRcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZVZpZXcudmlzaWJsZSA9IHRydWVcblxuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMudyA9IHRoaXMudmlkZW9FbC52aWRlb1dpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5oID0gdGhpcy52aWRlb0VsLnZpZGVvSGVpZ2h0XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRBc3BlY3RSYXRpbyA9IHRoaXMudmlkZW9UZXh0dXJlVmlldy53IC8gdGhpcy52aWRlb1RleHR1cmVWaWV3LmhcbiAgICAgICAgICAgICAgICBjb25zdCByZWFsQXNwZWN0UmF0aW8gPSB0aGlzLnZpZGVvRWwudmlkZW9XaWR0aCAvIHRoaXMudmlkZW9FbC52aWRlb0hlaWdodFxuICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZEFzcGVjdFJhdGlvID4gcmVhbEFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZVZpZXcuc2NhbGVYID0gcmVhbEFzcGVjdFJhdGlvIC8gZXhwZWN0ZWRBc3BlY3RSYXRpb1xuICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmVWaWV3LnNjYWxlWSA9IDFcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmVWaWV3LnNjYWxlWSA9IGV4cGVjdGVkQXNwZWN0UmF0aW8gLyByZWFsQXNwZWN0UmF0aW9cbiAgICAgICAgICAgICAgICAgIHRoaXMudmlkZW9UZXh0dXJlVmlldy5zY2FsZVggPSAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgTG9nLmVycm9yKCd0ZXhJbWFnZTJkIHZpZGVvJywgZSlcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wVXBkYXRpbmdWaWRlb1RleHR1cmUoKVxuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9UZXh0dXJlVmlldy52aXNpYmxlID0gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZS5zb3VyY2UuZm9yY2VSZW5kZXJVcGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl91cGRhdGluZ1ZpZGVvVGV4dHVyZSkge1xuICAgICAgICBzdGFnZS5vbignZnJhbWVTdGFydCcsIHRoaXMuX3VwZGF0ZVZpZGVvVGV4dHVyZSlcbiAgICAgICAgdGhpcy5fdXBkYXRpbmdWaWRlb1RleHR1cmUgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3N0b3BVcGRhdGluZ1ZpZGVvVGV4dHVyZSgpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlTW9kZSkge1xuICAgICAgY29uc3Qgc3RhZ2UgPSB0aGlzLnN0YWdlXG4gICAgICBzdGFnZS5yZW1vdmVMaXN0ZW5lcignZnJhbWVTdGFydCcsIHRoaXMuX3VwZGF0ZVZpZGVvVGV4dHVyZSlcbiAgICAgIHRoaXMuX3VwZGF0aW5nVmlkZW9UZXh0dXJlID0gZmFsc2VcbiAgICAgIHRoaXMudmlkZW9UZXh0dXJlVmlldy52aXNpYmxlID0gZmFsc2VcblxuICAgICAgaWYgKHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMuc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGdsID0gc3RhZ2UuZ2xcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5zb3VyY2UpXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMSlcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVTZXR0aW5ncyhzZXR0aW5ncyA9IHt9KSB7XG4gICAgLy8gVGhlIENvbXBvbmVudCB0aGF0ICdjb25zdW1lcycgdGhlIG1lZGlhIHBsYXllci5cbiAgICB0aGlzLl9jb25zdW1lciA9IHNldHRpbmdzLmNvbnN1bWVyXG5cbiAgICBpZiAodGhpcy5fY29uc3VtZXIgJiYgdGhpcy5fY29uc3VtZXIuZ2V0TWVkaWFwbGF5ZXJTZXR0aW5ncykge1xuICAgICAgLy8gQWxsb3cgY29uc3VtZXIgdG8gYWRkIHNldHRpbmdzLlxuICAgICAgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHNldHRpbmdzLCB0aGlzLl9jb25zdW1lci5nZXRNZWRpYXBsYXllclNldHRpbmdzKCkpXG4gICAgfVxuXG4gICAgaWYgKCFMaWdodG5pbmcuVXRpbHMuZXF1YWxWYWx1ZXModGhpcy5fc3RyZWFtLCBzZXR0aW5ncy5zdHJlYW0pKSB7XG4gICAgICBpZiAoc2V0dGluZ3Muc3RyZWFtICYmIHNldHRpbmdzLnN0cmVhbS5rZXlTeXN0ZW0pIHtcbiAgICAgICAgbmF2aWdhdG9yXG4gICAgICAgICAgLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyhcbiAgICAgICAgICAgIHNldHRpbmdzLnN0cmVhbS5rZXlTeXN0ZW0uaWQsXG4gICAgICAgICAgICBzZXR0aW5ncy5zdHJlYW0ua2V5U3lzdGVtLmNvbmZpZ1xuICAgICAgICAgIClcbiAgICAgICAgICAudGhlbihrZXlTeXN0ZW1BY2Nlc3MgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGtleVN5c3RlbUFjY2Vzcy5jcmVhdGVNZWRpYUtleXMoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oY3JlYXRlZE1lZGlhS2V5cyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb0VsLnNldE1lZGlhS2V5cyhjcmVhdGVkTWVkaWFLZXlzKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN0cmVhbSAmJiBzZXR0aW5ncy5zdHJlYW0uc3JjKSB0aGlzLm9wZW4oc2V0dGluZ3Muc3RyZWFtLnNyYylcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2V0IHVwIE1lZGlhS2V5cycpXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Muc3RyZWFtICYmIHNldHRpbmdzLnN0cmVhbS5zcmMpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBoZXJlIHRvIGJlIGJhY2t3YXJkcyBjb21wYXRpYmxlLCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgLy8gaW4gZnV0dXJlIHNkayByZWxlYXNlXG4gICAgICAgIGlmIChTZXR0aW5ncy5nZXQoJ2FwcCcsICdobHMnKSkge1xuICAgICAgICAgIGlmICghd2luZG93Lkhscykge1xuICAgICAgICAgICAgd2luZG93LkhscyA9IGNsYXNzIEhscyB7XG4gICAgICAgICAgICAgIHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2hscy1saWdodCBub3QgaW5jbHVkZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aW5kb3cuSGxzLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGxzKSB0aGlzLl9obHMgPSBuZXcgd2luZG93Lkhscyh7IGxpdmVEdXJhdGlvbkluZmluaXR5OiB0cnVlIH0pXG4gICAgICAgICAgICB0aGlzLl9obHMubG9hZFNvdXJjZShzZXR0aW5ncy5zdHJlYW0uc3JjKVxuICAgICAgICAgICAgdGhpcy5faGxzLmF0dGFjaE1lZGlhKHRoaXMudmlkZW9FbClcbiAgICAgICAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wZW4oc2V0dGluZ3Muc3RyZWFtLnNyYylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9XG4gICAgICB0aGlzLl9zdHJlYW0gPSBzZXR0aW5ncy5zdHJlYW1cbiAgICB9XG5cbiAgICB0aGlzLl9zZXRIaWRlKHNldHRpbmdzLmhpZGUpXG4gICAgdGhpcy5fc2V0VmlkZW9BcmVhKHNldHRpbmdzLnZpZGVvUG9zKVxuICB9XG5cbiAgX3NldEhpZGUoaGlkZSkge1xuICAgIGlmICh0aGlzLnRleHR1cmVNb2RlKSB7XG4gICAgICB0aGlzLnRhZygnVmlkZW8nKS5zZXRTbW9vdGgoJ2FscGhhJywgaGlkZSA/IDAgOiAxKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZpZGVvRWwuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGUgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJ1xuICAgIH1cbiAgfVxuXG4gIG9wZW4odXJsLCBzZXR0aW5ncyA9IHsgaGlkZTogZmFsc2UsIHZpZGVvUG9zaXRpb246IG51bGwgfSkge1xuICAgIC8vIHByZXAgdGhlIG1lZGlhIHVybCB0byBwbGF5IGRlcGVuZGluZyBvbiBwbGF0Zm9ybSAobWVkaWFQbGF5ZXJwbHVnaW4pXG4gICAgdXJsID0gbWVkaWFVcmwodXJsKVxuICAgIHRoaXMuX21ldHJpY3MgPSBNZXRyaWNzLm1lZGlhKHVybClcbiAgICBMb2cuaW5mbygnUGxheWluZyBzdHJlYW0nLCB1cmwpXG4gICAgaWYgKHRoaXMuYXBwbGljYXRpb24ubm9WaWRlbykge1xuICAgICAgTG9nLmluZm8oJ25vVmlkZW8gb3B0aW9uIHNldCwgc28gaWdub3Jpbmc6ICcgKyB1cmwpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gY2xvc2UgdGhlIHZpZGVvIHdoZW4gb3BlbmluZyBzYW1lIHVybCBhcyBjdXJyZW50IChlZmZlY3RpdmVseSByZWxvYWRpbmcpXG4gICAgaWYgKHRoaXMudmlkZW9FbC5nZXRBdHRyaWJ1dGUoJ3NyYycpID09PSB1cmwpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgICB0aGlzLnZpZGVvRWwuc2V0QXR0cmlidXRlKCdzcmMnLCB1cmwpXG5cbiAgICAvLyBmb3JjZSBoaWRlLCB0aGVuIGZvcmNlIHNob3cgKGluIG5leHQgdGljayEpXG4gICAgLy8gKGZpeGVzIGNvbWNhc3QgcGxheWJhY2sgcm9sbG92ZXIgaXNzdWUpXG4gICAgdGhpcy52aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgIHRoaXMudmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICB9KVxuXG4gICAgdGhpcy5fc2V0SGlkZShzZXR0aW5ncy5oaWRlKVxuICAgIHRoaXMuX3NldFZpZGVvQXJlYShzZXR0aW5ncy52aWRlb1Bvc2l0aW9uIHx8IFswLCAwLCAxOTIwLCAxMDgwXSlcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gcGF1c2UgZmlyc3QgaW4gb3JkZXIgdG8gc3RvcCBzb3VuZC5cbiAgICB0aGlzLnZpZGVvRWwucGF1c2UoKVxuICAgIHRoaXMudmlkZW9FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpXG5cbiAgICAvLyBmb3JjZSBsb2FkIHRvIHJlc2V0IGV2ZXJ5dGhpbmcgd2l0aG91dCBlcnJvcnNcbiAgICB0aGlzLnZpZGVvRWwubG9hZCgpXG5cbiAgICB0aGlzLl9jbGVhclNyYygpXG5cbiAgICB0aGlzLnZpZGVvRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICB9XG5cbiAgcGxheVBhdXNlKCkge1xuICAgIGlmICh0aGlzLmlzUGxheWluZygpKSB7XG4gICAgICB0aGlzLmRvUGF1c2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvUGxheSgpXG4gICAgfVxuICB9XG5cbiAgZ2V0IG11dGVkKCkge1xuICAgIHJldHVybiB0aGlzLnZpZGVvRWwubXV0ZWRcbiAgfVxuXG4gIHNldCBtdXRlZCh2KSB7XG4gICAgdGhpcy52aWRlb0VsLm11dGVkID0gdlxuICB9XG5cbiAgZ2V0IGxvb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlkZW9FbC5sb29wXG4gIH1cblxuICBzZXQgbG9vcCh2KSB7XG4gICAgdGhpcy52aWRlb0VsLmxvb3AgPSB2XG4gIH1cblxuICBpc1BsYXlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YXRlKCkgPT09ICdQbGF5aW5nJ1xuICB9XG5cbiAgZG9QbGF5KCkge1xuICAgIHRoaXMudmlkZW9FbC5wbGF5KClcbiAgfVxuXG4gIGRvUGF1c2UoKSB7XG4gICAgdGhpcy52aWRlb0VsLnBhdXNlKClcbiAgfVxuXG4gIHJlbG9hZCgpIHtcbiAgICB2YXIgdXJsID0gdGhpcy52aWRlb0VsLmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgICB0aGlzLmNsb3NlKClcbiAgICB0aGlzLnZpZGVvRWwuc3JjID0gdXJsXG4gIH1cblxuICBnZXRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudmlkZW9FbC5jdXJyZW50VGltZSlcbiAgfVxuXG4gIHNldFBvc2l0aW9uKHBvcykge1xuICAgIHRoaXMudmlkZW9FbC5jdXJyZW50VGltZSA9IHBvc1xuICB9XG5cbiAgZ2V0RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnZpZGVvRWwuZHVyYXRpb24pXG4gIH1cblxuICBzZWVrKHRpbWUsIGFic29sdXRlID0gZmFsc2UpIHtcbiAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgIHRoaXMudmlkZW9FbC5jdXJyZW50VGltZSA9IHRpbWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52aWRlb0VsLmN1cnJlbnRUaW1lICs9IHRpbWVcbiAgICB9XG4gIH1cblxuICBnZXQgdmlkZW9UZXh0dXJlVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy50YWcoJ1ZpZGVvJykudGFnKCdWaWRlb1RleHR1cmUnKVxuICB9XG5cbiAgZ2V0IHZpZGVvVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy52aWRlb1RleHR1cmVWaWV3LnRleHR1cmVcbiAgfVxuXG4gIF9zZXRWaWRlb0FyZWEodmlkZW9Qb3MpIHtcbiAgICBpZiAoTGlnaHRuaW5nLlV0aWxzLmVxdWFsVmFsdWVzKHRoaXMuX3ZpZGVvUG9zLCB2aWRlb1BvcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3ZpZGVvUG9zID0gdmlkZW9Qb3NcblxuICAgIGlmICh0aGlzLnRleHR1cmVNb2RlKSB7XG4gICAgICB0aGlzLnZpZGVvVGV4dHVyZVZpZXcucGF0Y2goe1xuICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICB4OiB2aWRlb1Bvc1swXSxcbiAgICAgICAgICB5OiB2aWRlb1Bvc1sxXSxcbiAgICAgICAgICB3OiB2aWRlb1Bvc1syXSAtIHZpZGVvUG9zWzBdLFxuICAgICAgICAgIGg6IHZpZGVvUG9zWzNdIC0gdmlkZW9Qb3NbMV0sXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpXG4gICAgICB0aGlzLnZpZGVvRWwuc3R5bGUubGVmdCA9IE1hdGgucm91bmQodmlkZW9Qb3NbMF0gKiBwcmVjaXNpb24pICsgJ3B4J1xuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLnRvcCA9IE1hdGgucm91bmQodmlkZW9Qb3NbMV0gKiBwcmVjaXNpb24pICsgJ3B4J1xuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCgodmlkZW9Qb3NbMl0gLSB2aWRlb1Bvc1swXSkgKiBwcmVjaXNpb24pICsgJ3B4J1xuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLmhlaWdodCA9IE1hdGgucm91bmQoKHZpZGVvUG9zWzNdIC0gdmlkZW9Qb3NbMV0pICogcHJlY2lzaW9uKSArICdweCdcbiAgICB9XG4gIH1cblxuICBfZmlyZUNvbnN1bWVyKGV2ZW50LCBhcmdzKSB7XG4gICAgaWYgKHRoaXMuX2NvbnN1bWVyKSB7XG4gICAgICB0aGlzLl9jb25zdW1lci5maXJlKGV2ZW50LCBhcmdzKVxuICAgIH1cbiAgfVxuXG4gIF9lcXVhbEluaXREYXRhKGJ1ZjEsIGJ1ZjIpIHtcbiAgICBpZiAoIWJ1ZjEgfHwgIWJ1ZjIpIHJldHVybiBmYWxzZVxuICAgIGlmIChidWYxLmJ5dGVMZW5ndGggIT0gYnVmMi5ieXRlTGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBkdjEgPSBuZXcgSW50OEFycmF5KGJ1ZjEpXG4gICAgY29uc3QgZHYyID0gbmV3IEludDhBcnJheShidWYyKVxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9IGJ1ZjEuYnl0ZUxlbmd0aDsgaSsrKSBpZiAoZHYxW2ldICE9IGR2MltpXSkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGVycm9yKGFyZ3MpIHtcbiAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllckVycm9yJywgYXJncylcbiAgICB0aGlzLl9zZXRTdGF0ZSgnJylcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGxvYWRlZGRhdGEoYXJncykge1xuICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyTG9hZGVkRGF0YScsIGFyZ3MpXG4gIH1cblxuICBwbGF5KGFyZ3MpIHtcbiAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllclBsYXknLCBhcmdzKVxuICB9XG5cbiAgcGxheWluZyhhcmdzKSB7XG4gICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJQbGF5aW5nJywgYXJncylcbiAgICB0aGlzLl9zZXRTdGF0ZSgnUGxheWluZycpXG4gIH1cblxuICBjYW5wbGF5KGFyZ3MpIHtcbiAgICB0aGlzLnZpZGVvRWwucGxheSgpXG4gICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJTdGFydCcsIGFyZ3MpXG4gIH1cblxuICBsb2Fkc3RhcnQoYXJncykge1xuICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyTG9hZCcsIGFyZ3MpXG4gIH1cblxuICBzZWVrZWQoKSB7XG4gICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJTZWVrZWQnLCB7XG4gICAgICBjdXJyZW50VGltZTogdGhpcy52aWRlb0VsLmN1cnJlbnRUaW1lLFxuICAgICAgZHVyYXRpb246IHRoaXMudmlkZW9FbC5kdXJhdGlvbiB8fCAxLFxuICAgIH0pXG4gIH1cblxuICBzZWVraW5nKCkge1xuICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyU2Vla2luZycsIHtcbiAgICAgIGN1cnJlbnRUaW1lOiB0aGlzLnZpZGVvRWwuY3VycmVudFRpbWUsXG4gICAgICBkdXJhdGlvbjogdGhpcy52aWRlb0VsLmR1cmF0aW9uIHx8IDEsXG4gICAgfSlcbiAgfVxuXG4gIGR1cmF0aW9uY2hhbmdlKGFyZ3MpIHtcbiAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllckR1cmF0aW9uQ2hhbmdlJywgYXJncylcbiAgfVxuXG4gIGVuY3J5cHRlZChhcmdzKSB7XG4gICAgY29uc3QgdmlkZW8gPSBhcmdzLnZpZGVvRWxlbWVudFxuICAgIGNvbnN0IGV2ZW50ID0gYXJncy5ldmVudFxuICAgIC8vIEZJWE1FOiBEb3VibGUgZW5jcnlwdGVkIGV2ZW50cyBuZWVkIHRvIGJlIHByb3Blcmx5IGZpbHRlcmVkIGJ5IEdzdHJlYW1lclxuICAgIGlmICh2aWRlby5tZWRpYUtleXMgJiYgIXRoaXMuX2VxdWFsSW5pdERhdGEodGhpcy5fcHJldmlvdXNJbml0RGF0YSwgZXZlbnQuaW5pdERhdGEpKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c0luaXREYXRhID0gZXZlbnQuaW5pdERhdGFcbiAgICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyRW5jcnlwdGVkJywgYXJncylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX3N0YXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgY2xhc3MgUGxheWluZyBleHRlbmRzIHRoaXMge1xuICAgICAgICAkZW50ZXIoKSB7XG4gICAgICAgICAgdGhpcy5fc3RhcnRVcGRhdGluZ1ZpZGVvVGV4dHVyZSgpXG4gICAgICAgIH1cbiAgICAgICAgJGV4aXQoKSB7XG4gICAgICAgICAgdGhpcy5fc3RvcFVwZGF0aW5nVmlkZW9UZXh0dXJlKClcbiAgICAgICAgfVxuICAgICAgICB0aW1ldXBkYXRlKCkge1xuICAgICAgICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyUHJvZ3Jlc3MnLCB7XG4gICAgICAgICAgICBjdXJyZW50VGltZTogdGhpcy52aWRlb0VsLmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMudmlkZW9FbC5kdXJhdGlvbiB8fCAxLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZW5kZWQoYXJncykge1xuICAgICAgICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyRW5kZWQnLCBhcmdzKVxuICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCcnKVxuICAgICAgICB9XG4gICAgICAgIHBhdXNlKGFyZ3MpIHtcbiAgICAgICAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllclBhdXNlJywgYXJncylcbiAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnUGxheWluZy5QYXVzZWQnKVxuICAgICAgICB9XG4gICAgICAgIF9jbGVhclNyYygpIHtcbiAgICAgICAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllclN0b3AnLCB7fSlcbiAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnJylcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgX3N0YXRlcygpIHtcbiAgICAgICAgICByZXR1cm4gW2NsYXNzIFBhdXNlZCBleHRlbmRzIHRoaXMge31dXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgXVxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xubGV0IG1ldGFkYXRhID0ge31cblxuZXhwb3J0IGNvbnN0IGluaXRNZXRhZGF0YSA9IG1ldGFkYXRhT2JqID0+IHtcbiAgbWV0YWRhdGEgPSBtZXRhZGF0YU9ialxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldChrZXksIGZhbGxiYWNrID0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGtleSBpbiBtZXRhZGF0YSA/IG1ldGFkYXRhW2tleV0gOiBmYWxsYmFja1xuICB9LFxuICBhcHBJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2lkJylcbiAgfSxcbiAgc2FmZUFwcElkKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnaWQnKS5yZXBsYWNlKC9bXjAtOWEtekEtWl8kXS9nLCAnXycpXG4gIH0sXG4gIGFwcE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCduYW1lJylcbiAgfSxcbiAgYXBwVmVyc2lvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0KCd2ZXJzaW9uJykgfHwgJycpLnNwbGl0KCctJykuc2hpZnQoKVxuICB9LFxuICBhcHBJY29uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnaWNvbicpXG4gIH0sXG4gIC8vIFZlcnNpb24gZnJvbSBhcHAgc3RvcmUgKHdpdGggY29tbWl0IGhhc2gpXG4gIGFwcEZ1bGxWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgndmVyc2lvbicpXG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcblxubGV0IHNlbmRNZXRyaWMgPSAodHlwZSwgZXZlbnQsIHBhcmFtcykgPT4ge1xuICBMb2cuaW5mbygnU2VuZGluZyBtZXRyaWMnLCB0eXBlLCBldmVudCwgcGFyYW1zKVxufVxuXG5leHBvcnQgY29uc3QgaW5pdE1ldHJpY3MgPSBjb25maWcgPT4ge1xuICBzZW5kTWV0cmljID0gY29uZmlnLnNlbmRNZXRyaWNcbn1cblxuLy8gYXZhaWxhYmxlIG1ldHJpYyBwZXIgY2F0ZWdvcnlcbmNvbnN0IG1ldHJpY3MgPSB7XG4gIGFwcDogWydsYXVuY2gnLCAnbG9hZGVkJywgJ3JlYWR5JywgJ2Nsb3NlJ10sXG4gIHBhZ2U6IFsndmlldycsICdsZWF2ZSddLFxuICB1c2VyOiBbJ2NsaWNrJywgJ2lucHV0J10sXG4gIG1lZGlhOiBbXG4gICAgJ2Fib3J0JyxcbiAgICAnY2FucGxheScsXG4gICAgJ2VuZGVkJyxcbiAgICAncGF1c2UnLFxuICAgICdwbGF5JyxcbiAgICAvLyB3aXRoIHNvbWUgdmlkZW9zIHRoZXJlIG9jY3VyIGFsbW9zdCBjb25zdGFudCBzdXNwZW5kIGV2ZW50cyAuLi4gc2hvdWxkIGludmVzdGlnYXRlXG4gICAgLy8gJ3N1c3BlbmQnLFxuICAgICd2b2x1bWVjaGFuZ2UnLFxuICAgICd3YWl0aW5nJyxcbiAgICAnc2Vla2luZycsXG4gICAgJ3NlZWtlZCcsXG4gIF0sXG59XG5cbi8vIGVycm9yIG1ldHJpYyBmdW5jdGlvbiAoYWRkZWQgdG8gZWFjaCBjYXRlZ29yeSlcbmNvbnN0IGVycm9yTWV0cmljID0gKHR5cGUsIG1lc3NhZ2UsIGNvZGUsIHZpc2libGUsIHBhcmFtcyA9IHt9KSA9PiB7XG4gIHBhcmFtcyA9IHsgcGFyYW1zLCAuLi57IG1lc3NhZ2UsIGNvZGUsIHZpc2libGUgfSB9XG4gIHNlbmRNZXRyaWModHlwZSwgJ2Vycm9yJywgcGFyYW1zKVxufVxuXG5jb25zdCBNZXRyaWMgPSAodHlwZSwgZXZlbnRzLCBvcHRpb25zID0ge30pID0+IHtcbiAgcmV0dXJuIGV2ZW50cy5yZWR1Y2UoXG4gICAgKG9iaiwgZXZlbnQpID0+IHtcbiAgICAgIG9ialtldmVudF0gPSAobmFtZSwgcGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgcGFyYW1zID0geyAuLi5vcHRpb25zLCAuLi4obmFtZSA/IHsgbmFtZSB9IDoge30pLCAuLi5wYXJhbXMgfVxuICAgICAgICBzZW5kTWV0cmljKHR5cGUsIGV2ZW50LCBwYXJhbXMpXG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqXG4gICAgfSxcbiAgICB7XG4gICAgICBlcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgZXJyb3JNZXRyaWModHlwZSwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKVxuICAgICAgfSxcbiAgICAgIGV2ZW50KG5hbWUsIHBhcmFtcykge1xuICAgICAgICBzZW5kTWV0cmljKHR5cGUsIG5hbWUsIHBhcmFtcylcbiAgICAgIH0sXG4gICAgfVxuICApXG59XG5cbmNvbnN0IE1ldHJpY3MgPSB0eXBlcyA9PiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0eXBlcykucmVkdWNlKFxuICAgIChvYmosIHR5cGUpID0+IHtcbiAgICAgIC8vIG1lZGlhIG1ldHJpYyB3b3JrcyBhIGJpdCBkaWZmZXJlbnQhXG4gICAgICAvLyBpdCdzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgdXJsIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBhdmFpbGFibGUgbWV0cmljc1xuICAgICAgLy8gdXJsIGlzIGF1dG9tYXRpY2FsbHkgcGFzc2VkIGFzIGEgcGFyYW0gaW4gZXZlcnkgbWV0cmljXG4gICAgICB0eXBlID09PSAnbWVkaWEnXG4gICAgICAgID8gKG9ialt0eXBlXSA9IHVybCA9PiBNZXRyaWModHlwZSwgdHlwZXNbdHlwZV0sIHsgdXJsIH0pKVxuICAgICAgICA6IChvYmpbdHlwZV0gPSBNZXRyaWModHlwZSwgdHlwZXNbdHlwZV0pKVxuICAgICAgcmV0dXJuIG9ialxuICAgIH0sXG4gICAgeyBlcnJvcjogZXJyb3JNZXRyaWMsIGV2ZW50OiBzZW5kTWV0cmljIH1cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZXRyaWNzKG1ldHJpY3MpXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGlnaHRuaW5nIGZyb20gJy4uL0xpZ2h0bmluZydcbmltcG9ydCBQaW4gZnJvbSAnLi4vUGluJ1xuXG5jbGFzcyBQaW5JbnB1dCBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3OiAxMjAsXG4gICAgICBoOiAxNTAsXG4gICAgICByZWN0OiB0cnVlLFxuICAgICAgY29sb3I6IDB4ZmY5NDkzOTMsXG4gICAgICBhbHBoYTogMC41LFxuICAgICAgc2hhZGVyOiB7IHR5cGU6IExpZ2h0bmluZy5zaGFkZXJzLlJvdW5kZWRSZWN0YW5nbGUsIHJhZGl1czogMTAgfSxcbiAgICAgIE5yOiB7XG4gICAgICAgIHc6IHcgPT4gdyxcbiAgICAgICAgeTogMjQsXG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICB0ZXh0Q29sb3I6IDB4ZmYzMzMzMzMsXG4gICAgICAgICAgZm9udFNpemU6IDgwLFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIHNldCBpbmRleCh2KSB7XG4gICAgdGhpcy54ID0gdiAqICgxMjAgKyAyNClcbiAgfVxuXG4gIHNldCBucih2KSB7XG4gICAgdGhpcy5fdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dClcblxuICAgIGlmICh2KSB7XG4gICAgICB0aGlzLnNldFNtb290aCgnYWxwaGEnLCAxKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFNtb290aCgnYWxwaGEnLCAwLjUpXG4gICAgfVxuXG4gICAgdGhpcy50YWcoJ05yJykucGF0Y2goe1xuICAgICAgdGV4dDoge1xuICAgICAgICB0ZXh0OiAodiAmJiB2LnRvU3RyaW5nKCkpIHx8ICcnLFxuICAgICAgICBmb250U2l6ZTogdiA9PT0gJyonID8gMTIwIDogODAsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBpZiAodiAmJiB2ICE9PSAnKicpIHtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG51bGxcbiAgICAgICAgdGhpcy5uciA9ICcqJ1xuICAgICAgfSwgNzUwKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaW5EaWFsb2cgZXh0ZW5kcyBMaWdodG5pbmcuQ29tcG9uZW50IHtcbiAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgekluZGV4OiAxLFxuICAgICAgdzogdyA9PiB3LFxuICAgICAgaDogaCA9PiBoLFxuICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgIGNvbG9yOiAweGRkMDAwMDAwLFxuICAgICAgYWxwaGE6IDAuMDAwMDAxLFxuICAgICAgRGlhbG9nOiB7XG4gICAgICAgIHc6IDY0OCxcbiAgICAgICAgaDogMzIwLFxuICAgICAgICB5OiBoID0+IChoIC0gMzIwKSAvIDIsXG4gICAgICAgIHg6IHcgPT4gKHcgLSA2NDgpIC8gMixcbiAgICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgICAgY29sb3I6IDB4ZGQzMzMzMzMsXG4gICAgICAgIHNoYWRlcjogeyB0eXBlOiBMaWdodG5pbmcuc2hhZGVycy5Sb3VuZGVkUmVjdGFuZ2xlLCByYWRpdXM6IDEwIH0sXG4gICAgICAgIEluZm86IHtcbiAgICAgICAgICB5OiAyNCxcbiAgICAgICAgICB4OiA0OCxcbiAgICAgICAgICB0ZXh0OiB7IHRleHQ6ICdQbGVhc2UgZW50ZXIgeW91ciBQSU4nLCBmb250U2l6ZTogMzIgfSxcbiAgICAgICAgfSxcbiAgICAgICAgTXNnOiB7XG4gICAgICAgICAgeTogMjYwLFxuICAgICAgICAgIHg6IDQ4LFxuICAgICAgICAgIHRleHQ6IHsgdGV4dDogJycsIGZvbnRTaXplOiAyOCwgdGV4dENvbG9yOiAweGZmZmZmZmZmIH0sXG4gICAgICAgIH0sXG4gICAgICAgIENvZGU6IHtcbiAgICAgICAgICB4OiA0OCxcbiAgICAgICAgICB5OiA5NixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgX2luaXQoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogUGluSW5wdXQsXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLnRhZygnQ29kZScpLmNoaWxkcmVuID0gY2hpbGRyZW5cbiAgfVxuXG4gIGdldCBwaW4oKSB7XG4gICAgaWYgKCF0aGlzLl9waW4pIHRoaXMuX3BpbiA9ICcnXG4gICAgcmV0dXJuIHRoaXMuX3BpblxuICB9XG5cbiAgc2V0IHBpbih2KSB7XG4gICAgaWYgKHYubGVuZ3RoIDw9IDQpIHtcbiAgICAgIGNvbnN0IG1hc2tlZFBpbiA9IG5ldyBBcnJheShNYXRoLm1heCh2Lmxlbmd0aCAtIDEsIDApKS5maWxsKCcqJywgMCwgdi5sZW5ndGggLSAxKVxuICAgICAgdi5sZW5ndGggJiYgbWFza2VkUGluLnB1c2godi5sZW5ndGggPiB0aGlzLl9waW4ubGVuZ3RoID8gdi5zbGljZSgtMSkgOiAnKicpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICB0aGlzLnRhZygnQ29kZScpLmNoaWxkcmVuW2ldLm5yID0gbWFza2VkUGluW2ldIHx8ICcnXG4gICAgICB9XG4gICAgICB0aGlzLl9waW4gPSB2XG4gICAgfVxuICB9XG5cbiAgZ2V0IG1zZygpIHtcbiAgICBpZiAoIXRoaXMuX21zZykgdGhpcy5fbXNnID0gJydcbiAgICByZXR1cm4gdGhpcy5fbXNnXG4gIH1cblxuICBzZXQgbXNnKHYpIHtcbiAgICB0aGlzLl90aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KVxuXG4gICAgdGhpcy5fbXNnID0gdlxuICAgIGlmICh0aGlzLl9tc2cpIHtcbiAgICAgIHRoaXMudGFnKCdNc2cnKS50ZXh0ID0gdGhpcy5fbXNnXG4gICAgICB0aGlzLnRhZygnSW5mbycpLnNldFNtb290aCgnYWxwaGEnLCAwLjUpXG4gICAgICB0aGlzLnRhZygnQ29kZScpLnNldFNtb290aCgnYWxwaGEnLCAwLjUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFnKCdNc2cnKS50ZXh0ID0gJydcbiAgICAgIHRoaXMudGFnKCdJbmZvJykuc2V0U21vb3RoKCdhbHBoYScsIDEpXG4gICAgICB0aGlzLnRhZygnQ29kZScpLnNldFNtb290aCgnYWxwaGEnLCAxKVxuICAgIH1cbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLm1zZyA9ICcnXG4gICAgfSwgMjAwMClcbiAgfVxuXG4gIF9maXJzdEFjdGl2ZSgpIHtcbiAgICB0aGlzLnNldFNtb290aCgnYWxwaGEnLCAxKVxuICB9XG5cbiAgX2hhbmRsZUtleShldmVudCkge1xuICAgIGlmICh0aGlzLm1zZykge1xuICAgICAgdGhpcy5tc2cgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWwgPSBwYXJzZUludChldmVudC5rZXkpXG4gICAgICBpZiAodmFsID4gLTEpIHtcbiAgICAgICAgdGhpcy5waW4gKz0gdmFsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUJhY2soKSB7XG4gICAgaWYgKHRoaXMubXNnKSB7XG4gICAgICB0aGlzLm1zZyA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnBpbi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5waW4gPSB0aGlzLnBpbi5zbGljZSgwLCB0aGlzLnBpbi5sZW5ndGggLSAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUGluLmhpZGUoKVxuICAgICAgICB0aGlzLnJlc29sdmUoZmFsc2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUVudGVyKCkge1xuICAgIGlmICh0aGlzLm1zZykge1xuICAgICAgdGhpcy5tc2cgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBQaW4uc3VibWl0KHRoaXMucGluKVxuICAgICAgICAudGhlbih2YWwgPT4ge1xuICAgICAgICAgIHRoaXMubXNnID0gJ1VubG9ja2luZyAuLi4nXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBQaW4uaGlkZSgpXG4gICAgICAgICAgfSwgMTAwMClcbiAgICAgICAgICB0aGlzLnJlc29sdmUodmFsKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgdGhpcy5tc2cgPSBlXG4gICAgICAgICAgdGhpcy5yZWplY3QoZSlcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcbmltcG9ydCBQaW5EaWFsb2cgZnJvbSAnLi9kaWFsb2cnXG5pbXBvcnQgeyBBcHBsaWNhdGlvbkluc3RhbmNlIH0gZnJvbSAnLi4vTGF1bmNoJ1xuaW1wb3J0IHsgTG9nIH0gZnJvbSAnLi4vLi4vaW5kZXgnXG5cbi8vIG9ubHkgdXNlZCBkdXJpbmcgbG9jYWwgZGV2ZWxvcG1lbnRcbmxldCB1bmxvY2tlZCA9IGZhbHNlXG5jb25zdCBjb250ZXh0SXRlbXMgPSBbJ3B1cmNoYXNlJywgJ3BhcmVudGFsJ11cblxubGV0IHN1Ym1pdCA9IChwaW4sIGNvbnRleHQpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAocGluLnRvU3RyaW5nKCkgPT09IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAncGluJywgJzAwMDAnKS50b1N0cmluZygpKSB7XG4gICAgICB1bmxvY2tlZCA9IHRydWVcbiAgICAgIHJlc29sdmUodW5sb2NrZWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCgnSW5jb3JyZWN0IHBpbicpXG4gICAgfVxuICB9KVxufVxuXG5sZXQgY2hlY2sgPSBjb250ZXh0ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHJlc29sdmUodW5sb2NrZWQpXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBpbml0UGluID0gY29uZmlnID0+IHtcbiAgaWYgKGNvbmZpZy5zdWJtaXQgJiYgdHlwZW9mIGNvbmZpZy5zdWJtaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdWJtaXQgPSBjb25maWcuc3VibWl0XG4gIH1cbiAgaWYgKGNvbmZpZy5jaGVjayAmJiB0eXBlb2YgY29uZmlnLmNoZWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hlY2sgPSBjb25maWcuY2hlY2tcbiAgfVxufVxuXG5sZXQgcGluRGlhbG9nID0gbnVsbFxuXG5jb25zdCBjb250ZXh0Q2hlY2sgPSBjb250ZXh0ID0+IHtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIExvZy5pbmZvKCdQbGVhc2UgcHJvdmlkZSBjb250ZXh0IGV4cGxpY2l0bHknKVxuICAgIHJldHVybiBjb250ZXh0SXRlbXNbMF1cbiAgfSBlbHNlIGlmICghY29udGV4dEl0ZW1zLmluY2x1ZGVzKGNvbnRleHQpKSB7XG4gICAgTG9nLndhcm4oJ0luY29ycmVjdCBjb250ZXh0IHByb3ZpZGVkJylcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gY29udGV4dFxufVxuXG4vLyBQdWJsaWMgQVBJXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNob3coKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHBpbkRpYWxvZyA9IEFwcGxpY2F0aW9uSW5zdGFuY2Uuc3RhZ2UuYyh7XG4gICAgICAgIHJlZjogJ1BpbkRpYWxvZycsXG4gICAgICAgIHR5cGU6IFBpbkRpYWxvZyxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0LFxuICAgICAgfSlcbiAgICAgIEFwcGxpY2F0aW9uSW5zdGFuY2UuY2hpbGRMaXN0LmEocGluRGlhbG9nKVxuICAgICAgQXBwbGljYXRpb25JbnN0YW5jZS5mb2N1cyA9IHBpbkRpYWxvZ1xuICAgIH0pXG4gIH0sXG4gIGhpZGUoKSB7XG4gICAgQXBwbGljYXRpb25JbnN0YW5jZS5mb2N1cyA9IG51bGxcbiAgICBBcHBsaWNhdGlvbkluc3RhbmNlLmNoaWxkcmVuID0gQXBwbGljYXRpb25JbnN0YW5jZS5jaGlsZHJlbi5tYXAoXG4gICAgICBjaGlsZCA9PiBjaGlsZCAhPT0gcGluRGlhbG9nICYmIGNoaWxkXG4gICAgKVxuICAgIHBpbkRpYWxvZyA9IG51bGxcbiAgfSxcbiAgc3VibWl0KHBpbiwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dENoZWNrKGNvbnRleHQpXG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgc3VibWl0KHBpbiwgY29udGV4dClcbiAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdCgnSW5jb3JyZWN0IENvbnRleHQgcHJvdmlkZWQnKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIHVubG9ja2VkKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHRDaGVjayhjb250ZXh0KVxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGNoZWNrKGNvbnRleHQpXG4gICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ0luY29ycmVjdCBDb250ZXh0IHByb3ZpZGVkJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBsb2NrZWQoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dENoZWNrKGNvbnRleHQpXG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgY2hlY2soY29udGV4dClcbiAgICAgICAgICAgIC50aGVuKHVubG9ja2VkID0+IHJlc29sdmUoISEhdW5sb2NrZWQpKVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ0luY29ycmVjdCBDb250ZXh0IHByb3ZpZGVkJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgZ2V0TG9jYWxlLCBnZXRMYW5ndWFnZSwgZ2V0Q291bnRyeUNvZGUsIGdldExhdExvbiB9IGZyb20gJy4vaGVscGVycydcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQcm9maWxlID0ge1xuICBhZ2VSYXRpbmc6ICdhZHVsdCcsXG4gIGNpdHk6ICdOZXcgWW9yaycsXG4gIHppcENvZGU6ICcyNzUwNScsXG4gIGNvdW50cnlDb2RlOiAoKSA9PiBnZXRDb3VudHJ5Q29kZSgnVVMnKSxcbiAgaXA6ICcxMjcuMC4wLjEnLFxuICBob3VzZWhvbGQ6ICdiMjI0NGU5ZDRjMDQ4MjZjY2Q1YTdiMmMyYTUwZTdkNCcsXG4gIGxhbmd1YWdlOiAoKSA9PiBnZXRMYW5ndWFnZSgnZW4nKSxcbiAgbGF0bG9uOiAoKSA9PiBnZXRMYXRMb24oWzQwLjcxMjgsIDc0LjAwNl0pLFxuICBsb2NhbGU6ICgpID0+IGdldExvY2FsZSgnZW4tVVMnKSxcbiAgbWFjOiAnMDA6MDA6MDA6MDA6MDA6MDAnLFxuICBvcGVyYXRvcjogJ21ldHJvbG9naWNhbCcsXG4gIHBsYXRmb3JtOiAnbWV0cm9sb2dpY2FsJyxcbiAgcGFja2FnZXM6IFtdLFxuICB1aWQ6ICdlZTY3MjNiOC03YWIzLTQ2MmMtOGQ5My1kYmY2MTIyNzk5OGUnLFxuICBzdGJUeXBlOiAnbWV0cm9sb2dpY2FsJyxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcblxuY29uc3QgZm9ybWF0TG9jYWxlID0gbG9jYWxlID0+IHtcbiAgaWYgKGxvY2FsZSAmJiBsb2NhbGUubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIGAke2xvY2FsZS50b0xvd2VyQ2FzZSgpfS0ke2xvY2FsZS50b1VwcGVyQ2FzZSgpfWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9jYWxlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldExvY2FsZSA9IGRlZmF1bHRWYWx1ZSA9PiB7XG4gIGlmICgnbGFuZ3VhZ2UnIGluIG5hdmlnYXRvcikge1xuICAgIGNvbnN0IGxvY2FsZSA9IGZvcm1hdExvY2FsZShuYXZpZ2F0b3IubGFuZ3VhZ2UpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2NhbGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZWZhdWx0VmFsdWUpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldExhbmd1YWdlID0gZGVmYXVsdFZhbHVlID0+IHtcbiAgaWYgKCdsYW5ndWFnZScgaW4gbmF2aWdhdG9yKSB7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBmb3JtYXRMb2NhbGUobmF2aWdhdG9yLmxhbmd1YWdlKS5zbGljZSgwLCAyKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobGFuZ3VhZ2UpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZWZhdWx0VmFsdWUpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldENvdW50cnlDb2RlID0gZGVmYXVsdFZhbHVlID0+IHtcbiAgaWYgKCdsYW5ndWFnZScgaW4gbmF2aWdhdG9yKSB7XG4gICAgY29uc3QgY291bnRyeUNvZGUgPSBmb3JtYXRMb2NhbGUobmF2aWdhdG9yLmxhbmd1YWdlKS5zbGljZSgzLCA1KVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY291bnRyeUNvZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZWZhdWx0VmFsdWUpXG4gIH1cbn1cblxuY29uc3QgaGFzT3JBc2tGb3JHZW9Mb2NhdGlvblBlcm1pc3Npb24gPSAoKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAvLyBmb3JjZSB0byBwcm9tcHQgZm9yIGxvY2F0aW9uIHBlcm1pc3Npb25cbiAgICBpZiAoU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdmb3JjZUJyb3dzZXJHZW9sb2NhdGlvbicpID09PSB0cnVlKSByZXNvbHZlKHRydWUpXG4gICAgaWYgKCdwZXJtaXNzaW9ucycgaW4gbmF2aWdhdG9yICYmIHR5cGVvZiBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7IG5hbWU6ICdnZW9sb2NhdGlvbicgfSkudGhlbihzdGF0dXMgPT4ge1xuICAgICAgICByZXNvbHZlKHN0YXR1cy5zdGF0ZSA9PT0gJ2dyYW50ZWQnIHx8IHN0YXR1cy5zdGF0dXMgPT09ICdncmFudGVkJylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUoZmFsc2UpXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0TGF0TG9uID0gZGVmYXVsdFZhbHVlID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGhhc09yQXNrRm9yR2VvTG9jYXRpb25QZXJtaXNzaW9uKCkudGhlbihncmFudGVkID0+IHtcbiAgICAgIGlmIChncmFudGVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikge1xuICAgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oXG4gICAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgICAgICByZXN1bHQgPT5cbiAgICAgICAgICAgICAgcmVzdWx0ICYmIHJlc3VsdC5jb29yZHMgJiYgcmVzb2x2ZShbcmVzdWx0LmNvb3Jkcy5sYXRpdHVkZSwgcmVzdWx0LmNvb3Jkcy5sb25naXR1ZGVdKSxcbiAgICAgICAgICAgIC8vIGVycm9yXG4gICAgICAgICAgICAoKSA9PiByZXNvbHZlKGRlZmF1bHRWYWx1ZSksXG4gICAgICAgICAgICAvLyBvcHRpb25zXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZSxcbiAgICAgICAgICAgICAgdGltZW91dDogNTAwMCxcbiAgICAgICAgICAgICAgbWF4aW11bUFnZTogMCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5Rm9yTGF0TG9uKCkudGhlbihyZXN1bHQgPT4gcmVzb2x2ZShyZXN1bHQgfHwgZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5Rm9yTGF0TG9uKCkudGhlbihyZXN1bHQgPT4gcmVzb2x2ZShyZXN1bHQgfHwgZGVmYXVsdFZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5jb25zdCBxdWVyeUZvckxhdExvbiA9ICgpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGZldGNoKCdodHRwczovL2dlb2xvY2F0aW9uLWRiLmNvbS9qc29uLycpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAudGhlbigoeyBsYXRpdHVkZSwgbG9uZ2l0dWRlIH0pID0+XG4gICAgICAgIGxhdGl0dWRlICYmIGxvbmdpdHVkZSA/IHJlc29sdmUoW2xhdGl0dWRlLCBsb25naXR1ZGVdKSA6IHJlc29sdmUoZmFsc2UpXG4gICAgICApXG4gICAgICAuY2F0Y2goKCkgPT4gcmVzb2x2ZShmYWxzZSkpXG4gIH0pXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgeyBkZWZhdWx0UHJvZmlsZSB9IGZyb20gJy4vZGVmYXVsdHMnXG5cbmxldCBnZXRJbmZvID0ga2V5ID0+IHtcbiAgY29uc3QgcHJvZmlsZSA9IHsgLi4uZGVmYXVsdFByb2ZpbGUsIC4uLlNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAncHJvZmlsZScpIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlb2YgcHJvZmlsZVtrZXldID09PSAnZnVuY3Rpb24nID8gcHJvZmlsZVtrZXldKCkgOiBwcm9maWxlW2tleV0pXG59XG5cbmxldCBzZXRJbmZvID0gKGtleSwgcGFyYW1zKSA9PiB7XG4gIGlmIChrZXkgaW4gZGVmYXVsdFByb2ZpbGUpIGRlZmF1bHRQcm9maWxlW2tleV0gPSBwYXJhbXNcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRQcm9maWxlID0gY29uZmlnID0+IHtcbiAgZ2V0SW5mbyA9IGNvbmZpZy5nZXRJbmZvXG4gIHNldEluZm8gPSBjb25maWcuc2V0SW5mb1xufVxuXG5jb25zdCBnZXRPclNldCA9IChrZXksIHBhcmFtcykgPT4gKHBhcmFtcyA/IHNldEluZm8oa2V5LCBwYXJhbXMpIDogZ2V0SW5mbyhrZXkpKVxuXG4vLyBwdWJsaWMgQVBJXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFnZVJhdGluZyhwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2FnZVJhdGluZycsIHBhcmFtcylcbiAgfSxcbiAgY2l0eShwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2NpdHknLCBwYXJhbXMpXG4gIH0sXG4gIHppcENvZGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCd6aXBDb2RlJywgcGFyYW1zKVxuICB9LFxuICBjb3VudHJ5Q29kZShwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2NvdW50cnlDb2RlJywgcGFyYW1zKVxuICB9LFxuICBpcChwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2lwJywgcGFyYW1zKVxuICB9LFxuICBob3VzZWhvbGQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCdob3VzZWhvbGQnLCBwYXJhbXMpXG4gIH0sXG4gIGxhbmd1YWdlKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgnbGFuZ3VhZ2UnLCBwYXJhbXMpXG4gIH0sXG4gIGxhdGxvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2xhdGxvbicsIHBhcmFtcylcbiAgfSxcbiAgbG9jYWxlKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgnbG9jYWxlJywgcGFyYW1zKVxuICB9LFxuICBtYWMocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCdtYWMnLCBwYXJhbXMpXG4gIH0sXG4gIG9wZXJhdG9yKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgnb3BlcmF0b3InLCBwYXJhbXMpXG4gIH0sXG4gIHBsYXRmb3JtKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgncGxhdGZvcm0nLCBwYXJhbXMpXG4gIH0sXG4gIHBhY2thZ2VzKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgncGFja2FnZXMnLCBwYXJhbXMpXG4gIH0sXG4gIHVpZChwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ3VpZCcsIHBhcmFtcylcbiAgfSxcbiAgc3RiVHlwZShwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ3N0YlR5cGUnLCBwYXJhbXMpXG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgUHJvZmlsZSBmcm9tICcuLi9Qcm9maWxlJ1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuaW1wb3J0IHNlcXVlbmNlIGZyb20gJy4uL2hlbHBlcnMvc2VxdWVuY2UnXG5cbmxldCBjc3BVcmwgPSAnaHR0cDovL3BheW1lbnQtY3NwLWV4YW1wbGUubWV0cm9sb2dpY2FsLmNvbTo4MDgwLydcbmxldCBiaWxsaW5nVXJsID0gJ2h0dHBzOi8vcGF5bWVudC1zZGsubWV0cm9sb2dpY2FsLmNvbS8nXG5cbmxldCBjc3BFbmRwb2ludHMgPSB7XG4gIGFzc2V0czoge1xuICAgIHVyaTogJy9hc3NldHMnLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gIH0sXG4gIGFzc2V0OiB7XG4gICAgdXJpOiAnL2Fzc2V0cy86aWQnLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gIH0sXG4gIHNpZ25hdHVyZToge1xuICAgIHVyaTogJy9hc3NldHMvOmlkL3NpZ25hdHVyZScsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gIH0sXG4gIHN1YnNjcmliZToge1xuICAgIHVyaTogJy9hc3NldHMvOmlkL3N1YnNjcmliZScsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gIH0sXG4gIHVuc3Vic2NyaWJlOiB7XG4gICAgdXJpOiAnL2Fzc2V0cy86aWQvdW5zdWJzY3JpYmUnLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICB9LFxufVxuXG5leHBvcnQgY29uc3QgaW5pdFB1cmNoYXNlID0gY29uZmlnID0+IHtcbiAgaWYgKGNvbmZpZy5iaWxsaW5nVXJsKSBiaWxsaW5nVXJsID0gY29uZmlnLmJpbGxpbmdVcmxcbn1cblxuY29uc3QgY3JlYXRlVXJsID0gKHVyaSwgYmFzZVVybCwgcGFyYW1zID0ge30pID0+IHtcbiAgcmV0dXJuIG5ldyBVUkwoXG4gICAgLy8gc3ByaW5rbGUgaW4gdGhlIHBhcmFtc1xuICAgIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgIC5yZWR1Y2UoKHJlcywga2V5KSA9PiByZXMucmVwbGFjZShuZXcgUmVnRXhwKCc6JyArIGtleSwgJ2cnKSwgcGFyYW1zW2tleV0pLCB1cmkpXG4gICAgICAvLyByZW1vdmUgYW55IGxlYWRpbmcgc2xhc2ggZnJvbSB1cmlcbiAgICAgIC5yZXBsYWNlKC9eXFwvLywgJycpLFxuICAgIC8vIG1ha2Ugc3VyZSBiYXNlVXJsIGFsd2F5cyBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICAgIC9cXC8kLy50ZXN0KGJhc2VVcmwpID8gYmFzZVVybCA6IGJhc2VVcmwucmVwbGFjZSgvJC8sICcvJylcbiAgKVxufVxuXG5jb25zdCByZXF1ZXN0ID0gKHVybCwgbWV0aG9kID0gJ0dFVCcsIGRhdGEsIGhlYWRlcnMgPSB7fSkgPT4ge1xuICBpZiAobWV0aG9kID09PSAnR0VUJyAmJiBkYXRhKSB7XG4gICAgdXJsLnNlYXJjaCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoZGF0YSlcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZmV0Y2godXJsLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLntcbiAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgYm9keTogbWV0aG9kICE9PSAnR0VUJyAmJiBkYXRhID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiBudWxsLFxuICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiAocmVzcG9uc2Uub2sgPyByZXNvbHZlKHJlc3BvbnNlLmpzb24oKSkgOiByZWplY3QocmVzcG9uc2Uuc3RhdHVzVGV4dCkpKVxuICAgICAgLmNhdGNoKHJlamVjdClcbiAgfSlcbn1cblxuY29uc3QgY3NwUmVxdWVzdCA9ICh0eXBlLCBkYXRhID0gbnVsbCwgcGFyYW1zID0ge30pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBlbmRwb2ludCA9IGNzcEVuZHBvaW50c1t0eXBlXVxuXG4gICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgcmVqZWN0KCdObyBlbmRwb2ludCBmb3VuZCBmb3IgXCInICsgdHlwZSArICdcIiBjYWxsJylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuZHBvaW50LmNhbGxiYWNrICYmIHR5cGVvZiBlbmRwb2ludC5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbmRwb2ludFxuICAgICAgICAgIC5jYWxsYmFjayhkYXRhLCBwYXJhbXMpXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdChcbiAgICAgICAgICBjcmVhdGVVcmwoZW5kcG9pbnQudXJpLCBjc3BVcmwsIHBhcmFtcyksXG4gICAgICAgICAgZW5kcG9pbnQubWV0aG9kLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLihlbmRwb2ludC5kYXRhIHx8IHt9KSxcbiAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmRwb2ludC5oZWFkZXJzIHx8IHt9XG4gICAgICAgIClcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG5jb25zdCBiaWxsaW5nUmVxdWVzdCA9ICh1cmksIGRhdGEsIG1ldGhvZCA9ICdQT1NUJykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcXVlc3QoY3JlYXRlVXJsKHVyaSwgYmlsbGluZ1VybCksIG1ldGhvZCwgZGF0YSlcbiAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAuY2F0Y2gocmVqZWN0KVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldHVwKGNvbmZpZykge1xuICAgIGlmIChjb25maWcuY3NwVXJsKSBjc3BVcmwgPSBjb25maWcuY3NwVXJsXG4gICAgaWYgKGNvbmZpZy5lbmRwb2ludHMpIGNzcEVuZHBvaW50cyA9IHsgY3NwRW5kcG9pbnRzLCAuLi5jb25maWcuZW5kcG9pbnRzIH1cbiAgfSxcbiAgYXNzZXRzKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBQcm9maWxlLmhvdXNlaG9sZCgpLnRoZW4oaG91c2Vob2xkID0+IHtcbiAgICAgICAgY3NwUmVxdWVzdCgnYXNzZXRzJywgeyBob3VzZWhvbGQgfSlcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIGFzc2V0KGlkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIFByb2ZpbGUuaG91c2Vob2xkKCkudGhlbihob3VzZWhvbGQgPT4ge1xuICAgICAgICBjc3BSZXF1ZXN0KCdhc3NldCcsIHsgaG91c2Vob2xkIH0sIHsgaWQgfSlcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIHNpZ25hdHVyZShpZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBQcm9taXNlLmFsbChbUHJvZmlsZS5ob3VzZWhvbGQoKV0pLnRoZW4oKFtob3VzZWhvbGRdKSA9PiB7XG4gICAgICAgIGNzcFJlcXVlc3QoJ3NpZ25hdHVyZScsIHsgaG91c2Vob2xkIH0sIHsgaWQgfSlcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIHN1YnNjcmliZShpZCwgdHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY3NwUmVxdWVzdCgnc3Vic2NyaWJlJywgeyAuLi50cmFuc2FjdGlvbiB9LCB7IGlkIH0pXG4gICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfSxcbiAgdW5zdWJzY3JpYmUoaWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgUHJvZmlsZS5ob3VzZWhvbGQoKS50aGVuKGhvdXNlaG9sZCA9PiB7XG4gICAgICAgIGNzcFJlcXVlc3QoJ3Vuc3Vic2NyaWJlJywgeyBob3VzZWhvbGQgfSwgeyBpZCB9KVxuICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgcGF5bWVudChzaWduYXR1cmUgPSB7fSwgdHlwZSA9ICdpbi1hcHAnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgUHJvZmlsZS5ob3VzZWhvbGQoKSxcbiAgICAgICAgUHJvZmlsZS5jb3VudHJ5Q29kZSgpLFxuICAgICAgICBQcm9maWxlLm9wZXJhdG9yKCksXG4gICAgICAgIFByb2ZpbGUubWFjKCksXG4gICAgICAgIFByb2ZpbGUudWlkKCksXG4gICAgICBdKVxuICAgICAgICAudGhlbigoW2hvdXNlaG9sZCwgY291bnRyeSwgb3BlcmF0b3IsIG1hYywgdWlkXSkgPT4ge1xuICAgICAgICAgIGJpbGxpbmdSZXF1ZXN0KCcvJywge1xuICAgICAgICAgICAgcHVyY2hhc2U6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IFNldHRpbmdzLmdldCgnYXBwJywgJ2lkJyksXG4gICAgICAgICAgICBuYW1lOiBTZXR0aW5ncy5nZXQoJ2FwcCcsICdpZCcpLFxuICAgICAgICAgICAgaG91c2Vob2xkLFxuICAgICAgICAgICAgY291bnRyeSxcbiAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgbWFjLFxuICAgICAgICAgICAgdWlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfSxcbiAgY29uZmlybSh0cmFuc2FjdGlvbklkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGJpbGxpbmdSZXF1ZXN0KCcvY29uZmlybScsIHtcbiAgICAgICAgdHJhbnNhY3Rpb25JZCxcbiAgICAgIH0pXG4gICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfSxcbiAgYnV5KGFzc2V0SWQsIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHRyYW5zYWN0aW9uSWRcbiAgICAgIHNlcXVlbmNlKFtcbiAgICAgICAgKCkgPT4gdGhpcy5zaWduYXR1cmUoYXNzZXRJZCksXG4gICAgICAgIHNpZ25hdHVyZSA9PiB0aGlzLnBheW1lbnQoc2lnbmF0dXJlLCB0eXBlKSxcbiAgICAgICAgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICAgIHRyYW5zYWN0aW9uSWQgPSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbklkXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKGFzc2V0SWQsIHRyYW5zYWN0aW9uKVxuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB0aGlzLmNvbmZpcm0odHJhbnNhY3Rpb25JZCksXG4gICAgICBdKVxuICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgIH0pXG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcblxuY29uc3QgcmVnaXN0cnkgPSB7XG4gIGV2ZW50TGlzdGVuZXJzOiBbXSxcbiAgdGltZW91dHM6IFtdLFxuICBpbnRlcnZhbHM6IFtdLFxuICB0YXJnZXRzOiBbXSxcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAvLyBUaW1lb3V0c1xuICBzZXRUaW1lb3V0KGNiLCB0aW1lb3V0LCAuLi5wYXJhbXMpIHtcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4ge1xuICAgICAgICByZWdpc3RyeS50aW1lb3V0cyA9IHJlZ2lzdHJ5LnRpbWVvdXRzLmZpbHRlcihpZCA9PiBpZCAhPT0gdGltZW91dElkKVxuICAgICAgICBjYi5hcHBseShudWxsLCBwYXJhbXMpXG4gICAgICB9LFxuICAgICAgdGltZW91dCxcbiAgICAgIHBhcmFtc1xuICAgIClcbiAgICBMb2cuaW5mbygnU2V0IFRpbWVvdXQnLCAnSUQ6ICcgKyB0aW1lb3V0SWQpXG4gICAgcmVnaXN0cnkudGltZW91dHMucHVzaCh0aW1lb3V0SWQpXG4gICAgcmV0dXJuIHRpbWVvdXRJZFxuICB9LFxuXG4gIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpIHtcbiAgICBpZiAocmVnaXN0cnkudGltZW91dHMuaW5kZXhPZih0aW1lb3V0SWQpID4gLTEpIHtcbiAgICAgIHJlZ2lzdHJ5LnRpbWVvdXRzID0gcmVnaXN0cnkudGltZW91dHMuZmlsdGVyKGlkID0+IGlkICE9PSB0aW1lb3V0SWQpXG4gICAgICBMb2cuaW5mbygnQ2xlYXIgVGltZW91dCcsICdJRDogJyArIHRpbWVvdXRJZClcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIExvZy5lcnJvcignQ2xlYXIgVGltZW91dCcsICdJRCAnICsgdGltZW91dElkICsgJyBub3QgZm91bmQnKVxuICAgIH1cbiAgfSxcblxuICBjbGVhclRpbWVvdXRzKCkge1xuICAgIHJlZ2lzdHJ5LnRpbWVvdXRzLmZvckVhY2godGltZW91dElkID0+IHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICB9KVxuICB9LFxuXG4gIC8vIEludGVydmFsc1xuICBzZXRJbnRlcnZhbChjYiwgaW50ZXJ2YWwsIC4uLnBhcmFtcykge1xuICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChcbiAgICAgICgpID0+IHtcbiAgICAgICAgcmVnaXN0cnkuaW50ZXJ2YWxzLmZpbHRlcihpZCA9PiBpZCAhPT0gaW50ZXJ2YWxJZClcbiAgICAgICAgY2IuYXBwbHkobnVsbCwgcGFyYW1zKVxuICAgICAgfSxcbiAgICAgIGludGVydmFsLFxuICAgICAgcGFyYW1zXG4gICAgKVxuICAgIExvZy5pbmZvKCdTZXQgSW50ZXJ2YWwnLCAnSUQ6ICcgKyBpbnRlcnZhbElkKVxuICAgIHJlZ2lzdHJ5LmludGVydmFscy5wdXNoKGludGVydmFsSWQpXG4gICAgcmV0dXJuIGludGVydmFsSWRcbiAgfSxcblxuICBjbGVhckludGVydmFsKGludGVydmFsSWQpIHtcbiAgICBpZiAocmVnaXN0cnkuaW50ZXJ2YWxzLmluZGV4T2YoaW50ZXJ2YWxJZCkgPiAtMSkge1xuICAgICAgcmVnaXN0cnkuaW50ZXJ2YWxzID0gcmVnaXN0cnkuaW50ZXJ2YWxzLmZpbHRlcihpZCA9PiBpZCAhPT0gaW50ZXJ2YWxJZClcbiAgICAgIExvZy5pbmZvKCdDbGVhciBJbnRlcnZhbCcsICdJRDogJyArIGludGVydmFsSWQpXG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIExvZy5lcnJvcignQ2xlYXIgSW50ZXJ2YWwnLCAnSUQgJyArIGludGVydmFsSWQgKyAnIG5vdCBmb3VuZCcpXG4gICAgfVxuICB9LFxuXG4gIGNsZWFySW50ZXJ2YWxzKCkge1xuICAgIHJlZ2lzdHJ5LmludGVydmFscy5mb3JFYWNoKGludGVydmFsSWQgPT4ge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKGludGVydmFsSWQpXG4gICAgfSlcbiAgfSxcblxuICAvLyBFdmVudCBsaXN0ZW5lcnNcbiAgYWRkRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpXG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPVxuICAgICAgcmVnaXN0cnkudGFyZ2V0cy5pbmRleE9mKHRhcmdldCkgPiAtMVxuICAgICAgICA/IHJlZ2lzdHJ5LnRhcmdldHMuaW5kZXhPZih0YXJnZXQpXG4gICAgICAgIDogcmVnaXN0cnkudGFyZ2V0cy5wdXNoKHRhcmdldCkgLSAxXG5cbiAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF0gPSByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF0gfHwge31cbiAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF1bZXZlbnRdID0gcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdW2V2ZW50XSB8fCBbXVxuICAgIHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzW3RhcmdldEluZGV4XVtldmVudF0ucHVzaChoYW5kbGVyKVxuICAgIExvZy5pbmZvKFxuICAgICAgJ0FkZCBldmVudExpc3RlbmVyJyxcbiAgICAgICdUYXJnZXQ6JyxcbiAgICAgIHRhcmdldCxcbiAgICAgICdFdmVudDogJyArIGV2ZW50LFxuICAgICAgJ0hhbmRsZXI6JyxcbiAgICAgIGhhbmRsZXIudG9TdHJpbmcoKVxuICAgIClcbiAgfSxcblxuICByZW1vdmVFdmVudExpc3RlbmVyKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IHJlZ2lzdHJ5LnRhcmdldHMuaW5kZXhPZih0YXJnZXQpXG4gICAgaWYgKFxuICAgICAgdGFyZ2V0SW5kZXggPiAtMSAmJlxuICAgICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdICYmXG4gICAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF1bZXZlbnRdICYmXG4gICAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF1bZXZlbnRdLmluZGV4T2YoaGFuZGxlcikgPiAtMVxuICAgICkge1xuICAgICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdW2V2ZW50XSA9IHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzW3RhcmdldEluZGV4XVtcbiAgICAgICAgZXZlbnRcbiAgICAgIF0uZmlsdGVyKGZuID0+IGZuICE9PSBoYW5kbGVyKVxuICAgICAgTG9nLmluZm8oXG4gICAgICAgICdSZW1vdmUgZXZlbnRMaXN0ZW5lcicsXG4gICAgICAgICdUYXJnZXQ6JyxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICAnRXZlbnQ6ICcgKyBldmVudCxcbiAgICAgICAgJ0hhbmRsZXI6JyxcbiAgICAgICAgaGFuZGxlci50b1N0cmluZygpXG4gICAgICApXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcilcbiAgICB9IGVsc2Uge1xuICAgICAgTG9nLmVycm9yKFxuICAgICAgICAnUmVtb3ZlIGV2ZW50TGlzdGVuZXInLFxuICAgICAgICAnTm90IGZvdW5kJyxcbiAgICAgICAgJ1RhcmdldCcsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgJ0V2ZW50OiAnICsgZXZlbnQsXG4gICAgICAgICdIYW5kbGVyJyxcbiAgICAgICAgaGFuZGxlci50b1N0cmluZygpXG4gICAgICApXG4gICAgfVxuICB9LFxuXG4gIC8vIGlmIGBldmVudGAgaXMgb21pdHRlZCwgcmVtb3ZlcyBhbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMgZm9yIHRhcmdldFxuICAvLyBpZiBgdGFyZ2V0YCBpcyBhbHNvIG9taXR0ZWQsIHJlbW92ZXMgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgZXZlbnQpIHtcbiAgICBpZiAodGFyZ2V0ICYmIGV2ZW50KSB7XG4gICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHJlZ2lzdHJ5LnRhcmdldHMuaW5kZXhPZih0YXJnZXQpXG4gICAgICBpZiAodGFyZ2V0SW5kZXggPiAtMSkge1xuICAgICAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF1bZXZlbnRdLmZvckVhY2goaGFuZGxlciA9PiB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gcmVnaXN0cnkudGFyZ2V0cy5pbmRleE9mKHRhcmdldClcbiAgICAgIGlmICh0YXJnZXRJbmRleCA+IC0xKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzW3RhcmdldEluZGV4XSkuZm9yRWFjaChfZXZlbnQgPT4ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCBfZXZlbnQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzKS5mb3JFYWNoKHRhcmdldEluZGV4ID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycyhyZWdpc3RyeS50YXJnZXRzW3RhcmdldEluZGV4XSlcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIC8vIENsZWFyIGV2ZXJ5dGhpbmcgKHRvIGJlIGNhbGxlZCB1cG9uIGFwcCBjbG9zZSBmb3IgcHJvcGVyIGNsZWFudXApXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0cygpXG4gICAgdGhpcy5jbGVhckludGVydmFscygpXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpXG4gICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnMgPSBbXVxuICAgIHJlZ2lzdHJ5LnRpbWVvdXRzID0gW11cbiAgICByZWdpc3RyeS5pbnRlcnZhbHMgPSBbXVxuICAgIHJlZ2lzdHJ5LnRhcmdldHMgPSBbXVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi9MaWdodG5pbmcnXG5pbXBvcnQgeyBkZWZhdWx0IGFzIFJvdXRlciB9IGZyb20gJy4vaW5kZXgnXG5pbXBvcnQgeyByb3V0ZXJDb25maWcgfSBmcm9tICcuL3V0aWxzL3JvdXRlci5qcydcbmltcG9ydCB7IGlzQm9vbGVhbiB9IGZyb20gJy4vdXRpbHMvaGVscGVycydcblxuZXhwb3J0IGNsYXNzIFJvdXRlZEFwcCBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBQYWdlczoge1xuICAgICAgICBmb3JjZVpJbmRleENvbnRleHQ6IHRydWUsXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGEgZGVmYXVsdCBMb2FkaW5nIHBhZ2UgdGhhdCB3aWxsIGJlIG1hZGUgdmlzaWJsZVxuICAgICAgICogZHVyaW5nIGRhdGEtcHJvdmlkZXIgb24oKSB5b3UgQ0FOIG92ZXJyaWRlIGluIGNoaWxkLWNsYXNzXG4gICAgICAgKi9cbiAgICAgIExvYWRpbmc6IHtcbiAgICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgICAgdzogMTkyMCxcbiAgICAgICAgaDogMTA4MCxcbiAgICAgICAgY29sb3I6IDB4ZmYwMDAwMDAsXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICB6SW5kZXg6IDk5LFxuICAgICAgICBMYWJlbDoge1xuICAgICAgICAgIG1vdW50OiAwLjUsXG4gICAgICAgICAgeDogOTYwLFxuICAgICAgICAgIHk6IDU0MCxcbiAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICB0ZXh0OiAnTG9hZGluZy4uJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX3N0YXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgY2xhc3MgTG9hZGluZyBleHRlbmRzIHRoaXMge1xuICAgICAgICAkZW50ZXIoKSB7XG4gICAgICAgICAgdGhpcy50YWcoJ0xvYWRpbmcnKS52aXNpYmxlID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgJGV4aXQoKSB7XG4gICAgICAgICAgdGhpcy50YWcoJ0xvYWRpbmcnKS52aXNpYmxlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNsYXNzIFdpZGdldHMgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgJGVudGVyKGFyZ3MsIHdpZGdldCkge1xuICAgICAgICAgIC8vIHN0b3JlIHdpZGdldCByZWZlcmVuY2VcbiAgICAgICAgICB0aGlzLl93aWRnZXQgPSB3aWRnZXRcblxuICAgICAgICAgIC8vIHNpbmNlIGl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGJlaGF2aW91clxuICAgICAgICAgIC8vIGlzIG5vbi1yZW1vdGUgZHJpdmVuIHdlIGZvcmNlIGEgcmVjYWxjdWxhdGlvblxuICAgICAgICAgIC8vIG9mIHRoZSBmb2N1c3BhdGhcbiAgICAgICAgICB0aGlzLl9yZWZvY3VzKClcbiAgICAgICAgfVxuXG4gICAgICAgIF9nZXRGb2N1c2VkKCkge1xuICAgICAgICAgIC8vIHdlIGRlbGVnYXRlIGZvY3VzIHRvIHNlbGVjdGVkIHdpZGdldFxuICAgICAgICAgIC8vIHNvIGl0IGNhbiBjb25zdW1lIHJlbW90ZWNvbnRyb2wgcHJlc3Nlc1xuICAgICAgICAgIHJldHVybiB0aGlzLl93aWRnZXRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdG8gd2lkZ2V0IHRvIHdpZGdldCBmb2N1cyBkZWxlZ2F0aW9uXG4gICAgICAgIHJlbG9hZCh3aWRnZXQpIHtcbiAgICAgICAgICB0aGlzLl93aWRnZXQgPSB3aWRnZXRcbiAgICAgICAgICB0aGlzLl9yZWZvY3VzKClcbiAgICAgICAgfVxuXG4gICAgICAgIF9oYW5kbGVLZXkoKSB7XG4gICAgICAgICAgY29uc3QgcmVzdG9yZUZvY3VzID0gcm91dGVyQ29uZmlnLmdldCgnYXV0b1Jlc3RvcmVSZW1vdGUnKVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBSb3V0ZXIgdXNlZCB0byBkZWxlZ2F0ZSBmb2N1cyBiYWNrIHRvIHRoZSBwYWdlIGluc3RhbmNlIG9uXG4gICAgICAgICAgICogZXZlcnkgdW5oYW5kbGVkIGtleS4gVGhpcyBpcyBiYXJlbHkgdXNlZnVsbCBpbiBhbnkgc2l0dWF0aW9uXG4gICAgICAgICAgICogc28gZm9yIG5vdyB3ZSBvZmZlciB0aGUgb3B0aW9uIHRvIGV4cGxpY2l0eSB0dXJuIHRoYXQgYmVoYXZpb3VyIG9mZlxuICAgICAgICAgICAqIHNvIHdlIGRvbid0IGRvbid0IGludHJvZHVjZSBhIGJyZWFraW5nIGNoYW5nZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoIWlzQm9vbGVhbihyZXN0b3JlRm9jdXMpIHx8IHJlc3RvcmVGb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgUm91dGVyLmZvY3VzUGFnZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIF1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gbG9jYXRpb24gd2hlcmUgcGFnZXMgbmVlZCB0byBiZSBzdG9yZWRcbiAgICovXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy50YWcoJ1BhZ2VzJylcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxsIHJvdXRlciB3aGVyZSB3aWRnZXRzIGFyZSBzdG9yZWRcbiAgICovXG4gIGdldCB3aWRnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZygnV2lkZ2V0cycpXG4gIH1cblxuICAvKipcbiAgICogd2UgTVVTVCByZWdpc3RlciBfaGFuZGxlQmFjayBtZXRob2Qgc28gdGhlIFJvdXRlclxuICAgKiBjYW4gb3ZlcnJpZGUgaXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVCYWNrKCkge31cblxuICAvKipcbiAgICogV2UgTVVTVCByZXR1cm4gUm91dGVyLmFjdGl2ZVBhZ2UoKSBzbyB0aGUgbmV3IFBhZ2VcbiAgICogY2FuIGxpc3RlbiB0byB0aGUgcmVtb3RlLWNvbnRyb2wuXG4gICAqL1xuICBfZ2V0Rm9jdXNlZCgpIHtcbiAgICByZXR1cm4gUm91dGVyLmdldEFjdGl2ZVBhZ2UoKVxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBpc0Z1bmN0aW9uLFxuICBpc1BhZ2UsXG4gIGlzT2JqZWN0LFxuICBpc0Jvb2xlYW4sXG4gIGlzU3RyaW5nLFxuICBnZXRRdWVyeVN0cmluZ1BhcmFtcyxcbiAgc3ltYm9scyxcbiAgY2xlYW5IYXNoLFxufSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnXG5cbmltcG9ydCB7XG4gIGJvb3RSb3V0ZXIsXG4gIHJvdXRlRXhpc3RzLFxuICBnZXRSb290SGFzaCxcbiAgZ2V0Qm9vdFJlcXVlc3QsXG4gIG11c3RVcGRhdGVMb2NhdGlvbkhhc2gsXG4gIGdldENvbXBvbmVudCxcbiAgc3RvcmVDb21wb25lbnQsXG4gIHN0YWdlLFxuICBhcHAsXG4gIHJvdXRlckNvbmZpZyxcbiAgc2V0TGFzdEhhc2gsXG4gIGdldEFjdGl2ZVBhZ2UsXG4gIGJlZm9yZUVhY2hSb3V0ZSxcbiAgZ2V0QWN0aXZlSGFzaCxcbiAgZ2V0QWN0aXZlUm91dGUsXG59IGZyb20gJy4vdXRpbHMvcm91dGVyJ1xuXG5pbXBvcnQgeyBmb2N1c1dpZGdldCwgZ2V0QWN0aXZlV2lkZ2V0LCByZXN0b3JlRm9jdXMgfSBmcm9tICcuL3V0aWxzL3dpZGdldHMnXG5pbXBvcnQgeyBnZXRIaXN0b3J5LCBzZXRIaXN0b3J5LCBnZXRIaXN0b3J5U3RhdGUsIHJlcGxhY2VIaXN0b3J5U3RhdGUgfSBmcm9tICcuL3V0aWxzL2hpc3RvcnknXG5pbXBvcnQge1xuICBjcmVhdGVSZXF1ZXN0LFxuICBnZXRSb3V0ZUJ5SGFzaCxcbiAgZ2V0VmFsdWVzRnJvbUhhc2gsXG4gIGdldEZsb29yLFxuICBnZXRIYXNoQnlOYW1lLFxuICBrZWVwQWN0aXZlUGFnZUFsaXZlLFxufSBmcm9tICcuL3V0aWxzL3JvdXRlJ1xuaW1wb3J0IHsgbG9hZCB9IGZyb20gJy4vdXRpbHMvbG9hZGVyJ1xuaW1wb3J0IHsgc3RyaXBSZWdleCwgaXNXaWxkY2FyZCB9IGZyb20gJy4vdXRpbHMvcmVnZXgnXG5pbXBvcnQgeyBSb3V0ZWRBcHAgfSBmcm9tICcuL2Jhc2UnXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSAnLi4vUmVnaXN0cnknXG5cbi8qXG5yb3VUaG9yID09W3hdXG4gKi9cbmV4cG9ydCBsZXQgbmF2aWdhdGVRdWV1ZSA9IG5ldyBNYXAoKVxubGV0IGZvcmNlZEhhc2ggPSAnJ1xubGV0IHJlc3VtZUhhc2ggPSAnJ1xuXG4vKipcbiAqIFN0YXJ0IHJvdXRpbmcgdGhlIGFwcFxuICogQHBhcmFtIGNvbmZpZyAtIHJvdXRlIGNvbmZpZyBvYmplY3RcbiAqIEBwYXJhbSBpbnN0YW5jZSAtIGluc3RhbmNlIG9mIHRoZSBhcHBcbiAqL1xuY29uc3Qgc3RhcnRSb3V0ZXIgPSAoY29uZmlnLCBpbnN0YW5jZSkgPT4ge1xuICBib290Um91dGVyKGNvbmZpZywgaW5zdGFuY2UpXG4gIHJlZ2lzdGVyTGlzdGVuZXIoKVxuICBzdGFydCgpXG59XG5cbi8vIHN0YXJ0IHRyYW5zbGF0aW5nIHVybFxuY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gIGxldCBoYXNoID0gKGdldEhhc2goKSB8fCAnJykucmVwbGFjZSgvXiMvLCAnJylcbiAgY29uc3QgYm9vdEtleSA9ICckJ1xuICBjb25zdCBwYXJhbXMgPSBnZXRRdWVyeVN0cmluZ1BhcmFtcyhoYXNoKVxuICBjb25zdCBib290UmVxdWVzdCA9IGdldEJvb3RSZXF1ZXN0KClcbiAgY29uc3Qgcm9vdEhhc2ggPSBnZXRSb290SGFzaCgpXG4gIGNvbnN0IGlzRGlyZWN0TG9hZCA9IGhhc2guaW5kZXhPZihib290S2V5KSAhPT0gLTFcblxuICAvLyBwcmV2ZW50IGRpcmVjdCByZWxvYWQgb2Ygd2lsZGNhcmQgcm91dGVzXG4gIC8vIGV4cGVjdCBib290Q29tcG9uZW50XG4gIGlmIChpc1dpbGRjYXJkLnRlc3QoaGFzaCkgJiYgaGFzaCAhPT0gYm9vdEtleSkge1xuICAgIGhhc2ggPSAnJ1xuICB9XG5cbiAgLy8gc3RvcmUgcmVzdW1lIHBvaW50IGZvciBtYW51YWwgcmVzdW1lXG4gIHJlc3VtZUhhc2ggPSBpc0RpcmVjdExvYWQgPyByb290SGFzaCA6IGhhc2ggfHwgcm9vdEhhc2hcblxuICBjb25zdCByZWFkeSA9ICgpID0+IHtcbiAgICBpZiAoIWhhc2ggJiYgcm9vdEhhc2gpIHtcbiAgICAgIGlmIChpc1N0cmluZyhyb290SGFzaCkpIHtcbiAgICAgICAgbmF2aWdhdGUocm9vdEhhc2gpXG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocm9vdEhhc2gpKSB7XG4gICAgICAgIHJvb3RIYXNoKCkudGhlbihyZXMgPT4ge1xuICAgICAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgICAgICBuYXZpZ2F0ZShyZXMucGF0aCwgcmVzLnBhcmFtcylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmF2aWdhdGUocmVzKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWUoaGFzaClcbiAgICAgIGhhbmRsZUhhc2hDaGFuZ2UoKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgYXBwLl9yZWZvY3VzKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpZiAocm91dGVFeGlzdHMoYm9vdEtleSkpIHtcbiAgICBpZiAoaGFzaCAmJiAhaXNEaXJlY3RMb2FkKSB7XG4gICAgICBpZiAoIWdldFJvdXRlQnlIYXNoKGhhc2gpKSB7XG4gICAgICAgIG5hdmlnYXRlKCcqJywgeyBmYWlsZWRIYXNoOiBoYXNoIH0pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBuYXZpZ2F0ZShcbiAgICAgIGJvb3RLZXksXG4gICAgICB7XG4gICAgICAgIHJlc3VtZTogcmVzdW1lSGFzaCxcbiAgICAgICAgcmVsb2FkOiBib290S2V5ID09PSBoYXNoLFxuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oYm9vdFJlcXVlc3QpKSB7XG4gICAgYm9vdFJlcXVlc3QocGFyYW1zKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZWFkeSgpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICBoYW5kbGVCb290RXJyb3IoZSlcbiAgICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgcmVhZHkoKVxuICB9XG59XG5cbmNvbnN0IGhhbmRsZUJvb3RFcnJvciA9IGUgPT4ge1xuICBpZiAocm91dGVFeGlzdHMoJyEnKSkge1xuICAgIG5hdmlnYXRlKCchJywgeyByZXF1ZXN0OiB7IGVycm9yOiBlIH0gfSlcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGUpXG4gIH1cbn1cblxuLyoqXG4gKiBzdGFydCBhIG5ldyByZXF1ZXN0XG4gKiBAcGFyYW0gdXJsXG4gKiBAcGFyYW0gYXJnc1xuICogQHBhcmFtIHN0b3JlXG4gKi9cbmV4cG9ydCBjb25zdCBuYXZpZ2F0ZSA9ICh1cmwsIGFyZ3MgPSB7fSwgc3RvcmUpID0+IHtcbiAgaWYgKGlzT2JqZWN0KHVybCkpIHtcbiAgICB1cmwgPSBnZXRIYXNoQnlOYW1lKHVybClcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgbGV0IGhhc2ggPSBnZXRIYXNoKClcbiAgaWYgKCFtdXN0VXBkYXRlTG9jYXRpb25IYXNoKCkgJiYgZm9yY2VkSGFzaCkge1xuICAgIGhhc2ggPSBmb3JjZWRIYXNoXG4gIH1cbiAgaWYgKGhhc2gucmVwbGFjZSgvXiMvLCAnJykgIT09IHVybCkge1xuICAgIC8vIHB1c2ggcmVxdWVzdCBpbiB0aGUgcXVldWVcbiAgICBxdWV1ZSh1cmwsIGFyZ3MsIHN0b3JlKVxuXG4gICAgc2V0SGFzaCh1cmwpXG4gICAgaWYgKCFtdXN0VXBkYXRlTG9jYXRpb25IYXNoKCkpIHtcbiAgICAgIGZvcmNlZEhhc2ggPSB1cmxcbiAgICAgIGhhbmRsZUhhc2hDaGFuZ2UodXJsKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgYXBwLl9yZWZvY3VzKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJncy5yZWxvYWQpIHtcbiAgICAvLyBwdXNoIHJlcXVlc3QgaW4gdGhlIHF1ZXVlXG4gICAgcXVldWUodXJsLCBhcmdzLCBzdG9yZSlcblxuICAgIGhhbmRsZUhhc2hDaGFuZ2UodXJsKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBhcHAuX3JlZm9jdXMoKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgfSlcbiAgfVxufVxuXG5jb25zdCBxdWV1ZSA9IChoYXNoLCBhcmdzID0ge30sIHN0b3JlKSA9PiB7XG4gIGhhc2ggPSBjbGVhbkhhc2goaGFzaClcbiAgaWYgKCFuYXZpZ2F0ZVF1ZXVlLmhhcyhoYXNoKSkge1xuICAgIGZvciAobGV0IHJlcXVlc3Qgb2YgbmF2aWdhdGVRdWV1ZS52YWx1ZXMoKSkge1xuICAgICAgcmVxdWVzdC5jYW5jZWwoKVxuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChoYXNoLCBhcmdzLCBzdG9yZSlcbiAgICBuYXZpZ2F0ZVF1ZXVlLnNldChkZWNvZGVVUklDb21wb25lbnQoaGFzaCksIHJlcXVlc3QpXG5cbiAgICByZXR1cm4gcmVxdWVzdFxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIEhhbmRsZSBjaGFuZ2Ugb2YgaGFzaFxuICogQHBhcmFtIG92ZXJyaWRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuY29uc3QgaGFuZGxlSGFzaENoYW5nZSA9IGFzeW5jIG92ZXJyaWRlID0+IHtcbiAgY29uc3QgaGFzaCA9IGNsZWFuSGFzaChvdmVycmlkZSB8fCBnZXRIYXNoKCkpXG4gIGNvbnN0IHF1ZXVlSWQgPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaClcbiAgbGV0IHJlcXVlc3QgPSBuYXZpZ2F0ZVF1ZXVlLmdldChxdWV1ZUlkKVxuXG4gIC8vIGhhbmRsZSBoYXNoIHVwZGF0ZWQgbWFudWFsbHlcbiAgaWYgKCFyZXF1ZXN0ICYmICFuYXZpZ2F0ZVF1ZXVlLnNpemUpIHtcbiAgICByZXF1ZXN0ID0gcXVldWUoaGFzaClcbiAgfVxuXG4gIGNvbnN0IHJvdXRlID0gZ2V0Um91dGVCeUhhc2goaGFzaClcblxuICBpZiAoIXJvdXRlKSB7XG4gICAgaWYgKHJvdXRlRXhpc3RzKCcqJykpIHtcbiAgICAgIG5hdmlnYXRlKCcqJywgeyBmYWlsZWRIYXNoOiBoYXNoIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBuYXZpZ2F0ZSB0bzogJHtoYXNofWApXG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gdXBkYXRlIGN1cnJlbnQgcHJvY2Vzc2VkIHJlcXVlc3RcbiAgcmVxdWVzdC5oYXNoID0gaGFzaFxuICByZXF1ZXN0LnJvdXRlID0gcm91dGVcblxuICBsZXQgcmVzdWx0ID0gYXdhaXQgYmVmb3JlRWFjaFJvdXRlKGdldEFjdGl2ZUhhc2goKSwgcmVxdWVzdClcblxuICAvLyB0ZXN0IGlmIGEgbG9jYWwgaG9vayBpcyBjb25maWd1cmVkIGZvciB0aGUgcm91dGVcbiAgaWYgKHJvdXRlLmJlZm9yZU5hdmlnYXRlKSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgcm91dGUuYmVmb3JlTmF2aWdhdGUoZ2V0QWN0aXZlSGFzaCgpLCByZXF1ZXN0KVxuICB9XG5cbiAgaWYgKGlzQm9vbGVhbihyZXN1bHQpKSB7XG4gICAgLy8gb25seSBpZiByZXNvbHZlIHZhbHVlIGlzIGV4cGxpY2l0bHkgdHJ1ZVxuICAgIC8vIHdlIGNvbnRpbnVlIHRoZSBjdXJyZW50IHJvdXRlIHJlcXVlc3RcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZUhhc2hDaGFuZ2UocmVxdWVzdClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgbmF2aWdhdGlvbiBndWFyZCBkaWRuJ3QgcmV0dXJuIHRydWVcbiAgICAvLyB3ZSBjYW5jZWwgdGhlIGN1cnJlbnQgcmVxdWVzdFxuICAgIHJlcXVlc3QuY2FuY2VsKClcbiAgICBuYXZpZ2F0ZVF1ZXVlLmRlbGV0ZShxdWV1ZUlkKVxuXG4gICAgaWYgKGlzU3RyaW5nKHJlc3VsdCkpIHtcbiAgICAgIG5hdmlnYXRlKHJlc3VsdClcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBzdG9yZSA9IHRydWVcbiAgICAgIGlmIChpc0Jvb2xlYW4ocmVzdWx0LnN0b3JlKSkge1xuICAgICAgICBzdG9yZSA9IHJlc3VsdC5zdG9yZVxuICAgICAgfVxuICAgICAgbmF2aWdhdGUocmVzdWx0LnBhdGgsIHJlc3VsdC5wYXJhbXMsIHN0b3JlKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbnRpbnVlIHByb2Nlc3NpbmcgdGhlIGhhc2ggY2hhbmdlIGlmIG5vdCBibG9ja2VkXG4gKiBieSBnbG9iYWwgb3IgbG9jYWwgaG9va1xuICogQHBhcmFtIHJlcXVlc3QgLSB7fVxuICovXG5jb25zdCByZXNvbHZlSGFzaENoYW5nZSA9IHJlcXVlc3QgPT4ge1xuICBjb25zdCBoYXNoID0gcmVxdWVzdC5oYXNoXG4gIGNvbnN0IHJvdXRlID0gcmVxdWVzdC5yb3V0ZVxuICBjb25zdCBxdWV1ZUlkID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpXG4gIC8vIHN0b3JlIGxhc3QgcmVxdWVzdGVkIGhhc2ggc28gd2UgY2FuXG4gIC8vIHByZXZlbnQgYSByb3V0ZSB0aGF0IHJlc29sdmVkIGxhdGVyXG4gIC8vIGZyb20gZGlzcGxheWluZyBpdHNlbGZcbiAgc2V0TGFzdEhhc2goaGFzaClcblxuICBpZiAocm91dGUucGF0aCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldENvbXBvbmVudChyb3V0ZS5wYXRoKVxuICAgIC8vIGlmIGEgaG9vayBpcyBwcm92aWRlZCBmb3IgdGhlIGN1cnJlbnQgcm91dGVcbiAgICBpZiAoaXNGdW5jdGlvbihyb3V0ZS5ob29rKSkge1xuICAgICAgY29uc3QgdXJsUGFyYW1zID0gZ2V0VmFsdWVzRnJvbUhhc2goaGFzaCwgcm91dGUucGF0aClcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHt9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiB1cmxQYXJhbXMua2V5cygpKSB7XG4gICAgICAgIHBhcmFtc1trZXldID0gdXJsUGFyYW1zLmdldChrZXkpXG4gICAgICB9XG4gICAgICByb3V0ZS5ob29rKGFwcCwgeyAuLi5wYXJhbXMgfSlcbiAgICB9XG4gICAgLy8gaWYgdGhlcmUgaXMgYSBjb21wb25lbnQgYXR0YWNoZWQgdG8gdGhlIHJvdXRlXG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgLy8gZm9yY2UgcGFnZSB0byByb290IHN0YXRlIHRvIHByZXZlbnQgc2hhcmVkIHN0YXRlIGlzc3Vlc1xuICAgICAgY29uc3QgYWN0aXZlUGFnZSA9IGdldEFjdGl2ZVBhZ2UoKVxuICAgICAgaWYgKGFjdGl2ZVBhZ2UpIHtcbiAgICAgICAgY29uc3Qga2VlcEFsaXZlID0ga2VlcEFjdGl2ZVBhZ2VBbGl2ZShnZXRBY3RpdmVSb3V0ZSgpLCByZXF1ZXN0KVxuICAgICAgICBpZiAoYWN0aXZlUGFnZSAmJiByb3V0ZS5wYXRoID09PSBnZXRBY3RpdmVSb3V0ZSgpICYmICFrZWVwQWxpdmUpIHtcbiAgICAgICAgICBhY3RpdmVQYWdlLl9zZXRTdGF0ZSgnJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNQYWdlKGNvbXBvbmVudCwgc3RhZ2UpKSB7XG4gICAgICAgIGxvYWQocmVxdWVzdCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgYXBwLl9yZWZvY3VzKClcbiAgICAgICAgICBuYXZpZ2F0ZVF1ZXVlLmRlbGV0ZShxdWV1ZUlkKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb2YgdGhlIGNvbXBvbmVudCBpcyBub3QgYSBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBvciBhIENvbXBvbmVudCBpbnN0YW5jZSB3ZSBjYW4gYXNzdW1lXG4gICAgICAgIC8vIHRoYXQgaXQncyBhIGR5bmFtaWMgaW1wb3J0XG4gICAgICAgIGNvbXBvbmVudCgpXG4gICAgICAgICAgLnRoZW4oY29udGVudHMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzLmRlZmF1bHRcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBzdG9yZUNvbXBvbmVudChyb3V0ZS5wYXRoLCBtb2R1bGUpXG4gICAgICAgICAgICByZXR1cm4gbG9hZChyZXF1ZXN0KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgYXBwLl9yZWZvY3VzKClcbiAgICAgICAgICAgIG5hdmlnYXRlUXVldWUuZGVsZXRlKHF1ZXVlSWQpXG4gICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmF2aWdhdGVRdWV1ZS5kZWxldGUocXVldWVJZClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXJlY3Rpb25hbCBzdGVwIGluIGhpc3RvcnlcbiAqIEBwYXJhbSBkaXJlY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN0ZXAgPSAobGV2ZWwgPSAwKSA9PiB7XG4gIGlmICghbGV2ZWwgfHwgaXNOYU4obGV2ZWwpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgY29uc3QgaGlzdG9yeSA9IGdldEhpc3RvcnkoKVxuICAvLyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBuZWdhdGl2ZSBudW1iZXJzXG4gIGxldmVsID0gTWF0aC5hYnMobGV2ZWwpXG5cbiAgLy8gd2UgY2FuJ3Qgc3RlcCBiYWNrIHBhc3QgdGhlIGFtb3VudFxuICAvLyBvZiBoaXN0b3J5IGVudHJpZXNcbiAgaWYgKGxldmVsID4gaGlzdG9yeS5sZW5ndGgpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihhcHAuX2hhbmRsZUFwcENsb3NlKSkge1xuICAgICAgcmV0dXJuIGFwcC5faGFuZGxlQXBwQ2xvc2UoKVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChoaXN0b3J5Lmxlbmd0aCkge1xuICAgIC8vIGZvciBub3cgd2Ugb25seSBzdXBwb3J0IGhpc3RvcnkgYmFja1xuICAgIGNvbnN0IHJvdXRlID0gaGlzdG9yeS5zcGxpY2UoaGlzdG9yeS5sZW5ndGggLSBsZXZlbCwgbGV2ZWwpWzBdXG4gICAgLy8gc3RvcmUgY2hhbmdlZCBoaXN0b3J5XG4gICAgc2V0SGlzdG9yeShoaXN0b3J5KVxuICAgIHJldHVybiBuYXZpZ2F0ZShcbiAgICAgIHJvdXRlLmhhc2gsXG4gICAgICB7XG4gICAgICAgIFtzeW1ib2xzLmJhY2t0cmFja106IHRydWUsXG4gICAgICAgIFtzeW1ib2xzLmhpc3RvcnlTdGF0ZV06IHJvdXRlLnN0YXRlLFxuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKVxuICB9IGVsc2UgaWYgKHJvdXRlckNvbmZpZy5nZXQoJ2JhY2t0cmFjaycpKSB7XG4gICAgY29uc3QgaGFzaExhc3RQYXJ0ID0gLyhcXC86P1tcXHclXFxzLV0rKSQvXG4gICAgbGV0IGhhc2ggPSBzdHJpcFJlZ2V4KGdldEhhc2goKSlcbiAgICBsZXQgZmxvb3IgPSBnZXRGbG9vcihoYXNoKVxuXG4gICAgLy8gdGVzdCBpZiB3ZSBnb3QgZGVlcC1saW5rZWRcbiAgICBpZiAoZmxvb3IgPiAxKSB7XG4gICAgICB3aGlsZSAoZmxvb3ItLSkge1xuICAgICAgICAvLyBzdHJpcCBvZiBsYXN0IHBhcnRcbiAgICAgICAgaGFzaCA9IGhhc2gucmVwbGFjZShoYXNoTGFzdFBhcnQsICcnKVxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY29uZmlndXJlZCByb3V0ZVxuICAgICAgICAvLyB3ZSBuYXZpZ2F0ZSB0byBpdFxuICAgICAgICBpZiAoZ2V0Um91dGVCeUhhc2goaGFzaCkpIHtcbiAgICAgICAgICByZXR1cm4gbmF2aWdhdGUoaGFzaCwgeyBbc3ltYm9scy5iYWNrdHJhY2tdOiB0cnVlIH0sIGZhbHNlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIFJlc3VtZSBSb3V0ZXIncyBwYWdlIGxvYWRpbmcgcHJvY2VzcyBhZnRlclxuICogdGhlIEJvb3RDb21wb25lbnQgYmVjYW1lIHZpc2libGU7XG4gKi9cbmNvbnN0IHJlc3VtZSA9ICgpID0+IHtcbiAgaWYgKGlzU3RyaW5nKHJlc3VtZUhhc2gpKSB7XG4gICAgbmF2aWdhdGUocmVzdW1lSGFzaCwgZmFsc2UpXG4gICAgcmVzdW1lSGFzaCA9ICcnXG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihyZXN1bWVIYXNoKSkge1xuICAgIHJlc3VtZUhhc2goKS50aGVuKHJlcyA9PiB7XG4gICAgICByZXN1bWVIYXNoID0gJydcbiAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgIG5hdmlnYXRlKHJlcy5wYXRoLCByZXMucGFyYW1zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmF2aWdhdGUocmVzKVxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCdbUm91dGVyXTogcmVzdW1lKCkgY2FsbGVkIGJ1dCBubyBoYXNoIGZvdW5kJylcbiAgfVxufVxuXG4vKipcbiAqIEZvcmNlIHJlbG9hZCBhY3RpdmUgaGFzaFxuICovXG5jb25zdCByZWxvYWQgPSAoKSA9PiB7XG4gIGlmICghaXNOYXZpZ2F0aW5nKCkpIHtcbiAgICBjb25zdCBoYXNoID0gZ2V0QWN0aXZlSGFzaCgpXG4gICAgbmF2aWdhdGUoaGFzaCwgeyByZWxvYWQ6IHRydWUgfSwgZmFsc2UpXG4gIH1cbn1cblxuLyoqXG4gKiBRdWVyeSBpZiB0aGUgUm91dGVyIGlzIHN0aWxsIHByb2Nlc3NpbmcgYSBSZXF1ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNOYXZpZ2F0aW5nID0gKCkgPT4ge1xuICBpZiAobmF2aWdhdGVRdWV1ZS5zaXplKSB7XG4gICAgbGV0IGlzUHJvY2Vzc2luZyA9IGZhbHNlXG4gICAgZm9yIChsZXQgcmVxdWVzdCBvZiBuYXZpZ2F0ZVF1ZXVlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoIXJlcXVlc3QuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgaXNQcm9jZXNzaW5nID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNQcm9jZXNzaW5nXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBjb25zdCBnZXRSZXN1bWVIYXNoID0gKCkgPT4ge1xuICByZXR1cm4gcmVzdW1lSGFzaFxufVxuXG4vKipcbiAqIEJ5IGRlZmF1bHQgd2UgcmV0dXJuIHRoZSBsb2NhdGlvbiBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5sZXQgZ2V0SGFzaCA9ICgpID0+IHtcbiAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhhc2hcbn1cblxuLyoqXG4gKiBVcGRhdGUgbG9jYXRpb24gaGFzaFxuICogQHBhcmFtIHVybFxuICovXG5sZXQgc2V0SGFzaCA9IHVybCA9PiB7XG4gIGRvY3VtZW50LmxvY2F0aW9uLmhhc2ggPSB1cmxcbn1cblxuLyoqXG4gKiBUaGlzIGNhbiBiZSBjYWxsZWQgZnJvbSB0aGUgcGxhdGZvcm0gLyBib290c3RyYXBwZXIgdG8gb3ZlcnJpZGVcbiAqIHRoZSBkZWZhdWx0IGdldHRpbmcgYW5kIHNldHRpbmcgb2YgdGhlIGhhc2hcbiAqIEBwYXJhbSBjb25maWdcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRSb3V0ZXIgPSBjb25maWcgPT4ge1xuICBpZiAoY29uZmlnLmdldEhhc2gpIHtcbiAgICBnZXRIYXNoID0gY29uZmlnLmdldEhhc2hcbiAgfVxuICBpZiAoY29uZmlnLnNldEhhc2gpIHtcbiAgICBzZXRIYXNoID0gY29uZmlnLnNldEhhc2hcbiAgfVxufVxuXG4vKipcbiAqIE9uIGhhc2ggY2hhbmdlIHdlIHN0YXJ0IHByb2Nlc3NpbmdcbiAqL1xuY29uc3QgcmVnaXN0ZXJMaXN0ZW5lciA9ICgpID0+IHtcbiAgUmVnaXN0cnkuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdoYXNoY2hhbmdlJywgYXN5bmMgKCkgPT4ge1xuICAgIGlmIChtdXN0VXBkYXRlTG9jYXRpb25IYXNoKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUhhc2hDaGFuZ2UoKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIE5hdmlnYXRlIHRvIHJvb3QgaGFzaFxuICovXG5jb25zdCByb290ID0gKCkgPT4ge1xuICBjb25zdCByb290SGFzaCA9IGdldFJvb3RIYXNoKClcbiAgaWYgKGlzU3RyaW5nKHJvb3RIYXNoKSkge1xuICAgIG5hdmlnYXRlKHJvb3RIYXNoKVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocm9vdEhhc2gpKSB7XG4gICAgcm9vdEhhc2goKS50aGVuKHJlcyA9PiB7XG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICBuYXZpZ2F0ZShyZXMucGF0aCwgcmVzLnBhcmFtcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hdmlnYXRlKHJlcylcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8vIGV4cG9ydCBBUElcbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3RhcnRSb3V0ZXIsXG4gIG5hdmlnYXRlLFxuICByZXN1bWUsXG4gIHN0ZXAsXG4gIGdvOiBzdGVwLFxuICBiYWNrOiBzdGVwLmJpbmQobnVsbCwgLTEpLFxuICBhY3RpdmVQYWdlOiBnZXRBY3RpdmVQYWdlLFxuICBnZXRBY3RpdmVQYWdlKCkge1xuICAgIC8vIHdhcm5pbmdcbiAgICByZXR1cm4gZ2V0QWN0aXZlUGFnZSgpXG4gIH0sXG4gIGdldEFjdGl2ZVJvdXRlLFxuICBnZXRBY3RpdmVIYXNoLFxuICBmb2N1c1dpZGdldCxcbiAgZ2V0QWN0aXZlV2lkZ2V0LFxuICByZXN0b3JlRm9jdXMsXG4gIGlzTmF2aWdhdGluZyxcbiAgZ2V0SGlzdG9yeSxcbiAgc2V0SGlzdG9yeSxcbiAgZ2V0SGlzdG9yeVN0YXRlLFxuICByZXBsYWNlSGlzdG9yeVN0YXRlLFxuICBnZXRRdWVyeVN0cmluZ1BhcmFtcyxcbiAgcmVsb2FkLFxuICBzeW1ib2xzLFxuICBBcHA6IFJvdXRlZEFwcCxcbiAgLy8ga2VlcCBiYWNrd2FyZHMgY29tcGF0aWJsZVxuICBmb2N1c1BhZ2U6IHJlc3RvcmVGb2N1cyxcbiAgcm9vdDogcm9vdCxcbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgYXBpIG1ldGhvZHNcbiAgICovXG4gIHNldHVwUm91dGVzKCkge1xuICAgIGNvbnNvbGUud2FybignUm91dGVyOiBzZXR1cFJvdXRlcyBpcyBkZXByZWNhdGVkLCBjb25zb2xpZGF0ZSB5b3VyIGNvbmZpZ3VyYXRpb24nKVxuICAgIGNvbnNvbGUud2FybignaHR0cHM6Ly9yZGtjZW50cmFsLmdpdGh1Yi5pby9MaWdodG5pbmctU0RLLyMvcGx1Z2lucy9yb3V0ZXIvY29uZmlndXJhdGlvbicpXG4gIH0sXG4gIG9uKCkge1xuICAgIGNvbnNvbGUud2FybignUm91dGVyLm9uKCkgaXMgZGVwcmVjYXRlZCwgY29uc29saWRhdGUgeW91ciBjb25maWd1cmF0aW9uJylcbiAgICBjb25zb2xlLndhcm4oJ2h0dHBzOi8vcmRrY2VudHJhbC5naXRodWIuaW8vTGlnaHRuaW5nLVNESy8jL3BsdWdpbnMvcm91dGVyL2NvbmZpZ3VyYXRpb24nKVxuICB9LFxuICBiZWZvcmUoKSB7XG4gICAgY29uc29sZS53YXJuKCdSb3V0ZXIuYmVmb3JlKCkgaXMgZGVwcmVjYXRlZCwgY29uc29saWRhdGUgeW91ciBjb25maWd1cmF0aW9uJylcbiAgICBjb25zb2xlLndhcm4oJ2h0dHBzOi8vcmRrY2VudHJhbC5naXRodWIuaW8vTGlnaHRuaW5nLVNESy8jL3BsdWdpbnMvcm91dGVyL2NvbmZpZ3VyYXRpb24nKVxuICB9LFxuICBhZnRlcigpIHtcbiAgICBjb25zb2xlLndhcm4oJ1JvdXRlci5hZnRlcigpIGlzIGRlcHJlY2F0ZWQsIGNvbnNvbGlkYXRlIHlvdXIgY29uZmlndXJhdGlvbicpXG4gICAgY29uc29sZS53YXJuKCdodHRwczovL3Jka2NlbnRyYWwuZ2l0aHViLmlvL0xpZ2h0bmluZy1TREsvIy9wbHVnaW5zL3JvdXRlci9jb25maWd1cmF0aW9uJylcbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGlzQm9vbGVhbiwgaXNPYmplY3QsIHN5bWJvbHMgfSBmcm9tICcuLi91dGlscy9oZWxwZXJzJ1xuaW1wb3J0IHsgY3JlYXRlUmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9yZWdpc3RlcidcbmltcG9ydCBMb2cgZnJvbSAnLi4vLi4vTG9nJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoaGFzaCA9ICcnLCBuYXZBcmdzLCBzdG9yZUNhbGxlcikge1xuICAgIC8qKlxuICAgICAqIEhhc2ggd2UgbmF2aWdhdGUgdG9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faGFzaCA9IGhhc2hcblxuICAgIC8qKlxuICAgICAqIERvIHdlIHN0b3JlIHByZXZpb3VzIGhhc2ggaW4gaGlzdG9yeVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVDYWxsZXIgPSBzdG9yZUNhbGxlclxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhbmQgbmF2aWdhdGUgZGF0YVxuICAgICAqIEB0eXBlIHtNYXB9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZWdpc3RlciA9IG5ldyBNYXAoKVxuXG4gICAgLyoqXG4gICAgICogRmxhZyBpZiB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCBkdWUgdG9cbiAgICAgKiB0aGlzIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2lzQ3JlYXRlZCA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBGbGFnIGlmIHRoZSBpbnN0YW5jZSBpcyBzaGFyZWQgYmV0d2VlblxuICAgICAqIHByZXZpb3VzIGFuZCBjdXJyZW50IHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2lzU2hhcmVkSW5zdGFuY2UgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgICogRmxhZyBpZiB0aGUgcmVxdWVzdCBoYXMgYmVlbiBjYW5jZWxsZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NhbmNlbGxlZCA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBpZiBpbnN0YW5jZSBpcyBzaGFyZWQgYmV0d2VlbiByZXF1ZXN0cyB3ZSBjb3B5IHN0YXRlIG9iamVjdFxuICAgICAqIGZyb20gaW5zdGFuY2UgYmVmb3JlIHRoZSBuZXcgcmVxdWVzdCBvdmVycmlkZXMgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NvcGllZEhpc3RvcnlTdGF0ZSA9IG51bGxcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBhcmd1bWVudHMgYXR0YWNoZWQgdG8gbmF2aWdhdGUoKVxuICAgIC8vIHdlIHN0b3JlIHRoZW0gaW4gbmV3IHJlcXVlc3RcbiAgICBpZiAoaXNPYmplY3QobmF2QXJncykpIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyID0gY3JlYXRlUmVnaXN0ZXIobmF2QXJncylcbiAgICB9IGVsc2UgaWYgKGlzQm9vbGVhbihuYXZBcmdzKSkge1xuICAgICAgLy8gaWYgc2Vjb25kIG5hdmlnYXRlKCkgYXJndW1lbnQgaXMgZXhwbGljaXRseVxuICAgICAgLy8gc2V0IHRvIGZhbHNlIHdlIHByZXZlbnQgdGhlIGNhbGxpbmcgcGFnZVxuICAgICAgLy8gZnJvbSBlbmRpbmcgdXAgaW4gaGlzdG9yeVxuICAgICAgdGhpcy5fc3RvcmVDYWxsZXIgPSBuYXZBcmdzXG4gICAgfVxuICAgIC8vIEB0b2RvOiByZW1vdmUgYmVjYXVzZSB3ZSBjYW4gc2ltcGx5IGNoZWNrXG4gICAgLy8gLl9zdG9yZUNhbGxlciBwcm9wZXJ0eVxuICAgIHRoaXMuX3JlZ2lzdGVyLnNldChzeW1ib2xzLnN0b3JlLCB0aGlzLl9zdG9yZUNhbGxlcilcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBMb2cuZGVidWcoJ1tyb3V0ZXJdOicsIGBjYW5jZWxsZWQgJHt0aGlzLl9oYXNofWApXG4gICAgdGhpcy5fY2FuY2VsbGVkID0gdHJ1ZVxuICB9XG5cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzaFxuICB9XG5cbiAgZ2V0IHJlZ2lzdGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWdpc3RlclxuICB9XG5cbiAgZ2V0IGhhc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc2hcbiAgfVxuXG4gIHNldCBoYXNoKGFyZ3MpIHtcbiAgICB0aGlzLl9oYXNoID0gYXJnc1xuICB9XG5cbiAgZ2V0IHJvdXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3V0ZVxuICB9XG5cbiAgc2V0IHJvdXRlKGFyZ3MpIHtcbiAgICB0aGlzLl9yb3V0ZSA9IGFyZ3NcbiAgfVxuXG4gIGdldCBwcm92aWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXJcbiAgfVxuXG4gIHNldCBwcm92aWRlcihhcmdzKSB7XG4gICAgdGhpcy5fcHJvdmlkZXIgPSBhcmdzXG4gIH1cblxuICBnZXQgcHJvdmlkZXJUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm92aWRlclR5cGVcbiAgfVxuXG4gIHNldCBwcm92aWRlclR5cGUoYXJncykge1xuICAgIHRoaXMuX3Byb3ZpZGVyVHlwZSA9IGFyZ3NcbiAgfVxuXG4gIHNldCBwYWdlKGFyZ3MpIHtcbiAgICB0aGlzLl9wYWdlID0gYXJnc1xuICB9XG5cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VcbiAgfVxuXG4gIHNldCBpc0NyZWF0ZWQoYXJncykge1xuICAgIHRoaXMuX2lzQ3JlYXRlZCA9IGFyZ3NcbiAgfVxuXG4gIGdldCBpc0NyZWF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQ3JlYXRlZFxuICB9XG5cbiAgZ2V0IGlzU2hhcmVkSW5zdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hhcmVkSW5zdGFuY2VcbiAgfVxuXG4gIHNldCBpc1NoYXJlZEluc3RhbmNlKGFyZ3MpIHtcbiAgICB0aGlzLl9pc1NoYXJlZEluc3RhbmNlID0gYXJnc1xuICB9XG5cbiAgZ2V0IGlzQ2FuY2VsbGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW5jZWxsZWRcbiAgfVxuXG4gIHNldCBjb3BpZWRIaXN0b3J5U3RhdGUodikge1xuICAgIHRoaXMuX2NvcGllZEhpc3RvcnlTdGF0ZSA9IHZcbiAgfVxuXG4gIGdldCBjb3BpZWRIaXN0b3J5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvcGllZEhpc3RvcnlTdGF0ZVxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvaGVscGVycydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIC8vIGtlZXAgYmFja3dhcmRzIGNvbXBhdGlibGVcbiAgICBsZXQgdHlwZSA9IFsnb24nLCAnYmVmb3JlJywgJ2FmdGVyJ10ucmVkdWNlKChhY2MsIHR5cGUpID0+IHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbmZpZ1t0eXBlXSkgPyB0eXBlIDogYWNjXG4gICAgfSwgdW5kZWZpbmVkKVxuXG4gICAgdGhpcy5fY2ZnID0gY29uZmlnXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHRoaXMuX3Byb3ZpZGVyID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICByZXF1ZXN0OiBjb25maWdbdHlwZV0sXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NmZy5wYXRoXG4gIH1cblxuICBnZXQgY29tcG9uZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcuY29tcG9uZW50XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2ZnLm9wdGlvbnNcbiAgfVxuXG4gIGdldCB3aWRnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcud2lkZ2V0c1xuICB9XG5cbiAgZ2V0IGNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcuY2FjaGVcbiAgfVxuXG4gIGdldCBob29rKCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcuaG9va1xuICB9XG5cbiAgZ2V0IGJlZm9yZU5hdmlnYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcuYmVmb3JlTmF2aWdhdGVcbiAgfVxuXG4gIGdldCBwcm92aWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXJcbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgZmFkZSA9IChpLCBvKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBpLnBhdGNoKHtcbiAgICAgIGFscGhhOiAwLFxuICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgIHNtb290aDoge1xuICAgICAgICBhbHBoYTogWzEsIHsgZHVyYXRpb246IDAuNSwgZGVsYXk6IDAuMSB9XSxcbiAgICAgIH0sXG4gICAgfSlcbiAgICAvLyByZXNvbHZlIG9uIHkgZmluaXNoXG4gICAgaS50cmFuc2l0aW9uKCdhbHBoYScpLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICBpZiAobykge1xuICAgICAgICBvLnZpc2libGUgPSBmYWxzZVxuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfSlcbn1cblxuY29uc3QgY3Jvc3NGYWRlID0gKGksIG8pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGkucGF0Y2goe1xuICAgICAgYWxwaGE6IDAsXG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgc21vb3RoOiB7XG4gICAgICAgIGFscGhhOiBbMSwgeyBkdXJhdGlvbjogMC41LCBkZWxheTogMC4xIH1dLFxuICAgICAgfSxcbiAgICB9KVxuICAgIGlmIChvKSB7XG4gICAgICBvLnBhdGNoKHtcbiAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgYWxwaGE6IFswLCB7IGR1cmF0aW9uOiAwLjUsIGRlbGF5OiAwLjMgfV0sXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICAvLyByZXNvbHZlIG9uIHkgZmluaXNoXG4gICAgaS50cmFuc2l0aW9uKCdhbHBoYScpLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9KVxufVxuXG5jb25zdCBtb3ZlT25BeGVzID0gKGF4aXMsIGRpcmVjdGlvbiwgaSwgbykgPT4ge1xuICBjb25zdCBib3VuZHMgPSBheGlzID09PSAneCcgPyAxOTIwIDogMTA4MFxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgaS5wYXRjaCh7XG4gICAgICBbYCR7YXhpc31gXTogZGlyZWN0aW9uID8gYm91bmRzICogLTEgOiBib3VuZHMsXG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgc21vb3RoOiB7XG4gICAgICAgIFtgJHtheGlzfWBdOiBbMCwgeyBkdXJhdGlvbjogMC40LCBkZWxheTogMC4yIH1dLFxuICAgICAgfSxcbiAgICB9KVxuICAgIC8vIG91dCBpcyBvcHRpb25hbFxuICAgIGlmIChvKSB7XG4gICAgICBvLnBhdGNoKHtcbiAgICAgICAgW2Ake2F4aXN9YF06IDAsXG4gICAgICAgIHNtb290aDoge1xuICAgICAgICAgIFtgJHtheGlzfWBdOiBbZGlyZWN0aW9uID8gYm91bmRzIDogYm91bmRzICogLTEsIHsgZHVyYXRpb246IDAuNCwgZGVsYXk6IDAuMiB9XSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfVxuICAgIC8vIHJlc29sdmUgb24geSBmaW5pc2hcbiAgICBpLnRyYW5zaXRpb24oYXhpcykub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gIH0pXG59XG5cbmNvbnN0IHVwID0gKGksIG8pID0+IHtcbiAgcmV0dXJuIG1vdmVPbkF4ZXMoJ3knLCAwLCBpLCBvKVxufVxuXG5jb25zdCBkb3duID0gKGksIG8pID0+IHtcbiAgcmV0dXJuIG1vdmVPbkF4ZXMoJ3knLCAxLCBpLCBvKVxufVxuXG5jb25zdCBsZWZ0ID0gKGksIG8pID0+IHtcbiAgcmV0dXJuIG1vdmVPbkF4ZXMoJ3gnLCAwLCBpLCBvKVxufVxuXG5jb25zdCByaWdodCA9IChpLCBvKSA9PiB7XG4gIHJldHVybiBtb3ZlT25BeGVzKCd4JywgMSwgaSwgbylcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBmYWRlLFxuICBjcm9zc0ZhZGUsXG4gIHVwLFxuICBkb3duLFxuICBsZWZ0LFxuICByaWdodCxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGdldFJlZmVyZW5jZXMgfSBmcm9tICcuL3dpZGdldHMnXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb21wb25lbnQgPSAoc3RhZ2UsIHR5cGUpID0+IHtcbiAgcmV0dXJuIHN0YWdlLmMoe1xuICAgIHR5cGUsXG4gICAgdmlzaWJsZTogZmFsc2UsXG4gICAgd2lkZ2V0czogZ2V0UmVmZXJlbmNlcygpLFxuICB9KVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaXNBcnJheSwgaXNGdW5jdGlvbiwgdWNmaXJzdCB9IGZyb20gJy4vaGVscGVycydcblxuZXhwb3J0IGRlZmF1bHQgKHBhZ2UsIGV2ZW50cyA9IFtdLCBwYXJhbXMgPSB7fSkgPT4ge1xuICBpZiAoIWlzQXJyYXkoZXZlbnRzKSkge1xuICAgIGV2ZW50cyA9IFtldmVudHNdXG4gIH1cbiAgZXZlbnRzLmZvckVhY2goZSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBgX29uJHt1Y2ZpcnN0KGUpfWBcbiAgICBpZiAoaXNGdW5jdGlvbihwYWdlW2V2ZW50XSkpIHtcbiAgICAgIHBhZ2VbZXZlbnRdKHBhcmFtcylcbiAgICB9XG4gIH0pXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGlnaHRuaW5nIGZyb20gJy4uLy4uL0xpZ2h0bmluZydcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi8uLi9TZXR0aW5ncydcbmltcG9ydCB7IGdldEFjdGl2ZUhhc2ggfSBmcm9tICcuL3JvdXRlcidcbmltcG9ydCB7IGdldFJlc3VtZUhhc2ggfSBmcm9tICcuLi9pbmRleCdcblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSB2ID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nXG59XG5cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9IHYgPT4ge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGxcbn1cblxuZXhwb3J0IGNvbnN0IGlzQm9vbGVhbiA9IHYgPT4ge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdib29sZWFuJ1xufVxuXG5leHBvcnQgY29uc3QgaXNQYWdlID0gdiA9PiB7XG4gIGlmICh2IGluc3RhbmNlb2YgTGlnaHRuaW5nLkVsZW1lbnQgfHwgaXNDb21wb25lbnRDb25zdHJ1Y3Rvcih2KSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBjb25zdCBpc0NvbXBvbmVudENvbnN0cnVjdG9yID0gdHlwZSA9PiB7XG4gIHJldHVybiB0eXBlLnByb3RvdHlwZSAmJiAnaXNDb21wb25lbnQnIGluIHR5cGUucHJvdG90eXBlXG59XG5cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gdiA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHYpXG59XG5cbmV4cG9ydCBjb25zdCB1Y2ZpcnN0ID0gdiA9PiB7XG4gIHJldHVybiBgJHt2LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7di5zbGljZSgxKX1gXG59XG5cbmV4cG9ydCBjb25zdCBpc1N0cmluZyA9IHYgPT4ge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnXG59XG5cbmV4cG9ydCBjb25zdCBpc1Byb21pc2UgPSBtZXRob2QgPT4ge1xuICBsZXQgcmVzdWx0XG4gIGlmIChpc0Z1bmN0aW9uKG1ldGhvZCkpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KG51bGwpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBtZXRob2RcbiAgfVxuICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSAmJiBpc0Z1bmN0aW9uKHJlc3VsdC50aGVuKVxufVxuXG5leHBvcnQgY29uc3QgY2xlYW5IYXNoID0gKGhhc2ggPSAnJykgPT4ge1xuICByZXR1cm4gaGFzaC5yZXBsYWNlKC9eIy8sICcnKS5yZXBsYWNlKC9cXC8rJC8sICcnKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Q29uZmlnTWFwID0gKCkgPT4ge1xuICBjb25zdCByb3V0ZXJTZXR0aW5ncyA9IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAncm91dGVyJylcbiAgY29uc3QgaXNPYmogPSBpc09iamVjdChyb3V0ZXJTZXR0aW5ncylcbiAgcmV0dXJuIFtcbiAgICAnYmFja3RyYWNrJyxcbiAgICAnZ2NPblVubG9hZCcsXG4gICAgJ2Rlc3Ryb3lPbkhpc3RvcnlCYWNrJyxcbiAgICAnbGF6eUNyZWF0ZScsXG4gICAgJ2xhenlEZXN0cm95JyxcbiAgICAncmV1c2VJbnN0YW5jZScsXG4gICAgJ2F1dG9SZXN0b3JlUmVtb3RlJyxcbiAgICAnbnVtYmVyTmF2aWdhdGlvbicsXG4gICAgJ3VwZGF0ZUhhc2gnLFxuICAgICdzdG9yZVNhbWVIYXNoJyxcbiAgXS5yZWR1Y2UoKGNvbmZpZywga2V5KSA9PiB7XG4gICAgY29uZmlnLnNldChrZXksIGlzT2JqID8gcm91dGVyU2V0dGluZ3Nba2V5XSA6IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCBrZXkpKVxuICAgIHJldHVybiBjb25maWdcbiAgfSwgbmV3IE1hcCgpKVxufVxuXG5leHBvcnQgY29uc3QgaW5jb3JyZWN0UGFyYW1zID0gKGNiLCByb3V0ZSkgPT4ge1xuICBjb25zdCBpc0luY29ycmVjdCA9IC9eXFx3Kj9cXHM/XFwoXFxzP1xcey4qP1xcfVxccz9cXCkvaVxuICBpZiAoaXNJbmNvcnJlY3QudGVzdChjYi50b1N0cmluZygpKSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFtcbiAgICAgICAgYERFUFJFQ0FUSU9OOiBUaGUgZGF0YS1wcm92aWRlciBmb3Igcm91dGU6ICR7cm91dGV9IGlzIG5vdCBjb3JyZWN0LmAsXG4gICAgICAgICdcInBhZ2VcIiBpcyBubyBsb25nZXIgYSBwcm9wZXJ0eSBvZiB0aGUgcGFyYW1zIG9iamVjdCBidXQgaXMgbm93IHRoZSBmaXJzdCBmdW5jdGlvbiBwYXJhbWV0ZXI6ICcsXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vcmRrY2VudHJhbC9MaWdodG5pbmctU0RLL2Jsb2IvZmVhdHVyZS9yb3V0ZXIvZG9jcy9wbHVnaW5zL3JvdXRlci9kYXRhcHJvdmlkaW5nLm1kI2RhdGEtcHJvdmlkaW5nJyxcbiAgICAgICAgXCJJdCdzIHN1cHBvcnRlZCBmb3Igbm93IGJ1dCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIixcbiAgICAgIF0uam9pbignXFxuJylcbiAgICApXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGNvbnN0IGdldFF1ZXJ5U3RyaW5nUGFyYW1zID0gKGhhc2ggPSBnZXRBY3RpdmVIYXNoKCkpID0+IHtcbiAgY29uc3QgcmVzdW1lSGFzaCA9IGdldFJlc3VtZUhhc2goKVxuICBpZiAoKGhhc2ggPT09ICckJyB8fCAhaGFzaCkgJiYgcmVzdW1lSGFzaCkge1xuICAgIGlmIChpc1N0cmluZyhyZXN1bWVIYXNoKSkge1xuICAgICAgaGFzaCA9IHJlc3VtZUhhc2hcbiAgICB9XG4gIH1cblxuICBsZXQgcGFyc2UgPSAnJ1xuICBjb25zdCBnZXRRdWVyeSA9IC8oWz8mXS4qKS9cbiAgY29uc3QgbWF0Y2hlcyA9IGdldFF1ZXJ5LmV4ZWMoaGFzaClcbiAgY29uc3QgcGFyYW1zID0ge31cblxuICBpZiAoZG9jdW1lbnQubG9jYXRpb24gJiYgZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoKSB7XG4gICAgcGFyc2UgPSBkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2hcbiAgfVxuXG4gIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgbGV0IGhhc2hQYXJhbXMgPSBtYXRjaGVzWzFdXG4gICAgaWYgKHBhcnNlKSB7XG4gICAgICAvLyBpZiBsb2NhdGlvbi5zZWFyY2ggaXMgbm90IGVtcHR5IHdlXG4gICAgICAvLyByZW1vdmUgdGhlIGxlYWRpbmcgPyB0byBjcmVhdGUgYVxuICAgICAgLy8gdmFsaWQgc3RyaW5nXG4gICAgICBoYXNoUGFyYW1zID0gaGFzaFBhcmFtcy5yZXBsYWNlKC9eXFw/LywgJycpXG4gICAgICAvLyB3ZSBwYXJzZSBoYXNoIHBhcmFtcyBsYXN0IHNvIHRoZXkgd2UgY2FuIGFsd2F5c1xuICAgICAgLy8gb3ZlcnJpZGUgc2VhcmNoIHBhcmFtcyB3aXRoIGhhc2ggcGFyYW1zXG4gICAgICBwYXJzZSA9IGAke3BhcnNlfSYke2hhc2hQYXJhbXN9YFxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZSA9IGhhc2hQYXJhbXNcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2UpIHtcbiAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcnNlKVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHVybFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICAgIHBhcmFtc1trZXldID0gdmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBvYmplY3RUb1F1ZXJ5U3RyaW5nID0gb2JqID0+IHtcbiAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgcmV0dXJuIChcbiAgICAnPycgK1xuICAgIE9iamVjdC5rZXlzKG9iailcbiAgICAgIC5tYXAoa2V5ID0+IHtcbiAgICAgICAgcmV0dXJuIGAke2tleX09JHtvYmpba2V5XX1gXG4gICAgICB9KVxuICAgICAgLmpvaW4oJyYnKVxuICApXG59XG5cbmV4cG9ydCBjb25zdCBzeW1ib2xzID0ge1xuICByb3V0ZTogU3ltYm9sKCdyb3V0ZScpLFxuICBoYXNoOiBTeW1ib2woJ2hhc2gnKSxcbiAgc3RvcmU6IFN5bWJvbCgnc3RvcmUnKSxcbiAgZnJvbUhpc3Rvcnk6IFN5bWJvbCgnZnJvbUhpc3RvcnknKSxcbiAgZXhwaXJlczogU3ltYm9sKCdleHBpcmVzJyksXG4gIHJlc3VtZTogU3ltYm9sKCdyZXN1bWUnKSxcbiAgYmFja3RyYWNrOiBTeW1ib2woJ2JhY2t0cmFjaycpLFxuICBoaXN0b3J5U3RhdGU6IFN5bWJvbCgnaGlzdG9yeVN0YXRlJyksXG4gIHF1ZXJ5UGFyYW1zOiBTeW1ib2woJ3F1ZXJ5UGFyYW1zJyksXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBnZXRBY3RpdmVIYXNoLCBnZXRBY3RpdmVQYWdlIH0gZnJvbSAnLi9yb3V0ZXInXG5pbXBvcnQgeyBnZXRPcHRpb24sIGdldFJvdXRlQnlIYXNoIH0gZnJvbSAnLi9yb3V0ZSdcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc0FycmF5LCBpc0Jvb2xlYW4sIHN5bWJvbHMgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBnZXRSb3V0ZXJDb25maWcgfSBmcm9tICcuL3JvdXRlcidcblxuLyoqXG4gKiBTaW1wbGUgZmxhdCBhcnJheSB0aGF0IGhvbGRzIHRoZSB2aXNpdGVkIGhhc2hlcyArIHN0YXRlIE9iamVjdFxuICogc28gdGhlIHJvdXRlciBjYW4gbmF2aWdhdGUgYmFjayB0byB0aGVtXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbmxldCBoaXN0b3J5ID0gW11cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUhpc3RvcnkgPSByZXF1ZXN0ID0+IHtcbiAgY29uc3QgaGFzaCA9IGdldEFjdGl2ZUhhc2goKVxuICBpZiAoIWhhc2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIG5hdmlnYXRlIHN0b3JhZ2UgZmxhZ1xuICBjb25zdCByZWdpc3RlciA9IHJlcXVlc3QucmVnaXN0ZXJcbiAgY29uc3QgZm9yY2VOYXZpZ2F0ZVN0b3JlID0gcmVnaXN0ZXIuZ2V0KHN5bWJvbHMuc3RvcmUpXG5cbiAgLy8gdGVzdCBwcmV2ZW50U3RvcmFnZSBvbiByb3V0ZSBjb25maWd1cmF0aW9uXG4gIGNvbnN0IGFjdGl2ZVJvdXRlID0gZ2V0Um91dGVCeUhhc2goaGFzaClcbiAgY29uc3QgcHJldmVudFN0b3JhZ2UgPSBnZXRPcHRpb24oYWN0aXZlUm91dGUub3B0aW9ucywgJ3ByZXZlbnRTdG9yYWdlJylcblxuICAvLyB3ZSBnaXZlIHByaW8gdG8gbmF2aWdhdGUgc3RvcmFnZSBmbGFnXG4gIGxldCBzdG9yZSA9IGlzQm9vbGVhbihmb3JjZU5hdmlnYXRlU3RvcmUpID8gZm9yY2VOYXZpZ2F0ZVN0b3JlIDogIXByZXZlbnRTdG9yYWdlXG5cbiAgaWYgKHN0b3JlKSB7XG4gICAgY29uc3QgdG9TdG9yZSA9IGhhc2gucmVwbGFjZSgvXlxcLy8sICcnKVxuICAgIGNvbnN0IGxvY2F0aW9uID0gbG9jYXRpb25Jbkhpc3RvcnkodG9TdG9yZSlcbiAgICBjb25zdCBzdGF0ZU9iamVjdCA9IGdldFN0YXRlT2JqZWN0KGdldEFjdGl2ZVBhZ2UoKSwgcmVxdWVzdClcbiAgICBjb25zdCByb3V0ZXJDb25maWcgPSBnZXRSb3V0ZXJDb25maWcoKVxuXG4gICAgLy8gc3RvcmUgaGFzaCBpZiBpdCdzIG5vdCBhIHBhcnQgb2YgaGlzdG9yeSBvciBmbGFnIGZvclxuICAgIC8vIHN0b3JhZ2Ugb2Ygc2FtZSBoYXNoIGlzIHRydWVcbiAgICBpZiAobG9jYXRpb24gPT09IC0xIHx8IHJvdXRlckNvbmZpZy5nZXQoJ3N0b3JlU2FtZUhhc2gnKSkge1xuICAgICAgaGlzdG9yeS5wdXNoKHsgaGFzaDogdG9TdG9yZSwgc3RhdGU6IHN0YXRlT2JqZWN0IH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHdlIHZpc2l0IHRoZSBzYW1lIHJvdXRlIHdlIHdhbnQgdG8gc3luYyBoaXN0b3J5XG4gICAgICBjb25zdCBwcmV2ID0gaGlzdG9yeS5zcGxpY2UobG9jYXRpb24sIDEpWzBdXG4gICAgICBoaXN0b3J5LnB1c2goeyBoYXNoOiBwcmV2Lmhhc2gsIHN0YXRlOiBzdGF0ZU9iamVjdCB9KVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBsb2NhdGlvbkluSGlzdG9yeSA9IGhhc2ggPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhpc3RvcnkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGlzdG9yeVtpXS5oYXNoID09PSBoYXNoKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuZXhwb3J0IGNvbnN0IGdldEhpc3RvcnlTdGF0ZSA9IGhhc2ggPT4ge1xuICBsZXQgc3RhdGUgPSBudWxsXG4gIGlmIChoaXN0b3J5Lmxlbmd0aCkge1xuICAgIC8vIGlmIG5vIGhhc2ggaXMgcHJvdmlkZWQgd2UgZ2V0IHRoZSBsYXN0XG4gICAgLy8gcHVzaGVkIGhpc3RvcnkgcmVjb3JkXG4gICAgaWYgKCFoYXNoKSB7XG4gICAgICBjb25zdCByZWNvcmQgPSBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV1cbiAgICAgIC8vIGNvdWxkIGJlIG51bGxcbiAgICAgIHN0YXRlID0gcmVjb3JkLnN0YXRlXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb2NhdGlvbkluSGlzdG9yeShoYXNoKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gaGlzdG9yeVtsb2NhdGlvbkluSGlzdG9yeShoYXNoKV1cbiAgICAgICAgc3RhdGUgPSByZWNvcmQuc3RhdGVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBjb25zdCByZXBsYWNlSGlzdG9yeVN0YXRlID0gKHN0YXRlID0gbnVsbCwgaGFzaCkgPT4ge1xuICBpZiAoIWhpc3RvcnkubGVuZ3RoKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSBoYXNoID8gbG9jYXRpb25Jbkhpc3RvcnkoaGFzaCkgOiBoaXN0b3J5Lmxlbmd0aCAtIDFcbiAgaWYgKGxvY2F0aW9uICE9PSAtMSAmJiBpc09iamVjdChzdGF0ZSkpIHtcbiAgICBoaXN0b3J5W2xvY2F0aW9uXS5zdGF0ZSA9IHN0YXRlXG4gIH1cbn1cblxuY29uc3QgZ2V0U3RhdGVPYmplY3QgPSAocGFnZSwgcmVxdWVzdCkgPT4ge1xuICAvLyBpZiB0aGUgbmV3IHJlcXVlc3Qgc2hhcmVkIGluc3RhbmNlIHdpdGggdGhlXG4gIC8vIHByZXZpb3VzIHJlcXVlc3Qgd2UgdXNlZCB0aGUgY29waWVkIHN0YXRlIG9iamVjdFxuICBpZiAocmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlKSB7XG4gICAgaWYgKHJlcXVlc3QuY29waWVkSGlzdG9yeVN0YXRlKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdC5jb3BpZWRIaXN0b3J5U3RhdGVcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFnZSAmJiBpc0Z1bmN0aW9uKHBhZ2UuaGlzdG9yeVN0YXRlKSkge1xuICAgIHJldHVybiBwYWdlLmhpc3RvcnlTdGF0ZSgpXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGNvbnN0IGdldEhpc3RvcnkgPSAoKSA9PiB7XG4gIHJldHVybiBoaXN0b3J5LnNsaWNlKDApXG59XG5cbmV4cG9ydCBjb25zdCBzZXRIaXN0b3J5ID0gKGFyciA9IFtdKSA9PiB7XG4gIGlmIChpc0FycmF5KGFycikpIHtcbiAgICBoaXN0b3J5ID0gYXJyXG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIGFwcCxcbiAgZ2V0Q29tcG9uZW50LFxuICBvblJlcXVlc3RSZXNvbHZlZCxcbiAgZ2V0TGFzdEhhc2gsXG4gIHBhZ2VzSG9zdCxcbiAgc3RhZ2UsXG4gIGdldFByZXZpb3VzU3RhdGUsXG4gIGdldEFjdGl2ZVBhZ2UsXG4gIHJvdXRlckNvbmZpZyxcbiAgcm91dGVFeGlzdHMsXG59IGZyb20gJy4vcm91dGVyJ1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL0xvZydcbmltcG9ydCB7IGlzQm9vbGVhbiwgaXNDb21wb25lbnRDb25zdHJ1Y3RvciwgaXNGdW5jdGlvbiwgc3ltYm9scyB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7IGdldFByb3ZpZGVyLCBoYXNQcm92aWRlciwgaXNQYWdlRXhwaXJlZCwgZGF0YUhvb2tzLCBhZGRQZXJzaXN0RGF0YSB9IGZyb20gJy4vcHJvdmlkZXInXG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMnXG5pbXBvcnQgeyBleGVjdXRlVHJhbnNpdGlvbiB9IGZyb20gJy4vdHJhbnNpdGlvbidcbmltcG9ydCB7IGdldEFjdGl2ZVdpZGdldCB9IGZyb20gJy4vd2lkZ2V0cydcbmltcG9ydCBlbWl0IGZyb20gJy4vZW1pdCdcbmltcG9ydCB7IGdldE9wdGlvbiB9IGZyb20gJy4vcm91dGUnXG5pbXBvcnQgeyBuYXZpZ2F0ZSB9IGZyb20gJy4uL2luZGV4J1xuaW1wb3J0IHsgc2V0SGlzdG9yeSwgdXBkYXRlSGlzdG9yeSB9IGZyb20gJy4vaGlzdG9yeSdcbmltcG9ydCB7IGlzV2lsZGNhcmQgfSBmcm9tICcuL3JlZ2V4J1xuXG4vKipcbiAqIFRoZSBhY3R1YWwgbG9hZGluZyBvZiB0aGUgY29tcG9uZW50XG4gKiAqL1xuZXhwb3J0IGNvbnN0IGxvYWQgPSBhc3luYyByZXF1ZXN0ID0+IHtcbiAgbGV0IGV4cGlyZWQgPSBmYWxzZVxuICB0cnkge1xuICAgIHJlcXVlc3QgPSBhd2FpdCBsb2FkZXIocmVxdWVzdClcbiAgICBpZiAocmVxdWVzdCAmJiAhcmVxdWVzdC5pc0NhbmNlbGxlZCkge1xuICAgICAgLy8gaW4gY2FzZSBvZiBvbigpIHByb3ZpZGluZyB3ZSBuZWVkIHRvIHJlc2V0XG4gICAgICAvLyBhcHAgc3RhdGU7XG4gICAgICBpZiAoYXBwLnN0YXRlID09PSAnTG9hZGluZycpIHtcbiAgICAgICAgaWYgKGdldFByZXZpb3VzU3RhdGUoKSA9PT0gJ1dpZGdldHMnKSB7XG4gICAgICAgICAgYXBwLl9zZXRTdGF0ZSgnV2lkZ2V0cycsIFtnZXRBY3RpdmVXaWRnZXQoKV0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwLl9zZXRTdGF0ZSgnJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG8gcGFnZSB0cmFuc2l0aW9uIGlmIGluc3RhbmNlXG4gICAgICAvLyBpcyBub3Qgc2hhcmVkIGJldHdlZW4gdGhlIHJvdXRlc1xuICAgICAgaWYgKCFyZXF1ZXN0LmlzU2hhcmVkSW5zdGFuY2UgJiYgIXJlcXVlc3QuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgYXdhaXQgZXhlY3V0ZVRyYW5zaXRpb24ocmVxdWVzdC5wYWdlLCBnZXRBY3RpdmVQYWdlKCkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyZWQgPSB0cnVlXG4gICAgfVxuICAgIC8vIG9uIGV4cGlyZWQgd2Ugb25seSBjbGVhbnVwXG4gICAgaWYgKGV4cGlyZWQgfHwgcmVxdWVzdC5pc0NhbmNlbGxlZCkge1xuICAgICAgTG9nLmRlYnVnKCdbcm91dGVyXTonLCBgUmVqZWN0ZWQgJHtyZXF1ZXN0Lmhhc2h9IGJlY2F1c2Ugcm91dGUgdG8gJHtnZXRMYXN0SGFzaCgpfSBzdGFydGVkYClcbiAgICAgIGlmIChyZXF1ZXN0LmlzQ3JlYXRlZCAmJiAhcmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIHJlbmRlci10cmVlXG4gICAgICAgIHBhZ2VzSG9zdC5yZW1vdmUocmVxdWVzdC5wYWdlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvblJlcXVlc3RSZXNvbHZlZChyZXF1ZXN0KVxuICAgICAgLy8gcmVzb2x2ZSBwcm9taXNlXG4gICAgICByZXR1cm4gcmVxdWVzdC5wYWdlXG4gICAgfVxuICB9IGNhdGNoIChyZXF1ZXN0KSB7XG4gICAgaWYgKCFyZXF1ZXN0LnJvdXRlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHJlcXVlc3QpXG4gICAgfSBlbHNlIGlmICghZXhwaXJlZCkge1xuICAgICAgLy8gQHRvZG86IHJldmlzaXRcbiAgICAgIGNvbnN0IHsgcm91dGUgfSA9IHJlcXVlc3RcbiAgICAgIC8vIGNsZWFuIHVwIGhpc3RvcnkgaWYgbW9kaWZpZXIgaXMgc2V0XG4gICAgICBpZiAoZ2V0T3B0aW9uKHJvdXRlLm9wdGlvbnMsICdjbGVhckhpc3RvcnknKSkge1xuICAgICAgICBzZXRIaXN0b3J5KFtdKVxuICAgICAgfSBlbHNlIGlmICghaXNXaWxkY2FyZC50ZXN0KHJvdXRlLnBhdGgpKSB7XG4gICAgICAgIHVwZGF0ZUhpc3RvcnkocmVxdWVzdClcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3QuaXNDcmVhdGVkICYmICFyZXF1ZXN0LmlzU2hhcmVkSW5zdGFuY2UpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gcmVuZGVyLXRyZWVcbiAgICAgICAgcGFnZXNIb3N0LnJlbW92ZShyZXF1ZXN0LnBhZ2UpXG4gICAgICB9XG4gICAgICBoYW5kbGVFcnJvcihyZXF1ZXN0KVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBsb2FkZXIgPSBhc3luYyByZXF1ZXN0ID0+IHtcbiAgY29uc3Qgcm91dGUgPSByZXF1ZXN0LnJvdXRlXG4gIGNvbnN0IGhhc2ggPSByZXF1ZXN0Lmhhc2hcbiAgY29uc3QgcmVnaXN0ZXIgPSByZXF1ZXN0LnJlZ2lzdGVyXG5cbiAgLy8gdG9kbzogZ3JhYiBmcm9tIFJvdXRlIGluc3RhbmNlXG4gIGxldCB0eXBlID0gZ2V0Q29tcG9uZW50KHJvdXRlLnBhdGgpXG4gIGxldCBpc0NvbnN0cnVjdCA9IGlzQ29tcG9uZW50Q29uc3RydWN0b3IodHlwZSlcbiAgbGV0IHByb3ZpZGUgPSBmYWxzZVxuXG4gIC8vIGlmIGl0J3MgYW4gaW5zdGFuY2UgYnQgd2UncmUgbm90IGNvbWluZyBiYWNrIGZyb21cbiAgLy8gaGlzdG9yeSB3ZSB0ZXN0IGlmIHdlIGNhbiByZS11c2UgdGhpcyBpbnN0YW5jZVxuICBpZiAoIWlzQ29uc3RydWN0ICYmICFyZWdpc3Rlci5nZXQoc3ltYm9scy5iYWNrdHJhY2spKSB7XG4gICAgaWYgKCFtdXN0UmV1c2Uocm91dGUpKSB7XG4gICAgICB0eXBlID0gdHlwZS5jb25zdHJ1Y3RvclxuICAgICAgaXNDb25zdHJ1Y3QgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgcGFnZSBpcyBMaWdodG5pbmcgQ29tcG9uZW50IGluc3RhbmNlXG4gIGlmICghaXNDb25zdHJ1Y3QpIHtcbiAgICByZXF1ZXN0LnBhZ2UgPSB0eXBlXG4gICAgLy8gaWYgd2UgaGF2ZSBoYXZlIGEgZGF0YSByb3V0ZSBmb3IgY3VycmVudCBwYWdlXG4gICAgaWYgKGhhc1Byb3ZpZGVyKHJvdXRlLnBhdGgpKSB7XG4gICAgICBpZiAoaXNQYWdlRXhwaXJlZCh0eXBlKSB8fCB0eXBlW3N5bWJvbHMuaGFzaF0gIT09IGhhc2gpIHtcbiAgICAgICAgcHJvdmlkZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGN1cnJlbnRSb3V0ZSA9IGdldEFjdGl2ZVBhZ2UoKSAmJiBnZXRBY3RpdmVQYWdlKClbc3ltYm9scy5yb3V0ZV1cbiAgICAvLyBpZiB0aGUgbmV3IHJvdXRlIGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IHJvdXRlIGl0IG1lYW5zIHRoYXQgYm90aFxuICAgIC8vIHJvdXRlIHNoYXJlIHRoZSBDb21wb25lbnQgaW5zdGFuY2UgYW5kIHN0YWNrIGxvY2F0aW9uIC8gc2luY2UgdGhpcyBjYXNlXG4gICAgLy8gaXMgY29uZmxpY3Rpbmcgd2l0aCB0aGUgd2F5IGJlZm9yZSgpIGFuZCBhZnRlcigpIGxvYWRpbmcgd29ya3Mgd2UgZmxhZyBpdCxcbiAgICAvLyBhbmQgY2hlY2sgcGxhdGZvcm0gc2V0dGluZ3MgaW4gd2Ugd2FudCB0byByZS11c2UgaW5zdGFuY2VcbiAgICBpZiAocm91dGUucGF0aCA9PT0gY3VycmVudFJvdXRlKSB7XG4gICAgICByZXF1ZXN0LmlzU2hhcmVkSW5zdGFuY2UgPSB0cnVlXG4gICAgICAvLyBzaW5jZSB3ZSdyZSByZS11c2luZyB0aGUgaW5zdGFuY2Ugd2UgbXVzdCBhdHRhY2hcbiAgICAgIC8vIGhpc3RvcnlTdGF0ZSB0byB0aGUgcmVxdWVzdCB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgIC8vIGJlaW5nIG92ZXJyaWRkZW4uXG4gICAgICBpZiAoaXNGdW5jdGlvbihyZXF1ZXN0LnBhZ2UuaGlzdG9yeVN0YXRlKSkge1xuICAgICAgICByZXF1ZXN0LmNvcGllZEhpc3RvcnlTdGF0ZSA9IHJlcXVlc3QucGFnZS5oaXN0b3J5U3RhdGUoKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LnBhZ2UgPSBjcmVhdGVDb21wb25lbnQoc3RhZ2UsIHR5cGUpXG4gICAgcGFnZXNIb3N0LmEocmVxdWVzdC5wYWdlKVxuICAgIC8vIHRlc3QgaWYgbmVlZCB0byByZXF1ZXN0IGRhdGEgcHJvdmlkZXJcbiAgICBpZiAoaGFzUHJvdmlkZXIocm91dGUucGF0aCkpIHtcbiAgICAgIHByb3ZpZGUgPSB0cnVlXG4gICAgfVxuICAgIHJlcXVlc3QuaXNDcmVhdGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gd2Ugc3RvcmUgaGFzaCBhbmQgcm91dGUgYXMgcHJvcGVydGllcyBvbiB0aGUgcGFnZSBpbnN0YW5jZVxuICAvLyB0aGF0IHdheSB3ZSBjYW4gZWFzaWx5IGNhbGN1bGF0ZSBuZXcgYmVoYXZpb3VyIG9uIHBhZ2UgcmVsb2FkXG4gIHJlcXVlc3QucGFnZVtzeW1ib2xzLmhhc2hdID0gaGFzaFxuICByZXF1ZXN0LnBhZ2Vbc3ltYm9scy5yb3V0ZV0gPSByb3V0ZS5wYXRoXG5cbiAgdHJ5IHtcbiAgICBpZiAocHJvdmlkZSkge1xuICAgICAgLy8gZXh0cmFjdCBhdHRhY2hlZCBkYXRhLXByb3ZpZGVyIGZvciByb3V0ZVxuICAgICAgLy8gd2UncmUgcHJvY2Vzc2luZ1xuICAgICAgY29uc3QgeyB0eXBlOiBsb2FkVHlwZSwgcHJvdmlkZXIgfSA9IGdldFByb3ZpZGVyKHJvdXRlKVxuXG4gICAgICAvLyB1cGRhdGUgcnVubmluZyByZXF1ZXN0XG4gICAgICByZXF1ZXN0LnByb3ZpZGVyID0gcHJvdmlkZXJcbiAgICAgIHJlcXVlc3QucHJvdmlkZXJUeXBlID0gbG9hZFR5cGVcblxuICAgICAgYXdhaXQgZGF0YUhvb2tzW2xvYWRUeXBlXShyZXF1ZXN0KVxuXG4gICAgICAvLyB3ZSBlYXJseSBleGl0IGlmIHRoZSBjdXJyZW50IHJlcXVlc3QgaXMgZXhwaXJlZFxuICAgICAgaWYgKGhhc2ggIT09IGdldExhc3RIYXNoKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVxdWVzdC5wcm92aWRlclR5cGUgIT09ICdhZnRlcicpIHtcbiAgICAgICAgICBlbWl0KHJlcXVlc3QucGFnZSwgJ2RhdGFQcm92aWRlZCcpXG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBwcm9taXNlXG4gICAgICAgIHJldHVybiByZXF1ZXN0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFBlcnNpc3REYXRhKHJlcXVlc3QpXG4gICAgICByZXR1cm4gcmVxdWVzdFxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlcXVlc3QuZXJyb3IgPSBlXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlcXVlc3QpXG4gIH1cbn1cblxuY29uc3QgaGFuZGxlRXJyb3IgPSByZXF1ZXN0ID0+IHtcbiAgaWYgKHJlcXVlc3QgJiYgcmVxdWVzdC5lcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IocmVxdWVzdC5lcnJvcilcbiAgfSBlbHNlIGlmIChyZXF1ZXN0KSB7XG4gICAgTG9nLmVycm9yKHJlcXVlc3QpXG4gIH1cblxuICBpZiAocmVxdWVzdC5wYWdlICYmIHJvdXRlRXhpc3RzKCchJykpIHtcbiAgICBuYXZpZ2F0ZSgnIScsIHsgcmVxdWVzdCB9LCBmYWxzZSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbXVzdFJldXNlID0gcm91dGUgPT4ge1xuICBjb25zdCBvcHQgPSBnZXRPcHRpb24ocm91dGUub3B0aW9ucywgJ3JldXNlSW5zdGFuY2UnKVxuICBjb25zdCBjb25maWcgPSByb3V0ZXJDb25maWcuZ2V0KCdyZXVzZUluc3RhbmNlJylcblxuICAvLyByb3V0ZSBhbHdheXMgaGFzIGZpbmFsIGRlY2lzaW9uXG4gIGlmIChpc0Jvb2xlYW4ob3B0KSkge1xuICAgIHJldHVybiBvcHRcbiAgfVxuICByZXR1cm4gIShpc0Jvb2xlYW4oY29uZmlnKSAmJiBjb25maWcgPT09IGZhbHNlKVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgc3ltYm9scywgZ2V0UXVlcnlTdHJpbmdQYXJhbXMgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBhcHAsIHJvdXRlcywgcm91dGVFeGlzdHMgfSBmcm9tICcuL3JvdXRlcidcbmltcG9ydCB7IGdldFZhbHVlc0Zyb21IYXNoIH0gZnJvbSAnLi9yb3V0ZSdcbmltcG9ydCBlbWl0IGZyb20gJy4vZW1pdCdcblxuZXhwb3J0IGxldCBwcmV2aW91c1N0YXRlXG5cbmV4cG9ydCBjb25zdCBkYXRhSG9va3MgPSB7XG4gIG9uOiByZXF1ZXN0ID0+IHtcbiAgICBwcmV2aW91c1N0YXRlID0gYXBwLnN0YXRlIHx8ICcnXG4gICAgYXBwLl9zZXRTdGF0ZSgnTG9hZGluZycpXG4gICAgcmV0dXJuIGV4ZWNQcm92aWRlcihyZXF1ZXN0KVxuICB9LFxuICBiZWZvcmU6IHJlcXVlc3QgPT4ge1xuICAgIHJldHVybiBleGVjUHJvdmlkZXIocmVxdWVzdClcbiAgfSxcbiAgYWZ0ZXI6IHJlcXVlc3QgPT4ge1xuICAgIHRyeSB7XG4gICAgICBleGVjUHJvdmlkZXIocmVxdWVzdCwgdHJ1ZSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBmb3Igbm93IHdlIGZhaWwgc2lsZW50bHlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH0sXG59XG5cbmNvbnN0IGV4ZWNQcm92aWRlciA9IChyZXF1ZXN0LCBlbWl0UHJvdmlkZWQpID0+IHtcbiAgY29uc3Qgcm91dGUgPSByZXF1ZXN0LnJvdXRlXG4gIGNvbnN0IHByb3ZpZGVyID0gcm91dGUucHJvdmlkZXJcbiAgY29uc3QgZXhwaXJlcyA9IHJvdXRlLmNhY2hlID8gcm91dGUuY2FjaGUgKiAxMDAwIDogMFxuICBjb25zdCBwYXJhbXMgPSBhZGRQZXJzaXN0RGF0YShyZXF1ZXN0KVxuICByZXR1cm4gcHJvdmlkZXIucmVxdWVzdChyZXF1ZXN0LnBhZ2UsIHsgLi4ucGFyYW1zIH0pLnRoZW4oKCkgPT4ge1xuICAgIHJlcXVlc3QucGFnZVtzeW1ib2xzLmV4cGlyZXNdID0gRGF0ZS5ub3coKSArIGV4cGlyZXNcbiAgICBpZiAoZW1pdFByb3ZpZGVkKSB7XG4gICAgICBlbWl0KHJlcXVlc3QucGFnZSwgJ2RhdGFQcm92aWRlZCcpXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgYWRkUGVyc2lzdERhdGEgPSAoeyBwYWdlLCByb3V0ZSwgaGFzaCwgcmVnaXN0ZXIgPSBuZXcgTWFwKCkgfSkgPT4ge1xuICBjb25zdCB1cmxWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tSGFzaChoYXNoLCByb3V0ZS5wYXRoKVxuICBjb25zdCBxdWVyeVBhcmFtcyA9IGdldFF1ZXJ5U3RyaW5nUGFyYW1zKGhhc2gpXG4gIGNvbnN0IHBhZ2VEYXRhID0gbmV3IE1hcChbLi4udXJsVmFsdWVzLCAuLi5yZWdpc3Rlcl0pXG4gIGNvbnN0IHBhcmFtcyA9IHt9XG5cbiAgLy8gbWFrZSBkeW5hbWljIHVybCBkYXRhIGF2YWlsYWJsZSB0byB0aGUgcGFnZVxuICAvLyBhcyBpbnN0YW5jZSBwcm9wZXJ0aWVzXG4gIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgcGFnZURhdGEpIHtcbiAgICBwYXJhbXNbbmFtZV0gPSB2YWx1ZVxuICB9XG5cbiAgaWYgKHF1ZXJ5UGFyYW1zKSB7XG4gICAgcGFyYW1zW3N5bWJvbHMucXVlcnlQYXJhbXNdID0gcXVlcnlQYXJhbXNcbiAgfVxuXG4gIC8vIGNoZWNrIG5hdmlnYXRpb24gcmVnaXN0ZXIgZm9yIHBlcnNpc3RlbnQgZGF0YVxuICBpZiAocmVnaXN0ZXIuc2l6ZSkge1xuICAgIGNvbnN0IG9iaiA9IHt9XG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIHJlZ2lzdGVyKSB7XG4gICAgICBvYmpba10gPSB2XG4gICAgfVxuICAgIHBhZ2UucGVyc2lzdCA9IG9ialxuICB9XG5cbiAgLy8gbWFrZSB1cmwgZGF0YSBhbmQgcGVyc2lzdCBkYXRhIGF2YWlsYWJsZVxuICAvLyB2aWEgcGFyYW1zIHByb3BlcnR5XG4gIHBhZ2UucGFyYW1zID0gcGFyYW1zXG4gIGVtaXQocGFnZSwgWyd1cmxQYXJhbXMnXSwgcGFyYW1zKVxuXG4gIHJldHVybiBwYXJhbXNcbn1cblxuLyoqXG4gKiBUZXN0IGlmIHBhZ2UgcGFzc2VkIGNhY2hlLXRpbWVcbiAqIEBwYXJhbSBwYWdlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzUGFnZUV4cGlyZWQgPSBwYWdlID0+IHtcbiAgaWYgKCFwYWdlW3N5bWJvbHMuZXhwaXJlc10pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGV4cGlyZXMgPSBwYWdlW3N5bWJvbHMuZXhwaXJlc11cbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuXG4gIHJldHVybiBub3cgPj0gZXhwaXJlc1xufVxuXG5leHBvcnQgY29uc3QgaGFzUHJvdmlkZXIgPSBwYXRoID0+IHtcbiAgaWYgKHJvdXRlRXhpc3RzKHBhdGgpKSB7XG4gICAgY29uc3QgcmVjb3JkID0gcm91dGVzLmdldChwYXRoKVxuICAgIHJldHVybiAhIXJlY29yZC5wcm92aWRlclxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgY29uc3QgZ2V0UHJvdmlkZXIgPSByb3V0ZSA9PiB7XG4gIC8vIEB0b2RvOiBmaXgsIHJvdXRlIGFscmVhZHkgaXMgcGFzc2VkIGluXG4gIGlmIChyb3V0ZUV4aXN0cyhyb3V0ZS5wYXRoKSkge1xuICAgIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHJvdXRlcy5nZXQocm91dGUucGF0aClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogcHJvdmlkZXIudHlwZSxcbiAgICAgIHByb3ZpZGVyOiBwcm92aWRlci5yZXF1ZXN0LFxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGhhc1JlZ2V4ID0gL1xce1xcLyguKj8pXFwvKFtpZ21dezAsM30pXFx9L2dcbmV4cG9ydCBjb25zdCBpc1dpbGRjYXJkID0gL15bISokXSQvXG5leHBvcnQgY29uc3QgaGFzTG9va3VwSWQgPSAvXFwvOlxcdys/QEAoWzAtOV0rPylAQC9cbmV4cG9ydCBjb25zdCBpc05hbWVkR3JvdXAgPSAvXlxcLzovXG5cbi8qKlxuICogVGVzdCBpZiBhIHJvdXRlIGlzIHBhcnQgcmVndWxhciBleHByZXNzZWRcbiAqIGFuZCByZXBsYWNlIGl0IGZvciBhIHNpbXBsZSBjaGFyYWN0ZXJcbiAqIEBwYXJhbSByb3V0ZVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpcFJlZ2V4ID0gKHJvdXRlLCBjaGFyID0gJ1InKSA9PiB7XG4gIC8vIGlmIHJvdXRlIGlzIHBhcnQgcmVndWxhciBleHByZXNzZWQgd2UgcmVwbGFjZVxuICAvLyB0aGUgcmVndWxhciBleHByZXNzaW9uIGZvciBhIGNoYXJhY3RlciB0b1xuICAvLyBzaW1wbGlmeSBmbG9vciBjYWxjdWxhdGlvbiBhbmQgYmFja3RyYWNraW5nXG4gIGlmIChoYXNSZWdleC50ZXN0KHJvdXRlKSkge1xuICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShoYXNSZWdleCwgY2hhcilcbiAgfVxuICByZXR1cm4gcm91dGVcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbG9jYWwgcmVxdWVzdCByZWdpc3RlclxuICogQHBhcmFtIGZsYWdzXG4gKiBAcmV0dXJucyB7TWFwPGFueSwgYW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZ2lzdGVyID0gZmxhZ3MgPT4ge1xuICBjb25zdCByZWcgPSBuZXcgTWFwKClcbiAgLy8gc3RvcmUgdXNlciBkZWZpbmVkIGFuZCByb3V0ZXJcbiAgLy8gZGVmaW5lZCBmbGFncyBpbiByZWdpc3RlclxuICA7Wy4uLk9iamVjdC5rZXlzKGZsYWdzKSwgLi4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmbGFncyldLmZvckVhY2goa2V5ID0+IHtcbiAgICByZWcuc2V0KGtleSwgZmxhZ3Nba2V5XSlcbiAgfSlcbiAgcmV0dXJuIHJlZ1xufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaGFzUmVnZXgsIGhhc0xvb2t1cElkLCBpc05hbWVkR3JvdXAsIHN0cmlwUmVnZXggfSBmcm9tICcuL3JlZ2V4J1xuaW1wb3J0IHsgcm91dGVzLCByb3V0ZUV4aXN0cywgYm9vdFJlcXVlc3QsIGdldFJvdXRlcyB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IFJlcXVlc3QgZnJvbSAnLi4vbW9kZWwvUmVxdWVzdCdcbmltcG9ydCBSb3V0ZSBmcm9tICcuLi9tb2RlbC9Sb3V0ZSdcbmltcG9ydCB7IG9iamVjdFRvUXVlcnlTdHJpbmcsIGlzT2JqZWN0LCBpc1N0cmluZyB9IGZyb20gJy4vaGVscGVycydcblxuLyoqXG4gKiBTaW1wbGUgcm91dGUgbGVuZ3RoIGNhbGN1bGF0aW9uXG4gKiBAcGFyYW0gcm91dGUge3N0cmluZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gZmxvb3JcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZsb29yID0gcm91dGUgPT4ge1xuICByZXR1cm4gc3RyaXBSZWdleChyb3V0ZSkuc3BsaXQoJy8nKS5sZW5ndGhcbn1cblxuLyoqXG4gKiByZXR1cm4gYWxsIHN0b3JlZCByb3V0ZXMgdGhhdCBsaXZlIG9uIHRoZSBzYW1lIGZsb29yXG4gKiBAcGFyYW0gZmxvb3JcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuY29uc3QgZ2V0Um91dGVzQnlGbG9vciA9IGZsb29yID0+IHtcbiAgY29uc3QgbWF0Y2hlcyA9IFtdXG4gIC8vIHNpbXBsZSBmaWx0ZXIgb2YgbGV2ZWwgY2FuZGlkYXRlc1xuICBmb3IgKGxldCBbcm91dGVdIG9mIHJvdXRlcy5lbnRyaWVzKCkpIHtcbiAgICBpZiAoZ2V0Rmxvb3Iocm91dGUpID09PSBmbG9vcikge1xuICAgICAgbWF0Y2hlcy5wdXNoKHJvdXRlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlc1xufVxuXG4vKipcbiAqIHJldHVybiBhIG1hdGNoaW5nIHJvdXRlIGJ5IHByb3ZpZGVkIGhhc2hcbiAqIGhhc2g6IGhvbWUvYnJvd3NlLzEyIHdpbGwgbWF0Y2g6XG4gKiByb3V0ZTogaG9tZS9icm93c2UvOmNhdGVnb3J5SWRcbiAqIEBwYXJhbSBoYXNoIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbnx7fX0gLSByb3V0ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0Um91dGVCeUhhc2ggPSBoYXNoID0+IHtcbiAgLy8gQHRvZG86IGNsZWFuIHVwIG9uIGhhbmRsZUhhc2hcbiAgaGFzaCA9IGhhc2gucmVwbGFjZSgvXiMvLCAnJylcblxuICBjb25zdCBnZXRVcmxQYXJ0cyA9IC8oXFwvPzo/W14vXSspL2dcbiAgLy8gZ3JhYiBwb3NzaWJsZSBjYW5kaWRhdGVzIGZyb20gc3RvcmVkIHJvdXRlc1xuICBjb25zdCBjYW5kaWRhdGVzID0gZ2V0Um91dGVzQnlGbG9vcihnZXRGbG9vcihoYXNoKSlcbiAgLy8gYnJlYWsgaGFzaCBkb3duIGluIGNodW5rc1xuICBjb25zdCBoYXNoUGFydHMgPSBoYXNoLm1hdGNoKGdldFVybFBhcnRzKSB8fCBbXVxuXG4gIC8vIHRvIHNpbXBsaWZ5IHRoZSByb3V0ZSBtYXRjaGluZyBhbmQgcHJldmVudCBsb29rIGFyb3VuZFxuICAvLyBpbiBvdXIgZ2V0VXJsUGFydHMgcmVnZXggd2UgZ2V0IHRoZSByZWdleCBwYXJ0IGZyb21cbiAgLy8gcm91dGUgY2FuZGlkYXRlIGFuZCBzdG9yZSB0aGVtIHNvIHRoYXQgd2UgY2FuIHJlZmVyZW5jZVxuICAvLyB0aGVtIHdoZW4gd2UgcGVyZm9ybSB0aGUgYWN0dWFsIHJlZ2V4IGFnYWluc3QgaGFzaFxuICBsZXQgcmVnZXhTdG9yZSA9IFtdXG5cbiAgbGV0IG1hdGNoZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihyb3V0ZSA9PiB7XG4gICAgbGV0IGlzTWF0Y2hpbmcgPSB0cnVlXG4gICAgLy8gcmVwbGFjZSByZWdleCBpbiByb3V0ZSB3aXRoIGxvb2t1cCBpZCA9PiBAQHtzdG9yZUlkfUBAXG4gICAgaWYgKGhhc1JlZ2V4LnRlc3Qocm91dGUpKSB7XG4gICAgICBjb25zdCByZWdNYXRjaGVzID0gcm91dGUubWF0Y2goaGFzUmVnZXgpXG4gICAgICBpZiAocmVnTWF0Y2hlcyAmJiByZWdNYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICByb3V0ZSA9IHJlZ01hdGNoZXMucmVkdWNlKChmdWxsUm91dGUsIHJlZ2V4KSA9PiB7XG4gICAgICAgICAgY29uc3QgbG9va3VwSWQgPSByZWdleFN0b3JlLmxlbmd0aFxuICAgICAgICAgIGZ1bGxSb3V0ZSA9IGZ1bGxSb3V0ZS5yZXBsYWNlKHJlZ2V4LCBgQEAke2xvb2t1cElkfUBAYClcbiAgICAgICAgICByZWdleFN0b3JlLnB1c2gocmVnZXguc3Vic3RyaW5nKDEsIHJlZ2V4Lmxlbmd0aCAtIDEpKVxuICAgICAgICAgIHJldHVybiBmdWxsUm91dGVcbiAgICAgICAgfSwgcm91dGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVQYXJ0cyA9IHJvdXRlLm1hdGNoKGdldFVybFBhcnRzKSB8fCBbXVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSByb3V0ZVBhcnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3Qgcm91dGVQYXJ0ID0gcm91dGVQYXJ0c1tpXVxuICAgICAgY29uc3QgaGFzaFBhcnQgPSBoYXNoUGFydHNbaV1cblxuICAgICAgLy8gU2luY2Ugd2Ugc3VwcG9ydCBjYXRjaC1hbGwgYW5kIHJlZ2V4IGRyaXZlbiBuYW1lIGdyb3Vwc1xuICAgICAgLy8gd2UgZmlyc3QgdGVzdCBmb3IgcmVnZXggbG9va3VwIGlkIGFuZCBzZWUgaWYgdGhlIHJlZ2V4XG4gICAgICAvLyBtYXRjaGVzIHRoZSB2YWx1ZSBmcm9tIHRoZSBoYXNoXG4gICAgICBpZiAoaGFzTG9va3VwSWQudGVzdChyb3V0ZVBhcnQpKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2hlcyA9IGhhc0xvb2t1cElkLmV4ZWMocm91dGVQYXJ0KVxuICAgICAgICBjb25zdCBzdG9yZUlkID0gcm91dGVNYXRjaGVzWzFdXG4gICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSByZWdleFN0b3JlW3N0b3JlSWRdXG5cbiAgICAgICAgLy8gc3BsaXQgcmVnZXggYW5kIG1vZGlmaWVycyBzbyB3ZSBjYW4gdXNlIGJvdGhcbiAgICAgICAgLy8gdG8gY3JlYXRlIGEgbmV3IFJlZ0V4cFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICBjb25zdCByZWdNYXRjaGVzID0gL1xcLyhbXlxcL10rKVxcLyhbaWdtXXswLDN9KS8uZXhlYyhyb3V0ZVJlZ2V4KVxuXG4gICAgICAgIGlmIChyZWdNYXRjaGVzICYmIHJlZ01hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHJlZ01hdGNoZXNbMV1cbiAgICAgICAgICBjb25zdCBtb2RpZmllcnMgPSByZWdNYXRjaGVzWzJdXG5cbiAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4vJHtleHByZXNzaW9ufSRgLCBtb2RpZmllcnMpXG5cbiAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaGFzaFBhcnQpKSB7XG4gICAgICAgICAgICBpc01hdGNoaW5nID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNOYW1lZEdyb3VwLnRlc3Qocm91dGVQYXJ0KSkge1xuICAgICAgICAvLyB3ZSBraW5kbHkgc2tpcCBuYW1lZEdyb3VwcyBiZWNhdXNlIHRoaXMgaXMgZHluYW1pY1xuICAgICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gdGhlIHN0YXRpYyBhbmQgcmVnZXggZHJpdmUgcGFydHNcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAoaGFzaFBhcnQgJiYgcm91dGVQYXJ0LnRvTG93ZXJDYXNlKCkgIT09IGhhc2hQYXJ0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgaXNNYXRjaGluZyA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc01hdGNoaW5nXG4gIH0pXG5cbiAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgaWYgKG1hdGNoZXMuaW5kZXhPZihoYXNoKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmluZGV4T2YoaGFzaCldXG4gICAgICByZXR1cm4gcm91dGVzLmdldChtYXRjaClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgZ2l2ZSBwcmlvIHRvIHN0YXRpYyByb3V0ZXMgb3ZlciBkeW5hbWljXG4gICAgICBtYXRjaGVzID0gbWF0Y2hlcy5zb3J0KGEgPT4ge1xuICAgICAgICByZXR1cm4gaXNOYW1lZEdyb3VwLnRlc3QoYSkgPyAtMSA6IDFcbiAgICAgIH0pXG4gICAgICAvLyB3b3VsZCBiZSBzdHJhbmdlIGlmIHRoaXMgZmFpbHNcbiAgICAgIC8vIGJ1dCBzdGlsbCB3ZSB0ZXN0XG4gICAgICBpZiAocm91dGVFeGlzdHMobWF0Y2hlc1swXSkpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlcy5nZXQobWF0Y2hlc1swXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBjb25zdCBnZXRWYWx1ZXNGcm9tSGFzaCA9IChoYXNoID0gJycsIHBhdGgpID0+IHtcbiAgLy8gcmVwbGFjZSB0aGUgcmVnZXggZGVmaW5pdGlvbiBmcm9tIHRoZSByb3V0ZSBiZWNhdXNlXG4gIC8vIHdlIGFscmVhZHkgZGlkIHRoZSBtYXRjaGluZyBwYXJ0XG4gIHBhdGggPSBzdHJpcFJlZ2V4KHBhdGgsICcnKVxuXG4gIGNvbnN0IGdldFVybFBhcnRzID0gLyhcXC8/Oj9bXFx3JVxcczouLV0rKS9nXG4gIGNvbnN0IGhhc2hQYXJ0cyA9IGhhc2gubWF0Y2goZ2V0VXJsUGFydHMpIHx8IFtdXG4gIGNvbnN0IHJvdXRlUGFydHMgPSBwYXRoLm1hdGNoKGdldFVybFBhcnRzKSB8fCBbXVxuICBjb25zdCBnZXROYW1lZEdyb3VwID0gL15cXC86KFtcXHctXSspXFwvPy9cblxuICByZXR1cm4gcm91dGVQYXJ0cy5yZWR1Y2UoKHN0b3JhZ2UsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gZ2V0TmFtZWRHcm91cC5leGVjKHZhbHVlKVxuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGgpIHtcbiAgICAgIHN0b3JhZ2Uuc2V0KG1hdGNoWzFdLCBkZWNvZGVVUklDb21wb25lbnQoaGFzaFBhcnRzW2luZGV4XS5yZXBsYWNlKC9eXFwvLywgJycpKSlcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JhZ2VcbiAgfSwgbmV3IE1hcCgpKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0T3B0aW9uID0gKHN0YWNrLCBwcm9wKSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmKHN0YWNrICYmIHN0YWNrLmhhc093blByb3BlcnR5KHByb3ApKXtcbiAgICByZXR1cm4gc3RhY2tbcHJvcF1cbiAgfVxuICAvLyB3ZSBleHBsaWNpdGx5IHJldHVybiB1bmRlZmluZWQgc2luY2Ugd2UncmUgdGVzdGluZ1xuICAvLyBmb3IgZXhwbGljaXQgdGVzdCB2YWx1ZXNcbn1cblxuLyoqXG4gKiBjcmVhdGUgYW5kIHJldHVybiBuZXcgUm91dGUgaW5zdGFuY2VcbiAqIEBwYXJhbSBjb25maWdcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJvdXRlID0gY29uZmlnID0+IHtcbiAgLy8gd2UgbmVlZCB0byBwcm92aWRlIGEgYml0IG9mIGFkZGl0aW9uYWwgbG9naWNcbiAgLy8gZm9yIHRoZSBib290Q29tcG9uZW50XG4gIGlmIChjb25maWcucGF0aCA9PT0gJyQnKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICBwcmV2ZW50U3RvcmFnZTogdHJ1ZSxcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGNvbmZpZy5vcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4uY29uZmlnLm9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB9XG4gICAgfVxuICAgIGNvbmZpZy5vcHRpb25zID0gb3B0aW9uc1xuICAgIC8vIGlmIGNvbmZpZ3VyZWQgYWRkIHJlZmVyZW5jZSB0byBib290UmVxdWVzdFxuICAgIC8vIGFzIHJvdXRlciBhZnRlciBwcm92aWRlclxuICAgIGlmIChib290UmVxdWVzdCkge1xuICAgICAgY29uZmlnLmFmdGVyID0gYm9vdFJlcXVlc3RcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSb3V0ZShjb25maWcpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFJvdXRlciByZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIHVybFxuICogQHBhcmFtIGFyZ3NcbiAqIEBwYXJhbSBzdG9yZVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXF1ZXN0ID0gKHVybCwgYXJncywgc3RvcmUpID0+IHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgYXJncywgc3RvcmUpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRIYXNoQnlOYW1lID0gb2JqID0+IHtcbiAgaWYgKCFvYmoudG8gJiYgIW9iai5uYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgY29uc3Qgcm91dGUgPSBnZXRSb3V0ZUJ5TmFtZShvYmoudG8gfHwgb2JqLm5hbWUpXG4gIGNvbnN0IGhhc0R5bmFtaWNHcm91cCA9IC9cXC86KFtcXHctXSspXFwvPy9cbiAgbGV0IGhhc2ggPSByb3V0ZVxuXG4gIC8vIGlmIHJvdXRlIGNvbnRhaW5zIGR5bmFtaWMgZ3JvdXBcbiAgLy8gd2UgcmVwbGFjZSB0aGVtIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtc1xuICBpZiAoaGFzRHluYW1pY0dyb3VwLnRlc3Qocm91dGUpKSB7XG4gICAgaWYgKG9iai5wYXJhbXMpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmoucGFyYW1zKVxuICAgICAgaGFzaCA9IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gYWNjLnJlcGxhY2UoYDoke2tleX1gLCBvYmoucGFyYW1zW2tleV0pXG4gICAgICB9LCByb3V0ZSlcbiAgICB9XG4gICAgaWYgKG9iai5xdWVyeSkge1xuICAgICAgcmV0dXJuIGAke2hhc2h9JHtvYmplY3RUb1F1ZXJ5U3RyaW5nKG9iai5xdWVyeSl9YFxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzaFxufVxuXG5jb25zdCBnZXRSb3V0ZUJ5TmFtZSA9IG5hbWUgPT4ge1xuICBmb3IgKGxldCBbcGF0aCwgcm91dGVdIG9mIHJvdXRlcy5lbnRyaWVzKCkpIHtcbiAgICBpZiAocm91dGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIHBhdGhcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBjb25zdCBrZWVwQWN0aXZlUGFnZUFsaXZlID0gKHJvdXRlLCByZXF1ZXN0KSA9PiB7XG4gIGlmIChpc1N0cmluZyhyb3V0ZSkpIHtcbiAgICBjb25zdCByb3V0ZXMgPSBnZXRSb3V0ZXMoKVxuICAgIGlmIChyb3V0ZXMuaGFzKHJvdXRlKSkge1xuICAgICAgcm91dGUgPSByb3V0ZXMuZ2V0KHJvdXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBjb25zdCByZWdpc3RlciA9IHJlcXVlc3QucmVnaXN0ZXJcbiAgY29uc3Qgcm91dGVPcHRpb25zID0gcm91dGUub3B0aW9uc1xuXG4gIGlmIChyZWdpc3Rlci5oYXMoJ2tlZXBBbGl2ZScpKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVyLmdldCgna2VlcEFsaXZlJylcbiAgfSBlbHNlIGlmIChyb3V0ZU9wdGlvbnMgJiYgcm91dGVPcHRpb25zLmtlZXBBbGl2ZSkge1xuICAgIHJldHVybiByb3V0ZU9wdGlvbnMua2VlcEFsaXZlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIGdldENvbmZpZ01hcCxcbiAgaXNBcnJheSxcbiAgaXNCb29sZWFuLFxuICBpc0NvbXBvbmVudENvbnN0cnVjdG9yLFxuICBpc0Z1bmN0aW9uLFxuICBpc1BhZ2UsXG4gIHN5bWJvbHMsXG4gIGNsZWFuSGFzaCxcbn0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHsgc3RlcCwgbmF2aWdhdGVRdWV1ZSB9IGZyb20gJy4uL2luZGV4J1xuaW1wb3J0IHsgY3JlYXRlUm91dGUsIGdldE9wdGlvbiB9IGZyb20gJy4vcm91dGUnXG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMnXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL0xvZydcbmltcG9ydCB7IGlzV2lsZGNhcmQgfSBmcm9tICcuL3JlZ2V4J1xuaW1wb3J0IGVtaXQgZnJvbSAnLi9lbWl0J1xuaW1wb3J0IHsgdXBkYXRlV2lkZ2V0cyB9IGZyb20gJy4vd2lkZ2V0cydcbmltcG9ydCB7IHNldEhpc3RvcnksIHVwZGF0ZUhpc3RvcnkgfSBmcm9tICcuL2hpc3RvcnknXG5pbXBvcnQgeyBBcHBJbnN0YW5jZSB9IGZyb20gJy4uLy4uL0FwcGxpY2F0aW9uJ1xuXG4vKipcbiAqIEB0eXBlIHtMaWdodG5pbmcuQXBwbGljYXRpb259XG4gKi9cbmV4cG9ydCBsZXQgYXBwbGljYXRpb25cblxuLyoqXG4gKiBBY3R1YWwgaW5zdGFuY2Ugb2YgdGhlIGFwcFxuICogQHR5cGUge0xpZ2h0bmluZy5Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBsZXQgYXBwXG5cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgaG9zdHMgYWxsIHJvdXRlZCBwYWdlc1xuICogQHR5cGUge0xpZ2h0bmluZy5Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBsZXQgcGFnZXNIb3N0XG5cbi8qKlxuICogQHR5cGUge0xpZ2h0bmluZy5TdGFnZX1cbiAqL1xuZXhwb3J0IGxldCBzdGFnZVxuXG4vKipcbiAqIFBsYXRmb3JtIGRyaXZlbiBSb3V0ZXIgY29uZmlndXJhdGlvblxuICogQHR5cGUge01hcDxzdHJpbmc+fVxuICovXG5leHBvcnQgbGV0IHJvdXRlckNvbmZpZ1xuXG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGhvc3RzIGFsbCBhdHRhY2hlZCB3aWRnZXRzXG4gKiBAdHlwZSB7TGlnaHRuaW5nLkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGxldCB3aWRnZXRzSG9zdFxuXG4vKipcbiAqIEhhc2ggd2UgcG9pbnQgdGhlIGJyb3dzZXIgdG8gd2hlbiB3ZSBib290IHRoZSBhcHBcbiAqIGFuZCB0aGVyZSBpcyBubyBkZWVwLWxpbmsgcHJvdmlkZWRcbiAqIEB0eXBlIHtzdHJpbmd8RnVuY3Rpb259XG4gKi9cbmxldCByb290SGFzaFxuXG4vKipcbiAqIEJvb3QgcmVxdWVzdCB3aWxsIGZpcmUgYmVmb3JlIGFwcCBzdGFydFxuICogY2FuIGJlIHVzZWQgdG8gZXhlY3V0ZSBzb21lIGdsb2JhbCBsb2dpY1xuICogYW5kIGNhbiBiZSBjb25maWd1cmVkXG4gKi9cbmV4cG9ydCBsZXQgYm9vdFJlcXVlc3RcblxuLyoqXG4gKiBGbGFnIGlmIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBicm93c2VyIGxvY2F0aW9uIGhhc2guXG4gKiBSb3V0ZXIgY2FuIHdvcmsgd2l0aG91dC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgbGV0IHVwZGF0ZUhhc2ggPSB0cnVlXG5cbi8qKlxuICogV2lsbCBiZSBjYWxsZWQgYmVmb3JlIGEgcm91dGUgc3RhcnRzLCBjYW4gYmUgb3ZlcnJpZGRlblxuICogdmlhIHJvdXRlcyBjb25maWdcbiAqIEBwYXJhbSBmcm9tIC0gcm91dGUgd2UgY2FtZSBmcm9tXG4gKiBAcGFyYW0gdG8gLSByb3V0ZSB3ZSBuYXZpZ2F0ZSB0b1xuICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuZXhwb3J0IGxldCBiZWZvcmVFYWNoUm91dGUgPSBhc3luYyAoZnJvbSwgdG8pPT57XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogICogV2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYSBuYXZpZ2F0ZSBzdWNjZXNzZnVsbHkgcmVzb2x2ZWQsXG4gKiBjYW4gYmUgb3ZlcnJpZGRlbiB2aWEgcm91dGVzIGNvbmZpZ1xuICovXG5leHBvcnQgbGV0IGFmdGVyRWFjaFJvdXRlID0gKCkgPT4ge31cblxuLyoqXG4gKiBBbGwgY29uZmlndXJlZCByb3V0ZXNcbiAqIEB0eXBlIHtNYXA8c3RyaW5nLCBvYmplY3Q+fVxuICovXG5leHBvcnQgbGV0IHJvdXRlcyA9IG5ldyBNYXAoKVxuXG4vKipcbiAqIFN0b3JlIGFsbCBwYWdlIGNvbXBvbmVudHMgcGVyIHJvdXRlXG4gKiBAdHlwZSB7TWFwPHN0cmluZywgb2JqZWN0Pn1cbiAqL1xuZXhwb3J0IGxldCBjb21wb25lbnRzID0gbmV3IE1hcCgpXG5cbi8qKlxuICogRmxhZyBpZiByb3V0ZXIgaGFzIGJlZW4gaW5pdGlhbGlzZWRcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5sZXQgaW5pdGlhbGlzZWQgPSBmYWxzZVxuXG4vKipcbiAqIEN1cnJlbnQgcGFnZSBiZWluZyByZW5kZXJlZCBvbiBzY3JlZW5cbiAqIEB0eXBlIHtudWxsfVxuICovXG5sZXQgYWN0aXZlUGFnZSA9IG51bGxcbmxldCBhY3RpdmVIYXNoXG5sZXQgYWN0aXZlUm91dGVcblxuLyoqXG4gKiAgRHVyaW5nIHRoZSBwcm9jZXNzIG9mIGEgbmF2aWdhdGlvbiByZXF1ZXN0IGEgbmV3XG4gKiAgcmVxdWVzdCBjYW4gc3RhcnQsIHRvIHByZXZlbnQgdW53YW50ZWQgYmVoYXZpb3VyXG4gKiAgdGhlIG5hdmlnYXRlKCktbWV0aG9kIHN0b3JlcyB0aGUgbGFzdCBhY2NlcHRlZCBoYXNoXG4gKiAgc28gd2UgY2FuIGludmFsaWRhdGUgYW55IHByaW9yIHJlcXVlc3RzXG4gKi9cbmxldCBsYXN0QWNjZXB0ZWRIYXNoXG5cbi8qKlxuICogV2l0aCBvbigpLWRhdGEgcHJvdmlkaW5nIGJlaGF2aW91ciB0aGUgUm91dGVyIGZvcmNlZCB0aGUgQXBwXG4gKiBpbiBhIExvYWRpbmcgc3RhdGUuIFdoZW4gdGhlIGRhdGEtcHJvdmlkZXIgcmVzb2x2ZXMgd2Ugd2FudCB0b1xuICogY2hhbmdlIHRoZSBzdGF0ZSBiYWNrIHRvIHdoZXJlIHdlIGNhbWUgZnJvbVxuICovXG5sZXQgcHJldmlvdXNTdGF0ZVxuXG5jb25zdCBtaXhpbiA9IGFwcCA9PiB7XG4gIC8vIGJ5IGRlZmF1bHQgdGhlIFJvdXRlciBCYXNlY2xhc3MgcHJvdmlkZXMgdGhlIGNvbXBvbmVudFxuICAvLyByZWZlcmVuY2UgaW4gd2hpY2ggd2Ugc3RvcmUgb3VyIHBhZ2VzXG4gIGlmIChhcHAucGFnZXMpIHtcbiAgICBwYWdlc0hvc3QgPSBhcHAucGFnZXMuY2hpbGRMaXN0XG4gIH1cbiAgLy8gaWYgdGhlIGFwcCBpcyB1c2luZyB3aWRnZXRzIHdlIGdyYWIgcmVmc1xuICAvLyBhbmQgaGlkZSBhbGwgdGhlIHdpZGdldHNcbiAgaWYgKGFwcC53aWRnZXRzICYmIGFwcC53aWRnZXRzLmNoaWxkcmVuKSB7XG4gICAgd2lkZ2V0c0hvc3QgPSBhcHAud2lkZ2V0cy5jaGlsZExpc3RcbiAgICAvLyBoaWRlIGFsbCB3aWRnZXRzIG9uIGJvb3RcbiAgICB3aWRnZXRzSG9zdC5mb3JFYWNoKHcgPT4gKHcudmlzaWJsZSA9IGZhbHNlKSlcbiAgfVxuICBhcHAuX2hhbmRsZUJhY2sgPSBlID0+IHtcbiAgICBzdGVwKC0xKVxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBib290Um91dGVyID0gKGNvbmZpZywgaW5zdGFuY2UpID0+IHtcbiAgbGV0IHsgYXBwSW5zdGFuY2UsIHJvdXRlcyB9ID0gY29uZmlnXG5cbiAgLy8gaWYgaW5zdGFuY2UgaXMgcHJvdmlkZWQgYW5kIGl0J3MgYW5kIExpZ2h0bmluZyBDb21wb25lbnQgaW5zdGFuY2VcbiAgaWYgKGluc3RhbmNlICYmIGlzUGFnZShpbnN0YW5jZSkpIHtcbiAgICBhcHAgPSBpbnN0YW5jZVxuICB9XG4gIGlmICghYXBwKSB7XG4gICAgYXBwID0gYXBwSW5zdGFuY2UgfHwgQXBwSW5zdGFuY2VcbiAgfVxuXG4gIGFwcGxpY2F0aW9uID0gYXBwLmFwcGxpY2F0aW9uXG4gIHBhZ2VzSG9zdCA9IGFwcGxpY2F0aW9uLmNoaWxkTGlzdFxuICBzdGFnZSA9IGFwcC5zdGFnZVxuICByb3V0ZXJDb25maWcgPSBnZXRDb25maWdNYXAoKVxuXG4gIG1peGluKGFwcClcblxuICBpZiAoaXNBcnJheShyb3V0ZXMpKSB7XG4gICAgc2V0dXAoY29uZmlnKVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocm91dGVzKSkge1xuICAgIGNvbnNvbGUud2FybignW1JvdXRlcl06IENhbGxpbmcgUm91dGVyLnJvdXRlKCkgZGlyZWN0bHkgaXMgZGVwcmVjYXRlZC4nKVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdVc2Ugb2JqZWN0IGNvbmZpZzogaHR0cHM6Ly9yZGtjZW50cmFsLmdpdGh1Yi5pby9MaWdodG5pbmctU0RLLyMvcGx1Z2lucy9yb3V0ZXIvY29uZmlndXJhdGlvbidcbiAgICApXG4gIH1cbn1cblxuY29uc3Qgc2V0dXAgPSBjb25maWcgPT4ge1xuICBpZiAoIWluaXRpYWxpc2VkKSB7XG4gICAgaW5pdChjb25maWcpXG4gIH1cbiAgY29uZmlnLnJvdXRlcy5mb3JFYWNoKHIgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBjbGVhbkhhc2goci5wYXRoKVxuICAgIGlmICghcm91dGVFeGlzdHMocGF0aCkpIHtcbiAgICAgIGNvbnN0IHJvdXRlID0gY3JlYXRlUm91dGUocilcbiAgICAgIHJvdXRlcy5zZXQocGF0aCwgcm91dGUpXG4gICAgICAvLyBpZiByb3V0ZSBoYXMgYSBjb25maWd1cmVkIGNvbXBvbmVudCBwcm9wZXJ0eVxuICAgICAgLy8gd2Ugc3RvcmUgaXQgaW4gYSBkaWZmZXJlbnQgbWFwIHRvIHNpbXBsaWZ5XG4gICAgICAvLyB0aGUgY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgcGVyIHJvdXRlXG4gICAgICBpZiAocm91dGUuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCB0eXBlID0gcm91dGUuY29tcG9uZW50XG4gICAgICAgIGlmIChpc0NvbXBvbmVudENvbnN0cnVjdG9yKHR5cGUpKSB7XG4gICAgICAgICAgaWYgKCFyb3V0ZXJDb25maWcuZ2V0KCdsYXp5Q3JlYXRlJykpIHtcbiAgICAgICAgICAgIHR5cGUgPSBjcmVhdGVDb21wb25lbnQoc3RhZ2UsIHR5cGUpXG4gICAgICAgICAgICBwYWdlc0hvc3QuYSh0eXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnRzLnNldChwYXRoLCB0eXBlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGAke3BhdGh9IGFscmVhZHkgZXhpc3RzIGluIHJvdXRlcyBjb25maWd1cmF0aW9uYClcbiAgICB9XG4gIH0pXG59XG5cbmNvbnN0IGluaXQgPSBjb25maWcgPT4ge1xuICByb290SGFzaCA9IGNvbmZpZy5yb290XG4gIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5ib290KSkge1xuICAgIGJvb3RSZXF1ZXN0ID0gY29uZmlnLmJvb3RcbiAgfVxuICBpZiAoaXNCb29sZWFuKGNvbmZpZy51cGRhdGVIYXNoKSkge1xuICAgIHVwZGF0ZUhhc2ggPSBjb25maWcudXBkYXRlSGFzaFxuICB9XG4gIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5iZWZvcmVFYWNoUm91dGUpKSB7XG4gICAgYmVmb3JlRWFjaFJvdXRlID0gY29uZmlnLmJlZm9yZUVhY2hSb3V0ZVxuICB9XG4gIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5hZnRlckVhY2hSb3V0ZSkpIHtcbiAgICBhZnRlckVhY2hSb3V0ZSA9IGNvbmZpZy5hZnRlckVhY2hSb3V0ZVxuICB9XG4gIGlmIChjb25maWcuYm9vdENvbXBvbmVudCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdbUm91dGVyXTogQm9vdCBDb21wb25lbnQgaXMgbm93IGF2YWlsYWJsZSBhcyBhIHNwZWNpYWwgcm91dGVyOiBodHRwczovL3Jka2NlbnRyYWwuZ2l0aHViLmlvL0xpZ2h0bmluZy1TREsvIy9wbHVnaW5zL3JvdXRlci9jb25maWd1cmF0aW9uP2lkPXNwZWNpYWwtcm91dGVzJ1xuICAgIClcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnW1JvdXRlcl06IHNldHRpbmcgeyBib290Q29tcG9uZW50IH0gcHJvcGVydHkgd2lsbCBiZSBkZXByZWNhdGVkIGluIGEgZnV0dXJlIHJlbGVhc2UnXG4gICAgKVxuICAgIGlmIChpc1BhZ2UoY29uZmlnLmJvb3RDb21wb25lbnQpKSB7XG4gICAgICBjb25maWcucm91dGVzLnB1c2goe1xuICAgICAgICBwYXRoOiAnJCcsXG4gICAgICAgIGNvbXBvbmVudDogY29uZmlnLmJvb3RDb21wb25lbnQsXG4gICAgICAgIC8vIHdlIHRyeSB0byBhc3NpZ24gdGhlIGJvb3RSZXF1ZXN0IGFzIGFmdGVyIGRhdGEtcHJvdmlkZXJcbiAgICAgICAgLy8gc28gaXQgd2lsbCBiZWhhdmUgYXMgYW55IG90aGVyIGNvbXBvbmVudFxuICAgICAgICBhZnRlcjogYm9vdFJlcXVlc3QgfHwgbnVsbCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHByZXZlbnRTdG9yYWdlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgW1JvdXRlcl06ICR7Y29uZmlnLmJvb3RDb21wb25lbnR9IGlzIG5vdCBhIHZhbGlkIGJvb3QgY29tcG9uZW50YClcbiAgICB9XG4gIH1cbiAgaW5pdGlhbGlzZWQgPSB0cnVlXG59XG5cbmV4cG9ydCBjb25zdCBzdG9yZUNvbXBvbmVudCA9IChyb3V0ZSwgdHlwZSkgPT4ge1xuICBpZiAoY29tcG9uZW50cy5oYXMocm91dGUpKSB7XG4gICAgY29tcG9uZW50cy5zZXQocm91dGUsIHR5cGUpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldENvbXBvbmVudCA9IHJvdXRlID0+IHtcbiAgaWYgKGNvbXBvbmVudHMuaGFzKHJvdXRlKSkge1xuICAgIHJldHVybiBjb21wb25lbnRzLmdldChyb3V0ZSlcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuLyoqXG4gKiBUZXN0IGlmIHJvdXRlciBuZWVkcyB0byB1cGRhdGUgYnJvd3NlciBsb2NhdGlvbiBoYXNoXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IG11c3RVcGRhdGVMb2NhdGlvbkhhc2ggPSAoKSA9PiB7XG4gIGlmICghcm91dGVyQ29uZmlnIHx8ICFyb3V0ZXJDb25maWcuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIC8vIHdlIG5lZWQgc3VwcG9ydCB0byBlaXRoZXIgdHVybiBjaGFuZ2UgaGFzaCBvZmZcbiAgLy8gcGVyIHBsYXRmb3JtIG9yIHBlciBhcHBcbiAgY29uc3QgdXBkYXRlQ29uZmlnID0gcm91dGVyQ29uZmlnLmdldCgndXBkYXRlSGFzaCcpXG4gIHJldHVybiAhKChpc0Jvb2xlYW4odXBkYXRlQ29uZmlnKSAmJiAhdXBkYXRlQ29uZmlnKSB8fCAoaXNCb29sZWFuKHVwZGF0ZUhhc2gpICYmICF1cGRhdGVIYXNoKSlcbn1cblxuLyoqXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgbmV3IG5hdmlnYXRlKCkgcmVxdWVzdCBoYXMgY29tcGxldGVkXG4gKiBhbmQgaGFzIG5vdCBiZWVuIGV4cGlyZWQgZHVlIHRvIGl0J3MgYXN5bmMgbmF0dXJlXG4gKiBAcGFyYW0gcmVxdWVzdFxuICovXG5leHBvcnQgY29uc3Qgb25SZXF1ZXN0UmVzb2x2ZWQgPSByZXF1ZXN0ID0+IHtcbiAgY29uc3QgaGFzaCA9IHJlcXVlc3QuaGFzaFxuICBjb25zdCByb3V0ZSA9IHJlcXVlc3Qucm91dGVcbiAgY29uc3QgcmVnaXN0ZXIgPSByZXF1ZXN0LnJlZ2lzdGVyXG4gIGNvbnN0IHBhZ2UgPSByZXF1ZXN0LnBhZ2VcblxuICAvLyBjbGVhbiB1cCBoaXN0b3J5IGlmIG1vZGlmaWVyIGlzIHNldFxuICBpZiAoZ2V0T3B0aW9uKHJvdXRlLm9wdGlvbnMsICdjbGVhckhpc3RvcnknKSkge1xuICAgIHNldEhpc3RvcnkoW10pXG4gIH0gZWxzZSBpZiAoaGFzaCAmJiAhaXNXaWxkY2FyZC50ZXN0KHJvdXRlLnBhdGgpKSB7XG4gICAgdXBkYXRlSGlzdG9yeShyZXF1ZXN0KVxuICB9XG5cbiAgLy8gd2Ugb25seSB1cGRhdGUgdGhlIHN0YWNrTG9jYXRpb24gaWYgYSByb3V0ZVxuICAvLyBpcyBub3QgZXhwaXJlZCBiZWZvcmUgaXQgcmVzb2x2ZXNcbiAgc3RvcmVDb21wb25lbnQocm91dGUucGF0aCwgcGFnZSlcblxuICBpZiAocmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlIHx8ICFyZXF1ZXN0LmlzQ3JlYXRlZCkge1xuICAgIGVtaXQocGFnZSwgJ2NoYW5nZWQnKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QuaXNDcmVhdGVkKSB7XG4gICAgZW1pdChwYWdlLCAnbW91bnRlZCcpXG4gIH1cblxuICAvLyBvbmx5IHVwZGF0ZSB3aWRnZXRzIGlmIHdlIGhhdmUgYSBob3N0XG4gIGlmICh3aWRnZXRzSG9zdCkge1xuICAgIHVwZGF0ZVdpZGdldHMocm91dGUud2lkZ2V0cywgcGFnZSlcbiAgfVxuXG4gIC8vIHdlIHdhbnQgdG8gY2xlYW4gdXAgaWYgdGhlcmUgaXMgYW5cbiAgLy8gYWN0aXZlIHBhZ2UgdGhhdCBpcyBub3QgYmVpbmcgc2hhcmVkXG4gIC8vIGJldHdlZW4gY3VycmVudCBhbmQgcHJldmlvdXMgcm91dGVcbiAgaWYgKGdldEFjdGl2ZVBhZ2UoKSAmJiAhcmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlKSB7XG4gICAgY2xlYW5VcChhY3RpdmVQYWdlLCByZXF1ZXN0KVxuICB9XG5cbiAgLy8gcHJvdmlkZSBoaXN0b3J5IG9iamVjdCB0byBhY3RpdmUgcGFnZVxuICBpZiAocmVnaXN0ZXIuZ2V0KHN5bWJvbHMuaGlzdG9yeVN0YXRlKSAmJiBpc0Z1bmN0aW9uKHBhZ2UuaGlzdG9yeVN0YXRlKSkge1xuICAgIHBhZ2UuaGlzdG9yeVN0YXRlKHJlZ2lzdGVyLmdldChzeW1ib2xzLmhpc3RvcnlTdGF0ZSkpXG4gIH1cblxuICBzZXRBY3RpdmVQYWdlKHBhZ2UpXG5cbiAgYWN0aXZlSGFzaCA9IHJlcXVlc3QuaGFzaFxuICBhY3RpdmVSb3V0ZSA9IHJvdXRlLnBhdGhcblxuICAvLyBjbGVhbnVwIGFsbCBjYW5jZWxsZWQgcmVxdWVzdHNcbiAgZm9yIChsZXQgcmVxdWVzdCBvZiBuYXZpZ2F0ZVF1ZXVlLnZhbHVlcygpKSB7XG4gICAgaWYgKHJlcXVlc3QuaXNDYW5jZWxsZWQgJiYgcmVxdWVzdC5oYXNoKSB7XG4gICAgICBuYXZpZ2F0ZVF1ZXVlLmRlbGV0ZShyZXF1ZXN0Lmhhc2gpXG4gICAgfVxuICB9XG5cbiAgYWZ0ZXJFYWNoUm91dGUocmVxdWVzdClcblxuICBMb2cuaW5mbygnW3JvdXRlXTonLCByb3V0ZS5wYXRoKVxuICBMb2cuaW5mbygnW2hhc2hdOicsIGhhc2gpXG59XG5cbmNvbnN0IGNsZWFuVXAgPSAocGFnZSwgcmVxdWVzdCkgPT4ge1xuICBjb25zdCByb3V0ZSA9IGFjdGl2ZVJvdXRlXG4gIGNvbnN0IHJlZ2lzdGVyID0gcmVxdWVzdC5yZWdpc3RlclxuICBjb25zdCBsYXp5RGVzdHJveSA9IHJvdXRlckNvbmZpZy5nZXQoJ2xhenlEZXN0cm95JylcbiAgY29uc3QgZGVzdHJveU9uQmFjayA9IHJvdXRlckNvbmZpZy5nZXQoJ2Rlc3Ryb3lPbkhpc3RvcnlCYWNrJylcbiAgY29uc3Qga2VlcEFsaXZlID0gcmVnaXN0ZXIuZ2V0KCdrZWVwQWxpdmUnKVxuICBjb25zdCBpc0Zyb21IaXN0b3J5ID0gcmVnaXN0ZXIuZ2V0KHN5bWJvbHMuYmFja3RyYWNrKVxuXG4gIGxldCBkb0NsZWFudXAgPSBmYWxzZVxuXG4gIC8vIGlmIHRoaXMgcmVxdWVzdCBpcyBleGVjdXRlZCBkdWUgdG8gYSBzdGVwIGJhY2sgaW4gaGlzdG9yeVxuICAvLyBhbmQgd2UgaGF2ZSBjb25maWd1cmVkIHRvIGRlc3Ryb3kgYWN0aXZlIHBhZ2Ugd2hlbiB3ZSBnbyBiYWNrXG4gIC8vIGluIGhpc3Rvcnkgb3IgbGF6eURlc3RvcnkgaXMgZW5hYmxlZFxuICBpZiAoaXNGcm9tSGlzdG9yeSAmJiAoZGVzdHJveU9uQmFjayB8fCBsYXp5RGVzdHJveSkpIHtcbiAgICBkb0NsZWFudXAgPSB0cnVlXG4gIH1cblxuICAvLyBjbGVhbiB1cCBpZiBsYXp5RGVzdHJveSBpcyBlbmFibGVkIGFuZCB0aGUga2VlcEFsaXZlIGZsYWdcbiAgLy8gaW4gbmF2aWdhdGlvbiByZWdpc3RlciBpcyBmYWxzZVxuICBpZiAobGF6eURlc3Ryb3kgJiYgIWtlZXBBbGl2ZSkge1xuICAgIGRvQ2xlYW51cCA9IHRydWVcbiAgfVxuXG4gIC8vIGlmIHRoZSBjdXJyZW50IGFuZCBuZXcgcmVxdWVzdCBzaGFyZSB0aGUgc2FtZSByb3V0ZSBibHVlcHJpbnRcbiAgaWYgKGFjdGl2ZVJvdXRlID09PSByZXF1ZXN0LnJvdXRlLnBhdGgpIHtcbiAgICBkb0NsZWFudXAgPSB0cnVlXG4gIH1cblxuICBpZiAoZG9DbGVhbnVwKSB7XG4gICAgLy8gZ3JhYiBvcmlnaW5hbCBjbGFzcyBjb25zdHJ1Y3RvciBpZlxuICAgIC8vIHN0YXRlbWFjaGluZSByb3V0ZWQgZWxzZSBzdG9yZSBjb25zdHJ1Y3RvclxuICAgIHN0b3JlQ29tcG9uZW50KHJvdXRlLCBwYWdlLl9yb3V0ZWRUeXBlIHx8IHBhZ2UuY29uc3RydWN0b3IpXG5cbiAgICAvLyBhY3R1YWwgcmVtb3ZlIG9mIHBhZ2UgZnJvbSBtZW1vcnlcbiAgICBwYWdlc0hvc3QucmVtb3ZlKHBhZ2UpXG5cbiAgICAvLyBmb3JjZSB0ZXh0dXJlIGdjKCkgaWYgY29uZmlndXJlZFxuICAgIC8vIHNvIHdlIGNhbiBjbGVhbnVwIHRleHR1cmVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICBpZiAocm91dGVyQ29uZmlnLmdldCgnZ2NPblVubG9hZCcpKSB7XG4gICAgICBzdGFnZS5nYygpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlJ3JlIG5vdCByZW1vdmluZyB0aGUgcGFnZSB3ZSBuZWVkIHRvXG4gICAgLy8gcmVzZXQgaXQncyBwcm9wZXJ0aWVzXG4gICAgcGFnZS5wYXRjaCh7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHNjYWxlOiAxLFxuICAgICAgYWxwaGE6IDEsXG4gICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRBY3RpdmVIYXNoID0gKCkgPT4ge1xuICByZXR1cm4gYWN0aXZlSGFzaFxufVxuXG5leHBvcnQgY29uc3Qgc2V0QWN0aXZlSGFzaCA9IGhhc2ggPT4ge1xuICBhY3RpdmVIYXNoID0gaGFzaFxufVxuXG5leHBvcnQgY29uc3Qgc2V0QWN0aXZlUGFnZSA9IHBhZ2UgPT4ge1xuICBhY3RpdmVQYWdlID0gcGFnZVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZlUGFnZSA9ICgpID0+IHtcbiAgcmV0dXJuIGFjdGl2ZVBhZ2Vcbn1cblxuZXhwb3J0IGNvbnN0IGdldEFjdGl2ZVJvdXRlID0gKCkgPT4ge1xuICByZXR1cm4gYWN0aXZlUm91dGVcbn1cblxuZXhwb3J0IGNvbnN0IGdldExhc3RIYXNoID0gKCkgPT4ge1xuICByZXR1cm4gbGFzdEFjY2VwdGVkSGFzaFxufVxuXG5leHBvcnQgY29uc3Qgc2V0TGFzdEhhc2ggPSBoYXNoID0+IHtcbiAgbGFzdEFjY2VwdGVkSGFzaCA9IGhhc2hcbn1cblxuZXhwb3J0IGNvbnN0IHNldFByZXZpb3VzU3RhdGUgPSBzdGF0ZSA9PiB7XG4gIHByZXZpb3VzU3RhdGUgPSBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3QgZ2V0UHJldmlvdXNTdGF0ZSA9ICgpID0+IHtcbiAgcmV0dXJuIHByZXZpb3VzU3RhdGVcbn1cblxuZXhwb3J0IGNvbnN0IHJvdXRlRXhpc3RzID0ga2V5ID0+IHtcbiAgcmV0dXJuIHJvdXRlcy5oYXMoa2V5KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Um9vdEhhc2ggPSAoKSA9PiB7XG4gIHJldHVybiByb290SGFzaFxufVxuXG5leHBvcnQgY29uc3QgZ2V0Qm9vdFJlcXVlc3QgPSAoKSA9PiB7XG4gIHJldHVybiBib290UmVxdWVzdFxufVxuXG5leHBvcnQgY29uc3QgZ2V0Um91dGVyQ29uZmlnID0gKCkgPT4ge1xuICByZXR1cm4gcm91dGVyQ29uZmlnXG59XG5cbmV4cG9ydCBjb25zdCBnZXRSb3V0ZXMgPSAoKSA9PiB7XG4gIHJldHVybiByb3V0ZXNcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGdldFJvdXRlckNvbmZpZyB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgaXNQcm9taXNlLCBpc1N0cmluZyB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCBUcmFuc2l0aW9ucyBmcm9tICcuLi90cmFuc2l0aW9ucydcblxuLyoqXG4gKiBleGVjdXRlIHRyYW5zaXRpb24gYmV0d2VlbiBuZXcgLyBvbGQgcGFnZSBhbmRcbiAqIHRvZ2dsZSB0aGUgZGVmaW5lZCB3aWRnZXRzXG4gKiBAdG9kbzogcGxhdGZvcm0gb3ZlcnJpZGUgZGVmYXVsdCB0cmFuc2l0aW9uXG4gKiBAcGFyYW0gcGFnZUluXG4gKiBAcGFyYW0gcGFnZU91dFxuICovXG5leHBvcnQgY29uc3QgZXhlY3V0ZVRyYW5zaXRpb24gPSAocGFnZUluLCBwYWdlT3V0ID0gbnVsbCkgPT4ge1xuICBjb25zdCB0cmFuc2l0aW9uID0gcGFnZUluLnBhZ2VUcmFuc2l0aW9uIHx8IHBhZ2VJbi5lYXNpbmdcbiAgY29uc3QgaGFzQ3VzdG9tVHJhbnNpdGlvbnMgPSAhIShwYWdlSW4uc21vb3RoSW4gfHwgcGFnZUluLnNtb290aEluT3V0IHx8IHRyYW5zaXRpb24pXG4gIGNvbnN0IHRyYW5zaXRpb25zRGlzYWJsZWQgPSBnZXRSb3V0ZXJDb25maWcoKS5nZXQoJ2Rpc2FibGVUcmFuc2l0aW9ucycpXG5cbiAgaWYgKHBhZ2VJbi5lYXNpbmcpIHtcbiAgICBjb25zb2xlLndhcm4oJ2Vhc2luZygpIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQuIFVzZSBwYWdlVHJhbnNpdGlvbigpJylcbiAgfVxuXG4gIC8vIGRlZmF1bHQgYmVoYXZpb3VyIGlzIGEgdmlzaWJpbGl0eSB0b2dnbGVcbiAgaWYgKCFoYXNDdXN0b21UcmFuc2l0aW9ucyB8fCB0cmFuc2l0aW9uc0Rpc2FibGVkKSB7XG4gICAgcGFnZUluLnZpc2libGUgPSB0cnVlXG4gICAgaWYgKHBhZ2VPdXQpIHtcbiAgICAgIHBhZ2VPdXQudmlzaWJsZSA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICBsZXQgdHlwZVxuICAgIHRyeSB7XG4gICAgICB0eXBlID0gdHJhbnNpdGlvbi5jYWxsKHBhZ2VJbiwgcGFnZUluLCBwYWdlT3V0KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHR5cGUgPSAnY3Jvc3NGYWRlJ1xuICAgIH1cblxuICAgIGlmIChpc1Byb21pc2UodHlwZSkpIHtcbiAgICAgIHJldHVybiB0eXBlXG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKHR5cGUpKSB7XG4gICAgICBjb25zdCBmbiA9IFRyYW5zaXRpb25zW3R5cGVdXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKHBhZ2VJbiwgcGFnZU91dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBrZWVwIGJhY2t3YXJkcyBjb21wYXRpYmxlIGZvciBub3dcbiAgICBpZiAocGFnZUluLnNtb290aEluKSB7XG4gICAgICAvLyBwcm92aWRlIGEgc21vb3RoIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgaXRzZWxmXG4gICAgICAvLyBvbiB0cmFuc2l0aW9uIGZpbmlzaFxuICAgICAgY29uc3Qgc21vb3RoID0gKHAsIHYsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgcGFnZUluLnZpc2libGUgPSB0cnVlXG4gICAgICAgICAgcGFnZUluLnNldFNtb290aChwLCB2LCBhcmdzKVxuICAgICAgICAgIHBhZ2VJbi50cmFuc2l0aW9uKHApLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VJbi5zbW9vdGhJbih7IHBhZ2VJbiwgc21vb3RoIH0pXG4gICAgfVxuICB9XG4gIHJldHVybiBUcmFuc2l0aW9ucy5jcm9zc0ZhZGUocGFnZUluLCBwYWdlT3V0KVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXBwLCB3aWRnZXRzSG9zdCB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgdWNmaXJzdCB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCBlbWl0IGZyb20gJy4vZW1pdCdcblxubGV0IGFjdGl2ZVdpZGdldCA9IG51bGxcblxuZXhwb3J0IGNvbnN0IGdldFJlZmVyZW5jZXMgPSAoKSA9PiB7XG4gIGlmICghd2lkZ2V0c0hvc3QpIHtcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gd2lkZ2V0c0hvc3QuZ2V0KCkucmVkdWNlKChzdG9yYWdlLCB3aWRnZXQpID0+IHtcbiAgICBjb25zdCBrZXkgPSB3aWRnZXQucmVmLnRvTG93ZXJDYXNlKClcbiAgICBzdG9yYWdlW2tleV0gPSB3aWRnZXRcbiAgICByZXR1cm4gc3RvcmFnZVxuICB9LCB7fSlcbn1cblxuLyoqXG4gKiB1cGRhdGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGF2YWlsYWJsZSB3aWRnZXRzXG4gKiBmb3IgdGhlIGN1cnJlbnQgcGFnZSAvIHJvdXRlXG4gKiBAcGFyYW0gcGFnZVxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlV2lkZ2V0cyA9ICh3aWRnZXRzLCBwYWdlKSA9PiB7XG4gIC8vIGZvcmNlIGxvd2VyY2FzZSBsb29rdXBcbiAgY29uc3QgY29uZmlndXJlZCA9ICh3aWRnZXRzIHx8IFtdKS5tYXAocmVmID0+IHJlZi50b0xvd2VyQ2FzZSgpKVxuXG4gIHdpZGdldHNIb3N0LmZvckVhY2god2lkZ2V0ID0+IHtcbiAgICB3aWRnZXQudmlzaWJsZSA9IGNvbmZpZ3VyZWQuaW5kZXhPZih3aWRnZXQucmVmLnRvTG93ZXJDYXNlKCkpICE9PSAtMVxuICAgIGlmICh3aWRnZXQudmlzaWJsZSkge1xuICAgICAgZW1pdCh3aWRnZXQsIFsnYWN0aXZhdGVkJ10sIHBhZ2UpXG4gICAgfVxuICB9KVxuICBpZiAoYXBwLnN0YXRlID09PSAnV2lkZ2V0cycgJiYgYWN0aXZlV2lkZ2V0ICYmICFhY3RpdmVXaWRnZXQudmlzaWJsZSkge1xuICAgIGFwcC5fc2V0U3RhdGUoJycpXG4gIH1cbn1cblxuY29uc3QgZ2V0V2lkZ2V0QnlOYW1lID0gbmFtZSA9PiB7XG4gIG5hbWUgPSB1Y2ZpcnN0KG5hbWUpXG4gIHJldHVybiB3aWRnZXRzSG9zdC5nZXRCeVJlZihuYW1lKSB8fCBmYWxzZVxufVxuXG4vKipcbiAqIGRlbGVnYXRlIGFwcCBmb2N1cyB0byBhIG9uLXNjcmVlbiB3aWRnZXRcbiAqIEBwYXJhbSBuYW1lIC0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGZvY3VzV2lkZ2V0ID0gbmFtZSA9PiB7XG4gIGNvbnN0IHdpZGdldCA9IGdldFdpZGdldEJ5TmFtZShuYW1lKVxuICBpZiAod2lkZ2V0KSB7XG4gICAgc2V0QWN0aXZlV2lkZ2V0KHdpZGdldClcblxuICAgIC8vIGlmIGFwcCBpcyBhbHJlYWR5IGluICdXaWRnZXRzJyBzdGF0ZSB3ZSBjYW4gYXNzdW1lIHRoYXRcbiAgICAvLyBmb2N1cyBoYXMgYmVlbiBkZWxlZ2F0ZWQgZnJvbSBvbmUgd2lkZ2V0IHRvIGFub3RoZXIgc29cbiAgICAvLyB3ZSBuZWVkIHRvIHNldCB0aGUgbmV3IHdpZGdldCByZWZlcmVuY2UgYW5kIHRyaWdnZXIgYVxuICAgIC8vIG5ldyBmb2N1cyBjYWxjdWxhdGlvbiBvZiBMaWdodG5pbmcncyBmb2N1c3BhdGhcbiAgICBpZiAoYXBwLnN0YXRlID09PSAnV2lkZ2V0cycpIHtcbiAgICAgIGFwcC5yZWxvYWQoYWN0aXZlV2lkZ2V0KVxuICAgIH0gZWxzZSB7XG4gICAgICBhcHAuX3NldFN0YXRlKCdXaWRnZXRzJywgW2FjdGl2ZVdpZGdldF0pXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVSZW1vdGUgPSAodHlwZSwgbmFtZSkgPT4ge1xuICBpZiAodHlwZSA9PT0gJ3dpZGdldCcpIHtcbiAgICBmb2N1c1dpZGdldChuYW1lKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdwYWdlJykge1xuICAgIHJlc3RvcmVGb2N1cygpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlc3RvcmVGb2N1cyA9ICgpID0+IHtcbiAgYWN0aXZlV2lkZ2V0ID0gbnVsbFxuICBhcHAuX3NldFN0YXRlKCcnKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZlV2lkZ2V0ID0gKCkgPT4ge1xuICByZXR1cm4gYWN0aXZlV2lkZ2V0XG59XG5cbmV4cG9ydCBjb25zdCBzZXRBY3RpdmVXaWRnZXQgPSBpbnN0YW5jZSA9PiB7XG4gIGFjdGl2ZVdpZGdldCA9IGluc3RhbmNlXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBzZXR0aW5ncyA9IHt9XG5jb25zdCBzdWJzY3JpYmVycyA9IHt9XG5cbmV4cG9ydCBjb25zdCBpbml0U2V0dGluZ3MgPSAoYXBwU2V0dGluZ3MsIHBsYXRmb3JtU2V0dGluZ3MpID0+IHtcbiAgc2V0dGluZ3NbJ2FwcCddID0gYXBwU2V0dGluZ3NcbiAgc2V0dGluZ3NbJ3BsYXRmb3JtJ10gPSBwbGF0Zm9ybVNldHRpbmdzXG4gIHNldHRpbmdzWyd1c2VyJ10gPSB7fVxufVxuXG5jb25zdCBwdWJsaXNoID0gKGtleSwgdmFsdWUpID0+IHtcbiAgc3Vic2NyaWJlcnNba2V5XSAmJiBzdWJzY3JpYmVyc1trZXldLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKHZhbHVlKSlcbn1cblxuY29uc3QgZG90R3JhYiA9IChvYmogPSB7fSwga2V5KSA9PiB7XG4gIGlmIChvYmogPT09IG51bGwpIHJldHVybiB1bmRlZmluZWRcbiAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9iaiA9IG9ialtrZXlzW2ldXSA9IG9ialtrZXlzW2ldXSAhPT0gdW5kZWZpbmVkID8gb2JqW2tleXNbaV1dIDoge31cbiAgfVxuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsID8gKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID8gb2JqIDogdW5kZWZpbmVkKSA6IG9ialxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldCh0eXBlLCBrZXksIGZhbGxiYWNrID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgdmFsID0gZG90R3JhYihzZXR0aW5nc1t0eXBlXSwga2V5KVxuICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IGZhbGxiYWNrXG4gIH0sXG4gIGhhcyh0eXBlLCBrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldCh0eXBlLCBrZXkpXG4gIH0sXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgc2V0dGluZ3NbJ3VzZXInXVtrZXldID0gdmFsdWVcbiAgICBwdWJsaXNoKGtleSwgdmFsdWUpXG4gIH0sXG4gIHN1YnNjcmliZShrZXksIGNhbGxiYWNrKSB7XG4gICAgc3Vic2NyaWJlcnNba2V5XSA9IHN1YnNjcmliZXJzW2tleV0gfHwgW11cbiAgICBzdWJzY3JpYmVyc1trZXldLnB1c2goY2FsbGJhY2spXG4gIH0sXG4gIHVuc3Vic2NyaWJlKGtleSwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gc3Vic2NyaWJlcnNba2V5XSAmJiBzdWJzY3JpYmVyc1trZXldLmZpbmRJbmRleChjYiA9PiBjYiA9PT0gY2FsbGJhY2spXG4gICAgICBpbmRleCA+IC0xICYmIHN1YnNjcmliZXJzW2tleV0uc3BsaWNlKGluZGV4LCAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5IGluIHN1YnNjcmliZXJzKSB7XG4gICAgICAgIHN1YnNjcmliZXJzW2tleV0gPSBbXVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2xlYXJTdWJzY3JpYmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdWJzY3JpYmVycykpIHtcbiAgICAgIGRlbGV0ZSBzdWJzY3JpYmVyc1trZXldXG4gICAgfVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuaW1wb3J0IGxvY2FsQ29va2llIGZyb20gJ2xvY2FsQ29va2llL21vZHVsZS9sb2NhbENvb2tpZS5qcydcblxubGV0IG5hbWVzcGFjZVxubGV0IGxjXG5cbmV4cG9ydCBjb25zdCBpbml0U3RvcmFnZSA9ICgpID0+IHtcbiAgbmFtZXNwYWNlID0gU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdpZCcpXG4gIC8vIHRvZG86IHBhc3Mgb3B0aW9ucyAoZm9yIGV4YW1wbGUgdG8gZm9yY2UgdGhlIHVzZSBvZiBjb29raWVzKVxuICBsYyA9IG5ldyBsb2NhbENvb2tpZSgpXG59XG5cbmNvbnN0IG5hbWVzcGFjZWRLZXkgPSBrZXkgPT4gKG5hbWVzcGFjZSA/IFtuYW1lc3BhY2UsIGtleV0uam9pbignLicpIDoga2V5KVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldChrZXkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UobGMuZ2V0SXRlbShuYW1lc3BhY2VkS2V5KGtleSkpKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9LFxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBsYy5zZXRJdGVtKG5hbWVzcGFjZWRLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJlbW92ZShrZXkpIHtcbiAgICBsYy5yZW1vdmVJdGVtKG5hbWVzcGFjZWRLZXkoa2V5KSlcbiAgfSxcbiAgY2xlYXIoKSB7XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgbGMua2V5cygpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBpdGVtIGlmIGluIHRoZSBuYW1lc3BhY2VcbiAgICAgICAga2V5LmluZGV4T2YobmFtZXNwYWNlICsgJy4nKSA9PT0gMCA/IGxjLnJlbW92ZUl0ZW0oa2V5KSA6IG51bGxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxjLmNsZWFyKClcbiAgICB9XG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5cbmNvbnN0IGRlZmF1bHRDaGFubmVscyA9IFtcbiAge1xuICAgIG51bWJlcjogMSxcbiAgICBuYW1lOiAnTWV0cm8gTmV3cyAxJyxcbiAgICBkZXNjcmlwdGlvbjogJ05ldyBZb3JrIENhYmxlIE5ld3MgQ2hhbm5lbCcsXG4gICAgZW50aXRsZWQ6IHRydWUsXG4gICAgcHJvZ3JhbToge1xuICAgICAgdGl0bGU6ICdUaGUgTW9ybmluZyBTaG93JyxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk5ldyBZb3JrJ3MgYmVzdCBtb3JuaW5nIHNob3dcIixcbiAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUobmV3IERhdGUoKSAtIDYwICogNSAqIDEwMDApLnRvVVRDU3RyaW5nKCksIC8vIHN0YXJ0ZWQgNSBtaW51dGVzIGFnb1xuICAgICAgZHVyYXRpb246IDYwICogMzAsIC8vIDMwIG1pbnV0ZXNcbiAgICAgIGFnZVJhdGluZzogMCxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgbnVtYmVyOiAyLFxuICAgIG5hbWU6ICdNVFYnLFxuICAgIGRlc2NyaXB0aW9uOiAnTXVzaWMgVGVsZXZpc2lvbicsXG4gICAgZW50aXRsZWQ6IHRydWUsXG4gICAgcHJvZ3JhbToge1xuICAgICAgdGl0bGU6ICdCZWF2aXMgYW5kIEJ1dHRoZWFkJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQW1lcmljYW4gYWR1bHQgYW5pbWF0ZWQgc2l0Y29tIGNyZWF0ZWQgYnkgTWlrZSBKdWRnZScsXG4gICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKG5ldyBEYXRlKCkgLSA2MCAqIDIwICogMTAwMCkudG9VVENTdHJpbmcoKSwgLy8gc3RhcnRlZCAyMCBtaW51dGVzIGFnb1xuICAgICAgZHVyYXRpb246IDYwICogNDUsIC8vIDQ1IG1pbnV0ZXNcbiAgICAgIGFnZVJhdGluZzogMTgsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIG51bWJlcjogMyxcbiAgICBuYW1lOiAnTkJDJyxcbiAgICBkZXNjcmlwdGlvbjogJ05CQyBUViBOZXR3b3JrJyxcbiAgICBlbnRpdGxlZDogZmFsc2UsXG4gICAgcHJvZ3JhbToge1xuICAgICAgdGl0bGU6ICdUaGUgVG9uaWdodCBTaG93IFN0YXJyaW5nIEppbW15IEZhbGxvbicsXG4gICAgICBkZXNjcmlwdGlvbjogJ0xhdGUtbmlnaHQgdGFsayBzaG93IGhvc3RlZCBieSBKaW1teSBGYWxsb24gb24gTkJDJyxcbiAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUobmV3IERhdGUoKSAtIDYwICogMTAgKiAxMDAwKS50b1VUQ1N0cmluZygpLCAvLyBzdGFydGVkIDEwIG1pbnV0ZXMgYWdvXG4gICAgICBkdXJhdGlvbjogNjAgKiA2MCwgLy8gMSBob3VyXG4gICAgICBhZ2VSYXRpbmc6IDEwLFxuICAgIH0sXG4gIH0sXG5dXG5cbmV4cG9ydCBjb25zdCBjaGFubmVscyA9ICgpID0+IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAndHYnLCBkZWZhdWx0Q2hhbm5lbHMpXG5cbmV4cG9ydCBjb25zdCByYW5kb21DaGFubmVsID0gKCkgPT4gY2hhbm5lbHMoKVt+fihjaGFubmVscy5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKV1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMb2cgZnJvbSAnLi4vTG9nJ1xuXG5pbXBvcnQgeyBjaGFubmVscywgcmFuZG9tQ2hhbm5lbCB9IGZyb20gJy4vZGVmYXVsdHMnXG5cbmxldCBjdXJyZW50Q2hhbm5lbFxuY29uc3QgY2FsbGJhY2tzID0ge31cblxuY29uc3QgZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICBjYWxsYmFja3NbZXZlbnRdICYmXG4gICAgY2FsbGJhY2tzW2V2ZW50XS5mb3JFYWNoKGNiID0+IHtcbiAgICAgIGNiLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgfSlcbn1cblxuLy8gbG9jYWwgbW9jayBtZXRob2RzXG5sZXQgbWV0aG9kcyA9IHtcbiAgZ2V0Q2hhbm5lbCgpIHtcbiAgICBpZiAoIWN1cnJlbnRDaGFubmVsKSBjdXJyZW50Q2hhbm5lbCA9IHJhbmRvbUNoYW5uZWwoKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoY3VycmVudENoYW5uZWwpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHsgLi4uY3VycmVudENoYW5uZWwgfVxuICAgICAgICBkZWxldGUgY2hhbm5lbC5wcm9ncmFtXG4gICAgICAgIHJlc29sdmUoY2hhbm5lbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdCgnTm8gY2hhbm5lbCBmb3VuZCcpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgZ2V0UHJvZ3JhbSgpIHtcbiAgICBpZiAoIWN1cnJlbnRDaGFubmVsKSBjdXJyZW50Q2hhbm5lbCA9IHJhbmRvbUNoYW5uZWwoKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjdXJyZW50Q2hhbm5lbC5wcm9ncmFtID8gcmVzb2x2ZShjdXJyZW50Q2hhbm5lbC5wcm9ncmFtKSA6IHJlamVjdCgnTm8gcHJvZ3JhbSBmb3VuZCcpXG4gICAgfSlcbiAgfSxcbiAgc2V0Q2hhbm5lbChudW1iZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKG51bWJlcikge1xuICAgICAgICBjb25zdCBuZXdDaGFubmVsID0gY2hhbm5lbHMoKS5maW5kKGMgPT4gYy5udW1iZXIgPT09IG51bWJlcilcbiAgICAgICAgaWYgKG5ld0NoYW5uZWwpIHtcbiAgICAgICAgICBjdXJyZW50Q2hhbm5lbCA9IG5ld0NoYW5uZWxcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0geyAuLi5jdXJyZW50Q2hhbm5lbCB9XG4gICAgICAgICAgZGVsZXRlIGNoYW5uZWwucHJvZ3JhbVxuICAgICAgICAgIGVtaXQoJ2NoYW5uZWxDaGFuZ2UnLCBjaGFubmVsKVxuICAgICAgICAgIHJlc29sdmUoY2hhbm5lbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ0NoYW5uZWwgbm90IGZvdW5kJylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KCdObyBjaGFubmVsIG51bWJlciBzdXBwbGllZCcpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRUViA9IGNvbmZpZyA9PiB7XG4gIG1ldGhvZHMgPSB7fVxuICBpZiAoY29uZmlnLmdldENoYW5uZWwgJiYgdHlwZW9mIGNvbmZpZy5nZXRDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWV0aG9kcy5nZXRDaGFubmVsID0gY29uZmlnLmdldENoYW5uZWxcbiAgfVxuICBpZiAoY29uZmlnLmdldFByb2dyYW0gJiYgdHlwZW9mIGNvbmZpZy5nZXRQcm9ncmFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWV0aG9kcy5nZXRQcm9ncmFtID0gY29uZmlnLmdldFByb2dyYW1cbiAgfVxuICBpZiAoY29uZmlnLnNldENoYW5uZWwgJiYgdHlwZW9mIGNvbmZpZy5zZXRDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWV0aG9kcy5zZXRDaGFubmVsID0gY29uZmlnLnNldENoYW5uZWxcbiAgfVxuICBpZiAoY29uZmlnLmVtaXQgJiYgdHlwZW9mIGNvbmZpZy5lbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uZmlnLmVtaXQoZW1pdClcbiAgfVxufVxuXG4vLyBwdWJsaWMgQVBJXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNoYW5uZWwobnVtYmVyID0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBjYWxsIHNldENoYW5uZWwgd2hlbiBudW1iZXIgYXJndW1lbnQgaXMgcGFzc2VkLCBvdGhlcndpc2UgZ2V0Q2hhbm5lbFxuICAgICAgICBtZXRob2RzW251bWJlciA/ICdzZXRDaGFubmVsJyA6ICdnZXRDaGFubmVsJ10obnVtYmVyKVxuICAgICAgICAgIC50aGVuKGNoYW5uZWwgPT4ge1xuICAgICAgICAgICAgLy8gdG8gZG86IGVuc3VyZSBjb25zaXN0ZW50IGZvcm1hdHRpbmcgb2YgY2hhbm5lbCBpbmZvIGhlcmU/XG4gICAgICAgICAgICByZXNvbHZlKGNoYW5uZWwpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBwcm9ncmFtKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBtZXRob2RzXG4gICAgICAgICAgLmdldFByb2dyYW0oKVxuICAgICAgICAgIC50aGVuKHByb2dyYW0gPT4ge1xuICAgICAgICAgICAgLy8gdG8gZG86IGVuc3VyZSBjb25zaXN0ZW50IGZvcm1hdHRpbmcgb2YgcHJvZ3JhbSBpbmZvIGhlcmU/XG4gICAgICAgICAgICByZXNvbHZlKHByb2dyYW0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBlbnRpdGxlZCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWV0aG9kc1xuICAgICAgICAgIC5nZXRDaGFubmVsKClcbiAgICAgICAgICAudGhlbihjaGFubmVsID0+IHtcbiAgICAgICAgICAgICdlbnRpdGxlZCcgaW4gY2hhbm5lbCA/IHJlc29sdmUoISFjaGFubmVsLmVudGl0bGVkKSA6IHJlamVjdCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYikge1xuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrc1tldmVudF0gPSBjYWxsYmFja3NbZXZlbnRdIHx8IFtdXG4gICAgICBjYWxsYmFja3NbZXZlbnRdLnB1c2goY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIExvZy5lcnJvcignUGxlYXNlIHByb3ZpZGUgYSBmdW5jdGlvbiBhcyBhIGNhbGxiYWNrJylcbiAgICB9XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiID0gZmFsc2UpIHtcbiAgICBpZiAoY2FsbGJhY2tzW2V2ZW50XSAmJiBjYWxsYmFja3NbZXZlbnRdLmxlbmd0aCkge1xuICAgICAgY2FsbGJhY2tzW2V2ZW50XSA9IGNiID8gY2FsbGJhY2tzW2V2ZW50XS5maWx0ZXIoX2NiID0+IF9jYiA9PT0gY2IpIDogW11cbiAgICB9XG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5sZXQgYmFzZVBhdGhcbmxldCBwcm94eVVybFxuXG5leHBvcnQgY29uc3QgaW5pdFV0aWxzID0gY29uZmlnID0+IHtcbiAgYmFzZVBhdGggPSBlbnN1cmVVcmxXaXRoUHJvdG9jb2wobWFrZUZ1bGxTdGF0aWNQYXRoKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSwgY29uZmlnLnBhdGggfHwgJy8nKSlcblxuICBpZiAoY29uZmlnLnByb3h5VXJsKSB7XG4gICAgcHJveHlVcmwgPSBlbnN1cmVVcmxXaXRoUHJvdG9jb2woY29uZmlnLnByb3h5VXJsKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXQocmVsUGF0aCkge1xuICAgIHJldHVybiBiYXNlUGF0aCArIHJlbFBhdGhcbiAgfSxcbiAgcHJveHlVcmwodXJsLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gcHJveHlVcmwgPyBwcm94eVVybCArICc/JyArIG1ha2VRdWVyeVN0cmluZyh1cmwsIG9wdGlvbnMpIDogdXJsXG4gIH0sXG4gIG1ha2VRdWVyeVN0cmluZygpIHtcbiAgICByZXR1cm4gbWFrZVF1ZXJ5U3RyaW5nKC4uLmFyZ3VtZW50cylcbiAgfSxcbiAgLy8gc2luY2UgaW1hZ2V3b3JrZXJzIGRvbid0IHdvcmsgd2l0aG91dCBwcm90b2NvbFxuICBlbnN1cmVVcmxXaXRoUHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIGVuc3VyZVVybFdpdGhQcm90b2NvbCguLi5hcmd1bWVudHMpXG4gIH0sXG59XG5cbmV4cG9ydCBjb25zdCBlbnN1cmVVcmxXaXRoUHJvdG9jb2wgPSB1cmwgPT4ge1xuICBpZiAoL15cXC9cXC8vLnRlc3QodXJsKSkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyB1cmxcbiAgfVxuICBpZiAoIS9eKD86aHR0cHM/OikvaS50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHVybFxuICB9XG4gIHJldHVybiB1cmxcbn1cblxuZXhwb3J0IGNvbnN0IG1ha2VGdWxsU3RhdGljUGF0aCA9IChwYXRobmFtZSA9ICcvJywgcGF0aCkgPT4ge1xuICAvLyBlbnN1cmUgcGF0aCBoYXMgdHJhbGluZyBzbGFzaFxuICBwYXRoID0gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nID8gcGF0aCArICcvJyA6IHBhdGhcblxuICAvLyBpZiBwYXRoIGlzIFVSTCwgd2UgYXNzdW1lIGl0J3MgYWxyZWFkeSB0aGUgZnVsbCBzdGF0aWMgcGF0aCwgc28gd2UganVzdCByZXR1cm4gaXRcbiAgaWYgKC9eKD86aHR0cHM/Oik/KD86XFwvXFwvKS8udGVzdChwYXRoKSkge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiBwYXRoXG4gIH0gZWxzZSB7XG4gICAgLy8gY2xlYW51cCB0aGUgcGF0aG5hbWUgKGkuZS4gcmVtb3ZlIHBvc3NpYmxlIGluZGV4Lmh0bWwpXG4gICAgcGF0aG5hbWUgPSBjbGVhblVwUGF0aE5hbWUocGF0aG5hbWUpXG5cbiAgICAvLyByZW1vdmUgcG9zc2libGUgbGVhZGluZyBkb3QgZnJvbSBwYXRoXG4gICAgcGF0aCA9IHBhdGguY2hhckF0KDApID09PSAnLicgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGhcbiAgICAvLyBlbnN1cmUgcGF0aCBoYXMgbGVhZGluZyBzbGFzaFxuICAgIHBhdGggPSBwYXRoLmNoYXJBdCgwKSAhPT0gJy8nID8gJy8nICsgcGF0aCA6IHBhdGhcbiAgICByZXR1cm4gcGF0aG5hbWUgKyBwYXRoXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFuVXBQYXRoTmFtZSA9IHBhdGhuYW1lID0+IHtcbiAgaWYgKHBhdGhuYW1lLnNsaWNlKC0xKSA9PT0gJy8nKSByZXR1cm4gcGF0aG5hbWUuc2xpY2UoMCwgLTEpXG4gIGNvbnN0IHBhcnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKVxuICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0uaW5kZXhPZignLicpID4gLTEpIHBhcnRzLnBvcCgpXG4gIHJldHVybiBwYXJ0cy5qb2luKCcvJylcbn1cblxuY29uc3QgbWFrZVF1ZXJ5U3RyaW5nID0gKHVybCwgb3B0aW9ucyA9IHt9LCB0eXBlID0gJ3VybCcpID0+IHtcbiAgLy8gYWRkIG9wZXJhdG9yIGFzIGFuIG9wdGlvblxuICBvcHRpb25zLm9wZXJhdG9yID0gJ21ldHJvbG9naWNhbCcgLy8gVG9kbzogbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZSAodmlhIHVybD8pXG4gIC8vIGFkZCB0eXBlICg9IHVybCBvciBxcikgYXMgYW4gb3B0aW9uLCB3aXRoIHVybCBhcyB0aGUgdmFsdWVcbiAgb3B0aW9uc1t0eXBlXSA9IHVybFxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgIC5tYXAoa2V5ID0+IHtcbiAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCgnJyArIG9wdGlvbnNba2V5XSlcbiAgICB9KVxuICAgIC5qb2luKCcmJylcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMaWdodG5pbmcgZnJvbSAnLi4vTGlnaHRuaW5nJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJzaW9uTGFiZWwgZXh0ZW5kcyBMaWdodG5pbmcuQ29tcG9uZW50IHtcbiAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgIGNvbG9yOiAweGJiMDA3OGFjLFxuICAgICAgaDogNDAsXG4gICAgICB3OiAxMDAsXG4gICAgICB4OiB3ID0+IHcgLSA1MCxcbiAgICAgIHk6IGggPT4gaCAtIDUwLFxuICAgICAgbW91bnQ6IDEsXG4gICAgICBUZXh0OiB7XG4gICAgICAgIHc6IHcgPT4gdyxcbiAgICAgICAgaDogaCA9PiBoLFxuICAgICAgICB5OiA1LFxuICAgICAgICB4OiAyMCxcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIGZvbnRTaXplOiAyMixcbiAgICAgICAgICBsaW5lSGVpZ2h0OiAyNixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgX2ZpcnN0QWN0aXZlKCkge1xuICAgIHRoaXMudGFnKCdUZXh0JykudGV4dCA9IGBBUFAgLSB2JHt0aGlzLnZlcnNpb259XFxuU0RLIC0gdiR7dGhpcy5zZGtWZXJzaW9ufWBcbiAgICB0aGlzLnRhZygnVGV4dCcpLmxvYWRUZXh0dXJlKClcbiAgICB0aGlzLncgPSB0aGlzLnRhZygnVGV4dCcpLnJlbmRlcldpZHRoICsgNDBcbiAgICB0aGlzLmggPSB0aGlzLnRhZygnVGV4dCcpLnJlbmRlckhlaWdodCArIDVcbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi9MaWdodG5pbmcnXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlkZW9UZXh0dXJlIGV4dGVuZHMgTGlnaHRuaW5nLkNvbXBvbmVudCB7XG4gIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFZpZGVvOiB7XG4gICAgICAgIGFscGhhOiAxLFxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgcGl2b3Q6IDAuNSxcbiAgICAgICAgdGV4dHVyZTogeyB0eXBlOiBMaWdodG5pbmcudGV4dHVyZXMuU3RhdGljVGV4dHVyZSwgb3B0aW9uczoge30gfSxcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgc2V0IHZpZGVvRWwodikge1xuICAgIHRoaXMuX3ZpZGVvRWwgPSB2XG4gIH1cblxuICBnZXQgdmlkZW9FbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlkZW9FbFxuICB9XG5cbiAgZ2V0IHZpZGVvVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy50YWcoJ1ZpZGVvJylcbiAgfVxuXG4gIGdldCB2aWRlb1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlkZW9WaWV3LnRleHR1cmVcbiAgfVxuXG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlkZW9WaWV3LmFscGhhID09PSAxICYmIHRoaXMudmlkZW9WaWV3LnZpc2libGUgPT09IHRydWVcbiAgfVxuXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2NyZWF0ZVZpZGVvVGV4dHVyZSgpXG4gIH1cblxuICBfY3JlYXRlVmlkZW9UZXh0dXJlKCkge1xuICAgIGNvbnN0IHN0YWdlID0gdGhpcy5zdGFnZVxuXG4gICAgY29uc3QgZ2wgPSBzdGFnZS5nbFxuICAgIGNvbnN0IGdsVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSlcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuICAgIHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMgPSB7IHNvdXJjZTogZ2xUZXh0dXJlLCB3OiB0aGlzLnZpZGVvRWwud2lkdGgsIGg6IHRoaXMudmlkZW9FbC5oZWlnaHQgfVxuXG4gICAgdGhpcy52aWRlb1ZpZXcudyA9IHRoaXMudmlkZW9FbC53aWR0aCAvIHRoaXMuc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKClcbiAgICB0aGlzLnZpZGVvVmlldy5oID0gdGhpcy52aWRlb0VsLmhlaWdodCAvIHRoaXMuc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKClcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGNvbnN0IHN0YWdlID0gdGhpcy5zdGFnZVxuICAgIHRoaXMuX2xhc3RUaW1lID0gMFxuICAgIGlmICghdGhpcy5fdXBkYXRlVmlkZW9UZXh0dXJlKSB7XG4gICAgICB0aGlzLl91cGRhdGVWaWRlb1RleHR1cmUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zLnNvdXJjZSAmJiB0aGlzLnZpZGVvRWwudmlkZW9XaWR0aCAmJiB0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgIGNvbnN0IGdsID0gc3RhZ2UuZ2xcblxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgICBjb25zdCBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IHRoaXMudmlkZW9FbC5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpXG5cbiAgICAgICAgICAvLyBXaGVuIEJSMl9QQUNLQUdFX0dTVDFfUExVR0lOU19CQURfUExVR0lOX0RFQlVHVVRJTFMgaXMgbm90IHNldCBpbiBXUEUsIHdlYmtpdERlY29kZWRGcmFtZUNvdW50IHdpbGwgbm90IGJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAvLyBXZSdsbCBmYWxsYmFjayB0byBmaXhlZCAzMGZwcyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgLy8gQXMgJ3dlYmtpdERlY29kZWRGcmFtZUNvdW50JyBpcyBhYm91dCB0byBkZXByZWNhdGUsIGNoZWNrIGZvciB0aGUgJ3RvdGFsVmlkZW9GcmFtZXMnXG4gICAgICAgICAgY29uc3QgZnJhbWVDb3VudCA9IGdldFZpZGVvUGxheWJhY2tRdWFsaXR5XG4gICAgICAgICAgICA/IGdldFZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXNcbiAgICAgICAgICAgIDogdGhpcy52aWRlb0VsLndlYmtpdERlY29kZWRGcmFtZUNvdW50XG5cbiAgICAgICAgICBjb25zdCBtdXN0VXBkYXRlID0gZnJhbWVDb3VudFxuICAgICAgICAgICAgPyB0aGlzLl9sYXN0RnJhbWUgIT09IGZyYW1lQ291bnRcbiAgICAgICAgICAgIDogdGhpcy5fbGFzdFRpbWUgPCBjdXJyZW50VGltZSAtIDMwXG5cbiAgICAgICAgICBpZiAobXVzdFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdFRpbWUgPSBjdXJyZW50VGltZVxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gZnJhbWVDb3VudFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5zb3VyY2UpXG4gICAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZmFsc2UpXG4gICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy52aWRlb0VsKVxuICAgICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSB0aGlzLnZpZGVvRWwud2Via2l0RGVjb2RlZEZyYW1lQ291bnRcbiAgICAgICAgICAgICAgdGhpcy52aWRlb1ZpZXcudmlzaWJsZSA9IHRydWVcblxuICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zLncgPSB0aGlzLnZpZGVvRWwud2lkdGhcbiAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5oID0gdGhpcy52aWRlb0VsLmhlaWdodFxuICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZEFzcGVjdFJhdGlvID0gdGhpcy52aWRlb1ZpZXcudyAvIHRoaXMudmlkZW9WaWV3LmhcbiAgICAgICAgICAgICAgY29uc3QgcmVhbEFzcGVjdFJhdGlvID0gdGhpcy52aWRlb0VsLndpZHRoIC8gdGhpcy52aWRlb0VsLmhlaWdodFxuXG4gICAgICAgICAgICAgIGlmIChleHBlY3RlZEFzcGVjdFJhdGlvID4gcmVhbEFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb1ZpZXcuc2NhbGVYID0gcmVhbEFzcGVjdFJhdGlvIC8gZXhwZWN0ZWRBc3BlY3RSYXRpb1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9WaWV3LnNjYWxlWSA9IDFcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVmlldy5zY2FsZVkgPSBleHBlY3RlZEFzcGVjdFJhdGlvIC8gcmVhbEFzcGVjdFJhdGlvXG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb1ZpZXcuc2NhbGVYID0gMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIExvZy5lcnJvcigndGV4SW1hZ2UyZCB2aWRlbycsIGUpXG4gICAgICAgICAgICAgIHRoaXMuc3RvcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZS5zb3VyY2UuZm9yY2VSZW5kZXJVcGRhdGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX3VwZGF0aW5nVmlkZW9UZXh0dXJlKSB7XG4gICAgICBzdGFnZS5vbignZnJhbWVTdGFydCcsIHRoaXMuX3VwZGF0ZVZpZGVvVGV4dHVyZSlcbiAgICAgIHRoaXMuX3VwZGF0aW5nVmlkZW9UZXh0dXJlID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgY29uc3Qgc3RhZ2UgPSB0aGlzLnN0YWdlXG4gICAgc3RhZ2UucmVtb3ZlTGlzdGVuZXIoJ2ZyYW1lU3RhcnQnLCB0aGlzLl91cGRhdGVWaWRlb1RleHR1cmUpXG4gICAgdGhpcy5fdXBkYXRpbmdWaWRlb1RleHR1cmUgPSBmYWxzZVxuICAgIHRoaXMudmlkZW9WaWV3LnZpc2libGUgPSBmYWxzZVxuXG4gICAgaWYgKHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMuc291cmNlKSB7XG4gICAgICBjb25zdCBnbCA9IHN0YWdlLmdsXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zLnNvdXJjZSlcbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMSlcbiAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXG4gICAgfVxuICB9XG5cbiAgcG9zaXRpb24odG9wLCBsZWZ0KSB7XG4gICAgdGhpcy52aWRlb1ZpZXcucGF0Y2goe1xuICAgICAgc21vb3RoOiB7XG4gICAgICAgIHg6IGxlZnQsXG4gICAgICAgIHk6IHRvcCxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudmlkZW9WaWV3LnBhdGNoKHtcbiAgICAgIHNtb290aDoge1xuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgaDogaGVpZ2h0LFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnZpZGVvVmlldy5zZXRTbW9vdGgoJ2FscGhhJywgMSlcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy52aWRlb1ZpZXcuc2V0U21vb3RoKCdhbHBoYScsIDApXG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYWJvcnQ6ICdBYm9ydCcsXG4gIGNhbnBsYXk6ICdDYW5QbGF5JyxcbiAgY2FucGxheXRocm91Z2g6ICdDYW5QbGF5VGhyb3VnaCcsXG4gIGR1cmF0aW9uY2hhbmdlOiAnRHVyYXRpb25DaGFuZ2UnLFxuICBlbXB0aWVkOiAnRW1wdGllZCcsXG4gIGVuY3J5cHRlZDogJ0VuY3J5cHRlZCcsXG4gIGVuZGVkOiAnRW5kZWQnLFxuICBlcnJvcjogJ0Vycm9yJyxcbiAgaW50ZXJydXB0YmVnaW46ICdJbnRlcnJ1cHRCZWdpbicsXG4gIGludGVycnVwdGVuZDogJ0ludGVycnVwdEVuZCcsXG4gIGxvYWRlZGRhdGE6ICdMb2FkZWREYXRhJyxcbiAgbG9hZGVkbWV0YWRhdGE6ICdMb2FkZWRNZXRhZGF0YScsXG4gIGxvYWRzdGFydDogJ0xvYWRTdGFydCcsXG4gIHBhdXNlOiAnUGF1c2UnLFxuICBwbGF5OiAnUGxheScsXG4gIHBsYXlpbmc6ICdQbGF5aW5nJyxcbiAgcHJvZ3Jlc3M6ICdQcm9ncmVzcycsXG4gIHJhdGVjaGFuZ2U6ICdSYXRlY2hhbmdlJyxcbiAgc2Vla2VkOiAnU2Vla2VkJyxcbiAgc2Vla2luZzogJ1NlZWtpbmcnLFxuICBzdGFsbGVkOiAnU3RhbGxlZCcsXG4gIC8vIHN1c3BlbmQ6ICdTdXNwZW5kJywgLy8gdGhpcyBvbmUgaXMgY2FsbGVkIGEgbG9vb29vdCBmb3Igc29tZSB2aWRlb3NcbiAgdGltZXVwZGF0ZTogJ1RpbWVVcGRhdGUnLFxuICB2b2x1bWVjaGFuZ2U6ICdWb2x1bWVDaGFuZ2UnLFxuICB3YWl0aW5nOiAnV2FpdGluZycsXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgZXhlY3V0ZUFzUHJvbWlzZSBmcm9tICdAbWljaGllbGpzL2V4ZWN1dGUtYXMtcHJvbWlzZSdcblxuaW1wb3J0IE1ldHJpY3MgZnJvbSAnLi4vTWV0cmljcydcbmltcG9ydCBMb2cgZnJvbSAnLi4vTG9nJ1xuaW1wb3J0IEFkcyBmcm9tICcuLi9BZHMnXG5cbmltcG9ydCBldmVudHMgZnJvbSAnLi9ldmVudHMnXG5pbXBvcnQgYXV0b1NldHVwTWl4aW4gZnJvbSAnLi4vaGVscGVycy9hdXRvU2V0dXBNaXhpbidcbmltcG9ydCBlYXNlRXhlY3V0aW9uIGZyb20gJy4uL2hlbHBlcnMvZWFzZUV4ZWN1dGlvbidcbmltcG9ydCB7IEFwcGxpY2F0aW9uSW5zdGFuY2UgfSBmcm9tICcuLi9MYXVuY2gnXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgVmlkZW9UZXh0dXJlIGZyb20gJy4vVmlkZW9UZXh0dXJlJ1xuXG5leHBvcnQgbGV0IG1lZGlhVXJsID0gdXJsID0+IHVybFxubGV0IHZpZGVvRWxcbmxldCB2aWRlb1RleHR1cmVcbmxldCBtZXRyaWNzXG5sZXQgY29uc3VtZXJcbmxldCBwcmVjaXNpb24gPSAxXG5sZXQgdGV4dHVyZU1vZGUgPSBmYWxzZVxuXG5leHBvcnQgY29uc3QgaW5pdFZpZGVvUGxheWVyID0gY29uZmlnID0+IHtcbiAgaWYgKGNvbmZpZy5tZWRpYVVybCkge1xuICAgIG1lZGlhVXJsID0gY29uZmlnLm1lZGlhVXJsXG4gIH1cbn1cblxuLy8gdG9kbzogYWRkIHRoaXMgaW4gYSAnUmVnaXN0cnknIHBsdWdpblxuLy8gdG8gYmUgYWJsZSB0byBhbHdheXMgY2xlYW4gdGhpcyB1cCBvbiBhcHAgY2xvc2VcbmxldCBldmVudEhhbmRsZXJzID0ge31cblxuY29uc3Qgc3RhdGUgPSB7XG4gIGFkc0VuYWJsZWQ6IGZhbHNlLFxuICBwbGF5aW5nOiBmYWxzZSxcbiAgX3BsYXlpbmdBZHM6IGZhbHNlLFxuICBnZXQgcGxheWluZ0FkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxheWluZ0Fkc1xuICB9LFxuICBzZXQgcGxheWluZ0Fkcyh2YWwpIHtcbiAgICBpZiAodGhpcy5fcGxheWluZ0FkcyAhPT0gdmFsKSB7XG4gICAgICB0aGlzLl9wbGF5aW5nQWRzID0gdmFsXG4gICAgICBmaXJlT25Db25zdW1lcih2YWwgPT09IHRydWUgPyAnQWRTdGFydCcgOiAnQWRFbmQnKVxuICAgIH1cbiAgfSxcbiAgc2tpcFRpbWU6IGZhbHNlLFxuICBwbGF5QWZ0ZXJTZWVrOiBudWxsLFxufVxuXG5jb25zdCBob29rcyA9IHtcbiAgcGxheSgpIHtcbiAgICBzdGF0ZS5wbGF5aW5nID0gdHJ1ZVxuICB9LFxuICBwYXVzZSgpIHtcbiAgICBzdGF0ZS5wbGF5aW5nID0gZmFsc2VcbiAgfSxcbiAgc2Vla2VkKCkge1xuICAgIHN0YXRlLnBsYXlBZnRlclNlZWsgPT09IHRydWUgJiYgdmlkZW9QbGF5ZXJQbHVnaW4ucGxheSgpXG4gICAgc3RhdGUucGxheUFmdGVyU2VlayA9IG51bGxcbiAgfSxcbiAgYWJvcnQoKSB7XG4gICAgZGVyZWdpc3RlckV2ZW50TGlzdGVuZXJzKClcbiAgfSxcbn1cblxuY29uc3Qgd2l0aFByZWNpc2lvbiA9IHZhbCA9PiBNYXRoLnJvdW5kKHByZWNpc2lvbiAqIHZhbCkgKyAncHgnXG5cbmNvbnN0IGZpcmVPbkNvbnN1bWVyID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gIGlmIChjb25zdW1lcikge1xuICAgIGNvbnN1bWVyLmZpcmUoJyR2aWRlb1BsYXllcicgKyBldmVudCwgYXJncywgdmlkZW9FbC5jdXJyZW50VGltZSlcbiAgICBjb25zdW1lci5maXJlKCckdmlkZW9QbGF5ZXJFdmVudCcsIGV2ZW50LCBhcmdzLCB2aWRlb0VsLmN1cnJlbnRUaW1lKVxuICB9XG59XG5cbmNvbnN0IGZpcmVIb29rID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gIGhvb2tzW2V2ZW50XSAmJiB0eXBlb2YgaG9va3NbZXZlbnRdID09PSAnZnVuY3Rpb24nICYmIGhvb2tzW2V2ZW50XS5jYWxsKG51bGwsIGV2ZW50LCBhcmdzKVxufVxuXG5sZXQgY3VzdG9tTG9hZGVyID0gbnVsbFxubGV0IGN1c3RvbVVubG9hZGVyID0gbnVsbFxuXG5jb25zdCBsb2FkZXIgPSAodXJsLCB2aWRlb0VsLCBjb25maWcpID0+IHtcbiAgcmV0dXJuIGN1c3RvbUxvYWRlciAmJiB0eXBlb2YgY3VzdG9tTG9hZGVyID09PSAnZnVuY3Rpb24nXG4gICAgPyBjdXN0b21Mb2FkZXIodXJsLCB2aWRlb0VsLCBjb25maWcpXG4gICAgOiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdXJsID0gbWVkaWFVcmwodXJsKVxuICAgICAgICB2aWRlb0VsLnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKVxuICAgICAgICB2aWRlb0VsLmxvYWQoKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG59XG5cbmNvbnN0IHVubG9hZGVyID0gdmlkZW9FbCA9PiB7XG4gIHJldHVybiBjdXN0b21VbmxvYWRlciAmJiB0eXBlb2YgY3VzdG9tVW5sb2FkZXIgPT09ICdmdW5jdGlvbidcbiAgICA/IGN1c3RvbVVubG9hZGVyKHZpZGVvRWwpXG4gICAgOiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdmlkZW9FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpXG4gICAgICAgIHZpZGVvRWwubG9hZCgpXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IHNldHVwVmlkZW9UYWcgPSAoKSA9PiB7XG4gIGNvbnN0IHZpZGVvRWxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJylcbiAgaWYgKHZpZGVvRWxzICYmIHZpZGVvRWxzLmxlbmd0aCkge1xuICAgIHJldHVybiB2aWRlb0Vsc1swXVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHZpZGVvRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgY29uc3QgcGxhdGZvcm1TZXR0aW5nc1dpZHRoID0gU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICd3aWR0aCcpXG4gICAgICA/IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnd2lkdGgnKVxuICAgICAgOiAxOTIwXG4gICAgY29uc3QgcGxhdGZvcm1TZXR0aW5nc0hlaWdodCA9IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnaGVpZ2h0JylcbiAgICAgID8gU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdoZWlnaHQnKVxuICAgICAgOiAxMDgwXG4gICAgdmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3ZpZGVvLXBsYXllcicpXG4gICAgdmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2l0aFByZWNpc2lvbihwbGF0Zm9ybVNldHRpbmdzV2lkdGgpKVxuICAgIHZpZGVvRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB3aXRoUHJlY2lzaW9uKHBsYXRmb3JtU2V0dGluZ3NIZWlnaHQpKVxuICAgIHZpZGVvRWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgdmlkZW9FbC5zdHlsZS56SW5kZXggPSAnMSdcbiAgICB2aWRlb0VsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICB2aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgIHZpZGVvRWwuc3R5bGUudG9wID0gd2l0aFByZWNpc2lvbigwKVxuICAgIHZpZGVvRWwuc3R5bGUubGVmdCA9IHdpdGhQcmVjaXNpb24oMClcbiAgICB2aWRlb0VsLnN0eWxlLndpZHRoID0gd2l0aFByZWNpc2lvbihwbGF0Zm9ybVNldHRpbmdzV2lkdGgpXG4gICAgdmlkZW9FbC5zdHlsZS5oZWlnaHQgPSB3aXRoUHJlY2lzaW9uKHBsYXRmb3JtU2V0dGluZ3NIZWlnaHQpXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2aWRlb0VsKVxuICAgIHJldHVybiB2aWRlb0VsXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldFVwVmlkZW9UZXh0dXJlID0gKCkgPT4ge1xuICBpZiAoIUFwcGxpY2F0aW9uSW5zdGFuY2UudGFnKCdWaWRlb1RleHR1cmUnKSkge1xuICAgIGNvbnN0IGVsID0gQXBwbGljYXRpb25JbnN0YW5jZS5zdGFnZS5jKHtcbiAgICAgIHR5cGU6IFZpZGVvVGV4dHVyZSxcbiAgICAgIHJlZjogJ1ZpZGVvVGV4dHVyZScsXG4gICAgICB6SW5kZXg6IDAsXG4gICAgICB2aWRlb0VsLFxuICAgIH0pXG4gICAgQXBwbGljYXRpb25JbnN0YW5jZS5jaGlsZExpc3QuYWRkQXQoZWwsIDApXG4gIH1cbiAgcmV0dXJuIEFwcGxpY2F0aW9uSW5zdGFuY2UudGFnKCdWaWRlb1RleHR1cmUnKVxufVxuXG5jb25zdCByZWdpc3RlckV2ZW50TGlzdGVuZXJzID0gKCkgPT4ge1xuICBMb2cuaW5mbygnVmlkZW9QbGF5ZXInLCAnUmVnaXN0ZXJpbmcgZXZlbnQgbGlzdGVuZXJzJylcbiAgT2JqZWN0LmtleXMoZXZlbnRzKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICBjb25zdCBoYW5kbGVyID0gZSA9PiB7XG4gICAgICAvLyBGaXJlIGEgbWV0cmljIGZvciBlYWNoIGV2ZW50IChpZiBpdCBleGlzdHMgb24gdGhlIG1ldHJpY3Mgb2JqZWN0KVxuICAgICAgaWYgKG1ldHJpY3MgJiYgbWV0cmljc1tldmVudF0gJiYgdHlwZW9mIG1ldHJpY3NbZXZlbnRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1ldHJpY3NbZXZlbnRdKHsgY3VycmVudFRpbWU6IHZpZGVvRWwuY3VycmVudFRpbWUgfSlcbiAgICAgIH1cbiAgICAgIC8vIGZpcmUgYW4gaW50ZXJuYWwgaG9va1xuICAgICAgZmlyZUhvb2soZXZlbnQsIHsgdmlkZW9FbGVtZW50OiB2aWRlb0VsLCBldmVudDogZSB9KVxuXG4gICAgICAvLyBmaXJlIHRoZSBldmVudCAod2l0aCBodW1hbiBmcmllbmRseSBldmVudCBuYW1lKSB0byB0aGUgY29uc3VtZXIgb2YgdGhlIFZpZGVvUGxheWVyXG4gICAgICBmaXJlT25Db25zdW1lcihldmVudHNbZXZlbnRdLCB7IHZpZGVvRWxlbWVudDogdmlkZW9FbCwgZXZlbnQ6IGUgfSlcbiAgICB9XG5cbiAgICBldmVudEhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJcbiAgICB2aWRlb0VsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpXG4gIH0pXG59XG5cbmNvbnN0IGRlcmVnaXN0ZXJFdmVudExpc3RlbmVycyA9ICgpID0+IHtcbiAgTG9nLmluZm8oJ1ZpZGVvUGxheWVyJywgJ0RlcmVnaXN0ZXJpbmcgZXZlbnQgbGlzdGVuZXJzJylcbiAgT2JqZWN0LmtleXMoZXZlbnRIYW5kbGVycykuZm9yRWFjaChldmVudCA9PiB7XG4gICAgdmlkZW9FbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBldmVudEhhbmRsZXJzW2V2ZW50XSlcbiAgfSlcbiAgZXZlbnRIYW5kbGVycyA9IHt9XG59XG5cbmNvbnN0IHZpZGVvUGxheWVyUGx1Z2luID0ge1xuICBjb25zdW1lcihjb21wb25lbnQpIHtcbiAgICBjb25zdW1lciA9IGNvbXBvbmVudFxuICB9LFxuXG4gIGxvYWRlcihsb2FkZXJGbikge1xuICAgIGN1c3RvbUxvYWRlciA9IGxvYWRlckZuXG4gIH0sXG5cbiAgdW5sb2FkZXIodW5sb2FkZXJGbikge1xuICAgIGN1c3RvbVVubG9hZGVyID0gdW5sb2FkZXJGblxuICB9LFxuXG4gIHBvc2l0aW9uKHRvcCA9IDAsIGxlZnQgPSAwKSB7XG4gICAgdmlkZW9FbC5zdHlsZS5sZWZ0ID0gd2l0aFByZWNpc2lvbihsZWZ0KVxuICAgIHZpZGVvRWwuc3R5bGUudG9wID0gd2l0aFByZWNpc2lvbih0b3ApXG4gICAgaWYgKHRleHR1cmVNb2RlID09PSB0cnVlKSB7XG4gICAgICB2aWRlb1RleHR1cmUucG9zaXRpb24odG9wLCBsZWZ0KVxuICAgIH1cbiAgfSxcblxuICBzaXplKHdpZHRoID0gMTkyMCwgaGVpZ2h0ID0gMTA4MCkge1xuICAgIHZpZGVvRWwuc3R5bGUud2lkdGggPSB3aXRoUHJlY2lzaW9uKHdpZHRoKVxuICAgIHZpZGVvRWwuc3R5bGUuaGVpZ2h0ID0gd2l0aFByZWNpc2lvbihoZWlnaHQpXG4gICAgdmlkZW9FbC53aWR0aCA9IHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS53aWR0aClcbiAgICB2aWRlb0VsLmhlaWdodCA9IHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS5oZWlnaHQpXG4gICAgaWYgKHRleHR1cmVNb2RlID09PSB0cnVlKSB7XG4gICAgICB2aWRlb1RleHR1cmUuc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICAgIH1cbiAgfSxcblxuICBhcmVhKHRvcCA9IDAsIHJpZ2h0ID0gMTkyMCwgYm90dG9tID0gMTA4MCwgbGVmdCA9IDApIHtcbiAgICB0aGlzLnBvc2l0aW9uKHRvcCwgbGVmdClcbiAgICB0aGlzLnNpemUocmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApXG4gIH0sXG5cbiAgb3Blbih1cmwsIGNvbmZpZyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICBtZXRyaWNzID0gTWV0cmljcy5tZWRpYSh1cmwpXG5cbiAgICB0aGlzLmhpZGUoKVxuICAgIGRlcmVnaXN0ZXJFdmVudExpc3RlbmVycygpXG5cbiAgICBpZiAodGhpcy5zcmMgPT0gdXJsKSB7XG4gICAgICB0aGlzLmNsZWFyKCkudGhlbih0aGlzLm9wZW4odXJsLCBjb25maWcpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhZENvbmZpZyA9IHsgZW5hYmxlZDogc3RhdGUuYWRzRW5hYmxlZCwgZHVyYXRpb246IDMwMCB9XG4gICAgICBpZiAoY29uZmlnLnZpZGVvSWQpIHtcbiAgICAgICAgYWRDb25maWcuY2FpZCA9IGNvbmZpZy52aWRlb0lkXG4gICAgICB9XG4gICAgICBBZHMuZ2V0KGFkQ29uZmlnLCBjb25zdW1lcikudGhlbihhZHMgPT4ge1xuICAgICAgICBzdGF0ZS5wbGF5aW5nQWRzID0gdHJ1ZVxuICAgICAgICBhZHMucHJlcm9sbHMoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZS5wbGF5aW5nQWRzID0gZmFsc2VcbiAgICAgICAgICBsb2FkZXIodXJsLCB2aWRlb0VsLCBjb25maWcpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKVxuICAgICAgICAgICAgICB0aGlzLnNob3coKVxuICAgICAgICAgICAgICB0aGlzLnBsYXkoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ2Vycm9yJywgeyB2aWRlb0VsZW1lbnQ6IHZpZGVvRWwsIGV2ZW50OiBlIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgcmVsb2FkKCkge1xuICAgIGlmICghdGhpcy5jYW5JbnRlcmFjdCkgcmV0dXJuXG4gICAgY29uc3QgdXJsID0gdmlkZW9FbC5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgdGhpcy5jbG9zZSgpXG4gICAgdGhpcy5vcGVuKHVybClcbiAgfSxcblxuICBjbG9zZSgpIHtcbiAgICBBZHMuY2FuY2VsKClcbiAgICBpZiAoc3RhdGUucGxheWluZ0Fkcykge1xuICAgICAgc3RhdGUucGxheWluZ0FkcyA9IGZhbHNlXG4gICAgICBBZHMuc3RvcCgpXG4gICAgICAvLyBjYWxsIHNlbGYgaW4gbmV4dCB0aWNrXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIHRoaXMuY2xlYXIoKVxuICAgIHRoaXMuaGlkZSgpXG4gICAgZGVyZWdpc3RlckV2ZW50TGlzdGVuZXJzKClcbiAgfSxcblxuICBjbGVhcigpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIC8vIHBhdXNlIHRoZSB2aWRlbyBmaXJzdCB0byBkaXNhYmxlIHNvdW5kXG4gICAgdGhpcy5wYXVzZSgpXG4gICAgaWYgKHRleHR1cmVNb2RlID09PSB0cnVlKSB2aWRlb1RleHR1cmUuc3RvcCgpXG4gICAgcmV0dXJuIHVubG9hZGVyKHZpZGVvRWwpLnRoZW4oKCkgPT4ge1xuICAgICAgZmlyZU9uQ29uc3VtZXIoJ0NsZWFyJywgeyB2aWRlb0VsZW1lbnQ6IHZpZGVvRWwgfSlcbiAgICB9KVxuICB9LFxuXG4gIHBsYXkoKSB7XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICBpZiAodGV4dHVyZU1vZGUgPT09IHRydWUpIHZpZGVvVGV4dHVyZS5zdGFydCgpXG4gICAgZXhlY3V0ZUFzUHJvbWlzZSh2aWRlb0VsLnBsYXksIG51bGwsIHZpZGVvRWwpLmNhdGNoKGUgPT4ge1xuICAgICAgZmlyZU9uQ29uc3VtZXIoJ2Vycm9yJywgeyB2aWRlb0VsZW1lbnQ6IHZpZGVvRWwsIGV2ZW50OiBlIH0pXG4gICAgfSlcbiAgfSxcblxuICBwYXVzZSgpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIHZpZGVvRWwucGF1c2UoKVxuICB9LFxuXG4gIHBsYXlQYXVzZSgpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIHRoaXMucGxheWluZyA9PT0gdHJ1ZSA/IHRoaXMucGF1c2UoKSA6IHRoaXMucGxheSgpXG4gIH0sXG5cbiAgbXV0ZShtdXRlZCA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIHZpZGVvRWwubXV0ZWQgPSBtdXRlZFxuICB9LFxuXG4gIGxvb3AobG9vcGVkID0gdHJ1ZSkge1xuICAgIHZpZGVvRWwubG9vcCA9IGxvb3BlZFxuICB9LFxuXG4gIHNlZWsodGltZSkge1xuICAgIGlmICghdGhpcy5jYW5JbnRlcmFjdCkgcmV0dXJuXG4gICAgaWYgKCF0aGlzLnNyYykgcmV0dXJuXG4gICAgLy8gZGVmaW5lIHdoZXRoZXIgc2hvdWxkIGNvbnRpbnVlIHRvIHBsYXkgYWZ0ZXIgc2VlayBpcyBjb21wbGV0ZSAoaW4gc2Vla2VkIGhvb2spXG4gICAgaWYgKHN0YXRlLnBsYXlBZnRlclNlZWsgPT09IG51bGwpIHtcbiAgICAgIHN0YXRlLnBsYXlBZnRlclNlZWsgPSAhIXN0YXRlLnBsYXlpbmdcbiAgICB9XG4gICAgLy8gcGF1c2UgYmVmb3JlIGFjdHVhbGx5IHNlZWtpbmdcbiAgICB0aGlzLnBhdXNlKClcbiAgICAvLyBjdXJyZW50VGltZSBhbHdheXMgYmV0d2VlbiAwIGFuZCB0aGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIChtaW51cyAwLjFzIHRvIG5vdCBzZXQgdG8gdGhlIGZpbmFsIGZyYW1lIGFuZCBzdGFsbCB0aGUgdmlkZW8pXG4gICAgdmlkZW9FbC5jdXJyZW50VGltZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRpbWUsIHRoaXMuZHVyYXRpb24gLSAwLjEpKVxuICB9LFxuXG4gIHNraXAoc2Vjb25kcykge1xuICAgIGlmICghdGhpcy5jYW5JbnRlcmFjdCkgcmV0dXJuXG4gICAgaWYgKCF0aGlzLnNyYykgcmV0dXJuXG5cbiAgICBzdGF0ZS5za2lwVGltZSA9IChzdGF0ZS5za2lwVGltZSB8fCB2aWRlb0VsLmN1cnJlbnRUaW1lKSArIHNlY29uZHNcbiAgICBlYXNlRXhlY3V0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuc2VlayhzdGF0ZS5za2lwVGltZSlcbiAgICAgIHN0YXRlLnNraXBUaW1lID0gZmFsc2VcbiAgICB9LCAzMDApXG4gIH0sXG5cbiAgc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIGlmICh0ZXh0dXJlTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgdmlkZW9UZXh0dXJlLnNob3coKVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0VsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICB2aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICB9XG4gIH0sXG5cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIGlmICh0ZXh0dXJlTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgdmlkZW9UZXh0dXJlLmhpZGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0VsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgIHZpZGVvRWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgfVxuICB9LFxuXG4gIGVuYWJsZUFkcyhlbmFibGVkID0gdHJ1ZSkge1xuICAgIHN0YXRlLmFkc0VuYWJsZWQgPSBlbmFibGVkXG4gIH0sXG5cbiAgLyogUHVibGljIGdldHRlcnMgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIChpc05hTih2aWRlb0VsLmR1cmF0aW9uKSA/IEluZmluaXR5IDogdmlkZW9FbC5kdXJhdGlvbilcbiAgfSxcblxuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgdmlkZW9FbC5jdXJyZW50VGltZVxuICB9LFxuXG4gIGdldCBtdXRlZCgpIHtcbiAgICByZXR1cm4gdmlkZW9FbCAmJiB2aWRlb0VsLm11dGVkXG4gIH0sXG5cbiAgZ2V0IGxvb3BlZCgpIHtcbiAgICByZXR1cm4gdmlkZW9FbCAmJiB2aWRlb0VsLmxvb3BcbiAgfSxcblxuICBnZXQgc3JjKCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIHZpZGVvRWwuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICB9LFxuXG4gIGdldCBwbGF5aW5nKCkge1xuICAgIHJldHVybiBzdGF0ZS5wbGF5aW5nXG4gIH0sXG5cbiAgZ2V0IHBsYXlpbmdBZHMoKSB7XG4gICAgcmV0dXJuIHN0YXRlLnBsYXlpbmdBZHNcbiAgfSxcblxuICBnZXQgY2FuSW50ZXJhY3QoKSB7XG4gICAgLy8gdG9kbzogcGVyaGFwcyBhZGQgYW4gZXh0cmEgZmxhZyB3ZXRoZXIgd2UgYWxsb3cgaW50ZXJhY3Rpb25zIChpLmUuIHBhdXplLCBtdXRlLCBldGMuKSBkdXJpbmcgYWQgcGxheWJhY2tcbiAgICByZXR1cm4gc3RhdGUucGxheWluZ0FkcyA9PT0gZmFsc2VcbiAgfSxcblxuICBnZXQgdG9wKCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS50b3ApXG4gIH0sXG5cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgcGFyc2VGbG9hdCh2aWRlb0VsLnN0eWxlLmxlZnQpXG4gIH0sXG5cbiAgZ2V0IGJvdHRvbSgpIHtcbiAgICByZXR1cm4gdmlkZW9FbCAmJiBwYXJzZUZsb2F0KHZpZGVvRWwuc3R5bGUudG9wIC0gdmlkZW9FbC5zdHlsZS5oZWlnaHQpXG4gIH0sXG5cbiAgZ2V0IHJpZ2h0KCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS5sZWZ0IC0gdmlkZW9FbC5zdHlsZS53aWR0aClcbiAgfSxcblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgcGFyc2VGbG9hdCh2aWRlb0VsLnN0eWxlLndpZHRoKVxuICB9LFxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgcGFyc2VGbG9hdCh2aWRlb0VsLnN0eWxlLmhlaWdodClcbiAgfSxcblxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICBpZiAodGV4dHVyZU1vZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB2aWRlb1RleHR1cmUuaXNWaXNpYmxlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aWRlb0VsICYmIHZpZGVvRWwuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJ1xuICAgIH1cbiAgfSxcblxuICBnZXQgYWRzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gc3RhdGUuYWRzRW5hYmxlZFxuICB9LFxuXG4gIC8vIHByZWZpeGVkIHdpdGggdW5kZXJzY29yZSB0byBpbmRpY2F0ZSAnc2VtaS1wcml2YXRlJ1xuICAvLyBiZWNhdXNlIGl0J3Mgbm90IHJlY29tbWVuZGVkIHRvIGludGVyYWN0IGRpcmVjdGx5IHdpdGggdGhlIHZpZGVvIGVsZW1lbnRcbiAgZ2V0IF92aWRlb0VsKCkge1xuICAgIHJldHVybiB2aWRlb0VsXG4gIH0sXG5cbiAgZ2V0IF9jb25zdW1lcigpIHtcbiAgICByZXR1cm4gY29uc3VtZXJcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXV0b1NldHVwTWl4aW4odmlkZW9QbGF5ZXJQbHVnaW4sICgpID0+IHtcbiAgcHJlY2lzaW9uID1cbiAgICAoQXBwbGljYXRpb25JbnN0YW5jZSAmJlxuICAgICAgQXBwbGljYXRpb25JbnN0YW5jZS5zdGFnZSAmJlxuICAgICAgQXBwbGljYXRpb25JbnN0YW5jZS5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKSkgfHxcbiAgICBwcmVjaXNpb25cblxuICB2aWRlb0VsID0gc2V0dXBWaWRlb1RhZygpXG5cbiAgdGV4dHVyZU1vZGUgPSBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ3RleHR1cmVNb2RlJywgZmFsc2UpXG4gIGlmICh0ZXh0dXJlTW9kZSA9PT0gdHJ1ZSkge1xuICAgIHZpZGVvRWwuc2V0QXR0cmlidXRlKCdjcm9zc29yaWdpbicsICdhbm9ueW1vdXMnKVxuICAgIHZpZGVvVGV4dHVyZSA9IHNldFVwVmlkZW9UZXh0dXJlKClcbiAgfVxufSlcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IChzb3VyY2VPYmplY3QsIHNldHVwID0gKCkgPT4ge30pID0+IHtcbiAgbGV0IHJlYWR5ID0gZmFsc2VcblxuICBjb25zdCBkb1NldHVwID0gKCkgPT4ge1xuICAgIGlmIChyZWFkeSA9PT0gZmFsc2UpIHtcbiAgICAgIHNldHVwKClcbiAgICAgIHJlYWR5ID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2VPYmplY3QpLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZU9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmpba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkb1NldHVwKClcbiAgICAgICAgcmV0dXJuIHNvdXJjZU9iamVjdFtrZXldLmFwcGx5KHNvdXJjZU9iamVjdCwgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlT2JqZWN0LCBrZXkpLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2JqLl9fZGVmaW5lR2V0dGVyX18oa2V5LCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9TZXR1cCgpXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZU9iamVjdCwga2V5KS5nZXQuYXBwbHkoc291cmNlT2JqZWN0KVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZU9iamVjdCwga2V5KS5zZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9iai5fX2RlZmluZVNldHRlcl9fKGtleSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvU2V0dXAoKVxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VPYmplY3QsIGtleSkuc2V0LnNvdXJjZU9iamVjdFtrZXldLmFwcGx5KFxuICAgICAgICAgIHNvdXJjZU9iamVjdCxcbiAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2VPYmplY3Rba2V5XVxuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH0sIHt9KVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxubGV0IHRpbWVvdXQgPSBudWxsXG5cbmV4cG9ydCBkZWZhdWx0IChjYiwgZGVsYXkpID0+IHtcbiAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjYigpXG4gIH0sIGRlbGF5KVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgc3RlcHMgPT4ge1xuICByZXR1cm4gc3RlcHMucmVkdWNlKChwcm9taXNlLCBtZXRob2QpID0+IHtcbiAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtZXRob2QoLi4uYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlID0+IFByb21pc2UucmVqZWN0KGUpKVxuICB9LCBQcm9taXNlLnJlc29sdmUobnVsbCkpXG59XG4iLCJleHBvcnQgZGVmYXVsdCAobWV0aG9kLCBhcmdzID0gbnVsbCwgY29udGV4dCA9IG51bGwpID0+IHtcbiAgbGV0IHJlc3VsdFxuICBpZiAobWV0aG9kICYmIHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBtZXRob2RcbiAgfVxuXG4gIC8vIGlmIGl0IGxvb2tzIGxpa2UgYSBkdWNrIC4uIGVobSAuLi4gcHJvbWlzZSBhbmQgdGFsa3MgbGlrZSBhIHByb21pc2UsIGxldCdzIGFzc3VtZSBpdCdzIGEgcHJvbWlzZVxuICBpZiAoXG4gICAgcmVzdWx0ICE9PSBudWxsICYmXG4gICAgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiZcbiAgICByZXN1bHQudGhlbiAmJlxuICAgIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiAgLy8gb3RoZXJ3aXNlIG1ha2UgaXQgaW50byBhIHByb21pc2VcbiAgZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZWplY3QocmVzdWx0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRyZXR1cm4gc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxufVxuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKVxuXHRcdDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMuY3VzdG9tTWVyZ2UpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlXG5cdH1cblx0dmFyIGN1c3RvbU1lcmdlID0gb3B0aW9ucy5jdXN0b21NZXJnZShrZXkpO1xuXHRyZXR1cm4gdHlwZW9mIGN1c3RvbU1lcmdlID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWVyZ2UgOiBkZWVwbWVyZ2Vcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnByb3BlcnR5SXNFbnVtZXJhYmxlKHN5bWJvbClcblx0XHR9KVxuXHRcdDogW11cbn1cblxuZnVuY3Rpb24gZ2V0S2V5cyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlJc09uT2JqZWN0KG9iamVjdCwgcHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gcHJvcGVydHkgaW4gb2JqZWN0XG5cdH0gY2F0Y2goXykge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbi8vIFByb3RlY3RzIGZyb20gcHJvdG90eXBlIHBvaXNvbmluZyBhbmQgdW5leHBlY3RlZCBtZXJnaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5mdW5jdGlvbiBwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSB7XG5cdHJldHVybiBwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpIC8vIFByb3BlcnRpZXMgYXJlIHNhZmUgdG8gbWVyZ2UgaWYgdGhleSBkb24ndCBleGlzdCBpbiB0aGUgdGFyZ2V0IHlldCxcblx0XHQmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuXHRcdFx0JiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBrZXkpKSAvLyBhbmQgYWxzbyB1bnNhZmUgaWYgdGhleSdyZSBub25lbnVtZXJhYmxlLlxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdGdldEtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRnZXRLZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAocHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmIChwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pKSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0ID0gb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCB8fCBpc01lcmdlYWJsZU9iamVjdDtcblx0Ly8gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgaXMgYWRkZWQgdG8gYG9wdGlvbnNgIHNvIHRoYXQgY3VzdG9tIGFycmF5TWVyZ2UoKVxuXHQvLyBpbXBsZW1lbnRhdGlvbnMgY2FuIHVzZSBpdC4gVGhlIGNhbGxlciBtYXkgbm90IHJlcGxhY2UgaXQuXG5cdG9wdGlvbnMuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZDtcblxuXHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdHZhciBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcblxuXHRpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5hcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdH1cblxuXHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdH0sIHt9KVxufTtcblxudmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBtZXJnZV8xO1xuIiwiY2xhc3MgbG9jYWxDb29raWV7Y29uc3RydWN0b3IoZSl7cmV0dXJuIGU9ZXx8e30sdGhpcy5mb3JjZUNvb2tpZXM9ZS5mb3JjZUNvb2tpZXN8fCExLCEwPT09dGhpcy5fY2hlY2tJZkxvY2FsU3RvcmFnZVdvcmtzKCkmJiEwIT09ZS5mb3JjZUNvb2tpZXM/e2dldEl0ZW06dGhpcy5fZ2V0SXRlbUxvY2FsU3RvcmFnZSxzZXRJdGVtOnRoaXMuX3NldEl0ZW1Mb2NhbFN0b3JhZ2UscmVtb3ZlSXRlbTp0aGlzLl9yZW1vdmVJdGVtTG9jYWxTdG9yYWdlLGNsZWFyOnRoaXMuX2NsZWFyTG9jYWxTdG9yYWdlfTp7Z2V0SXRlbTp0aGlzLl9nZXRJdGVtQ29va2llLHNldEl0ZW06dGhpcy5fc2V0SXRlbUNvb2tpZSxyZW1vdmVJdGVtOnRoaXMuX3JlbW92ZUl0ZW1Db29raWUsY2xlYXI6dGhpcy5fY2xlYXJDb29raWVzfX1fY2hlY2tJZkxvY2FsU3RvcmFnZVdvcmtzKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGxvY2FsU3RvcmFnZSlyZXR1cm4hMTt0cnl7cmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiZmVhdHVyZV90ZXN0XCIsXCJ5ZXNcIiksXCJ5ZXNcIj09PWxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiZmVhdHVyZV90ZXN0XCIpJiYobG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJmZWF0dXJlX3Rlc3RcIiksITApfWNhdGNoKGUpe3JldHVybiExfX1fZ2V0SXRlbUxvY2FsU3RvcmFnZShlKXtyZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGUpfV9zZXRJdGVtTG9jYWxTdG9yYWdlKGUsdCl7cmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShlLHQpfV9yZW1vdmVJdGVtTG9jYWxTdG9yYWdlKGUpe3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZSl9X2NsZWFyTG9jYWxTdG9yYWdlKCl7cmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UuY2xlYXIoKX1fZ2V0SXRlbUNvb2tpZShlKXt2YXIgdD1kb2N1bWVudC5jb29raWUubWF0Y2goUmVnRXhwKFwiKD86Xnw7XFxcXHMqKVwiK2Z1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoLyhbLiorP1xcXiR7fSgpfFxcW1xcXVxcL1xcXFxdKS9nLFwiXFxcXCQxXCIpfShlKStcIj0oW147XSopXCIpKTtyZXR1cm4gdCYmXCJcIj09PXRbMV0mJih0WzFdPW51bGwpLHQ/dFsxXTpudWxsfV9zZXRJdGVtQ29va2llKGUsdCl7dmFyIG89bmV3IERhdGUscj1uZXcgRGF0ZShvLmdldFRpbWUoKSsxNTc2OGU3KTtkb2N1bWVudC5jb29raWU9YCR7ZX09JHt0fTsgZXhwaXJlcz0ke3IudG9VVENTdHJpbmcoKX07YH1fcmVtb3ZlSXRlbUNvb2tpZShlKXtkb2N1bWVudC5jb29raWU9YCR7ZX09O01heC1BZ2U9LTk5OTk5OTk5O2B9X2NsZWFyQ29va2llcygpe2RvY3VtZW50LmNvb2tpZS5zcGxpdChcIjtcIikuZm9yRWFjaChlPT57ZG9jdW1lbnQuY29va2llPWUucmVwbGFjZSgvXiArLyxcIlwiKS5yZXBsYWNlKC89LiovLFwiPTtleHBpcmVzPU1heC1BZ2U9LTk5OTk5OTk5XCIpfSl9fWV4cG9ydCBkZWZhdWx0IGxvY2FsQ29va2llO1xuIiwiXG5cbmltcG9ydCB7IExpZ2h0bmluZywgVXRpbHMsIExvZyB9IGZyb20gXCJAbGlnaHRuaW5nanMvc2RrXCI7XG5pbXBvcnQgeyBEZXZpY2UgfSBmcm9tIFwiQGZpcmVib2x0LWpzL3Nka1wiO1xuaW1wb3J0IHsgTXlCdXR0b24gfSBmcm9tIFwiLi9NeUJ1dHRvblwiO1xuXG5leHBvcnQgY2xhc3MgQXBwIGV4dGVuZHMgTGlnaHRuaW5nLkNvbXBvbmVudCB7XG4gIHN0YXRpYyBnZXRGb250cygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyBmYW1pbHk6IFwiUmVndWxhclwiLCB1cmw6IFV0aWxzLmFzc2V0KFwiZm9udHMvUm9ib3RvLVJlZ3VsYXIudHRmXCIpIH0sXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhlbGxvV29ybGQ6IHtcbiAgICAgICAgdzogMTkyMCxcbiAgICAgICAgaDogMTA4MCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgICAgLy8gY29sb3I6IDB4ZmYwMDAwMDAsXG4gICAgICAgc3JjOiBVdGlscy5hc3NldChcImltYWdlcy9wcC5wbmdcIiksXG5cbiAgICAgICAgRmlyZWJvbHRTdGF0dXM6IHtcbiAgICAgICAgICBSZGtsb2dvOiB7XG4gICAgICAgICAgICB4OiA3MCxcbiAgICAgICAgICAgIHk6IDUwLFxuICAgICAgICAgICAgdzogMzAwLFxuICAgICAgICAgICAgaDogNjUsXG4gICAgICAgICAgICB6SW5kZXg6IDEwLFxuICAgICAgICAgICAvLyBzaGFkb3dDb2xvcjogMHhmZmZmMDBmZixcbiAgICAgICAgICAgIHNyYzogVXRpbHMuYXNzZXQoXCJpbWFnZXMvUkRLLUxvZ28td2ViLndlYnBcIiksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBBbGV4YWxvZ286IHtcbiAgICAgICAgICAgIHg6IDEwNTAsXG4gICAgICAgICAgICB5OiA1LFxuICAgICAgICAgICAgdzogMTcwLFxuICAgICAgICAgICAgaDogMTUwLFxuICAgICAgICAgICAgc3JjOiBVdGlscy5hc3NldChcImltYWdlcy9hbGV4YS5wbmdcIiksXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIFRyYWlsZXI6IHtcbiAgICAgICAgICAgIHg6IDEyMCxcbiAgICAgICAgICAgIHk6IDM4NSxcbiAgICAgICAgICAgIHc6IDEwMCxcbiAgICAgICAgICAgIGg6IDEwMCxcbiAgICAgICAgICAgIC8vY29sb3I6IDB4ZmZmZjAwZmYsXG4gICAgICAgICAgICBzcmM6IFV0aWxzLmFzc2V0KFwiaW1hZ2VzL2ZhY2Vib29rLnBuZ1wiKSxcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgV2F0Y2hwYXJ0eToge1xuICAgICAgICAgICAgeDogNDgwLFxuICAgICAgICAgICAgeTogMzg1LFxuICAgICAgICAgICAgdzogOTAsXG4gICAgICAgICAgICAgaDogOTAsXG4gICAgICAgICAgIFxuICAgICAgICAgICAgc3JjOiBVdGlscy5hc3NldChcImltYWdlcy9zaGFyZS5wbmdcIiksXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIEJvb2ttYXJrOiB7XG4gICAgICAgICBcbiAgICAgICAgICAgIHg6IDMwMCxcbiAgICAgICAgICAgIHk6IDM4NSxcbiAgICAgICAgICAgIHc6IDEwMCxcbiAgICAgICAgICAgIGg6IDkwLFxuICAgICAgICAgICAgc3JjOiBVdGlscy5hc3NldChcImltYWdlcy9ib29rbWFyay5wbmdcIiksXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIEluZm86IHtcbiAgICAgICAgICAgIHg6IDY1MCxcbiAgICAgICAgICAgIHk6IDM4MCxcbiAgICAgICAgICAgIHc6IDEwMCxcbiAgICAgICAgICAgIGg6IDEwMCxcbiAgICAgICAgICAgIHNyYzogVXRpbHMuYXNzZXQoXCJpbWFnZXMvaW5mby5wbmdcIiksXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIEJlbGxsb2dvOiB7XG4gICAgICAgICAgICB4OiAxMjg1XG4gICAgICAgICAgICAsXG4gICAgICAgICAgICB5OiAzMCxcbiAgICAgICAgICAgIHc6IDkwLFxuICAgICAgICAgICAgaDogOTAsXG4gICAgICAgICAgICBzcmM6IFV0aWxzLmFzc2V0KFwiaW1hZ2VzL3NldHQucG5nXCIpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgTm90aWZpbG9nbzoge1xuICAgICAgICAgICAgeDogMTQ1MCxcbiAgICAgICAgICAgIHk6IDMwLFxuICAgICAgICAgICAgdzogMTAwLFxuICAgICAgICAgICAgaDogMTAwLFxuICAgICAgICAgICAgc3JjOiBVdGlscy5hc3NldChcImltYWdlcy9ub3RpLnBuZ1wiKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIEN1cnJlbnRUaW1lOiB7XG4gICAgICAgICAgICBtb3VudFg6IDAuNSxcbiAgICAgICAgICAgIHg6IDE3MDAsXG4gICAgICAgICAgICB5OiA0MCxcbiAgICAgICAgICAgIHc6IDIwMCxcbiAgICAgICAgICAgIGg6IDEwMCwgLy8gQWRqdXN0IHRoZSBZIHBvc2l0aW9uIGFzIG5lZWRlZFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICBmb250RmFjZTogXCJSZWd1bGFyXCIsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiA3MCxcbiAgICAgICAgICAgICAgLy90ZXh0Q29sb3I6IDB4ZmYwOWY2NzYsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgVGV4dDE6IHtcbiAgICAgICAgICBcbiAgICAgICAgICAgIHg6IDEwMCxcbiAgICAgICAgICAgIHk6IDYxMCxcbiAgICAgICAgICAgIHc6IDUwMCxcbiAgICAgICAgICAgIGg6IDgwLFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICB0ZXh0OiBcIkZlYXR1cmVkIFZpZGVvIG9uIERlbWFuZFwiLFxuICAgICAgICAgICAgICBmb250RmFjZTogXCJSZWd1bGFyXCIsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiAzMCxcbiAgICAgICAgICAgICAgLy90ZXh0Q29sb3I6IDB4ZmYwOWY2NzYsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgICAgRGV2aWNlOiB7XG4gICAgICAgICAgICBtb3VudFg6IDAuNSxcbiAgICAgICAgICAgIHg6IDk2MCxcbiAgICAgICAgICAgIHk6IDEwMzAsXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgIC8vIHRleHQ6IFwiRGV2aWNlIG5vdCBSZWFkeSFcIixcbiAgICAgICAgICAgICAgZm9udEZhY2U6IFwiUmVndWxhclwiLFxuICAgICAgICAgICAgICBmb250U2l6ZTogMjQsXG4gICAgICAgICAgICAgIC8vdGV4dENvbG9yOiAweGZmMDlmNjc2LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBQbGF5YnV0dG9uOiB7XG4gICAgICAgICAgdHlwZTogTXlCdXR0b24sXG4gICAgICAgICAgbW91bnQ6IC0wLjIsXG4gICAgICAgICAgeDogMTE1LFxuICAgICAgICAgIHk6IDEzMCxcbiAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAvL3RleHQ6IFwiUmVjZW50XCIsXG4gICAgICAgICAgICBmb250RmFjZTogXCJSZWd1bGFyXCIsXG4gICAgICAgICAgICBmb250U2l6ZTogNDUsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDB4ZmZmZmZmZmYsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaWduYWxzOiB7XG4gICAgICAgICAgICBvbkNsaWNrOiBcIiRvbkl0ZW1TZWxlY3RcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIFNsaWRlcjoge1xuICAgICAgICB3OiA4MDAsXG4gICAgICAgIGg6IDM1MCxcbiAgICAgICAgeDogNDgwLFxuICAgICAgICB5OiA3NTAsXG4gICAgICAgIG1vdW50OiAwLjUsXG4gICAgICAgIFdyYXBwZXI6IHt9LFxuICAgICAgfSxcbiAgICAgIFNlY29uZFNsaWRlcjoge1xuICAgICAgICB3OiA4MDAsXG4gICAgICAgIGg6IDM1MCxcbiAgICAgICAgeDogNDgwLFxuICAgICAgICB5OiA3NTAsIC8vIEFkanVzdCB0aGUgWSBwb3NpdGlvbiBmb3IgdGhlIHNlY29uZCBzbGlkZXJcbiAgICAgICAgbW91bnQ6IDAuNSxcbiAgICAgICAgU2Vjb25kV3JhcHBlcjoge30sXG4gICAgICB9LFxuICAgICAgVmlkZW9TZWN0aW9uOiB7XG4gICAgICAgIGFscGhhOiAxLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3OiAxOTIwLFxuICAgICAgICBoOiAxMDgwLFxuICAgICAgICBjb2xvcjogXCIweGZmMDAwMDAwXCIsXG4gICAgICAgIHJlY3Q6IHRydWUsXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICBIZWxwTXNnOiB7XG4gICAgICAgICAgeDogODAsXG4gICAgICAgICAgeTogNTAsXG4gICAgICAgICAgdzogMTkyMCxcbiAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICB0ZXh0OiBcIlBsYXkgdGhlIFZpZGVvIHVzaW5nIEFBTVAgUGxheWVyXCIsXG4gICAgICAgICAgICBmb250U2l6ZTogNDAsXG4gICAgICAgICAgICBmb250RmFjZTogXCJSZWd1bGFyXCIsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiA1MCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbG9yOiBcIjB4ZmZmZmZmZmZcIixcbiAgICAgICAgICBhbHBoYTogMSxcbiAgICAgICAgfSxcbiAgICAgICAgVmlkZW86IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgdzogMTkyMCwgLy8gU2V0IHRvIHlvdXIgZGVzaXJlZCB3aWR0aFxuICAgICAgICAgIGg6IDEwODAsIC8vIFNldCB0byB5b3VyIGRlc2lyZWQgaGVpZ2h0XG4gICAgICAgICAgdHlwZTogTGlnaHRuaW5nLmNvbXBvbmVudHMuVmlkZW9JdGVtLCAvLyBVc2UgdGhlIGFwcHJvcHJpYXRlIExpZ2h0bmluZyB2aWRlb1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgX2dldEZvY3VzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnKFwiUGxheWJ1dHRvblwiKTtcbiAgfVxuXG4gIF9pbml0KCkge1xuICAgIC8vIE5ldyBjb2RlXG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5kYXRhTGVuZ3RoID0gNjtcbiAgICB0aGlzLmN1cnJlbnRTbGlkZXIgPSBcInNsaWRlcjFcIjsgLy8gVGhpcyBrZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBzbGlkZXJcblxuICAgIC8vIENyZWF0ZSBidXR0b25zIGZvciB0aGUgZmlyc3Qgc2xpZGVyXG4gICAgY29uc3Qgc2xpZGVyQnV0dG9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgIHNsaWRlckJ1dHRvbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IE15QnV0dG9uLFxuICAgICAgICB4OiBpICogKDMwMCArIDEwKSxcbiAgICAgICAgaXRlbToge1xuICAgICAgICAgIGxhYmVsOiBgVHJhaW5gLFxuICAgICAgICAgIHNyYzogVXRpbHMuYXNzZXQoYGltYWdlcy9jYXJkSW1hZ2Uke2kgKyAxfS5qcGdgKSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnRhZyhcIldyYXBwZXJcIikuY2hpbGRyZW4gPSBzbGlkZXJCdXR0b25zO1xuICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnRUaW1lKCk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHRpbWUgZXZlcnkgc2Vjb25kICgxMDAwIG1pbGxpc2Vjb25kcylcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVDdXJyZW50VGltZSgpO1xuICAgIH0sIDEwMDApO1xuICB9XG5cbiAgX3NldFNsaWRlckZvY3VzKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTbGlkZXIgPT09IFwic2xpZGVyMVwiKSB7XG4gICAgICB0aGlzLnRhZyhcIldyYXBwZXJcIikuc2V0U21vb3RoKFwiYWxwaGFcIiwgMSk7XG4gICAgICB0aGlzLnRhZyhcIlNlY29uZFdyYXBwZXJcIikuc2V0U21vb3RoKFwiYWxwaGFcIiwgMSk7XG4gICAgICB0aGlzLnRhZyhcIldyYXBwZXJcIikuY2hpbGRyZW5bdGhpcy5pbmRleF0uc2V0Rm9jdXModHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRTbGlkZXIgPT09IFwic2xpZGVyMlwiKSB7XG4gICAgICB0aGlzLnRhZyhcIldyYXBwZXJcIikuc2V0U21vb3RoKFwiYWxwaGFcIiwgMSk7XG4gICAgICB0aGlzLnRhZyhcIlNlY29uZFdyYXBwZXJcIikuc2V0U21vb3RoKFwiYWxwaGFcIiwgMSk7XG4gICAgICB0aGlzLnRhZyhcIlNlY29uZFdyYXBwZXJcIikuY2hpbGRyZW5bdGhpcy5pbmRleF0uc2V0Rm9jdXModHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgJG9uSXRlbVNlbGVjdChvYmopIHtcbiAgICBjb25zdCB1cmwgPVxuICAgICAgXCJodHRwczovL21lZGlhLmF4cHJvZC5uZXQvVGVzdFZlY3RvcnMvdjktTXVsdGlGb3JtYXQvQ2xlYXIvTWFuaWZlc3RfMTA4MHAubTN1OFwiO1xuICAgIHRoaXMuX3BsYXllciA9IG5ldyBBQU1QTWVkaWFQbGF5ZXIoKTtcbiAgICB0aGlzLl9wbGF5ZXIubG9hZCh1cmwpO1xuICAgIHRoaXMuX3NldFN0YXRlKFwiVmlkZW9QbGF5XCIpO1xuICB9XG5cbiAgX3VwZGF0ZUN1cnJlbnRUaW1lKCkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBob3VycyA9IGN1cnJlbnRUaW1lLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgY29uc3QgbWludXRlcyA9IGN1cnJlbnRUaW1lLmdldE1pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICBjb25zdCBzZWNvbmRzID0gY3VycmVudFRpbWUuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgIGNvbnN0IGZvcm1hdHRlZFRpbWUgPSBgJHtob3Vyc306JHttaW51dGVzfWA7XG4gICAgdGhpcy50YWcoXCJDdXJyZW50VGltZVwiKS50ZXh0LnRleHQgPSBgJHtmb3JtYXR0ZWRUaW1lfWA7XG4gIH1cblxuICByZXBvc2l0aW9uV3JhcHBlcigpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gdGhpcy50YWcoXCJXcmFwcGVyXCIpO1xuICAgIGNvbnN0IHNsaWRlclcgPSB0aGlzLnRhZyhcIlNsaWRlclwiKS53O1xuICAgIGNvbnN0IGN1cnJlbnRXcmFwcGVyWCA9XG4gICAgICB3cmFwcGVyLnRyYW5zaXRpb24oXCJ4XCIpLnRhcmdldHZhbHVlIHx8IHdyYXBwZXIueDtcbiAgICBjb25zdCBjdXJyZW50Rm9jdXMgPSB3cmFwcGVyLmNoaWxkcmVuW3RoaXMuaW5kZXhdO1xuICAgIGNvbnN0IGN1cnJlbnRGb2N1c1ggPSBjdXJyZW50Rm9jdXMueCArIGN1cnJlbnRXcmFwcGVyWDtcbiAgICBjb25zdCBjdXJyZW50Rm9jdXNPdXRlcldpZHRoID1cbiAgICAgIGN1cnJlbnRGb2N1cy54ICsgY3VycmVudEZvY3VzLnc7XG5cbiAgICBpZiAoY3VycmVudEZvY3VzWCA8IDApIHtcbiAgICAgIHdyYXBwZXIuc2V0U21vb3RoKFwieFwiLCAtY3VycmVudEZvY3VzLngpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEZvY3VzT3V0ZXJXaWR0aCA+IHNsaWRlclcpIHtcbiAgICAgIHdyYXBwZXIuc2V0U21vb3RoKFxuICAgICAgICBcInhcIixcbiAgICAgICAgc2xpZGVyVyAtIGN1cnJlbnRGb2N1c091dGVyV2lkdGhcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVMZWZ0KCkge1xuICAgIGNvbnN0IHNsaWRlciA9XG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZXIgPT09IFwic2xpZGVyMVwiXG4gICAgICAgID8gdGhpcy50YWcoXCJXcmFwcGVyXCIpXG4gICAgICAgIDogdGhpcy50YWcoXCJTZWNvbmRXcmFwcGVyXCIpO1xuICAgIGlmICh0aGlzLmluZGV4ID4gMCkge1xuICAgICAgdGhpcy5pbmRleC0tO1xuICAgICAgc2xpZGVyLmNoaWxkcmVuW3RoaXMuaW5kZXhdLnNldEZvY3VzKHRydWUpO1xuICAgICAgc2xpZGVyLmNoaWxkcmVuW3RoaXMuaW5kZXggKyAxXS5zZXRGb2N1cyhmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmluZGV4ID09PSAwKSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBpbmRleCBpcyAwLCBzZXQgZm9jdXMgdG8gdGhlIGxhc3QgaW5kZXhcbiAgICAgIHRoaXMuaW5kZXggPSBzbGlkZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgIHNsaWRlci5jaGlsZHJlblswXS5zZXRGb2N1cyhmYWxzZSk7XG4gICAgICBzbGlkZXIuY2hpbGRyZW5bdGhpcy5pbmRleF0uc2V0Rm9jdXModHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVSaWdodCgpIHtcbiAgICBjb25zdCBzbGlkZXIgPVxuICAgICAgdGhpcy5jdXJyZW50U2xpZGVyID09PSBcInNsaWRlcjFcIlxuICAgICAgICA/IHRoaXMudGFnKFwiV3JhcHBlclwiKVxuICAgICAgICA6IHRoaXMudGFnKFwiU2Vjb25kV3JhcHBlclwiKTtcbiAgICBpZiAodGhpcy5pbmRleCA8IHRoaXMuZGF0YUxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIHNsaWRlci5jaGlsZHJlblt0aGlzLmluZGV4XS5zZXRGb2N1cyh0cnVlKTtcbiAgICAgIHNsaWRlci5jaGlsZHJlblt0aGlzLmluZGV4IC0gMV0uc2V0Rm9jdXMoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5kYXRhTGVuZ3RoIC0gMSkge1xuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaW5kZXggaXMgdGhlIGxhc3QgaW5kZXgsIHNldCBmb2N1cyB0byB0aGUgMHRoIGluZGV4XG4gICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgIHNsaWRlci5jaGlsZHJlblt0aGlzLmRhdGFMZW5ndGggLSAxXS5zZXRGb2N1cyhmYWxzZSk7XG4gICAgICBzbGlkZXIuY2hpbGRyZW5bMF0uc2V0Rm9jdXModHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgX2dldFNsaWRlckZvY3VzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnKFwiU2xpZGVyLldyYXBwZXJcIikuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gIH1cblxuICBzdGF0aWMgX3N0YXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgY2xhc3MgTGF1bmNoVmlldyBleHRlbmRzIHRoaXMge1xuICAgICAgICBfZ2V0Rm9jdXNlZCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YWcoXCJQbGF5YnV0dG9uXCIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xhc3MgU2Vjb25kU2xpZGVyU3RhdGUgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgX2dldEZvY3VzZWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNsaWRlciA9PT0gXCJzbGlkZXIxXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZyhcIlNsaWRlci5XcmFwcGVyXCIpLmNoaWxkcmVuW3RoaXMuaW5kZXhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWcoXCJTZWNvbmRTbGlkZXIuU2Vjb25kV3JhcHBlclwiKS5jaGlsZHJlblt0aGlzLmluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGFzcyBWaWRlb1BsYXkgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgX2dldEZvY3VzZWQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFnKFwiVmlkZW9cIik7XG4gICAgICAgIH1cbiAgICAgICAgJGVudGVyKCkge1xuICAgICAgICAgIHRoaXMudGFnKFwiVmlkZW9cIikudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy50YWcoXCJIZWxsb1dvcmxkXCIpLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnRhZyhcIlNsaWRlclwiKS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50YWcoXCJTZWNvbmRTbGlkZXJcIikudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIF9oYW5kbGVCYWNrKCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiYmFjayB0byBsYXVuY2hWaWV3XCIpO1xuICAgICAgICAgIHRoaXMudGFnKFwiVmlkZW9cIikudmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy50YWcoXCJIZWxsb1dvcmxkXCIpLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMudGFnKFwiU2xpZGVyXCIpLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMudGFnKFwiU2Vjb25kU2xpZGVyXCIpLnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgICAgdGhpcy5fc2V0U3RhdGUoXCJMYXVuY2hWaWV3XCIpO1xuICAgICAgICAgIGlmICh0aGlzLl9wbGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllci5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICBdO1xuICB9XG5cbiAgX2FjdGl2ZSgpIHtcbiAgICBjb25zb2xlLmxvZyhcImFjdGl2ZSBzZXQgc3RhdGUgdG8gbGF1bmNoVmlld1wiKTtcbiAgICB0aGlzLl9zZXRTdGF0ZShcIkxhdW5jaFZpZXdcIik7XG5cbiAgICBEZXZpY2UudmVyc2lvbigpLnRoZW4oKHZlcnNpb24pID0+IHtcbiAgICAgIGNvbnN0IGRldmljZVZlcnNpb24gPVxuICAgICAgICBcInZlcnNpb246XCIgK1xuICAgICAgICB2ZXJzaW9uLnNkay5yZWFkYWJsZSArXG4gICAgICAgIFwiIDogdlwiICtcbiAgICAgICAgdmVyc2lvbi5zZGsubWFqb3IgK1xuICAgICAgICBcIi5cIiArXG4gICAgICAgIHZlcnNpb24uc2RrLm1pbm9yICtcbiAgICAgICAgXCIuXCIgK1xuICAgICAgICB2ZXJzaW9uLnNkay5wYXRjaDtcbiAgICAgIExvZy5pbmZvKGRldmljZVZlcnNpb24pO1xuICAgICAgdGhpcy50YWcoXCJEZXZpY2VcIikudGV4dC50ZXh0ICs9IGRldmljZVZlcnNpb247XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IExpZ2h0bmluZyB9IGZyb20gXCJAbGlnaHRuaW5nanMvc2RrXCI7XG5cbmV4cG9ydCBjbGFzcyBNeUJ1dHRvbiBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3OiAyNTAsXG4gICAgICBoOiAzNTAsXG4gICAgICBcbiAgICAgIHk6IDEwMCxcbiAgICAgIEltYWdlOiB7XG4gICAgICAgIHg6IDUsXG4gICAgICAgIHc6IHcgPT4gdyxcbiAgICAgICAgaDogaCA9PiBoIC0gNTAsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuXG5cbiAgc2V0IGl0ZW0ob2JqKSB7XG4gICAgY29uc3QgeyBsYWJlbCwgc3JjLCB2aWRlb1VybCB9ID0gb2JqO1xuICAgIHRoaXMuX3ZpZGVvVXJsID0gdmlkZW9Vcmw7XG4gICAgdGhpcy5wYXRjaCh7XG4gICAgICBJbWFnZTogeyBzcmMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHNldEZvY3VzKGlzRm9jdXNlZCkge1xuICAgIGlmIChpc0ZvY3VzZWQpIHtcbiAgICAgIHRoaXMuX2ZvY3VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgXG4gIF9oYW5kbGVFbnRlcigpIHtcbiAgICAvL2NvbnNvbGUubG9nKCdFbnRlciBwcmVzc2VkJyk7XG4gICAgLy8gdGhpcy5zaWduYWwoXCJvbkNsaWNrXCIpO1xuICAgIHRoaXMuZmlyZUFuY2VzdG9ycygnJG9uSXRlbVNlbGVjdCcsIHtcbiAgICAgLy8gdmlkZW9Vcmw6IHRoaXMuX3ZpZGVvVXJsXG4gICAgICAvLyBpdGVtOiB0aGlzLl9pdGVtLFxuXG4gICAgfSlcblxuICB9XG5cbiAgX2ZvY3VzKCkge1xuICAgIGNvbnNvbGUubG9nKCdCdXR0b24gRm9jdXMnKTtcbiAgICB0aGlzLnBhdGNoKHtcbiAgICAgIHNtb290aDogeyBjb2xvcjogMHhmZjAwNTUwMCwgc2NhbGU6IDEuMSB9LFxuICAgICAgc2hhZGVyOiB7IHR5cGU6IExpZ2h0bmluZy5zaGFkZXJzLk91dGxpbmUsIHN0cm9rZTogMS4xLCBjb2xvcjogMHhmZjA5ZjY3NiB9LFxuICAgIH0pO1xuICB9XG5cblxuICBfdW5mb2N1cygpIHtcbiAgICBjb25zb2xlLmxvZygnQnV0dG9uIFVuZm9jdXMnKTtcbiAgICB0aGlzLnBhdGNoKHtcbiAgICAgIHNtb290aDogeyBjb2xvcjogMHhmZmZmZmZmZiwgc2NhbGU6IDEuMCB9LFxuICAgICAgc2hhZGVyOiB7IHR5cGU6IExpZ2h0bmluZy5zaGFkZXJzLk91dGxpbmUsIHN0cm9rZTogMCwgY29sb3I6IDB4MDAwMDAwMCB9LFxuICAgIH0pO1xuICB9XG59IiwiXG5pbXBvcnQgcGtnIGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5cbmNvbnN0IGlzRGV2ZWxvcG1lbnQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JztcblxuZXhwb3J0IGNvbnN0IGFwcERhdGEgPSB7fTtcblxuZXhwb3J0IGNvbnN0IGFwcFNldHRpbmdzID0ge1xuICB2ZXJzaW9uOiBwa2cudmVyc2lvbixcbiAgc3RhZ2U6IHtcbiAgICBjbGVhckNvbG9yOiAnMHgwMDAwMDAnLFxuICB9LFxuICBkZWJ1ZzogZmFsc2UsXG4gIFxufTtcblxuZXhwb3J0IGNvbnN0IHBsYXRmb3JtU2V0dGluZ3MgPSB7XG4gIGxvZzogdHJ1ZSxcbiAgcGF0aDogXCIuL3N0YXRpY1wiLFxuICBzaG93VmVyc2lvbjogZmFsc2UsXG4gIFxufTtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIHBhcnRpYWwgKGFuZCBtb3JlIGVmZmljaWVudCkgaW1wbGVtZW50YXRpb24gb2YgdGhlIGV2ZW50IGVtaXR0ZXIuXG4gKiBJdCBhdHRlbXB0cyB0byBtYWludGFpbiBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuIGV2ZW50cyBhbmQgbGlzdGVuZXJzLCBza2lwcGluZyBhbiBhcnJheSBsb29rdXAuXG4gKiBPbmx5IGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBsaXN0ZW5lcnMsIHRoZXkgYXJlIGNvbWJpbmVkIGluIGFuIGFycmF5LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudEVtaXR0ZXIge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgc2V0IChhbmQga2VwdCkgdG8gdHJ1ZSB3aGVuIGV2ZW50cyBhcmUgdXNlZCBhdCBhbGwuXG4gICAgICAgIHRoaXMuX2hhc0V2ZW50TGlzdGVuZXJzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRGdW5jdGlvbiA9IHt9XG4gICAgICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9XG4gICAgICAgICAgICB0aGlzLl9oYXNFdmVudExpc3RlbmVycyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXTtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdID0gbGlzdGVuZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXSAhPT0gRXZlbnRFbWl0dGVyLmNvbWJpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0gPSBbdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXSwgbGlzdGVuZXJdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV0gPSBFdmVudEVtaXR0ZXIuY29tYmluZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25jZShuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gKGFyZzEsIGFyZzIsIGFyZzMpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgICAgICAgdGhpcy5vZmYobmFtZSwgd3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlci5fX29yaWdpbmFsRnVuYyA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLm9uKG5hbWUsIHdyYXBwZXIpO1xuICAgIH1cblxuICAgIGhhcyhuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5faGFzRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gRXZlbnRFbWl0dGVyLmNvbWJpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGwgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobCA9PT0gbGlzdGVuZXIgfHwgbC5fX29yaWdpbmFsRnVuYyA9PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdID09PSBsaXN0ZW5lciB8fCB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdLl9fb3JpZ2luYWxGdW5jID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9mZihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5faGFzRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gRXZlbnRFbWl0dGVyLmNvbWJpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGxpc3RlbmVycy5tYXAoKGwpID0+IGwuX19vcmlnaW5hbEZ1bmMpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV0gPSBsaXN0ZW5lcnNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXSA9PT0gbGlzdGVuZXIgfHwgdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXS5fX29yaWdpbmFsRnVuYyA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLm9mZihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgZW1pdChuYW1lLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgY29uc3QgZnVuYyA9IHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV07XG4gICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jID09PSBFdmVudEVtaXR0ZXIuY29tYmluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYyh0aGlzLCBuYW1lLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmdW5jKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxpc3RlbmVyQ291bnQobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5faGFzRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdO1xuICAgICAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYyA9PT0gRXZlbnRFbWl0dGVyLmNvbWJpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuRXZlbnRFbWl0dGVyLmNvbWJpbmVyID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gb2JqZWN0Ll9ldmVudExpc3RlbmVyc1tuYW1lXTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8qIEJlY2F1c2UgbGlzdGVuZXIgbWF5IGRldGFjaCBpdHNlbGYgd2hpbGUgYmVpbmcgaW52b2tlZCBhbmQgdGhlcmVmb3JlIGludmFsaWRhdGUgdGhlIGl0ZXJhdG9yLFxuICAgICAgICAgICB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGNvcHkgdG8gbG9vcCBvdmVyIGl0ICovXG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgWy4uLmxpc3RlbmVyc10pIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5FdmVudEVtaXR0ZXIuYWRkQXNNaXhpbiA9IGZ1bmN0aW9uKGNscykge1xuICAgIGNscy5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuICAgIGNscy5wcm90b3R5cGUub25jZSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZTtcbiAgICBjbHMucHJvdG90eXBlLmhhcyA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuaGFzO1xuICAgIGNscy5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmY7XG4gICAgY2xzLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG4gICAgY2xzLnByb3RvdHlwZS5lbWl0ID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuICAgIGNscy5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudDtcbiAgICBjbHMucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzO1xufVxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCIuLi9FdmVudEVtaXR0ZXIubWpzXCI7XG5pbXBvcnQgQW5pbWF0aW9uU2V0dGluZ3MgZnJvbSBcIi4vQW5pbWF0aW9uU2V0dGluZ3MubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBzZXR0aW5ncywgZWxlbWVudCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG5cbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBzZXR0aW5ncztcblxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuSURMRTtcblxuICAgICAgICB0aGlzLl9wID0gMDtcbiAgICAgICAgdGhpcy5fZGVsYXlMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5fcmVwZWF0c0xlZnQgPSAwO1xuXG4gICAgICAgIHRoaXMuX3N0b3BEZWxheUxlZnQgPSAwO1xuICAgICAgICB0aGlzLl9zdG9wUCA9IDA7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50ICYmIHRoaXMuX2VsZW1lbnQuYXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3AgPSAwO1xuICAgICAgICAgICAgdGhpcy5fZGVsYXlMZWZ0ID0gdGhpcy5zZXR0aW5ncy5kZWxheTtcbiAgICAgICAgICAgIHRoaXMuX3JlcGVhdHNMZWZ0ID0gdGhpcy5zZXR0aW5ncy5yZXBlYXQ7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuUExBWUlORztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tBY3RpdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIEVsZW1lbnQgbXVzdCBiZSBhdHRhY2hlZCBiZWZvcmUgc3RhcnRpbmcgYW5pbWF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGxheSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLlBBVVNFRCkge1xuICAgICAgICAgICAgLy8gQ29udGludWUuO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlBMQVlJTkc7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQWN0aXZlKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlID09IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBJTkcgJiYgdGhpcy5zZXR0aW5ncy5zdG9wTWV0aG9kID09IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5SRVZFUlNFKSB7XG4gICAgICAgICAgICAvLyBDb250aW51ZS47XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuUExBWUlORztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcENvbnRpbnVlJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT0gQW5pbWF0aW9uLlNUQVRFUy5QTEFZSU5HICYmIHRoaXMuX3N0YXRlICE9IEFuaW1hdGlvbi5TVEFURVMuRklOSVNIRUQpIHtcbiAgICAgICAgICAgIC8vIFJlc3RhcnQuO1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5QTEFZSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuUEFVU0VEO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVwbGF5KCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT0gQW5pbWF0aW9uLlNUQVRFUy5GSU5JU0hFRCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBza2lwRGVsYXkoKSB7XG4gICAgICAgIHRoaXMuX2RlbGF5TGVmdCA9IDA7XG4gICAgICAgIHRoaXMuX3N0b3BEZWxheUxlZnQgPSAwO1xuICAgIH1cblxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLlBMQVlJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5TGVmdCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUElORykge1xuICAgICAgICAgICAgdGhpcy5fc3RvcERlbGF5TGVmdCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9wID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUEVEIHx8IHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLklETEUpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9zdG9wRGVsYXlMZWZ0ID0gdGhpcy5zZXR0aW5ncy5zdG9wRGVsYXkgfHwgMDtcblxuICAgICAgICBpZiAoKCh0aGlzLnNldHRpbmdzLnN0b3BNZXRob2QgPT09IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5JTU1FRElBVEUpICYmICF0aGlzLl9zdG9wRGVsYXlMZWZ0KSB8fCB0aGlzLl9kZWxheUxlZnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBTdG9wIHVwb24gbmV4dCBwcm9ncmVzcy47XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBJTkc7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0b3BNZXRob2QgPT09IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5GQURFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFAgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBJTkc7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hlY2tBY3RpdmUoKTtcbiAgICB9XG5cbiAgICBzdG9wTm93KCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBFRCB8fCB0aGlzLl9zdGF0ZSAhPT0gQW5pbWF0aW9uLlNUQVRFUy5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBJTkc7XG4gICAgICAgICAgICB0aGlzLl9wID0gMDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcpO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlNUT1BQRUQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3BGaW5pc2gnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzUGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuUEFVU0VEO1xuICAgIH1cblxuICAgIGlzUGxheWluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLlBMQVlJTkc7XG4gICAgfVxuXG4gICAgaXNTdG9wcGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLlNUT1BQSU5HO1xuICAgIH1cblxuICAgIGlzRmluaXNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5GSU5JU0hFRDtcbiAgICB9XG5cbiAgICBjaGVja0FjdGl2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmFkZEFjdGl2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3N0YXRlID09IEFuaW1hdGlvbi5TVEFURVMuUExBWUlORyB8fCB0aGlzLl9zdGF0ZSA9PSBBbmltYXRpb24uU1RBVEVTLlNUT1BQSU5HKSAmJiB0aGlzLl9lbGVtZW50ICYmIHRoaXMuX2VsZW1lbnQuYXR0YWNoZWQ7XG4gICAgfVxuXG4gICAgcHJvZ3Jlc3MoZHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50KSByZXR1cm47XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzKGR0KTtcbiAgICAgICAgdGhpcy5hcHBseSgpO1xuICAgIH1cblxuICAgIF9wcm9ncmVzcyhkdCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUElORykge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFByb2dyZXNzKGR0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPSBBbmltYXRpb24uU1RBVEVTLlBMQVlJTkcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9kZWxheUxlZnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxheUxlZnQgLT0gZHQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWxheUxlZnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgZHQgPSAtdGhpcy5fZGVsYXlMZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGF5TGVmdCA9IDA7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RlbGF5RW5kJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLmR1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcCArPSBkdCAvIHRoaXMuc2V0dGluZ3MuZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3AgPj0gMSkge1xuICAgICAgICAgICAgLy8gRmluaXNoZWQhO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVwZWF0ID09IC0xIHx8IHRoaXMuX3JlcGVhdHNMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZXBlYXRzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwZWF0c0xlZnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcCA9IHRoaXMuc2V0dGluZ3MucmVwZWF0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLl9wKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZXBlYXREZWxheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWxheUxlZnQgPSB0aGlzLnNldHRpbmdzLnJlcGVhdERlbGF5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVwZWF0JywgdGhpcy5fcmVwZWF0c0xlZnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdGhpcy5fcCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLkZJTklTSEVEO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b3N0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRoaXMuX3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIF9zdG9wUHJvZ3Jlc3MoZHQpIHtcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gdGhpcy5fZ2V0U3RvcER1cmF0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0b3BEZWxheUxlZnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wRGVsYXlMZWZ0IC09IGR0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcERlbGF5TGVmdCA8IDApIHtcbiAgICAgICAgICAgICAgICBkdCA9IC10aGlzLl9zdG9wRGVsYXlMZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BEZWxheUxlZnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wRGVsYXlFbmQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0b3BNZXRob2QgPT0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLklNTUVESUFURSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlNUT1BQRUQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3BGaW5pc2gnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnN0b3BNZXRob2QgPT0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLlJFVkVSU0UpIHtcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wIC09IGR0IC8gZHVyYXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBFRDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3BGaW5pc2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnN0b3BNZXRob2QgPT0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLkZBREUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzU3RvcFRyYW5zaXRpb24oZHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BQID49IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBFRDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3BGaW5pc2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnN0b3BNZXRob2QgPT0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLk9ORVRPVFdPKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcCA8IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcCA9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3AgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wICs9IGR0IC8gdGhpcy5zZXR0aW5ncy5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3AgKz0gZHQgLyBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBFRDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wRmluaXNoJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRoaXMuX3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnN0b3BNZXRob2QgPT0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLkZPUldBUkQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wIDwgMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmR1cmF0aW9uID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcCArPSBkdCAvIHRoaXMuc2V0dGluZ3MuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RvcE1ldGhvZCA9PSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuRk9SV0FSRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcEZpbmlzaCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlcGVhdHNMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcGVhdHNMZWZ0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXBlYXQnLCB0aGlzLl9yZXBlYXRzTGVmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcEZpbmlzaCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRoaXMuX3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgX3Byb2dyZXNzU3RvcFRyYW5zaXRpb24oZHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BQIDwgMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BEZWxheUxlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcERlbGF5TGVmdCAtPSBkdDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wRGVsYXlMZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBkdCA9IC10aGlzLl9zdG9wRGVsYXlMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wRGVsYXlMZWZ0ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RlbGF5RW5kJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl9nZXRTdG9wRHVyYXRpb24oKTtcblxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wUCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BQICs9IGR0IC8gZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcFAgPj0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmlzaGVkITtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wUCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0U3RvcER1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5zdG9wRHVyYXRpb24gfHwgdGhpcy5zZXR0aW5ncy5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBhcHBseSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLlNUT1BQRUQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmYWN0b3IgPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLlNUT1BQSU5HICYmIHRoaXMuc2V0dGluZ3Muc3RvcE1ldGhvZCA9PT0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLkZBREUpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPSAoMSAtIHRoaXMuc2V0dGluZ3Muc3RvcFRpbWluZ0Z1bmN0aW9uSW1wbCh0aGlzLl9zdG9wUCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3MuYXBwbHkodGhpcy5fZWxlbWVudCwgdGhpcy5fcCwgZmFjdG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9zZXR0aW5ncy5yZXNldCh0aGlzLl9lbGVtZW50KTtcbiAgICB9XG5cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG5cbiAgICBnZXQgcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3A7XG4gICAgfVxuXG4gICAgZ2V0IGRlbGF5TGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGF5TGVmdDtcbiAgICB9XG5cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgfVxuXG4gICAgZ2V0IGZyYW1lKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9wICogdGhpcy5fc2V0dGluZ3MuZHVyYXRpb24gKiA2MCk7XG4gICAgfVxuXG4gICAgZ2V0IHNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3M7XG4gICAgfVxuXG59XG5cbkFuaW1hdGlvbi5TVEFURVMgPSB7XG4gICAgSURMRTogMCxcbiAgICBQTEFZSU5HOiAxLFxuICAgIFNUT1BQSU5HOiAyLFxuICAgIFNUT1BQRUQ6IDMsXG4gICAgRklOSVNIRUQ6IDQsXG4gICAgUEFVU0VEOiA1XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25BY3Rpb25TZXR0aW5ncyB7XG5cbiAgICBjb25zdHJ1Y3RvcihhbmltYXRpb25TZXR0aW5ncykge1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU2V0dGluZ3MgPSBhbmltYXRpb25TZXR0aW5ncztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlbGVjdG9yIHRoYXQgc2VsZWN0cyB0aGUgZWxlbWVudHMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RvciA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBpdGVtcywgb3JkZXJlZCBieSBwcm9ncmVzcyBvZmZzZXQuXG4gICAgICAgICAqIEB0eXBlIHtNdWx0aVNwbGluZX1cbiAgICAgICAgICogQHByaXZhdGU7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtcyA9IG5ldyBNdWx0aVNwbGluZSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWZmZWN0ZWQgcHJvcGVydGllcyAocGF0aHMpLlxuICAgICAgICAgKiBAcHJpdmF0ZTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Byb3BzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnR5IHNldHRlcnMsIGluZGV4ZWQgYWNjb3JkaW5nIHRvIHByb3BzLlxuICAgICAgICAgKiBAcHJpdmF0ZTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Byb3BTZXR0ZXJzID0gW107XG5cbiAgICAgICAgdGhpcy5fcmVzZXRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faGFzUmVzZXRWYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2hhc0NvbG9yUHJvcGVydHkgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0UmVzZXRWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc1Jlc2V0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNldFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmdldFZhbHVlKDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXBwbHkoZWxlbWVudCwgcCwgZmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5nZXRBbmltYXRlZEVsZW1lbnRzKGVsZW1lbnQpO1xuXG4gICAgICAgIGxldCB2ID0gdGhpcy5faXRlbXMuZ2V0VmFsdWUocCk7XG5cbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCAhZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmFjdG9yICE9PSAxKSB7XG4gICAgICAgICAgICAvLyBTdG9wIGZhY3Rvci47XG4gICAgICAgICAgICBsZXQgc3YgPSB0aGlzLmdldFJlc2V0VmFsdWUoKTtcblxuICAgICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKHYpICYmIFV0aWxzLmlzTnVtYmVyKHN2KSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0NvbG9yUHJvcGVydHkoKSkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gU3RhZ2VVdGlscy5tZXJnZUNvbG9ycyh2LCBzdiwgZmFjdG9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ID0gU3RhZ2VVdGlscy5tZXJnZU51bWJlcnModiwgc3YsIGZhY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgdHJhbnNmb3JtYXRpb24gdG8gYWxsIGNvbXBvbmVudHMuO1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fcHJvcFNldHRlcnMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IG0gPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BTZXR0ZXJzW2ldKGVsZW1lbnRzW2pdLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBnZXRBbmltYXRlZEVsZW1lbnRzKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuc2VsZWN0KHRoaXMuX3NlbGVjdG9yKTtcbiAgICB9XG5cbiAgICByZXNldChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5nZXRBbmltYXRlZEVsZW1lbnRzKGVsZW1lbnQpO1xuXG4gICAgICAgIGxldCB2ID0gdGhpcy5nZXRSZXNldFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCAhZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSB0cmFuc2Zvcm1hdGlvbiB0byBhbGwgY29tcG9uZW50cy5cbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX3Byb3BTZXR0ZXJzLmxlbmd0aDtcblxuICAgICAgICBjb25zdCBtID0gZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wU2V0dGVyc1tpXShlbGVtZW50c1tqXSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2V0IHNlbGVjdG9yKHYpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSB2O1xuICAgIH1cblxuICAgIHNldCB0KHYpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHJlc2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNldFZhbHVlO1xuICAgIH1cbiAgICBcbiAgICBzZXQgcmVzZXRWYWx1ZSh2KSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0VmFsdWUgPSB2O1xuICAgICAgICB0aGlzLl9oYXNSZXNldFZhbHVlID0gKHYgIT09IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgc2V0IHJ2KHYpIHtcbiAgICAgICAgdGhpcy5yZXNldFZhbHVlID0gdjtcbiAgICB9XG5cbiAgICBzZXQgdmFsdWUodikge1xuICAgICAgICB0aGlzLl9pdGVtcy5wYXJzZSh0aGlzLmhhc0NvbG9yUHJvcGVydHkoKSwgdik7XG4gICAgfVxuXG4gICAgc2V0IHYodikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdjtcbiAgICB9XG5cbiAgICBzZXQgcHJvcGVydGllcyh2KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgdiA9IFt2XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Byb3BzID0gW107XG5cbiAgICAgICAgdi5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9wcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgdGhpcy5fcHJvcFNldHRlcnMucHVzaChFbGVtZW50LmdldFNldHRlcihwcm9wKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldCBwcm9wZXJ0eSh2KSB7XG4gICAgICAgIHRoaXMuX2hhc0NvbG9yUHJvcGVydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHY7XG4gICAgfVxuXG4gICAgc2V0IHAodikge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB2O1xuICAgIH1cblxuICAgIHBhdGNoKHNldHRpbmdzKSB7XG4gICAgICAgIEJhc2UucGF0Y2hPYmplY3QodGhpcywgc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGhhc0NvbG9yUHJvcGVydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNDb2xvclByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc0NvbG9yUHJvcGVydHkgPSB0aGlzLl9wcm9wcy5sZW5ndGggPyBFbGVtZW50LmlzQ29sb3JQcm9wZXJ0eSh0aGlzLl9wcm9wc1swXSkgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGFzQ29sb3JQcm9wZXJ0eTtcbiAgICB9XG59XG5cbkFuaW1hdGlvbkFjdGlvblNldHRpbmdzLnByb3RvdHlwZS5pc0FuaW1hdGlvbkFjdGlvblNldHRpbmdzID0gdHJ1ZTtcblxuaW1wb3J0IE11bHRpU3BsaW5lIGZyb20gXCIuLi90b29scy9NdWx0aVNwbGluZS5tanNcIjtcbmltcG9ydCBFbGVtZW50IGZyb20gXCIuLi90cmVlL0VsZW1lbnQubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuaW1wb3J0IEJhc2UgZnJvbSBcIi4uL3RyZWUvQmFzZS5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbk1hbmFnZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuXG4gICAgICAgIHRoaXMuc3RhZ2Uub24oJ2ZyYW1lU3RhcnQnLCAoKSA9PiB0aGlzLnByb2dyZXNzKCkpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgcnVubmluZyBhbmltYXRpb25zIG9uIGF0dGFjaGVkIHN1YmplY3RzLlxuICAgICAgICAgKiBAdHlwZSB7U2V0PEFuaW1hdGlvbj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICBwcm9ncmVzcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlLnNpemUpIHtcbiAgICAgICAgICAgIGxldCBkdCA9IHRoaXMuc3RhZ2UuZHQ7XG5cbiAgICAgICAgICAgIGxldCBmaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgIGlmIChhLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wcm9ncmVzcyhkdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gbmV3IFNldChbLi4udGhpcy5hY3RpdmVdLmZpbHRlcih0ID0+IHQuaXNBY3RpdmUoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlQW5pbWF0aW9uKGVsZW1lbnQsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwoc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHBsYWluIG9iamVjdCB0byBwcm9wZXIgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLmNyZWF0ZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHNldHRpbmdzLFxuICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNyZWF0ZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvblNldHRpbmdzID0gbmV3IEFuaW1hdGlvblNldHRpbmdzKCk7XG4gICAgICAgIEJhc2UucGF0Y2hPYmplY3QoYW5pbWF0aW9uU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvblNldHRpbmdzO1xuICAgIH1cblxuICAgIGFkZEFjdGl2ZSh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlLmFkZCh0cmFuc2l0aW9uKTtcbiAgICB9XG59XG5cbmltcG9ydCBCYXNlIGZyb20gXCIuLi90cmVlL0Jhc2UubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG5pbXBvcnQgQW5pbWF0aW9uU2V0dGluZ3MgZnJvbSBcIi4vQW5pbWF0aW9uU2V0dGluZ3MubWpzXCI7XG5pbXBvcnQgQW5pbWF0aW9uIGZyb20gXCIuL0FuaW1hdGlvbi5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgQW5pbWF0aW9uQWN0aW9uU2V0dGluZ3MgZnJvbSBcIi4vQW5pbWF0aW9uQWN0aW9uU2V0dGluZ3MubWpzXCI7XG5pbXBvcnQgQmFzZSBmcm9tIFwiLi4vdHJlZS9CYXNlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25TZXR0aW5ncyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QW5pbWF0aW9uQWN0aW9uU2V0dGluZ3NbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FjdGlvbnMgPSBbXTtcblxuICAgICAgICB0aGlzLmRlbGF5ID0gMDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDE7XG5cbiAgICAgICAgdGhpcy5yZXBlYXQgPSAwO1xuICAgICAgICB0aGlzLnJlcGVhdE9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMucmVwZWF0RGVsYXkgPSAwO1xuXG4gICAgICAgIHRoaXMuYXV0b3N0b3AgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnN0b3BNZXRob2QgPSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuRkFERTtcbiAgICAgICAgdGhpcy5fc3RvcFRpbWluZ0Z1bmN0aW9uID0gJ2Vhc2UnO1xuICAgICAgICB0aGlzLl9zdG9wVGltaW5nRnVuY3Rpb25JbXBsID0gU3RhZ2VVdGlscy5nZXRUaW1pbmdGdW5jdGlvbih0aGlzLl9zdG9wVGltaW5nRnVuY3Rpb24pO1xuICAgICAgICB0aGlzLnN0b3BEdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuc3RvcERlbGF5ID0gMDtcbiAgICB9XG5cbiAgICBnZXQgYWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnM7XG4gICAgfVxuXG4gICAgc2V0IGFjdGlvbnModikge1xuICAgICAgICB0aGlzLl9hY3Rpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSB2W2ldO1xuICAgICAgICAgICAgaWYgKCFlLmlzQW5pbWF0aW9uQWN0aW9uU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhYXMgPSBuZXcgQW5pbWF0aW9uQWN0aW9uU2V0dGluZ3ModGhpcyk7XG4gICAgICAgICAgICAgICAgYWFzLnBhdGNoKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMucHVzaChhYXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBhbmltYXRpb24gdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LCBmb3IgdGhlIHNwZWNpZmllZCBwcm9ncmVzcyBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50O1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwO1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3I7XG4gICAgICovXG4gICAgYXBwbHkoZWxlbWVudCwgcCwgZmFjdG9yID0gMSkge1xuICAgICAgICB0aGlzLl9hY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICBhY3Rpb24uYXBwbHkoZWxlbWVudCwgcCwgZmFjdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBhbmltYXRpb24gdG8gdGhlIHJlc2V0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQ7XG4gICAgICovXG4gICAgcmVzZXQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9hY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICBhY3Rpb24ucmVzZXQoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCBzdG9wVGltaW5nRnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltaW5nRnVuY3Rpb247XG4gICAgfVxuXG4gICAgc2V0IHN0b3BUaW1pbmdGdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX3N0b3BUaW1pbmdGdW5jdGlvbiA9IHY7XG4gICAgICAgIHRoaXMuX3N0b3BUaW1pbmdGdW5jdGlvbkltcGwgPSBTdGFnZVV0aWxzLmdldFRpbWluZ0Z1bmN0aW9uKHYpO1xuICAgIH1cblxuICAgIGdldCBzdG9wVGltaW5nRnVuY3Rpb25JbXBsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcFRpbWluZ0Z1bmN0aW9uSW1wbDtcbiAgICB9XG5cbiAgICBwYXRjaChzZXR0aW5ncykge1xuICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRoaXMsIHNldHRpbmdzKTtcbiAgICB9XG5cbn1cblxuQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTID0ge1xuICAgIEZBREU6ICdmYWRlJyxcbiAgICBSRVZFUlNFOiAncmV2ZXJzZScsXG4gICAgRk9SV0FSRDogJ2ZvcndhcmQnLFxuICAgIElNTUVESUFURTogJ2ltbWVkaWF0ZScsXG4gICAgT05FVE9UV086ICdvbmV0b3R3bydcbn07XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50RW1pdHRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNpdGlvbiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBzZXR0aW5ncywgZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuXG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gc2V0dGluZ3M7XG5cbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy5fZ2V0dGVyID0gZWxlbWVudC5jb25zdHJ1Y3Rvci5nZXRHZXR0ZXIocHJvcGVydHkpO1xuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBlbGVtZW50LmNvbnN0cnVjdG9yLmdldFNldHRlcihwcm9wZXJ0eSk7XG5cbiAgICAgICAgdGhpcy5fbWVyZ2VyID0gc2V0dGluZ3MubWVyZ2VyO1xuXG4gICAgICAgIGlmICghdGhpcy5fbWVyZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZXIgPSBlbGVtZW50LmNvbnN0cnVjdG9yLmdldE1lcmdlcihwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICB0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX3N0YXJ0VmFsdWU7XG5cbiAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgIHRoaXMuX2RlbGF5TGVmdCA9IDA7XG4gICAgfVxuXG4gICAgc3RhcnQodGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl9lbGVtZW50KTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHRyYW5zaXRpb25zIG9uIG5vbi1hdHRhY2hlZCBlbGVtZW50cy4gSnVzdCBzZXQgdmFsdWUgd2l0aG91dCBpbnZva2luZyBsaXN0ZW5lcnMuXG4gICAgICAgICAgICB0aGlzLl90YXJnZXRWYWx1ZSA9IHRhcmdldFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEcmF3VmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRWYWx1ZSA9PT0gdGhpcy5fc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQodGFyZ2V0VmFsdWUsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRWYWx1ZSA9IHRhcmdldFZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGF5TGVmdCA9IHRoaXMuX3NldHRpbmdzLmRlbGF5O1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5fcCA8IDEpIHtcbiAgICAgICAgICAgIC8vIFZhbHVlIHNldHRpbmcgYW5kIHdpbGwgbXVzdCBiZSBpbnZva2VkIChhc3luYykgdXBvbiBuZXh0IHRyYW5zaXRpb24gY3ljbGUuXG4gICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIC8vIEp1c3Qgc3RvcCB3aGVyZSB0aGUgdHJhbnNpdGlvbiBpcyBhdC5cbiAgICAgICAgdGhpcy5lbWl0KCdzdG9wJyk7XG4gICAgICAgIHRoaXMubWFuYWdlci5yZW1vdmVBY3RpdmUodGhpcyk7XG4gICAgfVxuXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cblxuICAgIHBsYXkoKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5hZGRBY3RpdmUodGhpcyk7XG4gICAgfVxuXG4gICAgcmVzZXQodGFyZ2V0VmFsdWUsIHApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCB0cmFuc2l0aW9ucyBvbiBub24tYXR0YWNoZWQgZWxlbWVudHMuIEp1c3Qgc2V0IHZhbHVlIHdpdGhvdXQgaW52b2tpbmcgbGlzdGVuZXJzLlxuICAgICAgICAgICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFZhbHVlID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURyYXdWYWx1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFZhbHVlID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9wID0gcDtcbiAgICAgICAgICAgIHRoaXMuYWRkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlRHJhd1ZhbHVlKCkge1xuICAgICAgICB0aGlzLl9zZXR0ZXIodGhpcy5fZWxlbWVudCwgdGhpcy5nZXREcmF3VmFsdWUoKSk7XG4gICAgfVxuXG4gICAgYWRkKCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuYWRkQWN0aXZlKHRoaXMpO1xuICAgIH1cblxuICAgIGlzQXR0YWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmF0dGFjaGVkO1xuICAgIH1cblxuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9wIDwgMS4wKTtcbiAgICB9XG5cbiAgICBwcm9ncmVzcyhkdCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHRvIGVuZCBvZiB0cmFuc2l0aW9uIHNvIHRoYXQgaXQgaXMgcmVtb3ZlZC5cbiAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucCA8IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGF5TGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWxheUxlZnQgLT0gZHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxheUxlZnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGR0ID0gLXRoaXMuZGVsYXlMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWxheUxlZnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVsYXlFbmQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuZHVyYXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wICs9IGR0IC8gdGhpcy5fc2V0dGluZ3MuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluaXNoZWQhO1xuICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlRHJhd1ZhbHVlKCk7XG5cbiAgICAgICAgdGhpcy5pbnZva2VMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBpbnZva2VMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLnApO1xuICAgICAgICBpZiAodGhpcy5wID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlVGFyZ2V0VmFsdWUodGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzLl9zZXR0aW5ncy50aW1pbmdGdW5jdGlvbkltcGwodGhpcy5wKTtcbiAgICAgICAgaWYgKHQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFZhbHVlID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMuX3RhcmdldFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0VmFsdWUgPSB0YXJnZXRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0YXJnZXRWYWx1ZSAtICgodGFyZ2V0VmFsdWUgLSB0aGlzLl90YXJnZXRWYWx1ZSkgLyAoMSAtIHQpKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFZhbHVlID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXREcmF3VmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnAgPj0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgdiA9IHRoaXMuX3NldHRpbmdzLl90aW1pbmdGdW5jdGlvbkltcGwodGhpcy5wKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZXIodGhpcy50YXJnZXRWYWx1ZSwgdGhpcy5zdGFydFZhbHVlLCB2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNraXBEZWxheSgpIHtcbiAgICAgICAgdGhpcy5fZGVsYXlMZWZ0ID0gMDtcbiAgICB9XG5cbiAgICBnZXQgc3RhcnRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0VmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHRhcmdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0VmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wO1xuICAgIH1cblxuICAgIGdldCBkZWxheUxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxheUxlZnQ7XG4gICAgfVxuXG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgIH1cblxuICAgIGdldCBzZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xuICAgIH1cblxuICAgIHNldCBzZXR0aW5ncyh2KSB7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gdjtcbiAgICB9XG5cbn1cblxuVHJhbnNpdGlvbi5wcm90b3R5cGUuaXNUcmFuc2l0aW9uID0gdHJ1ZTtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zaXRpb25NYW5hZ2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcblxuICAgICAgICB0aGlzLnN0YWdlLm9uKCdmcmFtZVN0YXJ0JywgKCkgPT4gdGhpcy5wcm9ncmVzcygpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHRyYW5zaXRpb25zIHRoYXQgYXJlIHJ1bm5pbmcgYW5kIGF0dGFjaGVkLlxuICAgICAgICAgKiAod2UgZG9uJ3Qgc3VwcG9ydCB0cmFuc2l0aW9ucyBvbiB1bi1hdHRhY2hlZCBlbGVtZW50cyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcylcbiAgICAgICAgICogQHR5cGUge1NldDxUcmFuc2l0aW9uPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlID0gbmV3IFNldCgpO1xuXG4gICAgICAgIHRoaXMuZGVmYXVsdFRyYW5zaXRpb25TZXR0aW5ncyA9IG5ldyBUcmFuc2l0aW9uU2V0dGluZ3ModGhpcy5zdGFnZSk7XG4gICAgfVxuXG4gICAgcHJvZ3Jlc3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZS5zaXplKSB7XG4gICAgICAgICAgICBsZXQgZHQgPSB0aGlzLnN0YWdlLmR0O1xuXG4gICAgICAgICAgICBsZXQgZmlsdGVyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICBhLnByb2dyZXNzKGR0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWEuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gbmV3IFNldChbLi4udGhpcy5hY3RpdmVdLmZpbHRlcih0ID0+ICh0LmlzUnVubmluZygpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvblNldHRpbmdzID0gbmV3IFRyYW5zaXRpb25TZXR0aW5ncygpO1xuICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRyYW5zaXRpb25TZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICByZXR1cm4gdHJhbnNpdGlvblNldHRpbmdzO1xuICAgIH1cblxuICAgIGFkZEFjdGl2ZSh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlLmFkZCh0cmFuc2l0aW9uKTtcbiAgICB9XG5cbiAgICByZW1vdmVBY3RpdmUodHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLmFjdGl2ZS5kZWxldGUodHJhbnNpdGlvbik7XG4gICAgfVxufVxuXG5pbXBvcnQgQmFzZSBmcm9tIFwiLi4vdHJlZS9CYXNlLm1qc1wiO1xuaW1wb3J0IFRyYW5zaXRpb25TZXR0aW5ncyBmcm9tIFwiLi9UcmFuc2l0aW9uU2V0dGluZ3MubWpzXCI7XG5pbXBvcnQgVHJhbnNpdGlvbiBmcm9tIFwiLi9UcmFuc2l0aW9uLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBCYXNlIGZyb20gXCIuLi90cmVlL0Jhc2UubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zaXRpb25TZXR0aW5ncyB7XG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICAgICAgICB0aGlzLl90aW1pbmdGdW5jdGlvbiA9ICdlYXNlJztcbiAgICAgICAgdGhpcy5fdGltaW5nRnVuY3Rpb25JbXBsID0gU3RhZ2VVdGlscy5nZXRUaW1pbmdGdW5jdGlvbih0aGlzLl90aW1pbmdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMC4yO1xuICAgICAgICB0aGlzLm1lcmdlciA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRpbWluZ0Z1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltaW5nRnVuY3Rpb247XG4gICAgfVxuXG4gICAgc2V0IHRpbWluZ0Z1bmN0aW9uKHYpIHtcbiAgICAgICAgdGhpcy5fdGltaW5nRnVuY3Rpb24gPSB2O1xuICAgICAgICB0aGlzLl90aW1pbmdGdW5jdGlvbkltcGwgPSBTdGFnZVV0aWxzLmdldFRpbWluZ0Z1bmN0aW9uKHYpO1xuICAgIH1cblxuICAgIGdldCB0aW1pbmdGdW5jdGlvbkltcGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW1pbmdGdW5jdGlvbkltcGw7XG4gICAgfVxuXG4gICAgcGF0Y2goc2V0dGluZ3MpIHtcbiAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgfVxufVxuXG5UcmFuc2l0aW9uU2V0dGluZ3MucHJvdG90eXBlLmlzVHJhbnNpdGlvblNldHRpbmdzID0gdHJ1ZTtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9Db21wb25lbnQubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFwcGxpY2F0aW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgcHJvcGVydGllcykge1xuICAgICAgICAvLyBTYXZlIG9wdGlvbnMgdGVtcG9yYXJpbHkgdG8gYXZvaWQgaGF2aW5nIHRvIHBhc3MgaXQgdGhyb3VnaCB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgIEFwcGxpY2F0aW9uLl90ZW1wX29wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIC8vIEJvb3RpbmcgZmxhZyBpcyB1c2VkIHRvIHBvc3Rwb25lIHVwZGF0ZUZvY3VzU2V0dGluZ3M7XG4gICAgICAgIEFwcGxpY2F0aW9uLmJvb3RpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCBzdGFnZSA9IG5ldyBTdGFnZShvcHRpb25zLnN0YWdlKTtcbiAgICAgICAgc3VwZXIoc3RhZ2UsIHByb3BlcnRpZXMpO1xuICAgICAgICBBcHBsaWNhdGlvbi5ib290aW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fX3VwZGF0ZUZvY3VzQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX19rZXlwcmVzc1RpbWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fX2hvdmVyZWRDaGlsZCA9IG51bGw7XG5cbiAgICAgICAgLy8gV2UgbXVzdCBjb25zdHJ1Y3Qgd2hpbGUgdGhlIGFwcGxpY2F0aW9uIGlzIG5vdCB5ZXQgYXR0YWNoZWQuXG4gICAgICAgIC8vIFRoYXQncyB3aHkgd2UgJ2luaXQnIHRoZSBzdGFnZSBsYXRlciAod2hpY2ggYWN0dWFsbHkgZW1pdHMgdGhlIGF0dGFjaCBldmVudCkuXG4gICAgICAgIHRoaXMuc3RhZ2UuaW5pdCgpO1xuXG4gICAgICAgIC8vIEluaXRpYWxseSwgdGhlIGZvY3VzIHNldHRpbmdzIGFyZSB1cGRhdGVkIGFmdGVyIGJvdGggdGhlIHN0YWdlIGFuZCBhcHBsaWNhdGlvbiBhcmUgY29uc3RydWN0ZWQuXG4gICAgICAgIHRoaXMudXBkYXRlRm9jdXNTZXR0aW5ncygpO1xuXG4gICAgICAgIHRoaXMuX19rZXltYXAgPSB0aGlzLmdldE9wdGlvbigna2V5cycpO1xuXG4gICAgICAgIGlmICh0aGlzLl9fa2V5bWFwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLnBsYXRmb3JtLnJlZ2lzdGVyS2V5ZG93bkhhbmRsZXIoKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNlaXZlS2V5ZG93bihlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnN0YWdlLnBsYXRmb3JtLnJlZ2lzdGVyS2V5dXBIYW5kbGVyKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjZWl2ZUtleXVwKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb24oXCJlbmFibGVQb2ludGVyXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLnBsYXRmb3JtLnJlZ2lzdGVyQ2xpY2tIYW5kbGVyKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjZWl2ZUNsaWNrKGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhZ2UucGxhdGZvcm0ucmVnaXN0ZXJIb3ZlckhhbmRsZXIoKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNlaXZlSG92ZXIoZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5zdGFnZS5wbGF0Zm9ybS5yZWdpc3RlclNjcm9sbFdoZWVsSGFuZGxlcigoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY2lldmVTY3JvbGxXaGVlbChlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb3B0aW9uc1tuYW1lXTtcbiAgICB9XG5cbiAgICBfc2V0T3B0aW9ucyhvKSB7XG4gICAgICAgIHRoaXMuX19vcHRpb25zID0ge307XG5cbiAgICAgICAgbGV0IG9wdCA9IChuYW1lLCBkZWYpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9bbmFtZV07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX29wdGlvbnNbbmFtZV0gPSBkZWY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX19vcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHQoJ2RlYnVnJywgZmFsc2UpO1xuICAgICAgICBvcHQoJ2tleXMnLCB7XG4gICAgICAgICAgICAzODogXCJVcFwiLFxuICAgICAgICAgICAgNDA6IFwiRG93blwiLFxuICAgICAgICAgICAgMzc6IFwiTGVmdFwiLFxuICAgICAgICAgICAgMzk6IFwiUmlnaHRcIixcbiAgICAgICAgICAgIDEzOiBcIkVudGVyXCIsXG4gICAgICAgICAgICA4OiBcIkJhY2tcIixcbiAgICAgICAgICAgIDI3OiBcIkV4aXRcIlxuICAgICAgICB9KTtcbiAgICAgICAgb3B0KCdlbmFibGVQb2ludGVyJywgZmFsc2UpO1xuICAgIH1cblxuICAgIF9fY29uc3RydWN0KCkge1xuICAgICAgICB0aGlzLnN0YWdlLnNldEFwcGxpY2F0aW9uKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3NldE9wdGlvbnMoQXBwbGljYXRpb24uX3RlbXBfb3B0aW9ucyk7XG4gICAgICAgIGRlbGV0ZSBBcHBsaWNhdGlvbi5fdGVtcF9vcHRpb25zO1xuXG4gICAgICAgIHN1cGVyLl9fY29uc3RydWN0KCk7XG4gICAgfVxuXG4gICAgX19pbml0KCkge1xuICAgICAgICBzdXBlci5fX2luaXQoKTtcbiAgICAgICAgdGhpcy5fX3VwZGF0ZUZvY3VzKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRm9jdXNQYXRoKCkge1xuICAgICAgICB0aGlzLl9fdXBkYXRlRm9jdXMoKTtcbiAgICB9XG5cbiAgICBfX3VwZGF0ZUZvY3VzKCkge1xuICAgICAgICBjb25zdCBub3RPdmVycmlkZGVuID0gdGhpcy5fX3VwZGF0ZUZvY3VzUmVjKCk7XG5cbiAgICAgICAgaWYgKCFBcHBsaWNhdGlvbi5ib290aW5nICYmIG5vdE92ZXJyaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9jdXNTZXR0aW5ncygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX191cGRhdGVGb2N1c1JlYygpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlRm9jdXNJZCA9ICsrdGhpcy5fX3VwZGF0ZUZvY3VzQ291bnRlcjtcbiAgICAgICAgdGhpcy5fX3VwZGF0ZUZvY3VzSWQgPSB1cGRhdGVGb2N1c0lkO1xuXG4gICAgICAgIGNvbnN0IG5ld0ZvY3VzUGF0aCA9IHRoaXMuX19nZXRGb2N1c1BhdGgoKTtcbiAgICAgICAgY29uc3QgbmV3Rm9jdXNlZENvbXBvbmVudCA9IG5ld0ZvY3VzUGF0aFtuZXdGb2N1c1BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHByZXZGb2N1c2VkQ29tcG9uZW50ID0gdGhpcy5fZm9jdXNQYXRoID8gdGhpcy5fZm9jdXNQYXRoW3RoaXMuX2ZvY3VzUGF0aC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoIXByZXZGb2N1c2VkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBGb2N1cyBldmVudHMuXG4gICAgICAgICAgICB0aGlzLl9mb2N1c1BhdGggPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmV3Rm9jdXNQYXRoLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUGF0aC5wdXNoKG5ld0ZvY3VzUGF0aFtpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNQYXRoW2ldLl9mb2N1cyhuZXdGb2N1c2VkQ29tcG9uZW50LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzT3ZlcnJpZGRlbiA9ICh0aGlzLl9fdXBkYXRlRm9jdXNJZCAhPT0gdXBkYXRlRm9jdXNJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzT3ZlcnJpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbSA9IE1hdGgubWluKHRoaXMuX2ZvY3VzUGF0aC5sZW5ndGgsIG5ld0ZvY3VzUGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbTsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mb2N1c1BhdGhbaW5kZXhdICE9PSBuZXdGb2N1c1BhdGhbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzUGF0aC5sZW5ndGggIT09IG5ld0ZvY3VzUGF0aC5sZW5ndGggfHwgaW5kZXggIT09IG5ld0ZvY3VzUGF0aC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldE9wdGlvbignZGVidWcnKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0xpZ2h0bmluZ10gRm9jdXMgY2hhbmdlZDogJyArIG5ld0ZvY3VzZWRDb21wb25lbnQuZ2V0TG9jYXRpb25TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVW5mb2N1cyBldmVudHMuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2ZvY3VzUGF0aC5sZW5ndGggLSAxOyBpID49IGluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5mb2N1c2VkRWxlbWVudCA9IHRoaXMuX2ZvY3VzUGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdW5mb2N1c2VkRWxlbWVudC5fdW5mb2N1cyhuZXdGb2N1c2VkQ29tcG9uZW50LCBwcmV2Rm9jdXNlZENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzT3ZlcnJpZGRlbiA9ICh0aGlzLl9fdXBkYXRlRm9jdXNJZCAhPT0gdXBkYXRlRm9jdXNJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2N1c092ZXJyaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZvY3VzIGV2ZW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXgsIG4gPSBuZXdGb2N1c1BhdGgubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUGF0aC5wdXNoKG5ld0ZvY3VzUGF0aFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUGF0aFtpXS5fZm9jdXMobmV3Rm9jdXNlZENvbXBvbmVudCwgcHJldkZvY3VzZWRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb2N1c092ZXJyaWRkZW4gPSAodGhpcy5fX3VwZGF0ZUZvY3VzSWQgIT09IHVwZGF0ZUZvY3VzSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNPdmVycmlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGb2N1cyBjaGFuZ2VkIGV2ZW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNQYXRoW2ldLl9mb2N1c0NoYW5nZShuZXdGb2N1c2VkQ29tcG9uZW50LCBwcmV2Rm9jdXNlZENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdXBkYXRlRm9jdXNTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZENvbXBvbmVudCA9IHRoaXMuX2ZvY3VzUGF0aFt0aGlzLl9mb2N1c1BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgLy8gR2V0IGZvY3VzIHNldHRpbmdzLiBUaGVzZSBjYW4gYmUgdXNlZCBmb3IgZHluYW1pYyBhcHBsaWNhdGlvbi13aWRlIHNldHRpbmdzIHRoYXQgZGVwZW5kIG9uIHRoZVxuICAgICAgICAvLyBmb2N1cyBkaXJlY3RseSAoc3VjaCBhcyB0aGUgYXBwbGljYXRpb24gYmFja2dyb3VuZCkuXG4gICAgICAgIGNvbnN0IGZvY3VzU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFNldEZvY3VzU2V0dGluZ3MgPSBDb21wb25lbnQucHJvdG90eXBlLl9zZXRGb2N1c1NldHRpbmdzO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2ZvY3VzUGF0aC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9mb2N1c1BhdGhbaV0uX3NldEZvY3VzU2V0dGluZ3MgIT09IGRlZmF1bHRTZXRGb2N1c1NldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNQYXRoW2ldLl9zZXRGb2N1c1NldHRpbmdzKGZvY3VzU2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVmYXVsdEhhbmRsZUZvY3VzU2V0dGluZ3MgPSBDb21wb25lbnQucHJvdG90eXBlLl9oYW5kbGVGb2N1c1NldHRpbmdzO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2ZvY3VzUGF0aC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9mb2N1c1BhdGhbaV0uX2hhbmRsZUZvY3VzU2V0dGluZ3MgIT09IGRlZmF1bHRIYW5kbGVGb2N1c1NldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNQYXRoW2ldLl9oYW5kbGVGb2N1c1NldHRpbmdzKGZvY3VzU2V0dGluZ3MsIHRoaXMuX19wcmV2Rm9jdXNTZXR0aW5ncywgZm9jdXNlZENvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fcHJldkZvY3VzU2V0dGluZ3MgPSBmb2N1c1NldHRpbmdzO1xuICAgIH1cblxuICAgIF9oYW5kbGVGb2N1c1NldHRpbmdzKHNldHRpbmdzLCBwcmV2U2V0dGluZ3MsIGZvY3VzZWQsIHByZXZGb2N1c2VkKSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRvIGhhbmRsZSBmb2N1cy1iYXNlZCBzZXR0aW5ncy5cbiAgICB9XG5cbiAgICBfX2dldEZvY3VzUGF0aCgpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFt0aGlzXTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Rm9jdXMgPSBjdXJyZW50Ll9nZXRGb2N1c2VkKCk7XG4gICAgICAgICAgICBpZiAoIW5leHRGb2N1cyB8fCAobmV4dEZvY3VzID09PSBjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kITtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBsZXQgcHRyID0gbmV4dEZvY3VzLmNwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocHRyID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5leHRGb2N1cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBhbiBpbW1lZGlhdGUgY2hpbGQ6IGluY2x1ZGUgZnVsbCBwYXRoIHRvIGRlc2NlbmRhbnQuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UGFydHMgPSBbbmV4dEZvY3VzXTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Ll90aHJvd0Vycm9yKFwiUmV0dXJuIHZhbHVlIGZvciBfZ2V0Rm9jdXNlZCBtdXN0IGJlIGFuIGF0dGFjaGVkIGRlc2NlbmRhbnQgY29tcG9uZW50IGJ1dCBpdHMgJ1wiICsgbmV4dEZvY3VzLmdldExvY2F0aW9uU3RyaW5nKCkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3UGFydHMucHVzaChwdHIpO1xuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIuY3BhcmVudDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChwdHIgIT09IGN1cnJlbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZW0gcmV2ZXJzZWQuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBuZXdQYXJ0cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5ld1BhcnRzW24gLSBpIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudCA9IG5leHRGb2N1cztcbiAgICAgICAgfSB3aGlsZSh0cnVlKTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICBnZXQgZm9jdXNQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9jdXNQYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluamVjdHMgYW4gZXZlbnQgaW4gdGhlIHN0YXRlIG1hY2hpbmVzLCB0b3AtZG93biBmcm9tIGFwcGxpY2F0aW9uIHRvIGZvY3VzZWQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGZvY3VzVG9wRG93bkV2ZW50KGV2ZW50cywgLi4uYXJncykge1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5mb2N1c1BhdGg7XG4gICAgICAgIGNvbnN0IG4gPSBwYXRoLmxlbmd0aDtcblxuICAgICAgICAvLyBNdWx0aXBsZSBldmVudHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHBhdGhbaV0uX2dldE1vc3RTcGVjaWZpY0hhbmRsZWRNZW1iZXIoZXZlbnRzKTtcbiAgICAgICAgICAgIGlmIChldmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBwYXRoW2ldW2V2ZW50XSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmplY3RzIGFuIGV2ZW50IGluIHRoZSBzdGF0ZSBtYWNoaW5lcywgYm90dG9tLXVwIGZyb20gZm9jdXNlZCBjb21wb25lbnQgdG8gYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgZm9jdXNCb3R0b21VcEV2ZW50KGV2ZW50cywgLi4uYXJncykge1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5mb2N1c1BhdGg7XG4gICAgICAgIGNvbnN0IG4gPSBwYXRoLmxlbmd0aDtcblxuICAgICAgICAvLyBNdWx0aXBsZSBldmVudHMuXG4gICAgICAgIGZvciAobGV0IGkgPSBuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gcGF0aFtpXS5fZ2V0TW9zdFNwZWNpZmljSGFuZGxlZE1lbWJlcihldmVudHMpO1xuICAgICAgICAgICAgaWYgKGV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IHBhdGhbaV1bZXZlbnRdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIF9yZWNlaXZlS2V5ZG93bihlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGU7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXltYXBbZS5rZXlDb2RlXTtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZm9jdXNQYXRoO1xuXG4gICAgICAgIGxldCBrZXlzO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBrZXlzID0gQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDogW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1RpbWVyID0gdGhpcy5fX2tleXByZXNzVGltZXJzLmhhcyhrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGV2ZW50IGZyb20gZ2V0dGluZyBmaXJlZCB3aGVuIHRoZSB0aW1lb3V0IGlzIHN0aWxsIGFjdGl2ZVxuICAgICAgICAgICAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0ubG9uZ3ByZXNzICYmIGhhc1RpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZm9jdXNUb3BEb3duRXZlbnQoW2BfY2FwdHVyZSR7a2V5c1tpXX1gLCBcIl9jYXB0dXJlS2V5XCJdLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZm9jdXNCb3R0b21VcEV2ZW50KFtgX2hhbmRsZSR7a2V5c1tpXX1gLCBcIl9oYW5kbGVLZXlcIl0sIG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZvY3VzVG9wRG93bkV2ZW50KFtcIl9jYXB0dXJlS2V5XCJdLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5mb2N1c0JvdHRvbVVwRXZlbnQoW1wiX2hhbmRsZUtleVwiXSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlRm9jdXNQYXRoKCk7XG5cbiAgICAgICAgY29uc3QgY29uc3VtZXIgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGtleXMgJiYgY29uc3VtZXIubG9uZ3ByZXNzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRMb25ncHJlc3NUaW1lcihrZXlzW2ldLCBjb25zdW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBLZXl1cCBsaXN0ZW5lclxuICAgICAqIFRvIHRha2UgYXdheSBzb21lIGNvbmZ1c2lvbiB3ZSBhZGQgYFJlbGVhc2VgIHRvIHRoZSBldmVudCB0byBwcmV2ZW50IGVuZGluZyB1cCB3aXRoIG1ldGhvZCBuYW1lcyBsaWtlOlxuICAgICAqICBfaGFuZGxlTGVmdFVwIC8gX2hhbmRsZVVwVXAgLyBfaGFuZGxlRW50ZXJVcCBldGNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVjZWl2ZUtleXVwKGUpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZTtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleW1hcFtlLmtleUNvZGVdO1xuXG4gICAgICAgIGxldCBrZXlzO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBrZXlzID0gQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDogW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5mb2N1c1RvcERvd25FdmVudChbYF9jYXB0dXJlJHtrZXlzW2ldfVJlbGVhc2VgLCBcIl9jYXB0dXJlS2V5UmVsZWFzZVwiXSwgb2JqKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZvY3VzQm90dG9tVXBFdmVudChbYF9oYW5kbGUke2tleXNbaV19UmVsZWFzZWAsIFwiX2hhbmRsZUtleVJlbGVhc2VcIl0sIG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZvY3VzVG9wRG93bkV2ZW50KFtcIl9jYXB0dXJlS2V5UmVsZWFzZVwiXSwgb2JqKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZm9jdXNCb3R0b21VcEV2ZW50KFtcIl9oYW5kbGVLZXlSZWxlYXNlXCJdLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVGb2N1c1BhdGgoKTtcblxuICAgICAgICBpZiAoa2V5cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fa2V5cHJlc3NUaW1lcnMuaGFzKGtleXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtleXVwIGhhcyBmaXJlZCBiZWZvcmUgZW5kIG9mIHRpbWVvdXQgc28gd2UgY2xlYXIgaXRcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX19rZXlwcmVzc1RpbWVycy5nZXQoa2V5c1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgc28gd2UgY2FuIHJlZ2lzdGVyIGl0IGFnYWluXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19rZXlwcmVzc1RpbWVycy5kZWxldGUoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuZCBzdGFydHMgYSB0aW1lciBmb3IgdGhlIHByZXNzZWQga2V5LiBUaW1lciB3aWxsIGJlIGNsZWFyZWQgd2hlbiB0aGUga2V5IGlzIHJlbGVhc2VkXG4gICAgICogYmVmb3JlIHRoZSB0aW1lciBnb2VzIG9mZi5cbiAgICAgKlxuICAgICAqIElmIGtleSBpcyBub3QgcmVsZWFzZSAoa2V5dXApIHRoZSBsb25ncHJlc3MgaGFuZGxlciB3aWxsIGJlIGZpcmVkLlxuICAgICAqIENvbmZpZ3VyYXRpb24gY2FuIGJlIHZpYSB0aGUgQ29tcG9uZW50cyB0ZW1wbGF0ZTpcbiAgICAgKlxuICAgICAqIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgICogICAgIHJldHVybiB7XG4gICAgICogICAgICAgICB3OjEwMCwgaDoxMDAsXG4gICAgICogICAgICAgICBsb25ncHJlc3M6e3VwOjcwMCwgZG93bjo1MDB9XG4gICAgICogICAgIH1cbiAgICAgKiB9ICAgICAqXG4gICAgICogLy8gdGhpcyB3aWxsIGdldCBjYWxsZWQgd2hlbiB1cCBoYXMgYmVlbiBwcmVzc2VkIGZvciA3MDBtc1xuICAgICAqIF9oYW5kbGVVcExvbmcoKSB7XG4gICAgICpcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zdGFydExvbmdwcmVzc1RpbWVyKGtleSwgZWxlbWVudCkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbGVtZW50LmxvbmdwcmVzcztcbiAgICAgICAgY29uc3QgbG9va3VwID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGNvbmZpZ1tsb29rdXBdKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gY29uZmlnW2xvb2t1cF07XG4gICAgICAgICAgICBpZiAoIVV0aWxzLmlzTnVtYmVyKHRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5fdGhyb3dFcnJvcihcImNvbmZpZyB2YWx1ZSBmb3IgbG9uZ3ByZXNzIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX19rZXlwcmVzc1RpbWVycy5zZXQoa2V5LCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZvY3VzVG9wRG93bkV2ZW50KFtgX2NhcHR1cmUke2tleX1Mb25nYCwgXCJfY2FwdHVyZUtleVwiXSwge30pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZvY3VzQm90dG9tVXBFdmVudChbYF9oYW5kbGUke2tleX1Mb25nYCwgXCJfaGFuZGxlS2V5XCJdLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fa2V5cHJlc3NUaW1lcnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCB8fCA1MDAgLyogcHJldmVudCAwbXMgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3JlY2lldmVTY3JvbGxXaGVlbChlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGU7XG4gICAgICAgIGNvbnN0IHtjbGllbnRYLCBjbGllbnRZfSA9IG9iajtcblxuICAgICAgICBpZiAoY2xpZW50WCA8PSB0aGlzLnN0YWdlLncgJiYgY2xpZW50WSA8PSB0aGlzLnN0YWdlLmgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maXJlVG9wRG93blNjcm9sbFdoZWVsSGFuZGxlcihcIl9jYXB0dXJlU2Nyb2xsXCIsIG9iaikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVCb3R0b21VcFNjcm9sbFdoZWVsSGFuZGxlcihcIl9oYW5kbGVTY3JvbGxcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpcmVUb3BEb3duU2Nyb2xsV2hlZWxIYW5kbGVyKGV2ZW50LCBvYmopIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5jaGlsZHJlbjtcbiAgICAgICAgbGV0IGFmZmVjdGVkID0gdGhpcy5fZmluZENoaWxkcmVuKFtdLCBjaGlsZHJlbikucmV2ZXJzZSgpO1xuICAgICAgICBsZXQgbiA9IGFmZmVjdGVkLmxlbmd0aDtcblxuICAgICAgICB3aGlsZShuLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gYWZmZWN0ZWRbbl07XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGRbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2NhcHR1cmVTY3JvbGwob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZpcmVCb3R0b21VcFNjcm9sbFdoZWVsSGFuZGxlcihldmVudCwgb2JqKSB7XG4gICAgICAgIGNvbnN0IHtjbGllbnRYLCBjbGllbnRZfSA9IG9iajtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fZ2V0VGFyZ2V0Q2hpbGQoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIGxldCBjaGlsZCA9IHRhcmdldDtcblxuICAgICAgICAvLyBTZWFyY2ggdHJlZSBib3R0b20gdXAgZm9yIGEgaGFuZGxlclxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5faGFuZGxlU2Nyb2xsKG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgX3JlY2VpdmVDbGljayhlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGU7XG4gICAgICAgIGNvbnN0IHtjbGllbnRYLCBjbGllbnRZfSA9IG9iajtcblxuICAgICAgICBpZiAoY2xpZW50WCA8PSB0aGlzLnN0YWdlLncgJiYgY2xpZW50WSA8PSB0aGlzLnN0YWdlLmgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZmlyZUJvdHRvbVVwQ2xpY2tIYW5kbGVyKG9iaik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaXJlQm90dG9tVXBDbGlja0hhbmRsZXIob2JqKSB7XG4gICAgICAgIGNvbnN0IHtjbGllbnRYLCBjbGllbnRZfSA9IG9iajtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fZ2V0VGFyZ2V0Q2hpbGQoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIGxldCBjaGlsZCA9IHRhcmdldDtcblxuICAgICAgICAvLyBTZWFyY2ggdHJlZSBib3R0b20gdXAgZm9yIGEgaGFuZGxlclxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZFtcIl9oYW5kbGVDbGlja1wiXSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9oYW5kbGVDbGljayh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVjZWl2ZUhvdmVyKGUpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZTtcbiAgICAgICAgY29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gb2JqO1xuXG4gICAgICAgIGlmIChjbGllbnRYIDw9IHRoaXMuc3RhZ2UudyAmJiBjbGllbnRZIDw9IHRoaXMuc3RhZ2UuaCkge1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5maXJlQm90dG9tVXBIb3ZlckhhbmRsZXIob2JqKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpcmVCb3R0b21VcEhvdmVySGFuZGxlcihvYmopIHtcbiAgICAgICAgY29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gb2JqO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9nZXRUYXJnZXRDaGlsZChjbGllbnRYLCBjbGllbnRZKTtcblxuICAgICAgICAvLyBPbmx5IGZpcmUgaGFuZGxlcnMgd2hlbiBwb2ludGVyIHRhcmdldCBjaGFuZ2VzXG4gICAgICAgIGlmICh0YXJnZXQgIT09IHRoaXMuX19ob3ZlcmVkQ2hpbGQpIHtcblxuICAgICAgICAgICAgbGV0IGhvdmVyZWRCcmFuY2ggPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBsZXQgbmV3SG92ZXJlZEJyYW5jaCA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIG5ld0hvdmVyZWRCcmFuY2ggPSBuZXcgU2V0KHRhcmdldC5nZXRBbmNlc3RvcnMoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9faG92ZXJlZENoaWxkKSB7XG4gICAgICAgICAgICAgICAgaG92ZXJlZEJyYW5jaCA9IG5ldyBTZXQodGhpcy5fX2hvdmVyZWRDaGlsZC5nZXRBbmNlc3RvcnMoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtIG9mIFsuLi5ob3ZlcmVkQnJhbmNoXS5maWx0ZXIoKGUpID0+ICFuZXdIb3ZlcmVkQnJhbmNoLmhhcyhlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjW1wiX2hhbmRsZVVuaG92ZXJcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuX2hhbmRsZVVuaG92ZXIoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ucGFyZW50ICYmIGVsZW0ucGFyZW50LmN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSBlbGVtLnBhcmVudC5jdXJzb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX19ob3ZlcmVkQ2hpbGQgPSB0YXJnZXQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpZmZCcmFuY2ggPSBbLi4ubmV3SG92ZXJlZEJyYW5jaF0uZmlsdGVyKChlKSA9PiAhaG92ZXJlZEJyYW5jaC5oYXMoZSkpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgZGlmZkJyYW5jaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KGVsZW0pO1xuICAgICAgICAgICAgICAgIGlmIChjW1wiX2hhbmRsZUhvdmVyXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuX2hhbmRsZUhvdmVyKGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmV3IGVsZW1lbnQgaG92ZXIgY3Vyc29yXG4gICAgICAgICAgICBjb25zdCBsYXN0RWxlbWVudCA9IGRpZmZCcmFuY2hbMF07XG4gICAgICAgICAgICBpZiAobGFzdEVsZW1lbnQgJiYgbGFzdEVsZW1lbnQuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSBsYXN0RWxlbWVudC5jdXJzb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlcnVuIF9oYW5kbGVIb3ZlciBmb3IgdGFyZ2V0IGVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlZW4gaG92ZXJlZFxuICAgICAgICAgICAgLy8gYmFjayBmcm9tIGl0cyBjaGlsZFxuICAgICAgICAgICAgaWYgKGRpZmZCcmFuY2gubGVuZ3RoID09PSAwICYmIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKGNbXCJfaGFuZGxlSG92ZXJcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYy5faGFuZGxlSG92ZXIodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0VGFyZ2V0Q2hpbGQoY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmNoaWxkcmVuO1xuICAgICAgICBsZXQgYWZmZWN0ZWQgPSB0aGlzLl9maW5kQ2hpbGRyZW4oW10sIGNoaWxkcmVuKTtcbiAgICAgICAgbGV0IGhvdmVyYWJsZUNoaWxkcmVuID0gdGhpcy5fd2l0aGluQ2xpY2thYmxlUmFuZ2UoYWZmZWN0ZWQsIGNsaWVudFgsIGNsaWVudFkpO1xuXG4gICAgICAgIGhvdmVyYWJsZUNoaWxkcmVuLnNvcnQoKGEsYikgPT4ge1xuICAgICAgICAgICAgLy8gU29ydCBieSB6SW5kZXggYW5kIHRoZW4gaWRcbiAgICAgICAgICAgIGlmIChhLnpJbmRleCA+IGIuekluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEuekluZGV4IDwgYi56SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmlkID4gYi5pZCA/IDE6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaG92ZXJhYmxlQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdGFyZ2V0IGhhcyBoaWdoZXN0IHpJbmRleCAoaWQgd2hlbiB6SW5kZXggZXF1YWwpXG4gICAgICAgICAgICByZXR1cm4gaG92ZXJhYmxlQ2hpbGRyZW4uc2xpY2UoLTEpWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZmluZENoaWxkcmVuKGJ1Y2tldCwgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IG4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bbl07XG4gICAgICAgICAgICAvLyBvbmx5IGFkZCBhY3RpdmUgY2hpbGRyZW5cbiAgICAgICAgICAgIGlmIChjaGlsZC5fX2FjdGl2ZSAmJiBjaGlsZC5jb2xsaXNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY29sbGlzaW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmluZENoaWxkcmVuKGJ1Y2tldCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgIH1cblxuICAgIF93aXRoaW5DbGlja2FibGVSYW5nZShhZmZlY3RlZENoaWxkcmVuLCBjdXJzb3JYLCBjdXJzb3JZKSB7XG4gICAgICAgIGxldCBuID0gYWZmZWN0ZWRDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBbXTtcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggYWZmZWN0ZWQgY2hpbGRyZW5cbiAgICAgICAgLy8gYW5kIHBlcmZvcm0gY29sbGlzaW9uIGRldGVjdGlvblxuICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGFmZmVjdGVkQ2hpbGRyZW5bbl07XG4gICAgICAgICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gY2hpbGQuY29yZS5fd29ybGRDb250ZXh0O1xuXG4gICAgICAgICAgICBjb25zdCBjeCA9IGN0eC5weCAqIHByZWNpc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gY3R4LnB5ICogcHJlY2lzaW9uO1xuICAgICAgICAgICAgY29uc3QgY3cgPSBjaGlsZC5maW5hbFcgKiBjdHgudGEgKiBwcmVjaXNpb247XG4gICAgICAgICAgICBjb25zdCBjaCA9IGNoaWxkLmZpbmFsSCAqIGN0eC50ZCAqIHByZWNpc2lvbjtcblxuICAgICAgICAgICAgaWYgKGN4ID4gdGhpcy5zdGFnZS53IHx8IGN5ID4gdGhpcy5zdGFnZS5oKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQuY29yZS5fc2Npc3Nvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaXNzb3IgPSBjaGlsZC5wYXJlbnQuY29yZS5fc2Npc3Nvci5tYXAoKHYpID0+IHYgKiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdGVzdENvbGxpc2lvbihjdXJzb3JYLCBjdXJzb3JZLCAuLi5zY2lzc29yKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rlc3RDb2xsaXNpb24oY3Vyc29yWCwgY3Vyc29yWSwgY3gsIGN5LCBjdywgY2gpKSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlcztcbiAgICB9XG5cbiAgICBfdGVzdENvbGxpc2lvbihweCwgcHksIGN4LCBjeSwgY3csIGNoKSB7XG4gICAgICAgIGlmIChweCA+PSBjeCAmJlxuICAgICAgICAgICAgcHggPD0gY3ggKyBjdyAmJlxuICAgICAgICAgICAgcHkgPj0gY3kgJiZcbiAgICAgICAgICAgIHB5IDw9IGN5ICsgY2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Rlc3Ryb3koKSB7XG4gICAgICAgIC8vIFRoaXMgZm9yY2VzIHRoZSBfZGV0YWNoLCBfZGlzYWJsZWQgYW5kIF9hY3RpdmUgZXZlbnRzIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgdGhpcy5zdGFnZS5zZXRBcHBsaWNhdGlvbih1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl91cGRhdGVBdHRhY2hlZEZsYWcoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRW5hYmxlZEZsYWcoKTtcblxuICAgICAgICBpZiAodGhpcy5fX2tleXByZXNzVGltZXJzLnNpemUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy5fX2tleXByZXNzVGltZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX2tleXByZXNzVGltZXJzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDYW52YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWdlLmdldENhbnZhcygpO1xuICAgIH1cblxufVxuXG5pbXBvcnQgU3RhZ2UgZnJvbSBcIi4uL3RyZWUvU3RhZ2UubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi4vdHJlZS9FbGVtZW50Lm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi9TdGF0ZU1hY2hpbmUubWpzXCI7XG5cbi8qKlxuICogQGV4dGVuZHMgU3RhdGVNYWNoaW5lXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvbmVudCBleHRlbmRzIEVsZW1lbnQge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuXG4gICAgICAgIC8vIEVuY2Fwc3VsYXRlIHRhZ3MgdG8gcHJldmVudCBsZWFraW5nLlxuICAgICAgICB0aGlzLnRhZ1Jvb3QgPSB0cnVlO1xuXG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwocHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcGVydGllcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2ZpcnN0QWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19maXJzdEVuYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX19zaWduYWxzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRoaXMuX19wYXNzU2lnbmFscyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0aGlzLl9fY29uc3RydWN0KCk7XG5cbiAgICAgICAgLy8gUXVpY2stYXBwbHkgdGVtcGxhdGUuXG4gICAgICAgIGNvbnN0IGZ1bmMgPSB0aGlzLmNvbnN0cnVjdG9yLmdldFRlbXBsYXRlRnVuYyh0aGlzKTtcbiAgICAgICAgZnVuYy5mKHRoaXMsIGZ1bmMuYSk7XG5cbiAgICAgICAgdGhpcy5fYnVpbGQoKTtcbiAgICB9XG5cbiAgICBfX3N0YXJ0KCkge1xuICAgICAgICBTdGF0ZU1hY2hpbmUuc2V0dXBTdGF0ZU1hY2hpbmUodGhpcyk7XG4gICAgICAgIHRoaXMuX29uU3RhdGVDaGFuZ2UgPSBDb21wb25lbnQucHJvdG90eXBlLl9fb25TdGF0ZUNoYW5nZTtcbiAgICB9XG5cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpO1xuICAgIH1cblxuICAgIF9fb25TdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgLyogRklYTUU6IFdvcmthcm91bmQgZm9yIGNhc2UsIHdoZXJlIGFwcGxpY2F0aW9uIHdhcyBzaHV0IGJ1dCBjb21wb25lbnQgc3RpbGwgbGl2ZXMgKi9cbiAgICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb24udXBkYXRlRm9jdXNQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVmb2N1cygpIHtcbiAgICAgICAgLyogRklYTUU6IFdvcmthcm91bmQgZm9yIGNhc2UsIHdoZXJlIGFwcGxpY2F0aW9uIHdhcyBzaHV0IGJ1dCBjb21wb25lbnQgc3RpbGwgbGl2ZXMgKi9cbiAgICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb24udXBkYXRlRm9jdXNQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgYmluZFByb3AobmFtZSwgZnVuYyA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtfX3Byb3BlcnR5QmluZGluZzogdHJ1ZSwgX19uYW1lOiBuYW1lLCBfX2Z1bmM6IGZ1bmN9O1xuICAgIH1cblxuICAgIF9fYmluZFByb3BlcnR5KHByb3BPYmosIHRhcmdldE9iaiwgdGFyZ2V0UHJvcCkge1xuICAgICAgICAvLyAxLiBmaW5kIGJpbmRpbmcgcG9zaXRpb246IGZpbmQgb2JqZWN0IGFuZCBwcm9wZXJ0eSBuYW1lIHRvIGJlIGJvdW5kXG4gICAgICAgIGNvbnN0IG9iaiA9IHRhcmdldE9iajtcbiAgICAgICAgY29uc3QgcHJvcCA9IHRhcmdldFByb3A7XG4gICAgICAgIGNvbnN0IHByb3BEZXBlbmRlbmNpZXMgPSBBcnJheS5pc0FycmF5KHByb3BPYmouX19uYW1lKSA/IHByb3BPYmouX19uYW1lIDogW3Byb3BPYmouX19uYW1lXTtcblxuICAgICAgICAvLyAyLiBjcmVhdGUgc2V0dGVycyBmb3IgZXZlcnkgZ2l2ZW4gZGVwZW5kZW5jeVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BEZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gcHJvcERlcGVuZGVuY2llc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSBwcm9wT2JqLl9fZnVuYyA/IHByb3BPYmouX19mdW5jIDogKGNvbnRleHQpID0+IGNvbnRleHRbcHJvcE5hbWVdO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tgX19wcm9wX2JpbmRpbmdzXyR7cHJvcE5hbWV9YF0gPSBbe19fb2JqOiBvYmosIF9fcHJvcDogcHJvcCwgX19mdW5jOiBmdW5jfV07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIHNldDogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2BfX3Byb3BfJHtwcm9wTmFtZX1gXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7X19vYmosIF9fcHJvcCwgX19mdW5jfSBvZiB0aGlzW2BfX3Byb3BfYmluZGluZ3NfJHtwcm9wTmFtZX1gXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fb2JqW19fcHJvcF0gPSBfX2Z1bmModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gdGhpc1tgX19wcm9wXyR7cHJvcE5hbWV9YF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tgX19wcm9wX2JpbmRpbmdzXyR7cHJvcE5hbWV9YF0ucHVzaCh7X19vYmo6IG9iaiwgX19wcm9wOiBwcm9wLCBfX2Z1bmM6IGZ1bmN9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBoaWdoLXBlcmZvcm1hbmNlIHRlbXBsYXRlIHBhdGNoZXIuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRlbXBsYXRlRnVuYyhjdHgpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBhIGRpZmZlcmVudCB0ZW1wbGF0ZSBmdW5jdGlvbiBwZXIgcGF0Y2ggaWQuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBcIl90ZW1wbGF0ZUZ1bmNcIjtcblxuICAgICAgICAvLyBCZSBjYXJlZnVsIHdpdGggY2xhc3MtYmFzZWQgc3RhdGljIGluaGVyaXRhbmNlLlxuICAgICAgICBjb25zdCBoYXNOYW1lID0gJ19faGFzJyArIG5hbWU7XG4gICAgICAgIGlmICh0aGlzW2hhc05hbWVdICE9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzW2hhc05hbWVdID0gdGhpcztcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB0aGlzLnBhcnNlVGVtcGxhdGUodGhpcy5fdGVtcGxhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbbmFtZV07XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlVGVtcGxhdGUob2JqKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBsb2M6IFtdLFxuICAgICAgICAgICAgc3RvcmU6IFtdLFxuICAgICAgICAgICAgcmlkOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wYXJzZVRlbXBsYXRlUmVjKG9iaiwgY29udGV4dCwgXCJlbGVtZW50XCIpO1xuXG4gICAgICAgIGNvbnN0IGNvZGUgPSBjb250ZXh0LmxvYy5qb2luKFwiO1xcblwiKTtcbiAgICAgICAgY29uc3QgZiA9IG5ldyBGdW5jdGlvbihcImVsZW1lbnRcIiwgXCJzdG9yZVwiLCBjb2RlKTtcbiAgICAgICAgcmV0dXJuIHtmOiBmLCBhOiBjb250ZXh0LnN0b3JlfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2VUZW1wbGF0ZVJlYyhvYmosIGNvbnRleHQsIGN1cnNvcikge1xuICAgICAgICBjb25zdCBzdG9yZSA9IGNvbnRleHQuc3RvcmU7XG4gICAgICAgIGNvbnN0IGxvYyA9IGNvbnRleHQubG9jO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc1VjQ2hhcihrZXkuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBWYWx1ZSBtdXN0IGJlIGV4cGFuZGVkIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVmLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN1cnNvciA9IGByJHtrZXkucmVwbGFjZSgvW15hLXowLTldL2dpLCBcIlwiKSArIGNvbnRleHQucmlkfWA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gdmFsdWUudHlwZSA/IHZhbHVlLnR5cGUgOiBFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYHZhciAke2NoaWxkQ3Vyc29yfSA9IGVsZW1lbnQuc3RhZ2UuY3JlYXRlRWxlbWVudCgpYCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYHZhciAke2NoaWxkQ3Vyc29yfSA9IG5ldyBzdG9yZVske3N0b3JlLmxlbmd0aCAtIDF9XSgke2N1cnNvcn0uc3RhZ2UpYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y2hpbGRDdXJzb3J9LnJlZiA9IFwiJHtrZXl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yaWQrKztcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnRlciBzdWIuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VUZW1wbGF0ZVJlYyh2YWx1ZSwgY29udGV4dCwgY2hpbGRDdXJzb3IpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn0uY2hpbGRMaXN0LmFkZCgke2NoaWxkQ3Vyc29yfSlgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEeW5hbWljIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9LmNoaWxkTGlzdC5hZGQoc3RvcmVbJHtzdG9yZS5sZW5ndGggLSAxfV0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wS2V5ID0gY3Vyc29yICsgXCJfX3RleHRcIjtcbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYHZhciAke3Byb3BLZXl9ID0gJHtjdXJzb3J9LmVuYWJsZVRleHRUZXh0dXJlKClgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLl9fcHJvcGVydHlCaW5kaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBiaW5kaW5nIGVudGlyZSBvYmplY3RzIHRvIHRleHQgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYGVsZW1lbnQuX19iaW5kUHJvcGVydHkoc3RvcmVbJHtzdG9yZS5sZW5ndGggLSAxfV0sICR7Y3Vyc29yfSwgXCIke2tleX1cIilgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VUZW1wbGF0ZVByb3BSZWModmFsdWUsIGNvbnRleHQsIHByb3BLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2hhZGVyXCIgJiYgVXRpbHMuaXNPYmplY3RMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFkZXJDdXJzb3IgPSBgJHtjdXJzb3J9W1wic2hhZGVyXCJdYFxuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfVtcIiR7a2V5fVwiXSA9IHN0b3JlWyR7c3RvcmUubGVuZ3RoIC0gMX1dYCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eUJpbmRpbmdzKHZhbHVlLCBjb250ZXh0LCBzaGFkZXJDdXJzb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInRleHR1cmVcIiAmJiBVdGlscy5pc09iamVjdExpdGVyYWwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BLZXkgPSBjdXJzb3IgKyBcIl9fdGV4dHVyZVwiO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gdmFsdWUudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgdmFyICR7cHJvcEtleX0gPSBuZXcgc3RvcmVbJHtzdG9yZS5sZW5ndGggLSAxfV0oJHtjdXJzb3J9LnN0YWdlKWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVRlbXBsYXRlUHJvcFJlYyh2YWx1ZSwgY29udGV4dCwgcHJvcEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9W1wiJHtrZXl9XCJdID0gJHtwcm9wS2V5fWApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7cHJvcEtleX0gPSAke2N1cnNvcn0udGV4dHVyZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVRlbXBsYXRlUHJvcFJlYyh2YWx1ZSwgY29udGV4dCwgcHJvcEtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2YWx1ZSkgJiYgdmFsdWUuX19wcm9wZXJ0eUJpbmRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGBlbGVtZW50Ll9fYmluZFByb3BlcnR5KHN0b3JlWyR7c3RvcmUubGVuZ3RoIC0gMX1dLCAke2N1cnNvcn0sIFwiJHtrZXl9XCIpYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn1bXCIke2tleX1cIl0gPSAke3ZhbHVlfWApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn1bXCIke2tleX1cIl0gPSAke3ZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEeW5hbWljIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGxpdGVyYWwgb2JqZWN0cyBtYXkgY29udGFpbiBkeW5hbWljcywgd2Ugc3RvcmUgdGhlIGZ1bGwgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9W1wiJHtrZXl9XCJdID0gc3RvcmVbJHtzdG9yZS5sZW5ndGggLSAxfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9W1wiJHtrZXl9XCJdID0gJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZVRlbXBsYXRlUHJvcFJlYyhvYmosIGNvbnRleHQsIGN1cnNvcikge1xuICAgICAgICBjb25zdCBzdG9yZSA9IGNvbnRleHQuc3RvcmU7XG4gICAgICAgIGNvbnN0IGxvYyA9IGNvbnRleHQubG9jO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcInR5cGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9W1wiJHtrZXl9XCJdID0gJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfVtcIiR7a2V5fVwiXSA9ICR7dmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIn1gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5fX3Byb3BlcnR5QmluZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYGVsZW1lbnQuX19iaW5kUHJvcGVydHkoc3RvcmVbJHtzdG9yZS5sZW5ndGggLSAxfV0sICR7Y3Vyc29yfSwgXCIke2tleX1cIilgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEeW5hbWljIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgbGl0ZXJhbCBvYmplY3RzIG1heSBjb250YWluIGR5bmFtaWNzLCB3ZSBzdG9yZSB0aGUgZnVsbCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9W1wiJHtrZXl9XCJdID0gc3RvcmVbJHtzdG9yZS5sZW5ndGggLSAxfV1gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgZXRjLlxuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9W1wiJHtrZXl9XCJdID0gJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2VQcm9wZXJ0eUJpbmRpbmdzKG9iaiwgY29udGV4dCwgY3Vyc29yKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gY29udGV4dC5zdG9yZTtcbiAgICAgICAgY29uc3QgbG9jID0gY29udGV4dC5sb2M7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHZhbHVlKSAmJiB2YWx1ZS5fX3Byb3BlcnR5QmluZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYGVsZW1lbnQuX19iaW5kUHJvcGVydHkoc3RvcmVbJHtzdG9yZS5sZW5ndGggLSAxfV0sICR7Y3Vyc29yfSwgXCIke2tleX1cIilgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9vblNldHVwKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXAoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXR1cCgpIHtcbiAgICB9XG5cbiAgICBfb25BdHRhY2goKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl9faW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5fX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2F0dGFjaCgpO1xuICAgIH1cblxuICAgIF9hdHRhY2goKSB7XG4gICAgfVxuXG4gICAgX29uRGV0YWNoKCkge1xuICAgICAgICB0aGlzLl9kZXRhY2goKTtcbiAgICB9XG5cbiAgICBfZGV0YWNoKCkge1xuICAgIH1cblxuICAgIF9vbkVuYWJsZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2ZpcnN0RW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJzdEVuYWJsZSgpO1xuICAgICAgICAgICAgdGhpcy5fX2ZpcnN0RW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VuYWJsZSgpO1xuICAgIH1cblxuICAgIF9maXJzdEVuYWJsZSgpIHtcbiAgICB9XG5cbiAgICBfZW5hYmxlKCkge1xuICAgIH1cblxuICAgIF9vbkRpc2FibGVkKCkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlKCk7XG4gICAgfVxuXG4gICAgX2Rpc2FibGUoKSB7XG4gICAgfVxuXG4gICAgX29uQWN0aXZlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19maXJzdEFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3RBY3RpdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX19maXJzdEFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmUoKTtcbiAgICB9XG5cbiAgICBfZmlyc3RBY3RpdmUoKSB7XG4gICAgfVxuXG4gICAgX2FjdGl2ZSgpIHtcbiAgICB9XG5cbiAgICBfb25JbmFjdGl2ZSgpIHtcbiAgICAgICAgdGhpcy5faW5hY3RpdmUoKTtcbiAgICB9XG5cbiAgICBfaW5hY3RpdmUoKSB7XG4gICAgfVxuXG4gICAgZ2V0IGFwcGxpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFnZS5hcHBsaWNhdGlvbjtcbiAgICB9XG5cbiAgICBfX2NvbnN0cnVjdCgpIHtcbiAgICAgICAgdGhpcy5fY29uc3RydWN0KCk7XG4gICAgfVxuXG4gICAgX2NvbnN0cnVjdCgpIHtcbiAgICB9XG5cbiAgICBfYnVpbGQoKSB7XG4gICAgfVxuXG4gICAgX19pbml0KCkge1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuXG4gICAgX2luaXQoKSB7XG4gICAgfVxuXG4gICAgX2ZvY3VzKG5ld1RhcmdldCwgcHJldlRhcmdldCkge1xuICAgIH1cblxuICAgIF91bmZvY3VzKG5ld1RhcmdldCkge1xuICAgIH1cblxuICAgIF9mb2N1c0NoYW5nZSh0YXJnZXQsIG5ld1RhcmdldCkge1xuICAgIH1cblxuICAgIF9nZXRGb2N1c2VkKCkge1xuICAgICAgICAvLyBPdmVycmlkZSB0byBkZWxlZ2F0ZSBmb2N1cyB0byBjaGlsZCBjb21wb25lbnRzLlxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfc2V0Rm9jdXNTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICAvLyBPdmVycmlkZSB0byBhZGQgY3VzdG9tIHNldHRpbmdzLiBTZWUgQXBwbGljYXRpb24uX2hhbmRsZUZvY3VzU2V0dGluZ3MoKS5cbiAgICB9XG5cbiAgICBfaGFuZGxlRm9jdXNTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICAvLyBPdmVycmlkZSB0byByZWFjdCBvbiBjdXN0b20gc2V0dGluZ3MuIFNlZSBBcHBsaWNhdGlvbi5faGFuZGxlRm9jdXNTZXR0aW5ncygpLlxuICAgIH1cblxuICAgIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBoYXNGaW5hbEZvY3VzKCkge1xuICAgICAgICBsZXQgcGF0aCA9IHRoaXMuYXBwbGljYXRpb24uX2ZvY3VzUGF0aDtcbiAgICAgICAgcmV0dXJuIHBhdGggJiYgcGF0aC5sZW5ndGggJiYgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSB0aGlzO1xuICAgIH1cblxuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICBsZXQgcGF0aCA9IHRoaXMuYXBwbGljYXRpb24uX2ZvY3VzUGF0aDtcbiAgICAgICAgcmV0dXJuIHBhdGggJiYgKHBhdGguaW5kZXhPZih0aGlzKSA+PSAwKTtcbiAgICB9XG5cbiAgICBnZXQgY3BhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudC5nZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuXG4gICAgc2Vla0FuY2VzdG9yQnlUeXBlKHR5cGUpIHtcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNwYXJlbnQ7XG4gICAgICAgIHdoaWxlIChjKSB7XG4gICAgICAgICAgICBpZiAoYy5jb25zdHJ1Y3RvciA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyA9IGMuY3BhcmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNoYXJlZEFuY2VzdG9yQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IGFuY2VzdG9yID0gdGhpcy5nZXRTaGFyZWRBbmNlc3RvcihlbGVtZW50KTtcbiAgICAgICAgd2hpbGUgKGFuY2VzdG9yICYmICFhbmNlc3Rvci5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yO1xuICAgIH1cblxuICAgIGdldCBzaWduYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3NpZ25hbHM7XG4gICAgfVxuXG4gICAgc2V0IHNpZ25hbHModikge1xuICAgICAgICBpZiAoIVV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2KSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIlNpZ25hbHM6IHNwZWNpZnkgYW4gb2JqZWN0IHdpdGggc2lnbmFsLXRvLWZpcmUgbWFwcGluZ3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3NpZ25hbHMgPSB2O1xuICAgIH1cblxuICAgIHNldCBhbHRlclNpZ25hbHModikge1xuICAgICAgICBpZiAoIVV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2KSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIlNpZ25hbHM6IHNwZWNpZnkgYW4gb2JqZWN0IHdpdGggc2lnbmFsLXRvLWZpcmUgbWFwcGluZ3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9fc2lnbmFscykge1xuICAgICAgICAgICAgdGhpcy5fX3NpZ25hbHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdikge1xuICAgICAgICAgICAgY29uc3QgZCA9IHZba2V5XTtcbiAgICAgICAgICAgIGlmIChkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fX3NpZ25hbHNba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3NpZ25hbHNba2V5XSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcGFzc1NpZ25hbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fcGFzc1NpZ25hbHMgfHwge307XG4gICAgfVxuXG4gICAgc2V0IHBhc3NTaWduYWxzKHYpIHtcbiAgICAgICAgdGhpcy5fX3Bhc3NTaWduYWxzID0gT2JqZWN0LmFzc2lnbih0aGlzLl9fcGFzc1NpZ25hbHMgfHwge30sIHYpO1xuICAgIH1cblxuICAgIHNldCBhbHRlclBhc3NTaWduYWxzKHYpIHtcbiAgICAgICAgaWYgKCFVdGlscy5pc09iamVjdExpdGVyYWwodikpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJTaWduYWxzOiBzcGVjaWZ5IGFuIG9iamVjdCB3aXRoIHNpZ25hbC10by1maXJlIG1hcHBpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fX3Bhc3NTaWduYWxzKSB7XG4gICAgICAgICAgICB0aGlzLl9fcGFzc1NpZ25hbHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdikge1xuICAgICAgICAgICAgY29uc3QgZCA9IHZba2V5XTtcbiAgICAgICAgICAgIGlmIChkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fX3Bhc3NTaWduYWxzW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX19wYXNzU2lnbmFsc1trZXldID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpZ25hbHMgdGhlIHBhcmVudCBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIEEgcGFyZW50L2FuY2VzdG9yIHRoYXQgd2lzaGVzIHRvIGhhbmRsZSB0aGUgc2lnbmFsIHNob3VsZCBzZXQgdGhlICdzaWduYWxzJyBwcm9wZXJ0eSBvbiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICAgKi9cbiAgICBzaWduYWwoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbChldmVudCwgYXJncyk7XG4gICAgfVxuXG4gICAgX3NpZ25hbChldmVudCwgYXJncykge1xuICAgICAgICBjb25zdCBzaWduYWxQYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRTaWduYWxIYW5kbGVyKCk7XG4gICAgICAgIGlmIChzaWduYWxQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fc2lnbmFscykge1xuICAgICAgICAgICAgICAgIGxldCBmaXJlRXZlbnQgPSB0aGlzLl9fc2lnbmFsc1tldmVudF07XG4gICAgICAgICAgICAgICAgaWYgKGZpcmVFdmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcmVFdmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzRnVuY3Rpb24oZmlyZUV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcmVFdmVudCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduYWxQYXJlbnQuX2hhc01ldGhvZChmaXJlRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsUGFyZW50W2ZpcmVFdmVudF0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBwYXNzU2lnbmFsID0gKHRoaXMuX19wYXNzU2lnbmFscyAmJiB0aGlzLl9fcGFzc1NpZ25hbHNbZXZlbnRdKTtcbiAgICAgICAgICAgIGlmIChwYXNzU2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gQnViYmxlIHVwLlxuICAgICAgICAgICAgICAgIGlmIChwYXNzU2lnbmFsICYmIHBhc3NTaWduYWwgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBzaWduYWwgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBwYXNzU2lnbmFsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduYWxQYXJlbnQuX3NpZ25hbChldmVudCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0UGFyZW50U2lnbmFsSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3BhcmVudCA/IHRoaXMuY3BhcmVudC5fZ2V0U2lnbmFsSGFuZGxlcigpIDogbnVsbDtcbiAgICB9XG5cbiAgICBfZ2V0U2lnbmFsSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hbFByb3h5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcGFyZW50ID8gdGhpcy5jcGFyZW50Ll9nZXRTaWduYWxIYW5kbGVyKCkgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldCBfc2lnbmFsUHJveHkoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmaXJlQW5jZXN0b3JzKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCFuYW1lLnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW5jZXN0b3IgZXZlbnQgbmFtZSBtdXN0IGJlIHByZWZpeGVkIGJ5IGRvbGxhciBzaWduLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2dldFBhcmVudFNpZ25hbEhhbmRsZXIoKTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5fZG9GaXJlQW5jZXN0b3JzKG5hbWUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2RvRmlyZUFuY2VzdG9ycyhuYW1lLCBhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNNZXRob2QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcmUobmFtZSwgLi4uYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxQYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRTaWduYWxIYW5kbGVyKCk7XG4gICAgICAgICAgICBpZiAoc2lnbmFsUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbFBhcmVudC5fZG9GaXJlQW5jZXN0b3JzKG5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbGxlY3RTdWJDb21wb25lbnRzKHN1YnMsIGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRMaXN0ID0gZWxlbWVudC5fX2NoaWxkTGlzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gY2hpbGRMaXN0Lmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRMaXN0LmdldEF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudC5jb2xsZWN0U3ViQ29tcG9uZW50cyhzdWJzLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldENvbXBvbmVudChlbGVtZW50KSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50ICYmICFwYXJlbnQuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudC5nZXRDb21wb25lbnQoZWxlbWVudC5wYXJlbnQpO1xuICAgIH1cbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc0NvbXBvbmVudCA9IHRydWU7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZU1hY2hpbmUge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIFN0YXRlTWFjaGluZS5zZXR1cFN0YXRlTWFjaGluZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2V0dXBTdGF0ZU1hY2hpbmUodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldENvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCByb3V0ZXIgPSBTdGF0ZU1hY2hpbmUuY3JlYXRlKHRhcmdldENvbnN0cnVjdG9yKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcm91dGVyLnByb3RvdHlwZSk7XG4gICAgICAgIHRhcmdldC5jb25zdHJ1Y3RvciA9IHRhcmdldENvbnN0cnVjdG9yO1xuICAgICAgICB0YXJnZXQuX2luaXRTdGF0ZU1hY2hpbmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhdGUgbWFjaGluZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBJdCBleHRlbmRzIHRoZSBvcmlnaW5hbCB0eXBlIGFuZCBzaG91bGQgYmUgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXMuXG4gICAgICogVGhlIG9yaWdpbmFsIHR5cGUgaXMgYXZhaWxhYmxlIGFzIHN0YXRpYyBwcm9wZXJ0eSAnb3JpZ2luYWwnLCBhbmQgaXQgbXVzdCBiZSB1c2VkIHdoZW4gc3ViY2xhc3NpbmcgYXMgZm9sbG93czpcbiAgICAgKiBjb25zdCB0eXBlID0gU3RhdGVNYWNoaW5lLmNyZWF0ZShjbGFzcyBZb3VyTmV3U3RhdGVNYWNoaW5lQ2xhc3MgZXh0ZW5kcyBZb3VyQmFzZVN0YXRlTWFjaGluZUNsYXNzLm9yaWdpbmFsIHsgIH0pXG4gICAgICogQHBhcmFtIHtDbGFzc30gdHlwZVxuICAgICAqIEByZXR1cm5zIHtTdGF0ZU1hY2hpbmV9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh0eXBlKSB7XG4gICAgICAgIGlmICghdHlwZS5oYXNPd25Qcm9wZXJ0eSgnX3NtJykpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgbmVlZCB0byBydW4gb25jZS5cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTWFjaGluZVR5cGUgPSBuZXcgU3RhdGVNYWNoaW5lVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIHR5cGUuX3NtID0gc3RhdGVNYWNoaW5lVHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlLl9zbS5yb3V0ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIHNwZWNpZmllZCBtZXRob2QgaWYgaXQgZXhpc3RzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7Ki4uLn0gYXJnc1xuICAgICAqL1xuICAgIGZpcmUoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc01ldGhvZChldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2V2ZW50XSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgcGF0aCAoZm9yIGV4YW1wbGUgXCJJbml0aWFsaXplZC5Mb2FkaW5nXCIpLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9nZXRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLl9fcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWZmIHN0YXRlUGF0aCBpcyAoYW4gYW5jZXN0b3Igb2YpIGN1cnJlbnRTdGF0ZVBhdGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlUGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50U3RhdGVQYXRoXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pblN0YXRlKHN0YXRlUGF0aCwgY3VycmVudFN0YXRlUGF0aCA9IHRoaXMuX3N0YXRlLl9fcGF0aCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3NtLmdldFN0YXRlQnlQYXRoKHN0YXRlUGF0aCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuX3NtLmdldFN0YXRlQnlQYXRoKGN1cnJlbnRTdGF0ZVBhdGgpO1xuICAgICAgICBjb25zdCBsZXZlbCA9IHN0YXRlLl9fbGV2ZWw7XG4gICAgICAgIGNvbnN0IHN0YXRlQXRMZXZlbCA9IFN0YXRlTWFjaGluZS5fZ2V0U3RhdGVBdExldmVsKGN1cnJlbnRTdGF0ZSwgbGV2ZWwpO1xuICAgICAgICByZXR1cm4gKHN0YXRlQXRMZXZlbCA9PT0gc3RhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNsYXNzIG1lbWJlciBpcyBkZWZpbmVkIGZvciB0aGUgY3VycmVudGx5IHNldCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzTWVtYmVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY2xhc3MgbWVtYmVyIGlzIGEgbWV0aG9kIGZvciB0aGUgY3VycmVudGx5IHNldCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzTWV0aG9kKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbWVtYmVyID0gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbbmFtZV07XG4gICAgICAgIHJldHVybiAhIW1lbWJlciAmJiAodHlwZW9mIG1lbWJlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIHRvIHRoZSBzcGVjaWZpZWQgc3RhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlUGF0aFxuICAgICAqICAgU3Vic3RhdGVzIGFyZSBzZXBlcmF0ZWQgYnkgYSB1bmRlcnNjb3JlcyAoZm9yIGV4YW1wbGUgXCJJbml0aWFsaXplZC5Mb2FkaW5nXCIpLlxuICAgICAqIEBwYXJhbSB7KltdfSBbYXJnc11cbiAgICAgKiAgIEFyZ3MgdGhhdCBhcmUgc3VwcGxpZWQgaW4gJGVudGVyIGFuZCAkZXhpdCBldmVudHMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRTdGF0ZShzdGF0ZVBhdGgsIGFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc2V0U3RhdGVJZCA9ICsrdGhpcy5fc2V0U3RhdGVDb3VudGVyO1xuICAgICAgICB0aGlzLl9zZXRTdGF0ZUlkID0gc2V0U3RhdGVJZDtcblxuICAgICAgICBpZiAodGhpcy5fc3RhdGUuX19wYXRoICE9PSBzdGF0ZVBhdGgpIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgIGxldCBuZXdTdGF0ZSA9IHRoaXMuX3NtLl9zdGF0ZU1hcFtzdGF0ZVBhdGhdO1xuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBzdXBlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXMuX3NtLmdldFN0YXRlQnlQYXRoKHN0YXRlUGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXG4gICAgICAgICAgICBjb25zdCBoYXNEaWZmZXJlbnRFbnRlck1ldGhvZCA9IChuZXdTdGF0ZS5wcm90b3R5cGUuJGVudGVyICE9PSB0aGlzLl9zdGF0ZS5wcm90b3R5cGUuJGVudGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0RpZmZlcmVudEV4aXRNZXRob2QgPSAobmV3U3RhdGUucHJvdG90eXBlLiRleGl0ICE9PSB0aGlzLl9zdGF0ZS5wcm90b3R5cGUuJGV4aXQpO1xuICAgICAgICAgICAgaWYgKGhhc0RpZmZlcmVudEVudGVyTWV0aG9kIHx8IGhhc0RpZmZlcmVudEV4aXRNZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWRTdGF0ZSA9IFN0YXRlTWFjaGluZS5fZ2V0U2hhcmVkU3RhdGUodGhpcy5fc3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZTogbmV3U3RhdGUuX19wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwcmV2U3RhdGU6IHByZXZTdGF0ZS5fX3BhdGgsXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlZFN0YXRlOiBzaGFyZWRTdGF0ZS5fX3BhdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlZExldmVsID0gc2hhcmVkU3RhdGUuX19sZXZlbDtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNEaWZmZXJlbnRFeGl0TWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXRTdGF0ZXMgPSBTdGF0ZU1hY2hpbmUuX2dldFN0YXRlc1VudGlsTGV2ZWwodGhpcy5fc3RhdGUsIHNoYXJlZExldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBleGl0U3RhdGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3NldFN0YXRlKGV4aXRTdGF0ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbEV4aXQodGhpcy5fc3RhdGUsIGFyZ3MsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVDaGFuZ2VPdmVycmlkZGVuID0gKHRoaXMuX3NldFN0YXRlSWQgIT09IHNldFN0YXRlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlQ2hhbmdlT3ZlcnJpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChoYXNEaWZmZXJlbnRFbnRlck1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRlclN0YXRlcyA9IFN0YXRlTWFjaGluZS5fZ2V0U3RhdGVzVW50aWxMZXZlbChuZXdTdGF0ZSwgc2hhcmVkTGV2ZWwpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBlbnRlclN0YXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19zZXRTdGF0ZShlbnRlclN0YXRlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsRW50ZXIodGhpcy5fc3RhdGUsIGFyZ3MsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVDaGFuZ2VPdmVycmlkZGVuID0gKHRoaXMuX3NldFN0YXRlSWQgIT09IHNldFN0YXRlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlQ2hhbmdlT3ZlcnJpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9fc2V0U3RhdGUobmV3U3RhdGUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGU6IG5ld1N0YXRlLl9fcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlN0YXRlOiBwcmV2U3RhdGUuX19wYXRoXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRTdGF0ZShjb250ZXh0LCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkU3RhdGUoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fb25TdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlOiBuZXdTdGF0ZS5fX3BhdGgsXG4gICAgICAgICAgICAgICAgICAgIHByZXZTdGF0ZTogcHJldlN0YXRlLl9fcGF0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGF0ZUNoYW5nZShjb250ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NhbGxFbnRlcihzdGF0ZSwgYXJncyA9IFtdLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGhhc1BhcmVudCA9ICEhc3RhdGUuX19wYXJlbnQ7XG4gICAgICAgIGlmIChzdGF0ZS5wcm90b3R5cGUuJGVudGVyKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1BhcmVudCB8fCAoc3RhdGUuX19wYXJlbnQucHJvdG90eXBlLiRlbnRlciAhPT0gc3RhdGUucHJvdG90eXBlLiRlbnRlcikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcm90b3R5cGUuJGVudGVyLmFwcGx5KHRoaXMsIFtjb250ZXh0LCAuLi5hcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2FsbEV4aXQoc3RhdGUsIGFyZ3MgPSBbXSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBoYXNQYXJlbnQgPSAhIXN0YXRlLl9fcGFyZW50O1xuICAgICAgICBpZiAoc3RhdGUucHJvdG90eXBlLiRleGl0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc1BhcmVudCB8fCAoc3RhdGUuX19wYXJlbnQucHJvdG90eXBlLiRleGl0ICE9PSBzdGF0ZS5wcm90b3R5cGUuJGV4aXQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucHJvdG90eXBlLiRleGl0LmFwcGx5KHRoaXMsIFtjb250ZXh0LCAuLi5hcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfX3NldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuX3N0YXRlSW5kZXggPSBzdGF0ZS5fX2luZGV4O1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gc3RhdGU7XG4gICAgfVxuXG4gICAgX2luaXRTdGF0ZU1hY2hpbmUoKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhdGVJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3NldFN0YXRlQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX3NtID0gdGhpcy5fcm91dGVkVHlwZS5fc207XG4gICAgICAgIHRoaXMuX19zZXRTdGF0ZSh0aGlzLl9zbS5nZXRTdGF0ZUJ5UGF0aChcIlwiKSk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7bmV3U3RhdGU6IFwiXCIsIHByZXZTdGF0ZTogdW5kZWZpbmVkLCBzaGFyZWRTdGF0ZTogdW5kZWZpbmVkfTtcbiAgICAgICAgdGhpcy5fY2FsbEVudGVyKHRoaXMuX3N0YXRlLCBbXSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMuX29uU3RhdGVDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmV0d2VlbiBtdWx0aXBsZSBtZW1iZXIgbmFtZXMsIHNlbGVjdCB0aGUgb25lIHNwZWNpZmllZCBpbiB0aGUgZGVlcGVzdCBzdGF0ZS5cbiAgICAgKiBJZiBtdWx0aXBsZSBtZW1iZXIgbmFtZXMgYXJlIHNwZWNpZmllZCBpbiB0aGUgc2FtZSBkZWVwZXN0IHN0YXRlLCB0aGUgZmlyc3Qgb25lIGluIHRoZSBhcnJheSBpcyByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBtZW1iZXJOYW1lc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZ2V0TW9zdFNwZWNpZmljSGFuZGxlZE1lbWJlcihtZW1iZXJOYW1lcykge1xuICAgICAgICBsZXQgY3VyID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbWVtYmVyTmFtZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyTmFtZSA9IG1lbWJlck5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghY3VyLl9fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIucHJvdG90eXBlW21lbWJlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtYmVyTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsaWFzID0gU3RhdGVNYWNoaW5lVHlwZS5nZXRTdGF0ZU1lbWJlckFsaWFzKGN1ci5fX3BhdGgsIG1lbWJlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1thbGlhc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXJOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gY3VyLl9fcGFyZW50O1xuICAgICAgICB9IHdoaWxlIChjdXIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0U3RhdGVzVW50aWxMZXZlbChzdGF0ZSwgbGV2ZWwpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gW107XG4gICAgICAgIHdoaWxlIChzdGF0ZS5fX2xldmVsID4gbGV2ZWwpIHtcbiAgICAgICAgICAgIHN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuX19wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlcztcbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFNoYXJlZFN0YXRlKHN0YXRlMSwgc3RhdGUyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlMUFycmF5ID0gU3RhdGVNYWNoaW5lLl9nZXRBbmNlc3RvclN0YXRlcyhzdGF0ZTEpO1xuICAgICAgICBjb25zdCBzdGF0ZTJBcnJheSA9IFN0YXRlTWFjaGluZS5fZ2V0QW5jZXN0b3JTdGF0ZXMoc3RhdGUyKTtcbiAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKHN0YXRlMUFycmF5Lmxlbmd0aCwgc3RhdGUyQXJyYXkubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZTFBcnJheVtpXSAhPT0gc3RhdGUyQXJyYXlbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUxQXJyYXlbaSAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTFBcnJheVtuIC0gMV07XG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRBbmNlc3RvclN0YXRlcyhzdGF0ZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGUpO1xuICAgICAgICB9IHdoaWxlKHN0YXRlID0gc3RhdGUuX19wYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFN0YXRlQXRMZXZlbChzdGF0ZSwgbGV2ZWwpIHtcbiAgICAgICAgaWYgKGxldmVsID4gc3RhdGUuX19sZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKGxldmVsIDwgc3RhdGUuX19sZXZlbCkge1xuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5fX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuXG5jbGFzcyBTdGF0ZU1hY2hpbmVUeXBlIHtcblxuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgZ2V0IHJvdXRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdXRlcjtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLl9jcmVhdGVSb3V0ZXIoKTtcblxuICAgICAgICB0aGlzLl9zdGF0ZU1hcCA9IHRoaXMuX2dldFN0YXRlTWFwKCk7XG5cbiAgICAgICAgdGhpcy5fYWRkU3RhdGVNZW1iZXJEZWxlZ2F0b3JzVG9Sb3V0ZXIoKTtcblxuICAgIH1cblxuICAgIF9jcmVhdGVSb3V0ZXIoKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLl90eXBlO1xuXG4gICAgICAgIGNvbnN0IHJvdXRlciA9IGNsYXNzIFN0YXRlTWFjaGluZVJvdXRlciBleHRlbmRzIHR5cGUge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoJ19pc1JvdXRlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG5lZWQgdG8gZXh0ZW5kICR7dHlwZS5uYW1lfS5vcmlnaW5hbCBpbnN0ZWFkIG9mICR7dHlwZS5uYW1lfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJvdXRlci5faXNSb3V0ZXIgPSB0cnVlO1xuICAgICAgICByb3V0ZXIucHJvdG90eXBlLl9yb3V0ZWRUeXBlID0gdHlwZTtcbiAgICAgICAgcm91dGVyLm9yaWdpbmFsID0gdHlwZTtcblxuICAgICAgICB0aGlzLl9taXhpblN0YXRlTWFjaGluZU1ldGhvZHMocm91dGVyKTtcblxuICAgICAgICByZXR1cm4gcm91dGVyO1xuICAgIH1cblxuICAgIF9taXhpblN0YXRlTWFjaGluZU1ldGhvZHMocm91dGVyKSB7XG4gICAgICAgIC8vIE1peGluIHRoZSBzdGF0ZSBtYWNoaW5lIG1ldGhvZHMsIHNvIHRoYXQgd2UgcmV1c2UgdGhlIG1ldGhvZHMgaW5zdGVhZCBvZiByZS1jcmVhdGluZyB0aGVtLlxuICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN0YXRlTWFjaGluZS5wcm90b3R5cGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IG5hbWVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFN0YXRlTWFjaGluZS5wcm90b3R5cGUsIG5hbWUpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb3V0ZXIucHJvdG90eXBlLCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hZGRTdGF0ZU1lbWJlckRlbGVnYXRvcnNUb1JvdXRlcigpIHtcbiAgICAgICAgY29uc3QgbWVtYmVycyA9IHRoaXMuX2dldEFsbE1lbWJlck5hbWVzKCk7XG5cbiAgICAgICAgbWVtYmVycy5mb3JFYWNoKG1lbWJlciA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hZGRNZW1iZXJSb3V0ZXIobWVtYmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5vdGUgV2UgYXJlIGdlbmVyYXRpbmcgY29kZSBiZWNhdXNlIGl0IHlpZWxkcyBtdWNoIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgKi9cbiAgICBfYWRkTWVtYmVyUm91dGVyKG1lbWJlcikge1xuICAgICAgICBjb25zdCBzdGF0ZVBhdGhzID0gT2JqZWN0LmtleXModGhpcy5fc3RhdGVNYXApO1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9ycyA9IFtdO1xuICAgICAgICBjb25zdCBhbGlhc2VzID0gW107XG4gICAgICAgIHN0YXRlUGF0aHMuZm9yRWFjaCgoc3RhdGVQYXRoLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZU1hcFtzdGF0ZVBhdGhdO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuX2dldERlc2NyaXB0b3Ioc3RhdGUsIG1lbWJlcik7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzW2luZGV4XSA9IGRlc2NyaXB0b3I7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gcHJvdG90eXBlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFsaWFzID0gU3RhdGVNYWNoaW5lVHlwZS5nZXRTdGF0ZU1lbWJlckFsaWFzKGRlc2NyaXB0b3IuX3NvdXJjZS5fX3BhdGgsIG1lbWJlcik7XG4gICAgICAgICAgICAgICAgYWxpYXNlc1tpbmRleF0gPSBhbGlhcztcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcm91dGVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShhbGlhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX3JvdXRlci5wcm90b3R5cGUsIGFsaWFzLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYWxpYXNlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZGVzY3JpcHRvcnMuZm9yRWFjaChkZXNjcmlwdG9yID0+IHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY1R5cGUgPSB0aGlzLl9nZXREZXNjcmlwdG9yVHlwZShkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSAmJiAodHlwZSAhPT0gZGVzY1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0xpZ2h0bmluZ10gTWVtYmVyICR7bWVtYmVyfSBpbiAke3RoaXMuX3R5cGUubmFtZX0gaGFzIGluY29uc2lzdGVudCB0eXBlcy5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eXBlID0gZGVzY1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWV0aG9kUm91dGVyKG1lbWJlciwgZGVzY3JpcHRvcnMsIGFsaWFzZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdldHRlclwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEdldHRlclNldHRlclJvdXRlcnMobWVtYmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwcm9wZXJ0eVwiOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIEZpeGVkIHByb3BlcnRpZXMgYXJlIG5vdCBzdXBwb3J0ZWQ7IHBsZWFzZSB1c2UgYSBnZXR0ZXIgaW5zdGVhZCFcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXREZXNjcmlwdG9yKHN0YXRlLCBtZW1iZXIsIGlzVmFsaWQgPSAoKSA9PiB0cnVlKSB7XG4gICAgICAgIGxldCB0eXBlID0gc3RhdGU7XG4gICAgICAgIGxldCBjdXJTdGF0ZSA9IHN0YXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHR5cGUucHJvdG90eXBlLCBtZW1iZXIpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChkZXNjcmlwdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLl9zb3VyY2UgPSBjdXJTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0eXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlICYmIHR5cGUuaGFzT3duUHJvcGVydHkoJ19fc3RhdGUnKSkge1xuICAgICAgICAgICAgICAgIGN1clN0YXRlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSh0eXBlICYmIHR5cGUucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBfZ2V0RGVzY3JpcHRvclR5cGUoZGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgfHwgZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgICAgIHJldHVybiAnZ2V0dGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtZXRob2QnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Byb3BlcnR5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBfc3VwcG9ydHNTcHJlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fc3VwcG9ydHNTcHJlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fX3N1cHBvcnRzU3ByZWFkID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gW10uY29uY2F0KC4uLmFyZ3VtZW50cyk7XCIpO1xuICAgICAgICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fc3VwcG9ydHNTcHJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fc3VwcG9ydHNTcHJlYWQ7XG4gICAgfVxuXG4gICAgX2FkZE1ldGhvZFJvdXRlcihtZW1iZXIsIGRlc2NyaXB0b3JzLCBhbGlhc2VzKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBbXG4gICAgICAgICAgICAvLyBUaGUgbGluZSBlbnN1cmVzIHRoYXQsIHdoaWxlIGRlYnVnZ2luZywgeW91ciBJREUgd29uJ3Qgb3BlbiBtYW55IHRhYnMuXG4gICAgICAgICAgICBcIi8vQCBzb3VyY2VVUkw9U3RhdGVNYWNoaW5lUm91dGVyLmpzXCIsXG4gICAgICAgICAgICBcInZhciBpID0gdGhpcy5fc3RhdGVJbmRleDtcIlxuICAgICAgICBdO1xuICAgICAgICBsZXQgY3VyID0gYWxpYXNlc1swXTtcbiAgICAgICAgY29uc3Qgc3VwcG9ydHNTcHJlYWQgPSBTdGF0ZU1hY2hpbmVUeXBlLl9zdXBwb3J0c1NwcmVhZCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMSwgbiA9IGFsaWFzZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhbGlhcyA9IGFsaWFzZXNbaV07XG4gICAgICAgICAgICBpZiAoYWxpYXMgIT09IGN1cikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzU3ByZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLnB1c2goYGlmIChpIDwgJHtpfSkgcmV0dXJuIHRoaXNbXCIke2N1cn1cIl0oLi4uYXJndW1lbnRzKTsgZWxzZWApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZS5wdXNoKGBpZiAoaSA8ICR7aX0pIHJldHVybiB0aGlzW1wiJHtjdXJ9XCJdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IGVsc2VgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucHVzaChgaWYgKGkgPCAke2l9KSByZXR1cm4gOyBlbHNlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gYWxpYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzU3ByZWFkKSB7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKGByZXR1cm4gdGhpc1tcIiR7Y3VyfVwiXSguLi5hcmd1bWVudHMpO2ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goYHJldHVybiB0aGlzW1wiJHtjdXJ9XCJdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goYDtgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbkJvZHkgPSBjb2RlLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIGNvbnN0IHJvdXRlciA9IG5ldyBGdW5jdGlvbihbXSwgZnVuY3Rpb25Cb2R5KTtcblxuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0ge3ZhbHVlOiByb3V0ZXJ9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5fcm91dGVyLnByb3RvdHlwZSwgbWVtYmVyLCBkZXNjcmlwdG9yKTtcbiAgICB9XG5cbiAgICBfYWRkR2V0dGVyU2V0dGVyUm91dGVycyhtZW1iZXIpIHtcbiAgICAgICAgY29uc3QgZ2V0dGVyID0gdGhpcy5fZ2V0R2V0dGVyUm91dGVyKG1lbWJlcik7XG4gICAgICAgIGNvbnN0IHNldHRlciA9IHRoaXMuX2dldFNldHRlclJvdXRlcihtZW1iZXIpO1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5fcm91dGVyLnByb3RvdHlwZSwgbWVtYmVyLCBkZXNjcmlwdG9yKTtcbiAgICB9XG5cbiAgICBfZ2V0R2V0dGVyUm91dGVyKG1lbWJlcikge1xuICAgICAgICBjb25zdCBzdGF0ZVBhdGhzID0gT2JqZWN0LmtleXModGhpcy5fc3RhdGVNYXApO1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9ycyA9IFtdO1xuICAgICAgICBjb25zdCBhbGlhc2VzID0gW107XG4gICAgICAgIHN0YXRlUGF0aHMuZm9yRWFjaCgoc3RhdGVQYXRoLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZU1hcFtzdGF0ZVBhdGhdO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuX2dldERlc2NyaXB0b3Ioc3RhdGUsIG1lbWJlciwgKGRlc2NyaXB0b3IgPT4gZGVzY3JpcHRvci5nZXQpKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNbaW5kZXhdID0gZGVzY3JpcHRvcjtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBwcm90b3R5cGUuXG4gICAgICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBTdGF0ZU1hY2hpbmVUeXBlLmdldFN0YXRlTWVtYmVyQWxpYXMoZGVzY3JpcHRvci5fc291cmNlLl9fcGF0aCwgbWVtYmVyKTtcbiAgICAgICAgICAgICAgICBhbGlhc2VzW2luZGV4XSA9IGFsaWFzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9yb3V0ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KGFsaWFzKSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5fcm91dGVyLnByb3RvdHlwZSwgYWxpYXMsIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICBhbGlhc2VzW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNvZGUgPSBbXG4gICAgICAgICAgICAvLyBUaGUgbGluZSBlbnN1cmVzIHRoYXQsIHdoaWxlIGRlYnVnZ2luZywgeW91ciBJREUgd29uJ3Qgb3BlbiBtYW55IHRhYnMuXG4gICAgICAgICAgICBcIi8vQCBzb3VyY2VVUkw9U3RhdGVNYWNoaW5lUm91dGVyLmpzXCIsXG4gICAgICAgICAgICBcInZhciBpID0gdGhpcy5fc3RhdGVJbmRleDtcIlxuICAgICAgICBdO1xuICAgICAgICBsZXQgY3VyID0gYWxpYXNlc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIG4gPSBhbGlhc2VzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBhbGlhc2VzW2ldO1xuICAgICAgICAgICAgaWYgKGFsaWFzICE9PSBjdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucHVzaChgaWYgKGkgPCAke2l9KSByZXR1cm4gdGhpc1tcIiR7Y3VyfVwiXTsgZWxzZWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucHVzaChgaWYgKGkgPCAke2l9KSByZXR1cm4gOyBlbHNlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gYWxpYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgY29kZS5wdXNoKGByZXR1cm4gdGhpc1tcIiR7Y3VyfVwiXTtgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUucHVzaChgO2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQm9keSA9IGNvZGUuam9pbihcIlxcblwiKTtcbiAgICAgICAgY29uc3Qgcm91dGVyID0gbmV3IEZ1bmN0aW9uKFtdLCBmdW5jdGlvbkJvZHkpO1xuICAgICAgICByZXR1cm4gcm91dGVyO1xuICAgIH1cblxuICAgIF9nZXRTZXR0ZXJSb3V0ZXIobWVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlUGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLl9zdGF0ZU1hcCk7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gW107XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSBbXTtcbiAgICAgICAgc3RhdGVQYXRocy5mb3JFYWNoKChzdGF0ZVBhdGgsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlTWFwW3N0YXRlUGF0aF07XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5fZ2V0RGVzY3JpcHRvcihzdGF0ZSwgbWVtYmVyLCAoZGVzY3JpcHRvciA9PiBkZXNjcmlwdG9yLnNldCkpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yc1tpbmRleF0gPSBkZXNjcmlwdG9yO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHByb3RvdHlwZS5cbiAgICAgICAgICAgICAgICBjb25zdCBhbGlhcyA9IFN0YXRlTWFjaGluZVR5cGUuZ2V0U3RhdGVNZW1iZXJBbGlhcyhkZXNjcmlwdG9yLl9zb3VyY2UuX19wYXRoLCBtZW1iZXIpO1xuICAgICAgICAgICAgICAgIGFsaWFzZXNbaW5kZXhdID0gYWxpYXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JvdXRlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLl9yb3V0ZXIucHJvdG90eXBlLCBhbGlhcywgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGFsaWFzZXNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY29kZSA9IFtcbiAgICAgICAgICAgIC8vIFRoZSBsaW5lIGVuc3VyZXMgdGhhdCwgd2hpbGUgZGVidWdnaW5nLCB5b3VyIElERSB3b24ndCBvcGVuIG1hbnkgdGFicy5cbiAgICAgICAgICAgIFwiLy9AIHNvdXJjZVVSTD1TdGF0ZU1hY2hpbmVSb3V0ZXIuanNcIixcbiAgICAgICAgICAgIFwidmFyIGkgPSB0aGlzLl9zdGF0ZUluZGV4O1wiXG4gICAgICAgIF07XG4gICAgICAgIGxldCBjdXIgPSBhbGlhc2VzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMSwgbiA9IGFsaWFzZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhbGlhcyA9IGFsaWFzZXNbaV07XG4gICAgICAgICAgICBpZiAoYWxpYXMgIT09IGN1cikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5wdXNoKGBpZiAoaSA8ICR7aX0pIHRoaXNbXCIke2N1cn1cIl0gPSBhcmc7IGVsc2VgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnB1c2goYGlmIChpIDwgJHtpfSkgOyBlbHNlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gYWxpYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgY29kZS5wdXNoKGB0aGlzW1wiJHtjdXJ9XCJdID0gYXJnO2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZS5wdXNoKGA7YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25Cb2R5ID0gY29kZS5qb2luKFwiXFxuXCIpO1xuICAgICAgICBjb25zdCByb3V0ZXIgPSBuZXcgRnVuY3Rpb24oW1wiYXJnXCJdLCBmdW5jdGlvbkJvZHkpO1xuICAgICAgICByZXR1cm4gcm91dGVyO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRTdGF0ZU1lbWJlckFsaWFzKHBhdGgsIG1lbWJlcikge1xuICAgICAgICByZXR1cm4gXCIkXCIgKyAocGF0aCA/IHBhdGggKyBcIi5cIiA6IFwiXCIpICsgbWVtYmVyO1xuICAgIH1cblxuICAgIF9nZXRBbGxNZW1iZXJOYW1lcygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVNYXAgPSB0aGlzLl9zdGF0ZU1hcDtcbiAgICAgICAgY29uc3QgbWFwID0gT2JqZWN0LmtleXMoc3RhdGVNYXApO1xuICAgICAgICBsZXQgbWVtYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbWFwLmZvckVhY2goc3RhdGVQYXRoID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0ZVBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSb290IHN0YXRlIGNhbiBiZSBza2lwcGVkOiBpZiB0aGUgbWV0aG9kIG9ubHkgb2NjdXJzIGluIHRoZSByb290IHN0YXRlLCB3ZSBkb24ndCBuZWVkIHRvIHJlLWRlbGVnYXRlIGl0IGJhc2VkIG9uIHN0YXRlLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVNYXBbc3RhdGVQYXRoXTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5fZ2V0U3RhdGVNZW1iZXJOYW1lcyhzdGF0ZSk7XG4gICAgICAgICAgICBuYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIG1lbWJlcnMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4ubWVtYmVyc107XG4gICAgfVxuXG4gICAgX2dldFN0YXRlTWVtYmVyTmFtZXMoc3RhdGUpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBzdGF0ZTtcbiAgICAgICAgbGV0IG1lbWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGlzUm9vdCA9IHRoaXMuX3R5cGUgPT09IHN0YXRlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMuX2dldFN0YXRlTWVtYmVyTmFtZXNGb3JUeXBlKHR5cGUpO1xuICAgICAgICAgICAgbmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICBtZW1iZXJzLmFkZChuYW1lKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHR5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodHlwZSk7XG4gICAgICAgIH0gd2hpbGUodHlwZSAmJiB0eXBlLnByb3RvdHlwZSAmJiAoIXR5cGUuaGFzT3duUHJvcGVydHkoXCJfX3N0YXRlXCIpIHx8IGlzUm9vdCkpO1xuXG4gICAgICAgIHJldHVybiBtZW1iZXJzO1xuICAgIH1cblxuICAgIF9nZXRTdGF0ZU1lbWJlck5hbWVzRm9yVHlwZSh0eXBlKSB7XG4gICAgICAgIGNvbnN0IG1lbWJlck5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModHlwZS5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gbWVtYmVyTmFtZXMuZmlsdGVyKG1lbWJlck5hbWUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChtZW1iZXJOYW1lICE9PSBcImNvbnN0cnVjdG9yXCIpICYmICFTdGF0ZU1hY2hpbmVUeXBlLl9pc1N0YXRlTG9jYWxNZW1iZXIobWVtYmVyTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBfaXNTdGF0ZUxvY2FsTWVtYmVyKG1lbWJlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChtZW1iZXJOYW1lID09PSBcIiRlbnRlclwiKSB8fCAobWVtYmVyTmFtZSA9PT0gXCIkZXhpdFwiKTtcbiAgICB9XG5cbiAgICBnZXRTdGF0ZUJ5UGF0aChzdGF0ZVBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlTWFwW3N0YXRlUGF0aF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZU1hcFtzdGF0ZVBhdGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VhcmNoIGZvciBjbG9zZXN0IG1hdGNoLlxuICAgICAgICBjb25zdCBwYXJ0cyA9IHN0YXRlUGF0aC5zcGxpdChcIi5cIik7XG4gICAgICAgIHdoaWxlKHBhcnRzLnBvcCgpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZVBhdGggPSBwYXJ0cy5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZU1hcFtzdGF0ZVBhdGhdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlTWFwW3N0YXRlUGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0U3RhdGVNYXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhdGVNYXApIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlTWFwID0gdGhpcy5fY3JlYXRlU3RhdGVNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVNYXA7XG4gICAgfVxuXG4gICAgX2NyZWF0ZVN0YXRlTWFwKCkge1xuICAgICAgICBjb25zdCBzdGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLl9hZGRTdGF0ZSh0aGlzLl90eXBlLCBudWxsLCBcIlwiLCBzdGF0ZU1hcCk7XG4gICAgICAgIHJldHVybiBzdGF0ZU1hcDtcbiAgICB9XG5cbiAgICBfYWRkU3RhdGUoc3RhdGUsIHBhcmVudFN0YXRlLCBuYW1lLCBzdGF0ZU1hcCkge1xuICAgICAgICBzdGF0ZS5fX3N0YXRlID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuX19uYW1lID0gbmFtZTtcblxuICAgICAgICB0aGlzLl9hZGRTdGF0aWNTdGF0ZVByb3BlcnR5KHN0YXRlLCBwYXJlbnRTdGF0ZSk7XG5cbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IChwYXJlbnRTdGF0ZSA/IHBhcmVudFN0YXRlLl9fcGF0aCA6IFwiXCIpO1xuICAgICAgICBsZXQgcGF0aCA9IChwYXJlbnRQYXRoID8gcGFyZW50UGF0aCArIFwiLlwiIDogXCJcIikgKyBuYW1lO1xuICAgICAgICBzdGF0ZS5fX3BhdGggPSBwYXRoO1xuICAgICAgICBzdGF0ZS5fX2xldmVsID0gcGFyZW50U3RhdGUgPyBwYXJlbnRTdGF0ZS5fX2xldmVsICsgMSA6IDA7XG4gICAgICAgIHN0YXRlLl9fcGFyZW50ID0gcGFyZW50U3RhdGU7XG4gICAgICAgIHN0YXRlLl9faW5kZXggPSBPYmplY3Qua2V5cyhzdGF0ZU1hcCkubGVuZ3RoO1xuICAgICAgICBzdGF0ZU1hcFtwYXRoXSA9IHN0YXRlO1xuXG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IHN0YXRlLl9zdGF0ZXM7XG4gICAgICAgIGlmIChzdGF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5oZXJpdGVkRnJvbVBhcmVudCA9IChwYXJlbnRTdGF0ZSAmJiBwYXJlbnRTdGF0ZS5fc3RhdGVzID09PSBzdGF0ZXMpO1xuICAgICAgICAgICAgaWYgKCFpc0luaGVyaXRlZEZyb21QYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJTdGF0ZXMgPSBzdGF0ZS5fc3RhdGVzKCk7XG4gICAgICAgICAgICAgICAgc3ViU3RhdGVzLmZvckVhY2goc3ViU3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZU5hbWUgPSBTdGF0ZU1hY2hpbmVUeXBlLl9nZXRTdGF0ZU5hbWUoc3ViU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRTdGF0ZShzdWJTdGF0ZSwgc3RhdGUsIHN0YXRlTmFtZSwgc3RhdGVNYXApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRTdGF0ZU5hbWUoc3RhdGUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHN0YXRlLm5hbWU7XG5cbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lLmluZGV4T2YoJyQnKTtcbiAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgLy8gU3RyaXAgb2ZmIHJvbGx1cCBuYW1lIHN1ZmZpeC5cbiAgICAgICAgICAgIHJldHVybiBuYW1lLnN1YnN0cigwLCBpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBfYWRkU3RhdGljU3RhdGVQcm9wZXJ0eShzdGF0ZSwgcGFyZW50U3RhdGUpIHtcbiAgICAgICAgaWYgKHBhcmVudFN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBpc0NsYXNzU3RhdGVMZXZlbCA9IHBhcmVudFN0YXRlICYmICFwYXJlbnRTdGF0ZS5fX3BhcmVudDtcbiAgICAgICAgICAgIGlmIChpc0NsYXNzU3RhdGVMZXZlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JvdXRlcltzdGF0ZS5fX25hbWVdID0gc3RhdGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudFN0YXRlW3N0YXRlLl9fbmFtZV0gPSBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi4vYXBwbGljYXRpb24vQ29tcG9uZW50Lm1qc1wiO1xuaW1wb3J0IExpbmVhckJsdXJTaGFkZXIgZnJvbSBcIi4uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvTGluZWFyQmx1clNoYWRlci5tanNcIjtcbmltcG9ydCBCb3hCbHVyU2hhZGVyIGZyb20gXCIuLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0JveEJsdXJTaGFkZXIubWpzXCI7XG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbG9vbUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgICAgICBjb25zdCBvblVwZGF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGVsZW1lbnRDb3JlKSB7XG4gICAgICAgICAgICBpZiAoKGVsZW1lbnRDb3JlLl9yZWNhbGMgJiAoMiArIDEyOCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdyA9IGVsZW1lbnRDb3JlLnc7XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IGVsZW1lbnRDb3JlLmg7XG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IGVsZW1lbnRDb3JlO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLl9jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICAgICAgY3VyLl9lbGVtZW50LncgPSB3O1xuICAgICAgICAgICAgICAgICAgICBjdXIuX2VsZW1lbnQuaCA9IGg7XG4gICAgICAgICAgICAgICAgfSB3aGlsZShjdXIuX2NoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgVGV4dHdyYXA6IHtydHQ6IHRydWUsIGZvcmNlWkluZGV4Q29udGV4dDogdHJ1ZSwgcmVuZGVyT2Zmc2NyZWVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIEJsb29tQmFzZToge3NoYWRlcjoge3R5cGU6IEJsb29tQmFzZVNoYWRlcn0sXG4gICAgICAgICAgICAgICAgICAgIENvbnRlbnQ6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIExheWVyczoge1xuICAgICAgICAgICAgICAgIEwwOiB7cnR0OiB0cnVlLCBvblVwZGF0ZTogb25VcGRhdGUsIHNjYWxlOiAyLCBwaXZvdDogMCwgdmlzaWJsZTogZmFsc2UsIENvbnRlbnQ6IHtzaGFkZXI6IHt0eXBlOiBCb3hCbHVyU2hhZGVyfX19LFxuICAgICAgICAgICAgICAgIEwxOiB7cnR0OiB0cnVlLCBvblVwZGF0ZTogb25VcGRhdGUsIHNjYWxlOiA0LCBwaXZvdDogMCwgdmlzaWJsZTogZmFsc2UsIENvbnRlbnQ6IHtzaGFkZXI6IHt0eXBlOiBCb3hCbHVyU2hhZGVyfX19LFxuICAgICAgICAgICAgICAgIEwyOiB7cnR0OiB0cnVlLCBvblVwZGF0ZTogb25VcGRhdGUsIHNjYWxlOiA4LCBwaXZvdDogMCwgdmlzaWJsZTogZmFsc2UsIENvbnRlbnQ6IHtzaGFkZXI6IHt0eXBlOiBCb3hCbHVyU2hhZGVyfX19LFxuICAgICAgICAgICAgICAgIEwzOiB7cnR0OiB0cnVlLCBvblVwZGF0ZTogb25VcGRhdGUsIHNjYWxlOiAxNiwgcGl2b3Q6IDAsIHZpc2libGU6IGZhbHNlLCBDb250ZW50OiB7c2hhZGVyOiB7dHlwZTogQm94Qmx1clNoYWRlcn19fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IF9zaWduYWxQcm94eSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuICAgICAgICB0aGlzLl90ZXh0d3JhcCA9IHRoaXMuc2VsKFwiVGV4dHdyYXBcIik7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIgPSB0aGlzLnNlbChcIlRleHR3cmFwLkNvbnRlbnRcIik7XG4gICAgICAgIHRoaXMuX2xheWVycyA9IHRoaXMuc2VsKFwiTGF5ZXJzXCIpO1xuXG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdYID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1kgPSAwO1xuICAgIH1cblxuICAgIF9idWlsZCgpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyU2hhZGVyU2V0dGluZ3MgPSBbe3g6MSx5OjAsa2VybmVsUmFkaXVzOjN9LHt4OjAseToxLGtlcm5lbFJhZGl1czozfSx7eDoxLjUseTowLGtlcm5lbFJhZGl1czozfSx7eDowLHk6MS41LGtlcm5lbFJhZGl1czozfV07XG4gICAgICAgIGNvbnN0IGZpbHRlclNoYWRlcnMgPSBmaWx0ZXJTaGFkZXJTZXR0aW5ncy5tYXAocyA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSB0aGlzLnN0YWdlLmNyZWF0ZVNoYWRlcihPYmplY3QuYXNzaWduKHt0eXBlOiBMaW5lYXJCbHVyU2hhZGVyfSwgcykpO1xuICAgICAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc2V0TGF5ZXJUZXh0dXJlKHRoaXMuZ2V0TGF5ZXJDb250ZW50cygwKSwgdGhpcy5fdGV4dHdyYXAuZ2V0VGV4dHVyZSgpLCBbXSk7XG4gICAgICAgIHRoaXMuX3NldExheWVyVGV4dHVyZSh0aGlzLmdldExheWVyQ29udGVudHMoMSksIHRoaXMuZ2V0TGF5ZXIoMCkuZ2V0VGV4dHVyZSgpLCBbZmlsdGVyU2hhZGVyc1swXSwgZmlsdGVyU2hhZGVyc1sxXV0pO1xuXG4gICAgICAgIC8vIE5vdGljZSB0aGF0IDEuNSBmaWx0ZXJzIHNob3VsZCBiZSBhcHBsaWVkIGJlZm9yZSAxLjAgZmlsdGVycy5cbiAgICAgICAgdGhpcy5fc2V0TGF5ZXJUZXh0dXJlKHRoaXMuZ2V0TGF5ZXJDb250ZW50cygyKSwgdGhpcy5nZXRMYXllcigxKS5nZXRUZXh0dXJlKCksIFtmaWx0ZXJTaGFkZXJzWzBdLCBmaWx0ZXJTaGFkZXJzWzFdLCBmaWx0ZXJTaGFkZXJzWzJdLCBmaWx0ZXJTaGFkZXJzWzNdXSk7XG4gICAgICAgIHRoaXMuX3NldExheWVyVGV4dHVyZSh0aGlzLmdldExheWVyQ29udGVudHMoMyksIHRoaXMuZ2V0TGF5ZXIoMikuZ2V0VGV4dHVyZSgpLCBbZmlsdGVyU2hhZGVyc1swXSwgZmlsdGVyU2hhZGVyc1sxXSwgZmlsdGVyU2hhZGVyc1syXSwgZmlsdGVyU2hhZGVyc1szXV0pO1xuICAgIH1cblxuICAgIF9zZXRMYXllclRleHR1cmUoZWxlbWVudCwgdGV4dHVyZSwgc3RlcHMpIHtcbiAgICAgICAgaWYgKCFzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGVwID0gc3RlcHMucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGVsZW1lbnQuc3RhZ2UuYyh7cnR0OiB0cnVlLCBzaGFkZXI6IHN0ZXB9KTtcblxuICAgICAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgICAgIHRoaXMuX3NldExheWVyVGV4dHVyZShjaGlsZCwgdGV4dHVyZSwgc3RlcHMpO1xuXG4gICAgICAgICAgICBlbGVtZW50LmNoaWxkTGlzdC5hZGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWwoJ1RleHR3cmFwLkNvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBzZXQgY29udGVudCh2KSB7XG4gICAgICAgIHRoaXMuc2VsKCdUZXh0d3JhcC5Db250ZW50JykucGF0Y2godik7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmcodikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nWCA9IHY7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdZID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1godikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nWCA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdZKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1kgPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIGdldExheWVyKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVycy5zZWwoXCJMXCIgKyBpKTtcbiAgICB9XG5cbiAgICBnZXRMYXllckNvbnRlbnRzKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIoaSkuc2VsKFwiQ29udGVudFwiKTtcbiAgICB9XG5cbiAgICBfb25SZXNpemUoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZUJsdXJTaXplKCkge1xuICAgICAgICBsZXQgdyA9IHRoaXMucmVuZGVyV2lkdGg7XG4gICAgICAgIGxldCBoID0gdGhpcy5yZW5kZXJIZWlnaHQ7XG5cbiAgICAgICAgbGV0IHBhZGRpbmdYID0gdGhpcy5fcGFkZGluZ1g7XG4gICAgICAgIGxldCBwYWRkaW5nWSA9IHRoaXMuX3BhZGRpbmdZO1xuXG4gICAgICAgIGxldCBmdyA9IHcgKyBwYWRkaW5nWCAqIDI7XG4gICAgICAgIGxldCBmaCA9IGggKyBwYWRkaW5nWSAqIDI7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwLncgPSBmdztcbiAgICAgICAgdGhpcy5fd3JhcHBlci54ID0gcGFkZGluZ1g7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMCkudyA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygwKS53ID0gZncgLyAyO1xuICAgICAgICB0aGlzLmdldExheWVyKDEpLncgPSB0aGlzLmdldExheWVyQ29udGVudHMoMSkudyA9IGZ3IC8gNDtcbiAgICAgICAgdGhpcy5nZXRMYXllcigyKS53ID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDIpLncgPSBmdyAvIDg7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMykudyA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygzKS53ID0gZncgLyAxNjtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAueCA9IC1wYWRkaW5nWDtcblxuICAgICAgICB0aGlzLl90ZXh0d3JhcC5oID0gZmg7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIueSA9IHBhZGRpbmdZO1xuICAgICAgICB0aGlzLmdldExheWVyKDApLmggPSB0aGlzLmdldExheWVyQ29udGVudHMoMCkuaCA9IGZoIC8gMjtcbiAgICAgICAgdGhpcy5nZXRMYXllcigxKS5oID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDEpLmggPSBmaCAvIDQ7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMikuaCA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygyKS5oID0gZmggLyA4O1xuICAgICAgICB0aGlzLmdldExheWVyKDMpLmggPSB0aGlzLmdldExheWVyQ29udGVudHMoMykuaCA9IGZoIC8gMTY7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwLnkgPSAtcGFkZGluZ1k7XG5cbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgdGhpcy5oID0gaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbW91bnQgb2YgYmx1ci4gQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDQuIEdvZXMgdXAgZXhwb25lbnRpYWxseSBmb3IgYmx1ci5cbiAgICAgKiBCZXN0IHJlc3VsdHMgZm9yIG5vbi1mcmFjdGlvbmFsIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gdjtcbiAgICAgKi9cbiAgICBzZXQgYW1vdW50KHYpIHtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudDtcbiAgICB9XG5cbiAgICBfdXBkYXRlKCkge1xuICAgICAgICBsZXQgdiA9IE1hdGgubWluKDQsIE1hdGgubWF4KDAsIHRoaXMuX2Ftb3VudCkpO1xuICAgICAgICBpZiAodiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGF5ZXIoMCkudmlzaWJsZSA9ICh2ID4gMCk7XG4gICAgICAgICAgICB0aGlzLmdldExheWVyKDEpLnZpc2libGUgPSAodiA+IDEpO1xuICAgICAgICAgICAgdGhpcy5nZXRMYXllcigyKS52aXNpYmxlID0gKHYgPiAyKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGF5ZXIoMykudmlzaWJsZSA9ICh2ID4gMyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2hhZGVyKHMpIHtcbiAgICAgICAgc3VwZXIuc2hhZGVyID0gcztcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gUGxlYXNlIGVuYWJsZSByZW5kZXJUb1RleHR1cmUgdG8gdXNlIHdpdGggYSBzaGFkZXIuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2ZpcnN0QWN0aXZlKCkge1xuICAgICAgICB0aGlzLl9idWlsZCgpO1xuICAgIH1cblxufVxuXG5jbGFzcyBCbG9vbUJhc2VTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcbn1cblxuQmxvb21CYXNlU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcbiAgICAgICAgZmxvYXQgbSA9IG1heChtYXgoY29sb3IuciwgY29sb3IuZyksIGNvbG9yLmIpO1xuICAgICAgICBmbG9hdCBjID0gbWF4KDAuMCwgKG0gLSAwLjgwKSkgKiA1LjA7XG4gICAgICAgIGNvbG9yID0gY29sb3IgKiBjO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi4vYXBwbGljYXRpb24vQ29tcG9uZW50Lm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb3JkZXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIENvbnRlbnQ6IHt9LFxuICAgICAgICAgICAgQm9yZGVyczoge1xuICAgICAgICAgICAgICAgIFRvcDoge3JlY3Q6IHRydWUsIHZpc2libGU6IGZhbHNlLCBtb3VudFk6IDF9LFxuICAgICAgICAgICAgICAgIFJpZ2h0OiB7cmVjdDogdHJ1ZSwgdmlzaWJsZTogZmFsc2V9LFxuICAgICAgICAgICAgICAgIEJvdHRvbToge3JlY3Q6IHRydWUsIHZpc2libGU6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICBMZWZ0OiB7cmVjdDogdHJ1ZSwgdmlzaWJsZTogZmFsc2UsIG1vdW50WDogMX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBnZXQgX3NpZ25hbFByb3h5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG5cbiAgICAgICAgdGhpcy5fYm9yZGVyVG9wID0gdGhpcy50YWcoXCJUb3BcIik7XG4gICAgICAgIHRoaXMuX2JvcmRlclJpZ2h0ID0gdGhpcy50YWcoXCJSaWdodFwiKTtcbiAgICAgICAgdGhpcy5fYm9yZGVyQm90dG9tID0gdGhpcy50YWcoXCJCb3R0b21cIik7XG4gICAgICAgIHRoaXMuX2JvcmRlckxlZnQgPSB0aGlzLnRhZyhcIkxlZnRcIik7XG5cbiAgICAgICAgdGhpcy5vbkFmdGVyVXBkYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbGVtZW50LmNoaWxkTGlzdC5maXJzdDtcbiAgICAgICAgICAgIGxldCB3ID0gZWxlbWVudC5jb3JlLncgfHwgY29udGVudC5yZW5kZXJXaWR0aDtcbiAgICAgICAgICAgIGxldCBoID0gZWxlbWVudC5jb3JlLmggfHwgY29udGVudC5yZW5kZXJIZWlnaHQ7XG4gICAgICAgICAgICBlbGVtZW50Ll9ib3JkZXJUb3AudyA9IHc7XG4gICAgICAgICAgICBlbGVtZW50Ll9ib3JkZXJCb3R0b20ueSA9IGg7XG4gICAgICAgICAgICBlbGVtZW50Ll9ib3JkZXJCb3R0b20udyA9IHc7XG4gICAgICAgICAgICBlbGVtZW50Ll9ib3JkZXJMZWZ0LmggPSBoICsgZWxlbWVudC5fYm9yZGVyVG9wLmggKyBlbGVtZW50Ll9ib3JkZXJCb3R0b20uaDtcbiAgICAgICAgICAgIGVsZW1lbnQuX2JvcmRlckxlZnQueSA9IC1lbGVtZW50Ll9ib3JkZXJUb3AuaDtcbiAgICAgICAgICAgIGVsZW1lbnQuX2JvcmRlclJpZ2h0LnggPSB3O1xuICAgICAgICAgICAgZWxlbWVudC5fYm9yZGVyUmlnaHQuaCA9IGggKyBlbGVtZW50Ll9ib3JkZXJUb3AuaCArIGVsZW1lbnQuX2JvcmRlckJvdHRvbS5oO1xuICAgICAgICAgICAgZWxlbWVudC5fYm9yZGVyUmlnaHQueSA9IC1lbGVtZW50Ll9ib3JkZXJUb3AuaDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmJvcmRlcldpZHRoID0gMTtcbiAgICB9XG5cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsKCdDb250ZW50Jyk7XG4gICAgfVxuXG4gICAgc2V0IGNvbnRlbnQodikge1xuICAgICAgICB0aGlzLnNlbCgnQ29udGVudCcpLnBhdGNoKHYsIHRydWUpO1xuICAgIH1cblxuICAgIGdldCBib3JkZXJXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyV2lkdGhUb3A7XG4gICAgfVxuXG4gICAgZ2V0IGJvcmRlcldpZHRoVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyVG9wLmg7XG4gICAgfVxuXG4gICAgZ2V0IGJvcmRlcldpZHRoUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJSaWdodC53O1xuICAgIH1cblxuICAgIGdldCBib3JkZXJXaWR0aEJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlckJvdHRvbS5oO1xuICAgIH1cblxuICAgIGdldCBib3JkZXJXaWR0aExlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJMZWZ0Lnc7XG4gICAgfVxuXG4gICAgc2V0IGJvcmRlcldpZHRoKHYpIHtcbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aFRvcCA9IHY7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGhSaWdodCA9IHY7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGhCb3R0b20gPSB2O1xuICAgICAgICB0aGlzLmJvcmRlcldpZHRoTGVmdCA9IHY7XG4gICAgfVxuXG4gICAgc2V0IGJvcmRlcldpZHRoVG9wKHYpIHtcbiAgICAgICAgdGhpcy5fYm9yZGVyVG9wLmggPSB2O1xuICAgICAgICB0aGlzLl9ib3JkZXJUb3AudmlzaWJsZSA9ICh2ID4gMCk7XG4gICAgfVxuXG4gICAgc2V0IGJvcmRlcldpZHRoUmlnaHQodikge1xuICAgICAgICB0aGlzLl9ib3JkZXJSaWdodC53ID0gdjtcbiAgICAgICAgdGhpcy5fYm9yZGVyUmlnaHQudmlzaWJsZSA9ICh2ID4gMCk7XG4gICAgfVxuXG4gICAgc2V0IGJvcmRlcldpZHRoQm90dG9tKHYpIHtcbiAgICAgICAgdGhpcy5fYm9yZGVyQm90dG9tLmggPSB2O1xuICAgICAgICB0aGlzLl9ib3JkZXJCb3R0b20udmlzaWJsZSA9ICh2ID4gMCk7XG4gICAgfVxuXG4gICAgc2V0IGJvcmRlcldpZHRoTGVmdCh2KSB7XG4gICAgICAgIHRoaXMuX2JvcmRlckxlZnQudyA9IHY7XG4gICAgICAgIHRoaXMuX2JvcmRlckxlZnQudmlzaWJsZSA9ICh2ID4gMCk7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yQm9yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvckJvcmRlclRvcDtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JCb3JkZXJUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJUb3AuY29sb3I7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yQm9yZGVyUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJSaWdodC5jb2xvcjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JCb3JkZXJCb3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJCb3R0b20uY29sb3I7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yQm9yZGVyTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlckxlZnQuY29sb3I7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQm9yZGVyKHYpIHtcbiAgICAgICAgdGhpcy5jb2xvckJvcmRlclRvcCA9IHY7XG4gICAgICAgIHRoaXMuY29sb3JCb3JkZXJSaWdodCA9IHY7XG4gICAgICAgIHRoaXMuY29sb3JCb3JkZXJCb3R0b20gPSB2O1xuICAgICAgICB0aGlzLmNvbG9yQm9yZGVyTGVmdCA9IHY7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQm9yZGVyVG9wKHYpIHtcbiAgICAgICAgdGhpcy5fYm9yZGVyVG9wLmNvbG9yID0gdjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCb3JkZXJSaWdodCh2KSB7XG4gICAgICAgIHRoaXMuX2JvcmRlclJpZ2h0LmNvbG9yID0gdjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCb3JkZXJCb3R0b20odikge1xuICAgICAgICB0aGlzLl9ib3JkZXJCb3R0b20uY29sb3IgPSB2O1xuICAgIH1cblxuICAgIHNldCBjb2xvckJvcmRlckxlZnQodikge1xuICAgICAgICB0aGlzLl9ib3JkZXJMZWZ0LmNvbG9yID0gdjtcbiAgICB9XG5cbiAgICBnZXQgYm9yZGVyVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyVG9wO1xuICAgIH1cblxuICAgIHNldCBib3JkZXJUb3Aoc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5ib3JkZXJUb3AucGF0Y2goc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGdldCBib3JkZXJSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlclJpZ2h0O1xuICAgIH1cblxuICAgIHNldCBib3JkZXJSaWdodChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmJvcmRlclJpZ2h0LnBhdGNoKHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBnZXQgYm9yZGVyQm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyQm90dG9tO1xuICAgIH1cblxuICAgIHNldCBib3JkZXJCb3R0b20oc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5ib3JkZXJCb3R0b20ucGF0Y2goc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGdldCBib3JkZXJMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyTGVmdDtcbiAgICB9XG5cbiAgICBzZXQgYm9yZGVyTGVmdChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmJvcmRlckxlZnQucGF0Y2goc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIHNldCBib3JkZXJzKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuYm9yZGVyVG9wID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuYm9yZGVyTGVmdCA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLmJvcmRlckJvdHRvbSA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLmJvcmRlclJpZ2h0ID0gc2V0dGluZ3M7XG4gICAgfVxuXG59XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4uL2FwcGxpY2F0aW9uL0NvbXBvbmVudC5tanNcIjtcbmltcG9ydCBMaW5lYXJCbHVyU2hhZGVyIGZyb20gXCIuLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0xpbmVhckJsdXJTaGFkZXIubWpzXCI7XG5pbXBvcnQgQm94Qmx1clNoYWRlciBmcm9tIFwiLi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9Cb3hCbHVyU2hhZGVyLm1qc1wiO1xuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanNcIjtcbmltcG9ydCBDMmRCbHVyU2hhZGVyIGZyb20gXCIuLi9yZW5kZXJlci9jMmQvc2hhZGVycy9CbHVyU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFNoYWRlciBmcm9tIFwiLi4vdHJlZS9TaGFkZXIubWpzXCI7XG5pbXBvcnQgTXVsdGlTcGxpbmUgZnJvbSBcIi4uL3Rvb2xzL011bHRpU3BsaW5lLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYXN0Qmx1ckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG4gICAgZ2V0IHdyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZyhcIldyYXBcIik7XG4gICAgfVxuXG4gICAgc2V0IGNvbnRlbnQodikge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwLmNvbnRlbnQgPSB2O1xuICAgIH1cblxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwLmNvbnRlbnQ7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmcodikge1xuICAgICAgICB0aGlzLndyYXAuX3BhZGRpbmdYID0gdjtcbiAgICAgICAgdGhpcy53cmFwLl9wYWRkaW5nWSA9IHY7XG4gICAgICAgIHRoaXMud3JhcC5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1godikge1xuICAgICAgICB0aGlzLndyYXAuX3BhZGRpbmdYID0gdjtcbiAgICAgICAgdGhpcy53cmFwLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nWSh2KSB7XG4gICAgICAgIHRoaXMud3JhcC5fcGFkZGluZ1kgPSB2O1xuICAgICAgICB0aGlzLndyYXAuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0IGFtb3VudCh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAuYW1vdW50ID0gdjtcbiAgICB9XG5cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwLmFtb3VudDtcbiAgICB9XG5cbiAgICBfb25SZXNpemUoKSB7XG4gICAgICAgIHRoaXMud3JhcC53ID0gdGhpcy5yZW5kZXJXaWR0aDtcbiAgICAgICAgdGhpcy53cmFwLmggPSB0aGlzLnJlbmRlckhlaWdodDtcbiAgICB9XG5cbiAgICBnZXQgX3NpZ25hbFByb3h5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfYnVpbGQoKSB7XG4gICAgICAgIHRoaXMucGF0Y2goe1xuICAgICAgICAgICAgV3JhcDoge3R5cGU6IHRoaXMuc3RhZ2UuZ2wgPyBXZWJHTEZhc3RCbHVyQ29tcG9uZW50IDogQzJkRmFzdEJsdXJDb21wb25lbnR9XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5cbmNsYXNzIEMyZEZhc3RCbHVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JjZVpJbmRleENvbnRleHQ6IHRydWUsXG4gICAgICAgICAgICBydHQ6IHRydWUsXG4gICAgICAgICAgICBUZXh0d3JhcDoge3NoYWRlcjoge3R5cGU6IEMyZEJsdXJTaGFkZXJ9LCBDb250ZW50OiB7fX1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAgPSB0aGlzLnNlbChcIlRleHR3cmFwXCIpO1xuICAgICAgICB0aGlzLl93cmFwcGVyID0gdGhpcy5zZWwoXCJUZXh0d3JhcD5Db250ZW50XCIpO1xuXG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdYID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1kgPSAwO1xuXG4gICAgfVxuXG4gICAgc3RhdGljIGdldFNwbGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tdWx0aVNwbGluZSkge1xuICAgICAgICAgICAgdGhpcy5fbXVsdGlTcGxpbmUgPSBuZXcgTXVsdGlTcGxpbmUoKTtcbiAgICAgICAgICAgIHRoaXMuX211bHRpU3BsaW5lLnBhcnNlKGZhbHNlLCB7MDogMCwgMC4yNTogMS41LCAwLjU6IDUuNSwgMC43NTogMTgsIDE6IDM5fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX211bHRpU3BsaW5lO1xuICAgIH1cblxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWwoJ1RleHR3cmFwPkNvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBzZXQgY29udGVudCh2KSB7XG4gICAgICAgIHRoaXMuc2VsKCdUZXh0d3JhcD5Db250ZW50JykucGF0Y2godiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmcodikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nWCA9IHY7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdZID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1godikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nWCA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdZKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1kgPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIF91cGRhdGVCbHVyU2l6ZSgpIHtcbiAgICAgICAgbGV0IHcgPSB0aGlzLnJlbmRlcldpZHRoO1xuICAgICAgICBsZXQgaCA9IHRoaXMucmVuZGVySGVpZ2h0O1xuXG4gICAgICAgIGxldCBwYWRkaW5nWCA9IHRoaXMuX3BhZGRpbmdYO1xuICAgICAgICBsZXQgcGFkZGluZ1kgPSB0aGlzLl9wYWRkaW5nWTtcblxuICAgICAgICB0aGlzLl93cmFwcGVyLnggPSBwYWRkaW5nWDtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAueCA9IC1wYWRkaW5nWDtcblxuICAgICAgICB0aGlzLl93cmFwcGVyLnkgPSBwYWRkaW5nWTtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAueSA9IC1wYWRkaW5nWTtcblxuICAgICAgICB0aGlzLl90ZXh0d3JhcC53ID0gdyArIHBhZGRpbmdYICogMjtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAuaCA9IGggKyBwYWRkaW5nWSAqIDI7XG4gICAgfVxuXG4gICAgZ2V0IGFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbW91bnQgb2YgYmx1ci4gQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDQuIEdvZXMgdXAgZXhwb25lbnRpYWxseSBmb3IgYmx1ci5cbiAgICAgKiBCZXN0IHJlc3VsdHMgZm9yIG5vbi1mcmFjdGlvbmFsIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gdjtcbiAgICAgKi9cbiAgICBzZXQgYW1vdW50KHYpIHtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gdjtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAuc2hhZGVyLmtlcm5lbFJhZGl1cyA9IEMyZEZhc3RCbHVyQ29tcG9uZW50Ll9hbW91bnRUb0tlcm5lbFJhZGl1cyh2KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2Ftb3VudFRvS2VybmVsUmFkaXVzKHYpIHtcbiAgICAgICAgcmV0dXJuIEMyZEZhc3RCbHVyQ29tcG9uZW50LmdldFNwbGluZSgpLmdldFZhbHVlKE1hdGgubWluKDEsIHYgKiAwLjI1KSk7XG4gICAgfVxuXG4gICAgZ2V0IF9zaWduYWxQcm94eSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59XG5cbmNsYXNzIFdlYkdMRmFzdEJsdXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgb25VcGRhdGUgPSBmdW5jdGlvbihlbGVtZW50LCBlbGVtZW50Q29yZSkge1xuICAgICAgICAgICAgaWYgKChlbGVtZW50Q29yZS5fcmVjYWxjICYgKDIgKyAxMjgpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBlbGVtZW50Q29yZS53O1xuICAgICAgICAgICAgICAgIGNvbnN0IGggPSBlbGVtZW50Q29yZS5oO1xuICAgICAgICAgICAgICAgIGxldCBjdXIgPSBlbGVtZW50Q29yZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5fY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgICAgIGN1ci5fZWxlbWVudC53ID0gdztcbiAgICAgICAgICAgICAgICAgICAgY3VyLl9lbGVtZW50LmggPSBoO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUoY3VyLl9jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFRleHR3cmFwOiB7cnR0OiB0cnVlLCBmb3JjZVpJbmRleENvbnRleHQ6IHRydWUsIHJlbmRlck9mZnNjcmVlbjogdHJ1ZSwgQ29udGVudDoge319LFxuICAgICAgICAgICAgTGF5ZXJzOiB7XG4gICAgICAgICAgICAgICAgTDA6IHtydHQ6IHRydWUsIG9uVXBkYXRlOiBvblVwZGF0ZSwgcmVuZGVyT2Zmc2NyZWVuOiB0cnVlLCB2aXNpYmxlOiBmYWxzZSwgQ29udGVudDoge3NoYWRlcjoge3R5cGU6IEJveEJsdXJTaGFkZXJ9fX0sXG4gICAgICAgICAgICAgICAgTDE6IHtydHQ6IHRydWUsIG9uVXBkYXRlOiBvblVwZGF0ZSwgcmVuZGVyT2Zmc2NyZWVuOiB0cnVlLCB2aXNpYmxlOiBmYWxzZSwgQ29udGVudDoge3NoYWRlcjoge3R5cGU6IEJveEJsdXJTaGFkZXJ9fX0sXG4gICAgICAgICAgICAgICAgTDI6IHtydHQ6IHRydWUsIG9uVXBkYXRlOiBvblVwZGF0ZSwgcmVuZGVyT2Zmc2NyZWVuOiB0cnVlLCB2aXNpYmxlOiBmYWxzZSwgQ29udGVudDoge3NoYWRlcjoge3R5cGU6IEJveEJsdXJTaGFkZXJ9fX0sXG4gICAgICAgICAgICAgICAgTDM6IHtydHQ6IHRydWUsIG9uVXBkYXRlOiBvblVwZGF0ZSwgcmVuZGVyT2Zmc2NyZWVuOiB0cnVlLCB2aXNpYmxlOiBmYWxzZSwgQ29udGVudDoge3NoYWRlcjoge3R5cGU6IEJveEJsdXJTaGFkZXJ9fX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBSZXN1bHQ6IHtzaGFkZXI6IHt0eXBlOiBGYXN0Qmx1ck91dHB1dFNoYWRlcn0sIHZpc2libGU6IGZhbHNlfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IF9zaWduYWxQcm94eSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuICAgICAgICB0aGlzLl90ZXh0d3JhcCA9IHRoaXMuc2VsKFwiVGV4dHdyYXBcIik7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIgPSB0aGlzLnNlbChcIlRleHR3cmFwPkNvbnRlbnRcIik7XG4gICAgICAgIHRoaXMuX2xheWVycyA9IHRoaXMuc2VsKFwiTGF5ZXJzXCIpO1xuICAgICAgICB0aGlzLl9vdXRwdXQgPSB0aGlzLnNlbChcIlJlc3VsdFwiKTtcblxuICAgICAgICB0aGlzLl9hbW91bnQgPSAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nWCA9IDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdZID0gMDtcbiAgICB9XG5cbiAgICBfYnVpbGRMYXllcnMoKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlclNoYWRlclNldHRpbmdzID0gW3t4OjEseTowLGtlcm5lbFJhZGl1czoxfSx7eDowLHk6MSxrZXJuZWxSYWRpdXM6MX0se3g6MS41LHk6MCxrZXJuZWxSYWRpdXM6MX0se3g6MCx5OjEuNSxrZXJuZWxSYWRpdXM6MX1dO1xuICAgICAgICBjb25zdCBmaWx0ZXJTaGFkZXJzID0gZmlsdGVyU2hhZGVyU2V0dGluZ3MubWFwKHMgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gU2hhZGVyLmNyZWF0ZSh0aGlzLnN0YWdlLCBPYmplY3QuYXNzaWduKHt0eXBlOiBMaW5lYXJCbHVyU2hhZGVyfSwgcykpO1xuICAgICAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc2V0TGF5ZXJUZXh0dXJlKHRoaXMuZ2V0TGF5ZXJDb250ZW50cygwKSwgdGhpcy5fdGV4dHdyYXAuZ2V0VGV4dHVyZSgpLCBbXSk7XG4gICAgICAgIHRoaXMuX3NldExheWVyVGV4dHVyZSh0aGlzLmdldExheWVyQ29udGVudHMoMSksIHRoaXMuZ2V0TGF5ZXIoMCkuZ2V0VGV4dHVyZSgpLCBbZmlsdGVyU2hhZGVyc1swXSwgZmlsdGVyU2hhZGVyc1sxXV0pO1xuXG4gICAgICAgIC8vIE5vdGljZSB0aGF0IDEuNSBmaWx0ZXJzIHNob3VsZCBiZSBhcHBsaWVkIGJlZm9yZSAxLjAgZmlsdGVycy5cbiAgICAgICAgdGhpcy5fc2V0TGF5ZXJUZXh0dXJlKHRoaXMuZ2V0TGF5ZXJDb250ZW50cygyKSwgdGhpcy5nZXRMYXllcigxKS5nZXRUZXh0dXJlKCksIFtmaWx0ZXJTaGFkZXJzWzBdLCBmaWx0ZXJTaGFkZXJzWzFdLCBmaWx0ZXJTaGFkZXJzWzJdLCBmaWx0ZXJTaGFkZXJzWzNdXSk7XG4gICAgICAgIHRoaXMuX3NldExheWVyVGV4dHVyZSh0aGlzLmdldExheWVyQ29udGVudHMoMyksIHRoaXMuZ2V0TGF5ZXIoMikuZ2V0VGV4dHVyZSgpLCBbZmlsdGVyU2hhZGVyc1swXSwgZmlsdGVyU2hhZGVyc1sxXSwgZmlsdGVyU2hhZGVyc1syXSwgZmlsdGVyU2hhZGVyc1szXV0pO1xuICAgIH1cblxuICAgIF9zZXRMYXllclRleHR1cmUoZWxlbWVudCwgdGV4dHVyZSwgc3RlcHMpIHtcbiAgICAgICAgaWYgKCFzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGVwID0gc3RlcHMucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGVsZW1lbnQuc3RhZ2UuYyh7cnR0OiB0cnVlLCBzaGFkZXI6IHN0ZXB9KTtcblxuICAgICAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgICAgIHRoaXMuX3NldExheWVyVGV4dHVyZShjaGlsZCwgdGV4dHVyZSwgc3RlcHMpO1xuXG4gICAgICAgICAgICBlbGVtZW50LmNoaWxkTGlzdC5hZGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWwoJ1RleHR3cmFwPkNvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBzZXQgY29udGVudCh2KSB7XG4gICAgICAgIHRoaXMuc2VsKCdUZXh0d3JhcD5Db250ZW50JykucGF0Y2godiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmcodikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nWCA9IHY7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdZID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1godikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nWCA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdZKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1kgPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIGdldExheWVyKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVycy5zZWwoXCJMXCIgKyBpKTtcbiAgICB9XG5cbiAgICBnZXRMYXllckNvbnRlbnRzKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIoaSkuc2VsKFwiQ29udGVudFwiKTtcbiAgICB9XG5cbiAgICBfb25SZXNpemUoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZUJsdXJTaXplKCkge1xuICAgICAgICBsZXQgdyA9IHRoaXMucmVuZGVyV2lkdGg7XG4gICAgICAgIGxldCBoID0gdGhpcy5yZW5kZXJIZWlnaHQ7XG5cbiAgICAgICAgbGV0IHBhZGRpbmdYID0gdGhpcy5fcGFkZGluZ1g7XG4gICAgICAgIGxldCBwYWRkaW5nWSA9IHRoaXMuX3BhZGRpbmdZO1xuXG4gICAgICAgIGxldCBmdyA9IHcgKyBwYWRkaW5nWCAqIDI7XG4gICAgICAgIGxldCBmaCA9IGggKyBwYWRkaW5nWSAqIDI7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwLncgPSBmdztcbiAgICAgICAgdGhpcy5fd3JhcHBlci54ID0gcGFkZGluZ1g7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMCkudyA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygwKS53ID0gZncgLyAyO1xuICAgICAgICB0aGlzLmdldExheWVyKDEpLncgPSB0aGlzLmdldExheWVyQ29udGVudHMoMSkudyA9IGZ3IC8gNDtcbiAgICAgICAgdGhpcy5nZXRMYXllcigyKS53ID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDIpLncgPSBmdyAvIDg7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMykudyA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygzKS53ID0gZncgLyAxNjtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnggPSAtcGFkZGluZ1g7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwLnggPSAtcGFkZGluZ1g7XG4gICAgICAgIHRoaXMuX291dHB1dC53ID0gZnc7XG5cbiAgICAgICAgdGhpcy5fdGV4dHdyYXAuaCA9IGZoO1xuICAgICAgICB0aGlzLl93cmFwcGVyLnkgPSBwYWRkaW5nWTtcbiAgICAgICAgdGhpcy5nZXRMYXllcigwKS5oID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDApLmggPSBmaCAvIDI7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMSkuaCA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygxKS5oID0gZmggLyA0O1xuICAgICAgICB0aGlzLmdldExheWVyKDIpLmggPSB0aGlzLmdldExheWVyQ29udGVudHMoMikuaCA9IGZoIC8gODtcbiAgICAgICAgdGhpcy5nZXRMYXllcigzKS5oID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDMpLmggPSBmaCAvIDE2O1xuICAgICAgICB0aGlzLl9vdXRwdXQueSA9IC1wYWRkaW5nWTtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAueSA9IC1wYWRkaW5nWTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmggPSBmaDtcblxuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICB0aGlzLmggPSBoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFtb3VudCBvZiBibHVyLiBBIHZhbHVlIGJldHdlZW4gMCBhbmQgNC4gR29lcyB1cCBleHBvbmVudGlhbGx5IGZvciBibHVyLlxuICAgICAqIEJlc3QgcmVzdWx0cyBmb3Igbm9uLWZyYWN0aW9uYWwgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB2O1xuICAgICAqL1xuICAgIHNldCBhbW91bnQodikge1xuICAgICAgICB0aGlzLl9hbW91bnQgPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50O1xuICAgIH1cblxuICAgIF91cGRhdGUoKSB7XG4gICAgICAgIGxldCB2ID0gTWF0aC5taW4oNCwgTWF0aC5tYXgoMCwgdGhpcy5fYW1vdW50KSk7XG4gICAgICAgIGlmICh2ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0d3JhcC5yZW5kZXJUb1RleHR1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX291dHB1dC5zaGFkZXIub3RoZXJUZXh0dXJlU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX291dHB1dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0d3JhcC5yZW5kZXJUb1RleHR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmdldExheWVyKDApLnZpc2libGUgPSAodiA+IDApO1xuICAgICAgICAgICAgdGhpcy5nZXRMYXllcigxKS52aXNpYmxlID0gKHYgPiAxKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGF5ZXIoMikudmlzaWJsZSA9ICh2ID4gMik7XG4gICAgICAgICAgICB0aGlzLmdldExheWVyKDMpLnZpc2libGUgPSAodiA+IDMpO1xuXG4gICAgICAgICAgICBpZiAodiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnRleHR1cmUgPSB0aGlzLl90ZXh0d3JhcC5nZXRUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNoYWRlci5vdGhlclRleHR1cmVTb3VyY2UgPSB0aGlzLmdldExheWVyKDApLmdldFRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQuc2hhZGVyLmEgPSB2O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2IDw9IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQudGV4dHVyZSA9IHRoaXMuZ2V0TGF5ZXIoMCkuZ2V0VGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC5zaGFkZXIub3RoZXJUZXh0dXJlU291cmNlID0gdGhpcy5nZXRMYXllcigxKS5nZXRUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNoYWRlci5hID0gdiAtIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYgPD0gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC50ZXh0dXJlID0gdGhpcy5nZXRMYXllcigxKS5nZXRUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNoYWRlci5vdGhlclRleHR1cmVTb3VyY2UgPSB0aGlzLmdldExheWVyKDIpLmdldFRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQuc2hhZGVyLmEgPSB2IC0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnRleHR1cmUgPSB0aGlzLmdldExheWVyKDIpLmdldFRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQuc2hhZGVyLm90aGVyVGV4dHVyZVNvdXJjZSA9IHRoaXMuZ2V0TGF5ZXIoMykuZ2V0VGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC5zaGFkZXIuYSA9IHYgLSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IHNoYWRlcihzKSB7XG4gICAgICAgIHN1cGVyLnNoYWRlciA9IHM7XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJUb1RleHR1cmUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIFBsZWFzZSBlbmFibGUgcmVuZGVyVG9UZXh0dXJlIHRvIHVzZSB3aXRoIGEgc2hhZGVyLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9maXJzdEFjdGl2ZSgpIHtcbiAgICAgICAgdGhpcy5fYnVpbGRMYXllcnMoKTtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBTaGFkZXIgdGhhdCBjb21iaW5lcyB0d28gdGV4dHVyZXMgaW50byBvbmUgb3V0cHV0LlxuICovXG5jbGFzcyBGYXN0Qmx1ck91dHB1dFNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG5cbiAgICAgICAgdGhpcy5fYSA9IDA7XG4gICAgICAgIHRoaXMuX290aGVyVGV4dHVyZVNvdXJjZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgIH1cblxuICAgIHNldCBhKHYpIHtcbiAgICAgICAgdGhpcy5fYSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IG90aGVyVGV4dHVyZVNvdXJjZSh2KSB7XG4gICAgICAgIHRoaXMuX290aGVyVGV4dHVyZVNvdXJjZSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiYVwiLCB0aGlzLl9hLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJ1U2FtcGxlcjJcIiwgMSwgdGhpcy5nbC51bmlmb3JtMWkpO1xuICAgIH1cblxuICAgIGJlZm9yZURyYXcob3BlcmF0aW9uKSB7XG4gICAgICAgIGxldCBnbFRleHR1cmUgPSB0aGlzLl9vdGhlclRleHR1cmVTb3VyY2UgPyB0aGlzLl9vdGhlclRleHR1cmVTb3VyY2UubmF0aXZlVGV4dHVyZSA6IG51bGw7XG5cbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSk7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIH1cbn1cblxuRmFzdEJsdXJPdXRwdXRTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjI7XG4gICAgdW5pZm9ybSBmbG9hdCBhO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgaWYgKGEgPT0gMS4wKSB7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9ICgoMS4wIC0gYSkgKiB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICsgKGEgKiB0ZXh0dXJlMkQodVNhbXBsZXIyLCB2VGV4dHVyZUNvb3JkKSkpICogdkNvbG9yO1xuICAgICAgICB9XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4uL2FwcGxpY2F0aW9uL0NvbXBvbmVudC5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG5cbiAgICAgICAgdGhpcy5fd3JhcHBlciA9IHN1cGVyLl9jaGlsZHJlbi5hKHt9KTtcblxuICAgICAgICB0aGlzLl9yZWxvYWRWaXNpYmxlRWxlbWVudHMgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl92aXNpYmxlSXRlbXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRyYW5zaXRpb24gZGVmaW5pdGlvbiB0aGF0IGlzIGJlaW5nIHVzZWQgd2hlbiBzY3JvbGxpbmcgdGhlIGl0ZW1zLlxuICAgICAgICAgKiBAdHlwZSBUcmFuc2l0aW9uU2V0dGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Njcm9sbFRyYW5zaXRpb25TZXR0aW5ncyA9IHRoaXMuc3RhZ2UudHJhbnNpdGlvbnMuY3JlYXRlU2V0dGluZ3Moe30pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2Nyb2xsIGFyZWEgc2l6ZSBpbiBwaXhlbHMgcGVyIGl0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtU2l6ZSA9IDEwMDtcblxuICAgICAgICB0aGlzLl92aWV3cG9ydFNjcm9sbE9mZnNldCA9IDA7XG5cbiAgICAgICAgdGhpcy5faXRlbVNjcm9sbE9mZnNldCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCB0aGUgbGlzdCBqdW1wIHdoZW4gc2Nyb2xsaW5nIGJldHdlZW4gZW5kIHRvIHN0YXJ0LCBvciBzaG91bGQgaXQgYmUgY29udGludW91cywgbGlrZSBhIGNhcnJvdXNlbD9cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JvbGwgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHJlc3RyaWN0aW5nIHRoZSBzdGFydCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yb2xsTWluID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHJlc3RyaWN0aW5nIHRoZSBlbmQgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcm9sbE1heCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluaXRpb24gZm9yIGEgY3VzdG9tIGFuaW1hdGlvbiB0aGF0IGlzIGFwcGxpZWQgd2hlbiBhbiBpdGVtIGlzIChwYXJ0aWFsbHkpIHNlbGVjdGVkLlxuICAgICAgICAgKiBAdHlwZSBBbmltYXRpb25TZXR0aW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NBbmltYXRpb24gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZlcnRzIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ludmVydERpcmVjdGlvbiA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMYXlvdXQgdGhlIGl0ZW1zIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5P1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvcml6b250YWwgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuaXRlbUxpc3QgPSBuZXcgTGlzdEl0ZW1zKHRoaXMpO1xuICAgIH1cblxuICAgIF9hbGxvd0NoaWxkcmVuQWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtTGlzdC5nZXQoKTtcbiAgICB9XG5cbiAgICBzZXQgaXRlbXMoY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5pdGVtTGlzdC5wYXRjaChjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIudHJhbnNpdGlvbih0aGlzLnByb3BlcnR5LCB0aGlzLl9zY3JvbGxUcmFuc2l0aW9uU2V0dGluZ3MpO1xuICAgICAgICB0aGlzLl9zY3JvbGxUcmFuc2l0aW9uID0gdGhpcy5fd3JhcHBlci50cmFuc2l0aW9uKHRoaXMucHJvcGVydHkpO1xuICAgICAgICB0aGlzLl9zY3JvbGxUcmFuc2l0aW9uLm9uKCdwcm9ncmVzcycsIHAgPT4gdGhpcy51cGRhdGUoKSk7XG5cbiAgICAgICAgdGhpcy5zZXRJbmRleCgwLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHNldEluZGV4KGluZGV4LCBpbW1lZGlhdGUgPSBmYWxzZSwgY2xvc2VzdCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBuRWxlbWVudHMgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFuRWxlbWVudHMpIHJldHVybjtcblxuICAgICAgICB0aGlzLmVtaXQoJ3VuZm9jdXMnLCB0aGlzLmdldEVsZW1lbnQodGhpcy5yZWFsSW5kZXgpLCB0aGlzLl9pbmRleCwgdGhpcy5yZWFsSW5kZXgpO1xuXG4gICAgICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICAgICAgICAvLyBTY3JvbGwgdG8gc2FtZSBvZmZzZXQgY2xvc2VzdCB0byB0aGUgaW5kZXguXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gVXRpbHMuZ2V0TW9kdWxvSW5kZXgoaW5kZXgsIG5FbGVtZW50cyk7XG4gICAgICAgICAgICBsZXQgbyA9IFV0aWxzLmdldE1vZHVsb0luZGV4KHRoaXMuaW5kZXgsIG5FbGVtZW50cyk7XG4gICAgICAgICAgICBsZXQgZGlmZiA9IG9mZnNldCAtIG87XG4gICAgICAgICAgICBpZiAoZGlmZiA+IDAuNSAqIG5FbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGRpZmYgLT0gbkVsZW1lbnRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgLTAuNSAqIG5FbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGRpZmYgKz0gbkVsZW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5kZXggKz0gZGlmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcm9sbCB8fCAodGhpcy52aWV3cG9ydFNpemUgPiB0aGlzLl9pdGVtU2l6ZSAqIG5FbGVtZW50cykpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gVXRpbHMuZ2V0TW9kdWxvSW5kZXgodGhpcy5faW5kZXgsIG5FbGVtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGlyZWN0aW9uID0gKHRoaXMuX2hvcml6b250YWwgXiB0aGlzLl9pbnZlcnREaXJlY3Rpb24gPyAtMSA6IDEpO1xuICAgICAgICBsZXQgdmFsdWUgPSBkaXJlY3Rpb24gKiB0aGlzLl9pbmRleCAqIHRoaXMuX2l0ZW1TaXplO1xuXG4gICAgICAgIGlmICh0aGlzLl9yb2xsKSB7XG4gICAgICAgICAgICBsZXQgbWluLCBtYXgsIHNjcm9sbERlbHRhO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gKG5FbGVtZW50cyAtIDEpICogdGhpcy5faXRlbVNpemU7XG4gICAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEgPSB0aGlzLl92aWV3cG9ydFNjcm9sbE9mZnNldCAqIHRoaXMudmlld3BvcnRTaXplIC0gdGhpcy5faXRlbVNjcm9sbE9mZnNldCAqIHRoaXMuX2l0ZW1TaXplO1xuXG4gICAgICAgICAgICAgICAgbWF4IC09IHNjcm9sbERlbHRhO1xuXG4gICAgICAgICAgICAgICAgbWluID0gdGhpcy52aWV3cG9ydFNpemUgLSAodGhpcy5faXRlbVNpemUgKyBzY3JvbGxEZWx0YSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcm9sbE1pbikgbWluIC09IHRoaXMuX3JvbGxNaW47XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JvbGxNYXgpIG1heCArPSB0aGlzLl9yb2xsTWF4O1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gKG5FbGVtZW50cyAqIHRoaXMuX2l0ZW1TaXplIC0gdGhpcy52aWV3cG9ydFNpemUpO1xuICAgICAgICAgICAgICAgIHNjcm9sbERlbHRhID0gdGhpcy5fdmlld3BvcnRTY3JvbGxPZmZzZXQgKiB0aGlzLnZpZXdwb3J0U2l6ZSAtIHRoaXMuX2l0ZW1TY3JvbGxPZmZzZXQgKiB0aGlzLl9pdGVtU2l6ZTtcblxuICAgICAgICAgICAgICAgIG1heCArPSBzY3JvbGxEZWx0YTtcblxuICAgICAgICAgICAgICAgIGxldCBtaW4gPSBzY3JvbGxEZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yb2xsTWluKSBtaW4gLT0gdGhpcy5fcm9sbE1pbjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcm9sbE1heCkgbWF4ICs9IHRoaXMuX3JvbGxNYXg7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWluKE1hdGgubWF4KC1tYXgsIHZhbHVlKSwgLW1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zY3JvbGxUcmFuc2l0aW9uLnN0YXJ0KHZhbHVlKTtcblxuICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUcmFuc2l0aW9uLmZpbmlzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdmb2N1cycsIHRoaXMuZ2V0RWxlbWVudCh0aGlzLnJlYWxJbmRleCksIHRoaXMuX2luZGV4LCB0aGlzLnJlYWxJbmRleCk7XG4gICAgfVxuXG4gICAgZ2V0QXhpc1Bvc2l0aW9uKCkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gLXRoaXMuX3Njcm9sbFRyYW5zaXRpb24uX3RhcmdldFZhbHVlO1xuXG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSAodGhpcy5faG9yaXpvbnRhbCBeIHRoaXMuX2ludmVydERpcmVjdGlvbiA/IC0xIDogMSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IC1kaXJlY3Rpb24gKiB0aGlzLl9pbmRleCAqIHRoaXMuX2l0ZW1TaXplO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFNjcm9sbE9mZnNldCAqIHRoaXMudmlld3BvcnRTaXplICsgKHZhbHVlIC0gdGFyZ2V0KTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBuRWxlbWVudHMgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFuRWxlbWVudHMpIHJldHVybjtcblxuICAgICAgICBsZXQgZGlyZWN0aW9uID0gKHRoaXMuX2hvcml6b250YWwgXiB0aGlzLl9pbnZlcnREaXJlY3Rpb24gPyAtMSA6IDEpO1xuXG4gICAgICAgIC8vIE1hcCBwb3NpdGlvbiB0byBpbmRleCB2YWx1ZS5cbiAgICAgICAgbGV0IHYgPSAodGhpcy5faG9yaXpvbnRhbCA/IHRoaXMuX3dyYXBwZXIueCA6IHRoaXMuX3dyYXBwZXIueSk7XG5cbiAgICAgICAgbGV0IHZpZXdwb3J0U2l6ZSA9IHRoaXMudmlld3BvcnRTaXplO1xuICAgICAgICBsZXQgc2Nyb2xsRGVsdGEgPSB0aGlzLl92aWV3cG9ydFNjcm9sbE9mZnNldCAqIHZpZXdwb3J0U2l6ZSAtIHRoaXMuX2l0ZW1TY3JvbGxPZmZzZXQgKiB0aGlzLl9pdGVtU2l6ZTtcbiAgICAgICAgdiArPSBzY3JvbGxEZWx0YTtcblxuICAgICAgICBsZXQgcywgZSwgcHMsIHBlO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09IC0xKSB7XG4gICAgICAgICAgICBzID0gTWF0aC5mbG9vcigtdiAvIHRoaXMuX2l0ZW1TaXplKTtcbiAgICAgICAgICAgIHBzID0gMSAtICgoLXYgLyB0aGlzLl9pdGVtU2l6ZSkgLSBzKTtcbiAgICAgICAgICAgIGUgPSBNYXRoLmZsb29yKCh2aWV3cG9ydFNpemUgLSB2KSAvIHRoaXMuX2l0ZW1TaXplKTtcbiAgICAgICAgICAgIHBlID0gKCgodmlld3BvcnRTaXplIC0gdikgLyB0aGlzLl9pdGVtU2l6ZSkgLSBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBNYXRoLmNlaWwodiAvIHRoaXMuX2l0ZW1TaXplKTtcbiAgICAgICAgICAgIHBzID0gMSArICh2IC8gdGhpcy5faXRlbVNpemUpIC0gcztcbiAgICAgICAgICAgIGUgPSBNYXRoLmNlaWwoKHYgLSB2aWV3cG9ydFNpemUpIC8gdGhpcy5faXRlbVNpemUpO1xuICAgICAgICAgICAgcGUgPSBlIC0gKCh2IC0gdmlld3BvcnRTaXplKSAvIHRoaXMuX2l0ZW1TaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcm9sbCB8fCAodmlld3BvcnRTaXplID4gdGhpcy5faXRlbVNpemUgKiBuRWxlbWVudHMpKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBzaG93IGFkZGl0aW9uYWwgaXRlbXMuXG4gICAgICAgICAgICBpZiAoZSA+PSBuRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBlID0gbkVsZW1lbnRzIC0gMTtcbiAgICAgICAgICAgICAgICBwZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocyA+PSBuRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBzID0gbkVsZW1lbnRzIC0gMTtcbiAgICAgICAgICAgICAgICBwcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSA8PSAtMSkge1xuICAgICAgICAgICAgICAgIGUgPSAwO1xuICAgICAgICAgICAgICAgIHBlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzIDw9IC0xKSB7XG4gICAgICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgICAgICAgcHMgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IC1kaXJlY3Rpb24gKiBzICogdGhpcy5faXRlbVNpemU7XG5cbiAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gczsgKGRpcmVjdGlvbiA9PSAtMSA/IGluZGV4IDw9IGUgOiBpbmRleCA+PSBlKTsgKGRpcmVjdGlvbiA9PSAtMSA/IGluZGV4KysgOiBpbmRleC0tKSkge1xuICAgICAgICAgICAgbGV0IHJlYWxJbmRleCA9IFV0aWxzLmdldE1vZHVsb0luZGV4KGluZGV4LCBuRWxlbWVudHMpO1xuXG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudChyZWFsSW5kZXgpO1xuICAgICAgICAgICAgaXRlbSA9IGVsZW1lbnQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZUl0ZW1zLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgaXRlbS54ID0gb2Zmc2V0ICsgc2Nyb2xsRGVsdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0ueSA9IG9mZnNldCArIHNjcm9sbERlbHRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgd2FzVmlzaWJsZSA9IGl0ZW0udmlzaWJsZTtcbiAgICAgICAgICAgIGl0ZW0udmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghd2FzVmlzaWJsZSB8fCB0aGlzLl9yZWxvYWRWaXNpYmxlRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAvLyBUdXJuZWQgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3Zpc2libGUnLCBpbmRleCwgcmVhbEluZGV4KTtcbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBwID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gcykge1xuICAgICAgICAgICAgICAgICAgICBwID0gcHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgYW5pbWF0aW9uIHRvIHByb2dyZXNzLlxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzQW5pbWF0aW9uLmFwcGx5KGVsZW1lbnQsIHApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5faXRlbVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgaXRlbSB2aXNpYmlsaXR5LlxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Zpc2libGVJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGludmlzaWJsZUl0ZW0pIHtcbiAgICAgICAgICAgIGludmlzaWJsZUl0ZW0udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5fdmlzaWJsZUl0ZW1zLmRlbGV0ZShpbnZpc2libGVJdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSBzOyAoZGlyZWN0aW9uID09IC0xID8gaW5kZXggPD0gZSA6IGluZGV4ID49IGUpOyAoZGlyZWN0aW9uID09IC0xID8gaW5kZXgrKyA6IGluZGV4LS0pKSB7XG4gICAgICAgICAgICBsZXQgcmVhbEluZGV4ID0gVXRpbHMuZ2V0TW9kdWxvSW5kZXgoaW5kZXgsIG5FbGVtZW50cyk7XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlSXRlbXMuYWRkKHRoaXMuZ2V0V3JhcHBlcihyZWFsSW5kZXgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbG9hZFZpc2libGVFbGVtZW50cyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNldFByZXZpb3VzKCkge1xuICAgICAgICB0aGlzLnNldEluZGV4KHRoaXMuX2luZGV4IC0gMSk7XG4gICAgfVxuXG4gICAgc2V0TmV4dCgpIHtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLl9pbmRleCArIDEpO1xuICAgIH1cblxuICAgIGdldFdyYXBwZXIoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBwZXIuY2hpbGRyZW5baW5kZXhdO1xuICAgIH1cblxuICAgIGdldEVsZW1lbnQoaW5kZXgpIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLl93cmFwcGVyLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIGUgPyBlLmNoaWxkcmVuWzBdIDogbnVsbDtcbiAgICB9XG5cbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHRoaXMuX3JlbG9hZFZpc2libGVFbGVtZW50cyA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5fd3JhcHBlci5jaGlsZHJlblt0aGlzLnJlYWxJbmRleF07XG4gICAgICAgIHJldHVybiBlID8gZS5jaGlsZHJlblswXSA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIH1cblxuICAgIGdldCBwcm9wZXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvcml6b250YWwgPyAneCcgOiAneSc7XG4gICAgfVxuXG4gICAgZ2V0IHZpZXdwb3J0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvcml6b250YWwgPyB0aGlzLncgOiB0aGlzLmg7XG4gICAgfVxuXG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgfVxuXG4gICAgZ2V0IHJlYWxJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLmdldE1vZHVsb0luZGV4KHRoaXMuX2luZGV4LCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgZ2V0IGl0ZW1TaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbVNpemU7XG4gICAgfVxuXG4gICAgc2V0IGl0ZW1TaXplKHYpIHtcbiAgICAgICAgdGhpcy5faXRlbVNpemUgPSB2O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCB2aWV3cG9ydFNjcm9sbE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2Nyb2xsT2Zmc2V0O1xuICAgIH1cblxuICAgIHNldCB2aWV3cG9ydFNjcm9sbE9mZnNldCh2KSB7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0U2Nyb2xsT2Zmc2V0ID0gdjtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgaXRlbVNjcm9sbE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1TY3JvbGxPZmZzZXQ7XG4gICAgfVxuXG4gICAgc2V0IGl0ZW1TY3JvbGxPZmZzZXQodikge1xuICAgICAgICB0aGlzLl9pdGVtU2Nyb2xsT2Zmc2V0ID0gdjtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgc2Nyb2xsVHJhbnNpdGlvblNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsVHJhbnNpdGlvblNldHRpbmdzO1xuICAgIH1cblxuICAgIHNldCBzY3JvbGxUcmFuc2l0aW9uU2V0dGluZ3Modikge1xuICAgICAgICB0aGlzLl9zY3JvbGxUcmFuc2l0aW9uU2V0dGluZ3MucGF0Y2godik7XG4gICAgfVxuXG4gICAgc2V0IHNjcm9sbFRyYW5zaXRpb24odikge1xuICAgICAgICB0aGlzLl9zY3JvbGxUcmFuc2l0aW9uU2V0dGluZ3MucGF0Y2godik7XG4gICAgfVxuXG4gICAgZ2V0IHNjcm9sbFRyYW5zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxUcmFuc2l0aW9uO1xuICAgIH1cblxuICAgIGdldCBwcm9ncmVzc0FuaW1hdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzQW5pbWF0aW9uO1xuICAgIH1cblxuICAgIHNldCBwcm9ncmVzc0FuaW1hdGlvbih2KSB7XG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodikpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzQW5pbWF0aW9uID0gdGhpcy5zdGFnZS5hbmltYXRpb25zLmNyZWF0ZVNldHRpbmdzKHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NBbmltYXRpb24gPSB2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHJvbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb2xsO1xuICAgIH1cblxuICAgIHNldCByb2xsKHYpIHtcbiAgICAgICAgdGhpcy5fcm9sbCA9IHY7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHJvbGxNaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb2xsTWluO1xuICAgIH1cblxuICAgIHNldCByb2xsTWluKHYpIHtcbiAgICAgICAgdGhpcy5fcm9sbE1pbiA9IHY7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHJvbGxNYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb2xsTWF4O1xuICAgIH1cblxuICAgIHNldCByb2xsTWF4KHYpIHtcbiAgICAgICAgdGhpcy5fcm9sbE1heCA9IHY7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGludmVydERpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmVydERpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgaW52ZXJ0RGlyZWN0aW9uKHYpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZlcnREaXJlY3Rpb24gPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGhvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3Jpem9udGFsO1xuICAgIH1cblxuICAgIHNldCBob3Jpem9udGFsKHYpIHtcbiAgICAgICAgaWYgKHYgIT09IHRoaXMuX2hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvcml6b250YWwgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmltcG9ydCBPYmplY3RMaXN0V3JhcHBlciBmcm9tIFwiLi4vdG9vbHMvT2JqZWN0TGlzdFdyYXBwZXIubWpzXCI7XG5jbGFzcyBMaXN0SXRlbXMgZXh0ZW5kcyBPYmplY3RMaXN0V3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IobGlzdCkge1xuICAgICAgICBsZXQgd3JhcCA9IChpdGVtID0+IHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBpdGVtLnN0YWdlLmNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHBhcmVudC5hZGQoaXRlbSk7XG4gICAgICAgICAgICBwYXJlbnQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfSlcblxuICAgICAgICBzdXBlcihsaXN0Ll93cmFwcGVyLl9jaGlsZHJlbiwgd3JhcCk7XG4gICAgICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgfVxuXG4gICAgb25BZGQoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgc3VwZXIub25BZGQoaXRlbSwgaW5kZXgpO1xuICAgICAgICB0aGlzLmNoZWNrU3RhcnRlZChpbmRleCk7XG4gICAgfVxuXG4gICAgY2hlY2tTdGFydGVkKGluZGV4KSB7XG4gICAgICAgIHRoaXMubGlzdC5fcmVsb2FkVmlzaWJsZUVsZW1lbnRzID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3QuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5zdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc2V0SW5kZXgoMCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3QuX2luZGV4ID49IHRoaXMubGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnNldEluZGV4KDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGlzdC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uUmVtb3ZlKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHN1cGVyLm9uUmVtb3ZlKGl0ZW0sIGluZGV4KTtcbiAgICAgICAgbGV0IHJpID0gdGhpcy5saXN0LnJlYWxJbmRleDtcbiAgICAgICAgaWYgKHJpID09PSBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHJpID09PSB0aGlzLmxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0LnNldEluZGV4KHJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyaSA+IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmxpc3Quc2V0SW5kZXgocmkgLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGlzdC5fcmVsb2FkVmlzaWJsZUVsZW1lbnRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBvblNldChpdGVtLCBpbmRleCkge1xuICAgICAgICBzdXBlci5vblNldChpdGVtLCBpbmRleCk7XG4gICAgICAgIHRoaXMuY2hlY2tTdGFydGVkKGluZGV4KTtcbiAgICB9XG5cbiAgICBvblN5bmMocmVtb3ZlZCwgYWRkZWQsIG9yZGVyKSB7XG4gICAgICAgIHN1cGVyLm9uU3luYyhyZW1vdmVkLCBhZGRlZCwgb3JkZXIpO1xuICAgICAgICB0aGlzLmNoZWNrU3RhcnRlZCgwKTtcbiAgICB9XG5cbiAgICBnZXQgX3NpZ25hbFByb3h5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbn1cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi4vYXBwbGljYXRpb24vQ29tcG9uZW50Lm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbW9vdGhTY2FsZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQ29udGVudFdyYXA6IHtyZW5kZXJPZmZzY3JlZW46IHRydWUsIGZvcmNlWkluZGV4Q29udGV4dDogdHJ1ZSwgb25BZnRlclVwZGF0ZTogU21vb3RoU2NhbGVDb21wb25lbnQuX3VwZGF0ZURpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgQ29udGVudDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTY2FsZToge3Zpc2libGU6IGZhbHNlfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuXG4gICAgICAgIHRoaXMuX3Ntb290aFNjYWxlID0gMTtcbiAgICAgICAgdGhpcy5faXRlcmF0aW9ucyA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZygnQ29udGVudCcpO1xuICAgIH1cblxuICAgIHNldCBjb250ZW50KHYpIHtcbiAgICAgICAgdGhpcy50YWcoJ0NvbnRlbnQnKS5wYXRjaCh2LCB0cnVlKTtcbiAgICB9XG5cbiAgICBnZXQgc21vb3RoU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zbW9vdGhTY2FsZTtcbiAgICB9XG5cbiAgICBzZXQgc21vb3RoU2NhbGUodikge1xuICAgICAgICBpZiAodGhpcy5fc21vb3RoU2NhbGUgIT09IHYpIHtcbiAgICAgICAgICAgIGxldCBpdHMgPSAwO1xuICAgICAgICAgICAgd2hpbGUodiA8IDAuNSAmJiBpdHMgPCAxMikge1xuICAgICAgICAgICAgICAgIGl0cysrO1xuICAgICAgICAgICAgICAgIHYgPSB2ICogMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9zZXRJdGVyYXRpb25zKGl0cyk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Ntb290aFNjYWxlID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRJdGVyYXRpb25zKGl0cykge1xuICAgICAgICBpZiAodGhpcy5faXRlcmF0aW9ucyAhPT0gaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZXJzID0gdGhpcy5zZWwoXCJTY2FsZVwiKS5jaGlsZExpc3Q7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5zZWwoXCJDb250ZW50V3JhcFwiKTtcbiAgICAgICAgICAgIHdoaWxlIChzY2FsZXJzLmxlbmd0aCA8IGl0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gc2NhbGVycy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IChmaXJzdCA/IGNvbnRlbnQuZ2V0VGV4dHVyZSgpIDogc2NhbGVycy5sYXN0LmdldFRleHR1cmUoKSk7XG4gICAgICAgICAgICAgICAgc2NhbGVycy5hKHtydHQ6IHRydWUsIHJlbmRlck9mZnNjcmVlbjogdHJ1ZSwgdGV4dHVyZTogdGV4dHVyZX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBTbW9vdGhTY2FsZUNvbXBvbmVudC5fdXBkYXRlRGltZW5zaW9ucyh0aGlzLnRhZyhcIkNvbnRlbnRXcmFwXCIpLCB0cnVlKTtcblxuICAgICAgICAgICAgY29uc3QgdXNlU2NhbGVycyA9IChpdHMgPiAwKTtcbiAgICAgICAgICAgIHRoaXMucGF0Y2goe1xuICAgICAgICAgICAgICAgIENvbnRlbnRXcmFwOiB7cmVuZGVyVG9UZXh0dXJlOiB1c2VTY2FsZXJzfSxcbiAgICAgICAgICAgICAgICBTY2FsZToge3Zpc2libGU6IHVzZVNjYWxlcnN9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBzY2FsZXJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHNjYWxlcnMuZ2V0QXQoaSkucGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBpIDwgaXRzLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJPZmZzY3JlZW46IGkgIT09IGl0cyAtIDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2l0ZXJhdGlvbnMgPSBpdHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgX3VwZGF0ZURpbWVuc2lvbnMoY29udGVudFdyYXAsIGZvcmNlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50V3JhcC5jaGlsZHJlblswXTtcbiAgICAgICAgbGV0IHcgPSBjb250ZW50LnJlbmRlcldpZHRoO1xuICAgICAgICBsZXQgaCA9IGNvbnRlbnQucmVuZGVySGVpZ2h0O1xuICAgICAgICBpZiAodyAhPT0gY29udGVudFdyYXAudyB8fCBoICE9PSBjb250ZW50V3JhcC5oIHx8IGZvcmNlKSB7XG4gICAgICAgICAgICBjb250ZW50V3JhcC53ID0gdztcbiAgICAgICAgICAgIGNvbnRlbnRXcmFwLmggPSBoO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsZXJzID0gY29udGVudFdyYXAucGFyZW50LnRhZyhcIlNjYWxlXCIpLmNoaWxkcmVuO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBzY2FsZXJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHcgPSB3ICogMC41O1xuICAgICAgICAgICAgICAgIGggPSBoICogMC41O1xuICAgICAgICAgICAgICAgIHNjYWxlcnNbaV0udyA9IHc7XG4gICAgICAgICAgICAgICAgc2NhbGVyc1tpXS5oID0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBfc2lnbmFsUHJveHkoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEJhc2UgZnJvbSBcIi4uL3RyZWUvQmFzZS5tanNcIjtcbmltcG9ydCBMYXlvdXQgZnJvbSBcIi4vbGF5b3V0L0ZsZXhMYXlvdXQubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsZXhDb250YWluZXIge1xuXG5cbiAgICBjb25zdHJ1Y3RvcihpdGVtKSB7XG4gICAgICAgIHRoaXMuX2l0ZW0gPSBpdGVtO1xuXG4gICAgICAgIHRoaXMuX2xheW91dCA9IG5ldyBMYXlvdXQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hvcml6b250YWwgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZXZlcnNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dyYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWxpZ25JdGVtcyA9ICdzdHJldGNoJztcbiAgICAgICAgdGhpcy5fanVzdGlmeUNvbnRlbnQgPSAnZmxleC1zdGFydCc7XG4gICAgICAgIHRoaXMuX2FsaWduQ29udGVudCA9ICdmbGV4LXN0YXJ0JztcblxuICAgICAgICB0aGlzLl9wYWRkaW5nTGVmdCA9IDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdUb3AgPSAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nQm90dG9tID0gMDtcbiAgICB9XG5cbiAgICBnZXQgaXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW07XG4gICAgfVxuXG4gICAgX2NoYW5nZWREaW1lbnNpb25zKCkge1xuICAgICAgICB0aGlzLl9pdGVtLmNoYW5nZWREaW1lbnNpb25zKCk7XG4gICAgfVxuXG4gICAgX2NoYW5nZWRDb250ZW50cygpIHtcbiAgICAgICAgdGhpcy5faXRlbS5jaGFuZ2VkQ29udGVudHMoKTtcbiAgICB9XG5cbiAgICBnZXQgZGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2hvcml6b250YWwgPyBcInJvd1wiIDogXCJjb2x1bW5cIikgKyAodGhpcy5fcmV2ZXJzZSA/IFwiLXJldmVyc2VcIiA6IFwiXCIpO1xuICAgIH1cblxuICAgIHNldCBkaXJlY3Rpb24oZikge1xuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09IGYpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9ob3Jpem9udGFsID0gKGYgPT09ICdyb3cnIHx8IGYgPT09ICdyb3ctcmV2ZXJzZScpO1xuICAgICAgICB0aGlzLl9yZXZlcnNlID0gKGYgPT09ICdyb3ctcmV2ZXJzZScgfHwgZiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyk7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgfVxuXG4gICAgc2V0IHdyYXAodikge1xuICAgICAgICB0aGlzLl93cmFwID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgfVxuXG4gICAgZ2V0IHdyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwO1xuICAgIH1cblxuICAgIGdldCBhbGlnbkl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxpZ25JdGVtcztcbiAgICB9XG5cbiAgICBzZXQgYWxpZ25JdGVtcyh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9hbGlnbkl0ZW1zID09PSB2KSByZXR1cm47XG4gICAgICAgIGlmIChGbGV4Q29udGFpbmVyLkFMSUdOX0lURU1TLmluZGV4T2YodikgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFsaWduSXRlbXMsIG9wdGlvbnM6IFwiICsgRmxleENvbnRhaW5lci5BTElHTl9JVEVNUy5qb2luKFwiLFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWxpZ25JdGVtcyA9IHY7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgfVxuXG4gICAgZ2V0IGFsaWduQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsaWduQ29udGVudDtcbiAgICB9XG5cbiAgICBzZXQgYWxpZ25Db250ZW50KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FsaWduQ29udGVudCA9PT0gdikgcmV0dXJuO1xuICAgICAgICBpZiAoRmxleENvbnRhaW5lci5BTElHTl9DT05URU5ULmluZGV4T2YodikgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFsaWduQ29udGVudCwgb3B0aW9uczogXCIgKyBGbGV4Q29udGFpbmVyLkFMSUdOX0NPTlRFTlQuam9pbihcIixcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FsaWduQ29udGVudCA9IHY7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgfVxuXG4gICAgZ2V0IGp1c3RpZnlDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVzdGlmeUNvbnRlbnQ7XG4gICAgfVxuXG4gICAgc2V0IGp1c3RpZnlDb250ZW50KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2p1c3RpZnlDb250ZW50ID09PSB2KSByZXR1cm47XG5cbiAgICAgICAgaWYgKEZsZXhDb250YWluZXIuSlVTVElGWV9DT05URU5ULmluZGV4T2YodikgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGp1c3RpZnlDb250ZW50LCBvcHRpb25zOiBcIiArIEZsZXhDb250YWluZXIuSlVTVElGWV9DT05URU5ULmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9qdXN0aWZ5Q29udGVudCA9IHY7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmcodikge1xuICAgICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gdjtcbiAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gdjtcbiAgICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB2O1xuICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB2O1xuICAgIH1cblxuICAgIGdldCBwYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWRkaW5nTGVmdDtcbiAgICB9XG4gICAgXG4gICAgc2V0IHBhZGRpbmdMZWZ0KHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ0xlZnQgPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkRGltZW5zaW9ucygpO1xuICAgIH1cbiAgICBcbiAgICBnZXQgcGFkZGluZ0xlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nTGVmdDtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1RvcCh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdUb3AgPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkRGltZW5zaW9ucygpO1xuICAgIH1cblxuICAgIGdldCBwYWRkaW5nVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFkZGluZ1RvcDtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1JpZ2h0KHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1JpZ2h0ID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZERpbWVuc2lvbnMoKTtcbiAgICB9XG5cbiAgICBnZXQgcGFkZGluZ1JpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFkZGluZ1JpZ2h0O1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nQm90dG9tKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ0JvdHRvbSA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWREaW1lbnNpb25zKCk7XG4gICAgfVxuXG4gICAgZ2V0IHBhZGRpbmdCb3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nQm90dG9tO1xuICAgIH1cblxuICAgIHBhdGNoKHNldHRpbmdzKSB7XG4gICAgICAgIEJhc2UucGF0Y2hPYmplY3QodGhpcywgc2V0dGluZ3MpO1xuICAgIH1cblxufVxuXG5GbGV4Q29udGFpbmVyLkFMSUdOX0lURU1TID0gW1wiZmxleC1zdGFydFwiLCBcImZsZXgtZW5kXCIsIFwiY2VudGVyXCIsIFwic3RyZXRjaFwiXTtcbkZsZXhDb250YWluZXIuQUxJR05fQ09OVEVOVCA9IFtcImZsZXgtc3RhcnRcIiwgXCJmbGV4LWVuZFwiLCBcImNlbnRlclwiLCBcInNwYWNlLWJldHdlZW5cIiwgXCJzcGFjZS1hcm91bmRcIiwgXCJzcGFjZS1ldmVubHlcIiwgXCJzdHJldGNoXCJdO1xuRmxleENvbnRhaW5lci5KVVNUSUZZX0NPTlRFTlQgPSBbXCJmbGV4LXN0YXJ0XCIsIFwiZmxleC1lbmRcIiwgXCJjZW50ZXJcIiwgXCJzcGFjZS1iZXR3ZWVuXCIsIFwic3BhY2UtYXJvdW5kXCIsIFwic3BhY2UtZXZlbmx5XCJdO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEJhc2UgZnJvbSBcIi4uL3RyZWUvQmFzZS5tanNcIjtcbmltcG9ydCBGbGV4VXRpbHMgZnJvbSBcIi4vRmxleFV0aWxzLm1qc1wiO1xuaW1wb3J0IEZsZXhDb250YWluZXIgZnJvbSBcIi4vRmxleENvbnRhaW5lci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmxleEl0ZW0ge1xuXG4gICAgY29uc3RydWN0b3IoaXRlbSkge1xuICAgICAgICB0aGlzLl9jdHIgPSBudWxsO1xuICAgICAgICB0aGlzLl9pdGVtID0gaXRlbTtcbiAgICAgICAgdGhpcy5fZ3JvdyA9IDA7XG4gICAgICAgIHRoaXMuX3NocmluayA9IEZsZXhJdGVtLlNIUklOS19BVVRPO1xuICAgICAgICB0aGlzLl9hbGlnblNlbGYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX21pbldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fbWluSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fbWF4V2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9tYXhIZWlnaHQgPSAwO1xuXG4gICAgICAgIHRoaXMuX21hcmdpbkxlZnQgPSAwO1xuICAgICAgICB0aGlzLl9tYXJnaW5Ub3AgPSAwO1xuICAgICAgICB0aGlzLl9tYXJnaW5SaWdodCA9IDA7XG4gICAgICAgIHRoaXMuX21hcmdpbkJvdHRvbSA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IGl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtO1xuICAgIH1cblxuICAgIGdldCBncm93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdztcbiAgICB9XG5cbiAgICBzZXQgZ3Jvdyh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9ncm93ID09PSB2KSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fZ3JvdyA9IHBhcnNlSW50KHYpIHx8IDA7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGdldCBzaHJpbmsoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaHJpbmsgPT09IEZsZXhJdGVtLlNIUklOS19BVVRPKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGVmYXVsdFNocmluaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zaHJpbms7XG4gICAgfVxuXG4gICAgX2dldERlZmF1bHRTaHJpbmsoKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW0uaXNGbGV4RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFsbCBub24tZmxleCBjb250YWluZXJzIGFyZSBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgaXRlbXMgd2l0aCBmaXhlZCBkaW1lbnNpb25zLCBhbmQgYnkgZGVmYXVsdCBub3Qgc2hyaW5rYWJsZS5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IHNocmluayh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zaHJpbmsgPT09IHYpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9zaHJpbmsgPSBwYXJzZUludCh2KSB8fCAwO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgYWxpZ25TZWxmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxpZ25TZWxmO1xuICAgIH1cblxuICAgIHNldCBhbGlnblNlbGYodikge1xuICAgICAgICBpZiAodGhpcy5fYWxpZ25TZWxmID09PSB2KSByZXR1cm47XG5cbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fYWxpZ25TZWxmID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEZsZXhDb250YWluZXIuQUxJR05fSVRFTVMuaW5kZXhPZih2KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFsaWduU2VsZiwgb3B0aW9uczogXCIgKyBGbGV4Q29udGFpbmVyLkFMSUdOX0lURU1TLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FsaWduU2VsZiA9IHY7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgZ2V0IG1pbldpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluV2lkdGg7XG4gICAgfVxuXG4gICAgc2V0IG1pbldpZHRoKHYpIHtcbiAgICAgICAgdGhpcy5fbWluV2lkdGggPSBNYXRoLm1heCgwLCB2KTtcbiAgICAgICAgdGhpcy5faXRlbS5jaGFuZ2VkRGltZW5zaW9ucyh0cnVlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZ2V0IG1pbkhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbkhlaWdodDtcbiAgICB9XG5cbiAgICBzZXQgbWluSGVpZ2h0KHYpIHtcbiAgICAgICAgdGhpcy5fbWluSGVpZ2h0ID0gTWF0aC5tYXgoMCwgdik7XG4gICAgICAgIHRoaXMuX2l0ZW0uY2hhbmdlZERpbWVuc2lvbnMoZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIGdldCBtYXhXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heFdpZHRoO1xuICAgIH1cblxuICAgIHNldCBtYXhXaWR0aCh2KSB7XG4gICAgICAgIHRoaXMuX21heFdpZHRoID0gTWF0aC5tYXgoMCwgdik7XG4gICAgICAgIHRoaXMuX2l0ZW0uY2hhbmdlZERpbWVuc2lvbnModHJ1ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGdldCBtYXhIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhIZWlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IG1heEhlaWdodCh2KSB7XG4gICAgICAgIHRoaXMuX21heEhlaWdodCA9IE1hdGgubWF4KDAsIHYpO1xuICAgICAgICB0aGlzLl9pdGVtLmNoYW5nZWREaW1lbnNpb25zKGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbm90ZSBtYXJnaW5zIGJlaGF2ZSBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiBpbiBIVE1MIHdpdGggcmVnYXJkIHRvIHNocmlua2luZy5cbiAgICAgKiBJbiBIVE1MLCAob3V0ZXIpIG1hcmdpbnMgY2FuIGJlIHJlbW92ZWQgd2hlbiBzaHJpbmtpbmcuIEluIHRoaXMgZW5naW5lLCB0aGV5IHdpbGwgbm90IHNocmluayBhdCBhbGwuXG4gICAgICovXG4gICAgc2V0IG1hcmdpbih2KSB7XG4gICAgICAgIHRoaXMubWFyZ2luTGVmdCA9IHY7XG4gICAgICAgIHRoaXMubWFyZ2luVG9wID0gdjtcbiAgICAgICAgdGhpcy5tYXJnaW5SaWdodCA9IHY7XG4gICAgICAgIHRoaXMubWFyZ2luQm90dG9tID0gdjtcbiAgICB9XG5cbiAgICBnZXQgbWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJnaW5MZWZ0O1xuICAgIH1cblxuICAgIHNldCBtYXJnaW5MZWZ0KHYpIHtcbiAgICAgICAgdGhpcy5fbWFyZ2luTGVmdCA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgbWFyZ2luTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmdpbkxlZnQ7XG4gICAgfVxuXG4gICAgc2V0IG1hcmdpblRvcCh2KSB7XG4gICAgICAgIHRoaXMuX21hcmdpblRvcCA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgbWFyZ2luVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFyZ2luVG9wO1xuICAgIH1cblxuICAgIHNldCBtYXJnaW5SaWdodCh2KSB7XG4gICAgICAgIHRoaXMuX21hcmdpblJpZ2h0ID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGdldCBtYXJnaW5SaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmdpblJpZ2h0O1xuICAgIH1cblxuICAgIHNldCBtYXJnaW5Cb3R0b20odikge1xuICAgICAgICB0aGlzLl9tYXJnaW5Cb3R0b20gPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgZ2V0IG1hcmdpbkJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmdpbkJvdHRvbTtcbiAgICB9XG4gICAgXG4gICAgX2NoYW5nZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmN0cikgdGhpcy5jdHIuX2NoYW5nZWRDb250ZW50cygpO1xuICAgIH1cblxuICAgIHNldCBjdHIodikge1xuICAgICAgICB0aGlzLl9jdHIgPSB2O1xuICAgIH1cblxuICAgIGdldCBjdHIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdHI7XG4gICAgfVxuXG4gICAgcGF0Y2goc2V0dGluZ3MpIHtcbiAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgX3Jlc2V0TGF5b3V0U2l6ZSgpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRIb3Jpem9udGFsQXhpc0xheW91dFNpemUoKTtcbiAgICAgICAgdGhpcy5fcmVzZXRWZXJ0aWNhbEF4aXNMYXlvdXRTaXplKCk7XG4gICAgfVxuXG4gICAgX3Jlc2V0Q3Jvc3NBeGlzTGF5b3V0U2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3RyLl9ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldFZlcnRpY2FsQXhpc0xheW91dFNpemUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0SG9yaXpvbnRhbEF4aXNMYXlvdXRTaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVzZXRIb3Jpem9udGFsQXhpc0xheW91dFNpemUoKSB7XG4gICAgICAgIGxldCB3ID0gRmxleFV0aWxzLmdldFJlbEF4aXNTaXplKHRoaXMuaXRlbSwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9taW5XaWR0aCkge1xuICAgICAgICAgICAgdyA9IE1hdGgubWF4KHRoaXMuX21pbldpZHRoLCB3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbWF4V2lkdGgpIHtcbiAgICAgICAgICAgIHcgPSBNYXRoLm1pbih0aGlzLl9tYXhXaWR0aCwgdyk7XG4gICAgICAgIH1cbiAgICAgICAgRmxleFV0aWxzLnNldEF4aXNMYXlvdXRTaXplKHRoaXMuaXRlbSwgdHJ1ZSwgdyk7XG4gICAgfVxuXG4gICAgX3Jlc2V0VmVydGljYWxBeGlzTGF5b3V0U2l6ZSgpIHtcbiAgICAgICAgbGV0IGggPSBGbGV4VXRpbHMuZ2V0UmVsQXhpc1NpemUodGhpcy5pdGVtLCBmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLl9taW5IZWlnaHQpIHtcbiAgICAgICAgICAgIGggPSBNYXRoLm1heCh0aGlzLl9taW5IZWlnaHQsIGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIGggPSBNYXRoLm1pbih0aGlzLl9tYXhIZWlnaHQsIGgpO1xuICAgICAgICB9XG4gICAgICAgIEZsZXhVdGlscy5zZXRBeGlzTGF5b3V0U2l6ZSh0aGlzLml0ZW0sIGZhbHNlLCBoKTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzTWluU2l6ZVNldHRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRNaW5TaXplU2V0dGluZyghdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNNYXhTaXplU2V0dGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1heFNpemVTZXR0aW5nKCF0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzTWF4U2l6ZVNldHRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRNYXhTaXplU2V0dGluZyh0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldE1pblNpemVTZXR0aW5nKGhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taW5XaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taW5IZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0TWF4U2l6ZVNldHRpbmcoaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21heFdpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21heEhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc01pblNpemUoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0QXhpc01pblNpemUodGhpcy5pdGVtLCB0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc01pblNpemUoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0QXhpc01pblNpemUodGhpcy5pdGVtLCAhdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc0xheW91dFNpemUoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFNpemUodGhpcy5pdGVtLCB0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzTGF5b3V0UG9zKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRQb3ModGhpcy5pdGVtLCB0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX3NldE1haW5BeGlzTGF5b3V0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLnNldEF4aXNMYXlvdXRQb3ModGhpcy5pdGVtLCB0aGlzLmN0ci5faG9yaXpvbnRhbCwgcG9zKTtcbiAgICB9XG5cbiAgICBfc2V0Q3Jvc3NBeGlzTGF5b3V0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLnNldEF4aXNMYXlvdXRQb3ModGhpcy5pdGVtLCAhdGhpcy5jdHIuX2hvcml6b250YWwsIHBvcyk7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc0xheW91dFNpemUoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFNpemUodGhpcy5pdGVtLCAhdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9yZXNpemVDcm9zc0F4aXMoc2l6ZSkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLnJlc2l6ZUF4aXModGhpcy5pdGVtLCAhdGhpcy5jdHIuX2hvcml6b250YWwsIHNpemUpO1xuICAgIH1cblxuICAgIF9yZXNpemVNYWluQXhpcyhzaXplKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMucmVzaXplQXhpcyh0aGlzLml0ZW0sIHRoaXMuY3RyLl9ob3Jpem9udGFsLCBzaXplKTtcbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldFRvdGFsUGFkZGluZyh0aGlzLml0ZW0sIHRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzUGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRUb3RhbFBhZGRpbmcodGhpcy5pdGVtLCAhdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc01hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRUb3RhbE1hcmdpbih0aGlzLml0ZW0sIHRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldFRvdGFsTWFyZ2luKHRoaXMuaXRlbSwgIXRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0SG9yaXpvbnRhbE1hcmdpbk9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRNYXJnaW5PZmZzZXQodGhpcy5pdGVtLCB0cnVlKTtcbiAgICB9XG5cbiAgICBfZ2V0VmVydGljYWxNYXJnaW5PZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0TWFyZ2luT2Zmc2V0KHRoaXMuaXRlbSwgZmFsc2UpO1xuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc01pblNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1haW5BeGlzTWluU2l6ZSgpICsgdGhpcy5fZ2V0TWFpbkF4aXNQYWRkaW5nKCkgKyB0aGlzLl9nZXRNYWluQXhpc01hcmdpbigpO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNNaW5TaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDcm9zc0F4aXNNaW5TaXplKCkgKyB0aGlzLl9nZXRDcm9zc0F4aXNQYWRkaW5nKCkgKyB0aGlzLl9nZXRDcm9zc0F4aXNNYXJnaW4oKTtcbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNMYXlvdXRTaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRNYWluQXhpc0xheW91dFNpemUoKSArIHRoaXMuX2dldE1haW5BeGlzUGFkZGluZygpICsgdGhpcy5fZ2V0TWFpbkF4aXNNYXJnaW4oKTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzTGF5b3V0U2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q3Jvc3NBeGlzTGF5b3V0U2l6ZSgpICsgdGhpcy5fZ2V0Q3Jvc3NBeGlzUGFkZGluZygpICsgdGhpcy5fZ2V0Q3Jvc3NBeGlzTWFyZ2luKCk7XG4gICAgfVxuXG4gICAgX2hhc0ZpeGVkQ3Jvc3NBeGlzU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuICFGbGV4VXRpbHMuaXNaZXJvQXhpc1NpemUodGhpcy5pdGVtLCAhdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9oYXNSZWxDcm9zc0F4aXNTaXplKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5jdHIuX2hvcml6b250YWwgPyB0aGlzLml0ZW0uZnVuY0ggOiB0aGlzLml0ZW0uZnVuY1cpO1xuICAgIH1cblxufVxuXG5cbkZsZXhJdGVtLlNIUklOS19BVVRPID0gLTE7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRmxleENvbnRhaW5lciBmcm9tIFwiLi9GbGV4Q29udGFpbmVyLm1qc1wiO1xuaW1wb3J0IEZsZXhJdGVtIGZyb20gXCIuL0ZsZXhJdGVtLm1qc1wiO1xuaW1wb3J0IEZsZXhVdGlscyBmcm9tIFwiLi9GbGV4VXRpbHMubWpzXCI7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29ubmVjdGlvbiBiZXR3ZWVuIHRoZSByZW5kZXIgdHJlZSB3aXRoIHRoZSBsYXlvdXQgdHJlZSBvZiB0aGlzIGZsZXggY29udGFpbmVyL2l0ZW0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsZXhUYXJnZXQge1xuXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zc2libGUgdmFsdWVzIChvbmx5IGluIGNhc2Ugb2YgY29udGFpbmVyKTpcbiAgICAgICAgICogYml0IDA6IGhhcyBjaGFuZ2VkIG9yIGNvbnRhaW5zIGl0ZW1zIHdpdGggY2hhbmdlc1xuICAgICAgICAgKiBiaXQgMTogd2lkdGggY2hhbmdlZFxuICAgICAgICAgKiBiaXQgMjogaGVpZ2h0IGNoYW5nZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlY2FsYyA9IDA7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy53ID0gMDtcbiAgICAgICAgdGhpcy5oID0gMDtcblxuICAgICAgICB0aGlzLl9vcmlnaW5hbFggPSAwO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFkgPSAwO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxIZWlnaHQgPSAwO1xuXG4gICAgICAgIHRoaXMuX2ZsZXggPSBudWxsO1xuICAgICAgICB0aGlzLl9mbGV4SXRlbSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZsZXhJdGVtRGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGZsZXhMYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsZXggPyB0aGlzLmZsZXguX2xheW91dCA6IG51bGw7XG4gICAgfVxuXG4gICAgbGF5b3V0RmxleFRyZWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmxleEVuYWJsZWQoKSAmJiB0aGlzLmlzQ2hhbmdlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmZsZXhMYXlvdXQubGF5b3V0VHJlZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldDtcbiAgICB9XG5cbiAgICBnZXQgZmxleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsZXg7XG4gICAgfVxuXG4gICAgc2V0IGZsZXgodikge1xuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmxleEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVGbGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGbGV4RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlRmxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZmxleC5wYXRjaCh2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBmbGV4SXRlbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZsZXhJdGVtRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbnN1cmVGbGV4SXRlbSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZmxleEl0ZW07XG4gICAgfVxuXG4gICAgc2V0IGZsZXhJdGVtKHYpIHtcbiAgICAgICAgaWYgKHYgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ZsZXhJdGVtRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZsZXhQYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmxleEl0ZW1EaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tFbmFibGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuX2NsZWFyRmxleEl0ZW1zQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoYW5nZWRDb250ZW50cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUZsZXhJdGVtKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2ZsZXhJdGVtLnBhdGNoKHYpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZmxleEl0ZW1EaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZsZXhJdGVtRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja0VuYWJsZWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZsZXhQYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuX2NsZWFyRmxleEl0ZW1zQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoYW5nZWRDb250ZW50cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9lbmFibGVGbGV4KCkge1xuICAgICAgICB0aGlzLl9mbGV4ID0gbmV3IEZsZXhDb250YWluZXIodGhpcyk7XG4gICAgICAgIHRoaXMuX2NoZWNrRW5hYmxlZCgpO1xuICAgICAgICB0aGlzLmNoYW5nZWREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuX2VuYWJsZUNoaWxkcmVuQXNGbGV4SXRlbXMoKTtcbiAgICB9XG5cbiAgICBfZGlzYWJsZUZsZXgoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlZERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5fZmxleCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoZWNrRW5hYmxlZCgpO1xuICAgICAgICB0aGlzLl9kaXNhYmxlQ2hpbGRyZW5Bc0ZsZXhJdGVtcygpO1xuICAgIH1cblxuICAgIF9lbmFibGVDaGlsZHJlbkFzRmxleEl0ZW1zKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX3RhcmdldC5fY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkLmxheW91dC5fZW5hYmxlRmxleEl0ZW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kaXNhYmxlQ2hpbGRyZW5Bc0ZsZXhJdGVtcygpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl90YXJnZXQuX2NoaWxkcmVuO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZC5sYXlvdXQuX2Rpc2FibGVGbGV4SXRlbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2VuYWJsZUZsZXhJdGVtKCkge1xuICAgICAgICB0aGlzLl9lbnN1cmVGbGV4SXRlbSgpO1xuICAgICAgICBjb25zdCBmbGV4UGFyZW50ID0gdGhpcy5fdGFyZ2V0Ll9wYXJlbnQuX2xheW91dDtcbiAgICAgICAgdGhpcy5fZmxleEl0ZW0uY3RyID0gZmxleFBhcmVudC5fZmxleDtcbiAgICAgICAgZmxleFBhcmVudC5jaGFuZ2VkQ29udGVudHMoKTtcbiAgICAgICAgdGhpcy5fY2hlY2tFbmFibGVkKCk7XG4gICAgfVxuXG4gICAgX2Rpc2FibGVGbGV4SXRlbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZsZXhJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9mbGV4SXRlbS5jdHIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Uga2VlcCB0aGUgZmxleEl0ZW0gb2JqZWN0IGJlY2F1c2UgaXQgbWF5IGNvbnRhaW4gY3VzdG9tIHNldHRpbmdzLlxuICAgICAgICB0aGlzLl9jaGVja0VuYWJsZWQoKTtcblxuICAgICAgICAvLyBPZmZzZXRzIGhhdmUgYmVlbiBjaGFuZ2VkLiBXZSBjYW4ndCByZWNvdmVyIHRoZW0sIHNvIHdlJ2xsIGp1c3QgY2xlYXIgdGhlbSBpbnN0ZWFkLlxuICAgICAgICB0aGlzLl9yZXNldE9mZnNldHMoKTtcbiAgICB9XG5cbiAgICBfcmVzZXRPZmZzZXRzKCkge1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgIH1cblxuICAgIF9lbnN1cmVGbGV4SXRlbSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mbGV4SXRlbSkge1xuICAgICAgICAgICAgdGhpcy5fZmxleEl0ZW0gPSBuZXcgRmxleEl0ZW0odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2hlY2tFbmFibGVkKCkge1xuICAgICAgICBjb25zdCBlbmFibGVkID0gdGhpcy5pc0VuYWJsZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQgIT09IGVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIF9lbmFibGUoKSB7XG4gICAgICAgIHRoaXMuX3NldHVwVGFyZ2V0Rm9yRmxleCgpO1xuICAgICAgICB0aGlzLl90YXJnZXQuZW5hYmxlRmxleExheW91dCgpO1xuICAgIH1cblxuICAgIF9kaXNhYmxlKCkge1xuICAgICAgICB0aGlzLl9yZXN0b3JlVGFyZ2V0VG9Ob25GbGV4KCk7XG4gICAgICAgIHRoaXMuX3RhcmdldC5kaXNhYmxlRmxleExheW91dCgpO1xuICAgIH1cblxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGbGV4RW5hYmxlZCgpIHx8IHRoaXMuaXNGbGV4SXRlbUVuYWJsZWQoKTtcbiAgICB9XG5cbiAgICBpc0ZsZXhFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmxleCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICBpc0ZsZXhJdGVtRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxleFBhcmVudCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICBfcmVzdG9yZVRhcmdldFRvTm9uRmxleCgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgICB0YXJnZXQueCA9IHRoaXMuX29yaWdpbmFsWDtcbiAgICAgICAgdGFyZ2V0LnkgPSB0aGlzLl9vcmlnaW5hbFk7XG4gICAgICAgIHRhcmdldC5zZXREaW1lbnNpb25zKHRoaXMuX29yaWdpbmFsV2lkdGgsIHRoaXMuX29yaWdpbmFsSGVpZ2h0KTtcbiAgICB9XG5cbiAgICBfc2V0dXBUYXJnZXRGb3JGbGV4KCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl90YXJnZXQ7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsWCA9IHRhcmdldC5feDtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxZID0gdGFyZ2V0Ll95O1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFdpZHRoID0gdGFyZ2V0Ll93O1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEhlaWdodCA9IHRhcmdldC5faDtcbiAgICB9XG4gICAgXG4gICAgc2V0UGFyZW50KGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tICYmIGZyb20uaXNGbGV4Q29udGFpbmVyKCkpIHtcbiAgICAgICAgICAgIGZyb20uX2xheW91dC5fY2hhbmdlZENoaWxkcmVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG8gJiYgdG8uaXNGbGV4Q29udGFpbmVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZUZsZXhJdGVtKCk7XG4gICAgICAgICAgICB0by5fbGF5b3V0Ll9jaGFuZ2VkQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGVja0VuYWJsZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgZmxleFBhcmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZsZXhJdGVtRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fdGFyZ2V0Ll9wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmlzRmxleENvbnRhaW5lcigpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Ll9sYXlvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc2V0VmlzaWJsZSh2KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZmxleFBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50Ll9jaGFuZ2VkQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pdGVtcykge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSB0aGlzLl9nZXRGbGV4SXRlbXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxuXG4gICAgX2dldEZsZXhJdGVtcygpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl90YXJnZXQuX2NoaWxkcmVuO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXNGbGV4SXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0ubGF5b3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuXG4gICAgX2NoYW5nZWRDaGlsZHJlbigpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJGbGV4SXRlbXNDYWNoZSgpO1xuICAgICAgICB0aGlzLmNoYW5nZWRDb250ZW50cygpO1xuICAgIH1cblxuICAgIF9jbGVhckZsZXhJdGVtc0NhY2hlKCkge1xuICAgICAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgfVxuXG4gICAgc2V0TGF5b3V0KHgsIHksIHcsIGgpIHtcbiAgICAgICAgbGV0IG9yaWdpbmFsWCA9IHRoaXMuX29yaWdpbmFsWDtcbiAgICAgICAgbGV0IG9yaWdpbmFsWSA9IHRoaXMuX29yaWdpbmFsWTtcbiAgICAgICAgaWYgKHRoaXMuZnVuY1gpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsWCA9IHRoaXMuZnVuY1goRmxleFV0aWxzLmdldFBhcmVudEF4aXNTaXplV2l0aFBhZGRpbmcodGhpcywgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZ1bmNZKSB7XG4gICAgICAgICAgICBvcmlnaW5hbFkgPSB0aGlzLmZ1bmNZKEZsZXhVdGlscy5nZXRQYXJlbnRBeGlzU2l6ZVdpdGhQYWRkaW5nKHRoaXMsIGZhbHNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0ZsZXhJdGVtRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5zZXRMYXlvdXQoeCArIG9yaWdpbmFsWCwgeSArIG9yaWdpbmFsWSwgdywgaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXVzZSB0aGUgeCx5ICdzZXR0aW5ncycuXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5zZXRMYXlvdXQob3JpZ2luYWxYLCBvcmlnaW5hbFksIHcsIGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hhbmdlZERpbWVuc2lvbnMoY2hhbmdlV2lkdGggPSB0cnVlLCBjaGFuZ2VIZWlnaHQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlY2FsYyhjaGFuZ2VXaWR0aCwgY2hhbmdlSGVpZ2h0KTtcbiAgICB9XG5cbiAgICBjaGFuZ2VkQ29udGVudHMoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlY2FsYygpO1xuICAgIH1cblxuICAgIGZvcmNlTGF5b3V0KCkge1xuICAgICAgICB0aGlzLl91cGRhdGVSZWNhbGMoKTtcbiAgICB9XG5cbiAgICBpc0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNhbGMgPiAwO1xuICAgIH1cblxuICAgIF91cGRhdGVSZWNhbGMoY2hhbmdlRXh0ZXJuYWxXaWR0aCA9IGZhbHNlLCBjaGFuZ2VFeHRlcm5hbEhlaWdodCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmxleEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fZmxleC5fbGF5b3V0O1xuXG4gICAgICAgICAgICAvLyBXaGVuIHNvbWV0aGluZyBpbnRlcm5hbCBjaGFuZ2VzLCBpdCBjYW4gaGF2ZSBlZmZlY3Qgb24gdGhlIGV4dGVybmFsIGRpbWVuc2lvbnMuXG4gICAgICAgICAgICBjaGFuZ2VFeHRlcm5hbFdpZHRoID0gY2hhbmdlRXh0ZXJuYWxXaWR0aCB8fCBsYXlvdXQuaXNBeGlzRml0VG9Db250ZW50cyh0cnVlKTtcbiAgICAgICAgICAgIGNoYW5nZUV4dGVybmFsSGVpZ2h0ID0gY2hhbmdlRXh0ZXJuYWxIZWlnaHQgfHwgbGF5b3V0LmlzQXhpc0ZpdFRvQ29udGVudHMoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVjYWxjID0gMSArIChjaGFuZ2VFeHRlcm5hbFdpZHRoID8gMiA6IDApICsgKGNoYW5nZUV4dGVybmFsSGVpZ2h0ID8gNCA6IDApO1xuICAgICAgICBjb25zdCBuZXdSZWNhbGNGbGFncyA9IHRoaXMuZ2V0TmV3UmVjYWxjRmxhZ3MocmVjYWxjKTtcbiAgICAgICAgdGhpcy5fcmVjYWxjIHw9IHJlY2FsYztcbiAgICAgICAgaWYgKG5ld1JlY2FsY0ZsYWdzID4gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxleFBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmxleFBhcmVudC5fdXBkYXRlUmVjYWxjQm90dG9tVXAocmVjYWxjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LnRyaWdnZXJMYXlvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC50cmlnZ2VyTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXROZXdSZWNhbGNGbGFncyhmbGFncykge1xuICAgICAgICByZXR1cm4gKDcgLSB0aGlzLl9yZWNhbGMpICYgZmxhZ3M7XG4gICAgfVxuXG4gICAgX3VwZGF0ZVJlY2FsY0JvdHRvbVVwKGNoaWxkUmVjYWxjKSB7XG4gICAgICAgIGNvbnN0IG5ld1JlY2FsYyA9IHRoaXMuX2dldFJlY2FsY0Zyb21DaGFuZ2VkQ2hpbGRSZWNhbGMoY2hpbGRSZWNhbGMpO1xuICAgICAgICBjb25zdCBuZXdSZWNhbGNGbGFncyA9IHRoaXMuZ2V0TmV3UmVjYWxjRmxhZ3MobmV3UmVjYWxjKTtcbiAgICAgICAgdGhpcy5fcmVjYWxjIHw9IG5ld1JlY2FsYztcbiAgICAgICAgaWYgKG5ld1JlY2FsY0ZsYWdzID4gMSkge1xuICAgICAgICAgICAgY29uc3QgZmxleFBhcmVudCA9IHRoaXMuZmxleFBhcmVudDtcbiAgICAgICAgICAgIGlmIChmbGV4UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgZmxleFBhcmVudC5fdXBkYXRlUmVjYWxjQm90dG9tVXAobmV3UmVjYWxjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LnRyaWdnZXJMYXlvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC50cmlnZ2VyTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0UmVjYWxjRnJvbUNoYW5nZWRDaGlsZFJlY2FsYyhjaGlsZFJlY2FsYykge1xuICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLl9mbGV4Ll9sYXlvdXQ7XG5cbiAgICAgICAgY29uc3QgbWFpbkF4aXNSZWNhbGNGbGFnID0gbGF5b3V0Ll9ob3Jpem9udGFsID8gMSA6IDI7XG4gICAgICAgIGNvbnN0IGNyb3NzQXhpc1JlY2FsY0ZsYWcgPSBsYXlvdXQuX2hvcml6b250YWwgPyAyIDogMTtcblxuICAgICAgICBjb25zdCBjcm9zc0F4aXNEaW1lbnNpb25zQ2hhbmdlZEluQ2hpbGQgPSAoY2hpbGRSZWNhbGMgJiBjcm9zc0F4aXNSZWNhbGNGbGFnKTtcbiAgICAgICAgaWYgKCFjcm9zc0F4aXNEaW1lbnNpb25zQ2hhbmdlZEluQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1haW5BeGlzRGltZW5zaW9uc0NoYW5nZWRJbkNoaWxkID0gKGNoaWxkUmVjYWxjICYgbWFpbkF4aXNSZWNhbGNGbGFnKTtcbiAgICAgICAgICAgIGlmIChtYWluQXhpc0RpbWVuc2lvbnNDaGFuZ2VkSW5DaGlsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1haW5BeGlzSXNXcmFwcGluZyA9IGxheW91dC5pc1dyYXBwaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1haW5BeGlzSXNXcmFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcm9zc0F4aXNJc0ZpdFRvQ29udGVudHMgPSBsYXlvdXQuaXNDcm9zc0F4aXNGaXRUb0NvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjcm9zc0F4aXNJc0ZpdFRvQ29udGVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogZHVlIHRvIHdyYXBwaW5nLCB0aGUgY3Jvc3MgYXhpcyBzaXplIG1heSBiZSBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRSZWNhbGMgKz0gY3Jvc3NBeGlzUmVjYWxjRmxhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpc1dpZHRoRHluYW1pYyA9IGxheW91dC5pc0F4aXNGaXRUb0NvbnRlbnRzKHRydWUpO1xuICAgICAgICBsZXQgaXNIZWlnaHREeW5hbWljID0gbGF5b3V0LmlzQXhpc0ZpdFRvQ29udGVudHMoZmFsc2UpO1xuXG4gICAgICAgIGlmIChsYXlvdXQuc2hydW5rKSB7XG4gICAgICAgICAgICAvLyBJZiBkdXJpbmcgcHJldmlvdXMgbGF5b3V0IHRoaXMgY29udGFpbmVyIHdhcyAnc2hydW5rJywgYW55IGNoYW5nZXMgbWF5IGNoYW5nZSB0aGUgJ21pbiBheGlzIHNpemUnIG9mIHRoZVxuICAgICAgICAgICAgLy8gY29udGVudHMsIGxlYWRpbmcgdG8gYSBkaWZmZXJlbnQgYXhpcyBzaXplIG9uIHRoaXMgY29udGFpbmVyIGV2ZW4gd2hlbiBpdCB3YXMgbm90ICdmaXQgdG8gY29udGVudHMnLlxuICAgICAgICAgICAgaWYgKGxheW91dC5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGlzV2lkdGhEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNIZWlnaHREeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvY2FsUmVjYWxjID0gMSArIChpc1dpZHRoRHluYW1pYyA/IDIgOiAwKSArIChpc0hlaWdodER5bmFtaWMgPyA0IDogMCk7XG5cbiAgICAgICAgY29uc3QgY29tYmluZWRSZWNhbGMgPSBjaGlsZFJlY2FsYyAmIGxvY2FsUmVjYWxjO1xuICAgICAgICByZXR1cm4gY29tYmluZWRSZWNhbGM7XG4gICAgfVxuXG4gICAgZ2V0IHJlY2FsYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY2FsYztcbiAgICB9XG5cbiAgICBjbGVhclJlY2FsY0ZsYWcoKSB7XG4gICAgICAgIHRoaXMuX3JlY2FsYyA9IDA7XG4gICAgfVxuXG4gICAgZW5hYmxlTG9jYWxSZWNhbGNGbGFnKCkge1xuICAgICAgICB0aGlzLl9yZWNhbGMgPSAxO1xuICAgIH1cblxuICAgIGdldCBvcmlnaW5hbFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFg7XG4gICAgfVxuXG4gICAgc2V0T3JpZ2luYWxYV2l0aG91dFVwZGF0aW5nTGF5b3V0KHYpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxYID0gdjtcbiAgICB9XG5cbiAgICBnZXQgb3JpZ2luYWxZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxZO1xuICAgIH1cblxuICAgIHNldE9yaWdpbmFsWVdpdGhvdXRVcGRhdGluZ0xheW91dCh2KSB7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsWSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IG9yaWdpbmFsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFdpZHRoO1xuICAgIH1cblxuICAgIHNldCBvcmlnaW5hbFdpZHRoKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29yaWdpbmFsV2lkdGggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsV2lkdGggPSB2O1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkRGltZW5zaW9ucyh0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgb3JpZ2luYWxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbEhlaWdodDtcbiAgICB9XG5cbiAgICBzZXQgb3JpZ2luYWxIZWlnaHQodikge1xuICAgICAgICBpZiAodGhpcy5fb3JpZ2luYWxIZWlnaHQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsSGVpZ2h0ID0gdjtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZERpbWVuc2lvbnMoZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGZ1bmNYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0LmZ1bmNYO1xuICAgIH1cblxuICAgIGdldCBmdW5jWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldC5mdW5jWTtcbiAgICB9XG5cbiAgICBnZXQgZnVuY1coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQuZnVuY1c7XG4gICAgfVxuXG4gICAgZ2V0IGZ1bmNIKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0LmZ1bmNIO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsZXhVdGlscyB7XG5cbiAgICBzdGF0aWMgZ2V0UGFyZW50QXhpc1NpemVXaXRoUGFkZGluZyhpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGl0ZW0udGFyZ2V0O1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0YXJnZXQuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZsZXhQYXJlbnQgPSBpdGVtLmZsZXhQYXJlbnQ7XG4gICAgICAgICAgICBpZiAoZmxleFBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBwZW5kaW5nIGxheW91dCBzaXplLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF4aXNMYXlvdXRTaXplKGZsZXhQYXJlbnQsIGhvcml6b250YWwpICsgdGhpcy5nZXRUb3RhbFBhZGRpbmcoZmxleFBhcmVudCwgaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVzZSAnYWJzb2x1dGUnIHNpemUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvcml6b250YWwgPyBwYXJlbnQudyA6IHBhcmVudC5oO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFJlbEF4aXNTaXplKGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmZ1bmNXKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FsbG93UmVsQXhpc1NpemVGdW5jdGlvbihpdGVtLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5mdW5jVyh0aGlzLmdldFBhcmVudEF4aXNTaXplV2l0aFBhZGRpbmcoaXRlbSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ub3JpZ2luYWxXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmZ1bmNIKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FsbG93UmVsQXhpc1NpemVGdW5jdGlvbihpdGVtLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZnVuY0godGhpcy5nZXRQYXJlbnRBeGlzU2l6ZVdpdGhQYWRkaW5nKGl0ZW0sIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5vcmlnaW5hbEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBfYWxsb3dSZWxBeGlzU2l6ZUZ1bmN0aW9uKGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgY29uc3QgZmxleFBhcmVudCA9IGl0ZW0uZmxleFBhcmVudDtcbiAgICAgICAgaWYgKGZsZXhQYXJlbnQgJiYgZmxleFBhcmVudC5fZmxleC5fbGF5b3V0LmlzQXhpc0ZpdFRvQ29udGVudHMoaG9yaXpvbnRhbCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGFsbG93IHJlbGF0aXZlIHdpZHRoIG9uIGZpdC10by1jb250ZW50cyBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZsaWN0cy5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNaZXJvQXhpc1NpemUoaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuICFpdGVtLm9yaWdpbmFsV2lkdGggJiYgIWl0ZW0uZnVuY1c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gIWl0ZW0ub3JpZ2luYWxIZWlnaHQgJiYgIWl0ZW0uZnVuY0g7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QXhpc0xheW91dFBvcyhpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiBob3Jpem9udGFsID8gaXRlbS54IDogaXRlbS55O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRBeGlzTGF5b3V0U2l6ZShpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiBob3Jpem9udGFsID8gaXRlbS53IDogaXRlbS5oO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRBeGlzTGF5b3V0UG9zKGl0ZW0sIGhvcml6b250YWwsIHBvcykge1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgaXRlbS54ID0gcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS55ID0gcG9zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHNldEF4aXNMYXlvdXRTaXplKGl0ZW0sIGhvcml6b250YWwsIHNpemUpIHtcbiAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGl0ZW0udyA9IHNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLmggPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEF4aXNNaW5TaXplKGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgbGV0IG1pblNpemUgPSB0aGlzLmdldFBsYWluQXhpc01pblNpemUoaXRlbSwgaG9yaXpvbnRhbCk7XG5cbiAgICAgICAgbGV0IGZsZXhJdGVtTWluU2l6ZSA9IDA7XG4gICAgICAgIGlmIChpdGVtLmlzRmxleEl0ZW1FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGZsZXhJdGVtTWluU2l6ZSA9IGl0ZW0uX2ZsZXhJdGVtLl9nZXRNaW5TaXplU2V0dGluZyhob3Jpem9udGFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhhc0xpbWl0ZWRNaW5TaXplID0gKGZsZXhJdGVtTWluU2l6ZSA+IDApO1xuICAgICAgICBpZiAoaGFzTGltaXRlZE1pblNpemUpIHtcbiAgICAgICAgICAgIG1pblNpemUgPSBNYXRoLm1heChtaW5TaXplLCBmbGV4SXRlbU1pblNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW5TaXplO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRQbGFpbkF4aXNNaW5TaXplKGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGl0ZW0uaXNGbGV4RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5fZmxleC5fbGF5b3V0LmdldEF4aXNNaW5TaXplKGhvcml6b250YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXNTaHJpbmthYmxlID0gKGl0ZW0uZmxleEl0ZW0uc2hyaW5rICE9PSAwKTtcbiAgICAgICAgICAgIGlmIChpc1Nocmlua2FibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVsQXhpc1NpemUoaXRlbSwgaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzaXplQXhpcyhpdGVtLCBob3Jpem9udGFsLCBzaXplKSB7XG4gICAgICAgIGlmIChpdGVtLmlzRmxleEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgaXNNYWluQXhpcyA9IChpdGVtLl9mbGV4Ll9ob3Jpem9udGFsID09PSBob3Jpem9udGFsKTtcbiAgICAgICAgICAgIGlmIChpc01haW5BeGlzKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5fZmxleC5fbGF5b3V0LnJlc2l6ZU1haW5BeGlzKHNpemUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLl9mbGV4Ll9sYXlvdXQucmVzaXplQ3Jvc3NBeGlzKHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRBeGlzTGF5b3V0U2l6ZShpdGVtLCBob3Jpem9udGFsLCBzaXplKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgc3RhdGljIGdldFBhZGRpbmdPZmZzZXQoaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaXRlbS5pc0ZsZXhFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsZXggPSBpdGVtLl9mbGV4O1xuICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxleC5wYWRkaW5nTGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsZXgucGFkZGluZ1RvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFRvdGFsUGFkZGluZyhpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChpdGVtLmlzRmxleEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgZmxleCA9IGl0ZW0uX2ZsZXg7XG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGV4LnBhZGRpbmdSaWdodCArIGZsZXgucGFkZGluZ0xlZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGV4LnBhZGRpbmdUb3AgKyBmbGV4LnBhZGRpbmdCb3R0b207XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRNYXJnaW5PZmZzZXQoaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICBjb25zdCBmbGV4SXRlbSA9IGl0ZW0uZmxleEl0ZW07XG4gICAgICAgIGlmIChmbGV4SXRlbSkge1xuICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxleEl0ZW0ubWFyZ2luTGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsZXhJdGVtLm1hcmdpblRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFRvdGFsTWFyZ2luKGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgY29uc3QgZmxleEl0ZW0gPSBpdGVtLmZsZXhJdGVtO1xuICAgICAgICBpZiAoZmxleEl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsZXhJdGVtLm1hcmdpblJpZ2h0ICsgZmxleEl0ZW0ubWFyZ2luTGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsZXhJdGVtLm1hcmdpblRvcCArIGZsZXhJdGVtLm1hcmdpbkJvdHRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU3BhY2luZ0NhbGN1bGF0b3IgZnJvbSBcIi4vU3BhY2luZ0NhbGN1bGF0b3IubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRBbGlnbmVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIHRoaXMuX3RvdGFsQ3Jvc3NBeGlzU2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IF9saW5lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5fbGluZXM7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5fdG90YWxDcm9zc0F4aXNTaXplID0gdGhpcy5fZ2V0VG90YWxDcm9zc0F4aXNTaXplKCk7XG4gICAgfVxuXG4gICAgYWxpZ24oKSB7XG4gICAgICAgIGNvbnN0IGNyb3NzQXhpc1NpemUgPSB0aGlzLl9sYXlvdXQuY3Jvc3NBeGlzU2l6ZTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nU3BhY2UgPSBjcm9zc0F4aXNTaXplIC0gdGhpcy5fdG90YWxDcm9zc0F4aXNTaXplO1xuXG4gICAgICAgIGNvbnN0IHtzcGFjaW5nQmVmb3JlLCBzcGFjaW5nQmV0d2Vlbn0gPSB0aGlzLl9nZXRTcGFjaW5nKHJlbWFpbmluZ1NwYWNlKTtcblxuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMuX2xpbmVzO1xuXG4gICAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLl9sYXlvdXQuX2ZsZXhDb250YWluZXIuYWxpZ25Db250ZW50O1xuICAgICAgICBsZXQgZ3Jvd1NpemUgPSAwO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJzdHJldGNoXCIgJiYgbGluZXMubGVuZ3RoICYmIChyZW1haW5pbmdTcGFjZSA+IDApKSB7XG4gICAgICAgICAgICBncm93U2l6ZSA9IHJlbWFpbmluZ1NwYWNlIC8gbGluZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSBzcGFjaW5nQmVmb3JlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGxpbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3Jvc3NBeGlzTGF5b3V0T2Zmc2V0ID0gY3VycmVudFBvcztcbiAgICAgICAgICAgIGNvbnN0IGFsaWduZXIgPSBsaW5lc1tpXS5jcmVhdGVJdGVtQWxpZ25lcigpO1xuXG4gICAgICAgICAgICBsZXQgZmluYWxDcm9zc0F4aXNMYXlvdXRTaXplID0gbGluZXNbaV0uY3Jvc3NBeGlzTGF5b3V0U2l6ZSArIGdyb3dTaXplO1xuXG4gICAgICAgICAgICBhbGlnbmVyLnNldENyb3NzQXhpc0xheW91dFNpemUoZmluYWxDcm9zc0F4aXNMYXlvdXRTaXplKTtcbiAgICAgICAgICAgIGFsaWduZXIuc2V0Q3Jvc3NBeGlzTGF5b3V0T2Zmc2V0KGNyb3NzQXhpc0xheW91dE9mZnNldCk7XG5cbiAgICAgICAgICAgIGFsaWduZXIuYWxpZ24oKTtcblxuICAgICAgICAgICAgaWYgKGFsaWduZXIucmVjdXJzaXZlUmVzaXplT2NjdXJlZCkge1xuICAgICAgICAgICAgICAgIGxpbmVzW2ldLnNldEl0ZW1Qb3NpdGlvbnMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudFBvcyArPSBmaW5hbENyb3NzQXhpc0xheW91dFNpemU7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IHNwYWNpbmdCZXR3ZWVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRvdGFsQ3Jvc3NBeGlzU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsQ3Jvc3NBeGlzU2l6ZTtcbiAgICB9XG5cbiAgICBfZ2V0VG90YWxDcm9zc0F4aXNTaXplKCkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMuX2xpbmVzO1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGxpbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgdG90YWwgKz0gbGluZS5jcm9zc0F4aXNMYXlvdXRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG5cbiAgICBfZ2V0U3BhY2luZyhyZW1haW5pbmdTcGFjZSkge1xuICAgICAgICBjb25zdCBtb2RlID0gdGhpcy5fbGF5b3V0Ll9mbGV4Q29udGFpbmVyLmFsaWduQ29udGVudDtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZJdGVtcyA9IHRoaXMuX2xpbmVzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIFNwYWNpbmdDYWxjdWxhdG9yLmdldFNwYWNpbmcobW9kZSwgbnVtYmVyT2ZJdGVtcywgcmVtYWluaW5nU3BhY2UpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvbnRlbnRBbGlnbmVyIGZyb20gXCIuL0NvbnRlbnRBbGlnbmVyLm1qc1wiO1xuaW1wb3J0IEZsZXhVdGlscyBmcm9tIFwiLi4vRmxleFV0aWxzLm1qc1wiO1xuaW1wb3J0IExpbmVMYXlvdXRlciBmcm9tIFwiLi9MaW5lTGF5b3V0ZXIubWpzXCI7XG5pbXBvcnQgSXRlbUNvb3JkaW5hdGVzVXBkYXRlciBmcm9tIFwiLi9JdGVtQ29vcmRpbmF0ZXNVcGRhdGVyLm1qc1wiO1xuXG4vKipcbiAqIExheW91dHMgYSBmbGV4IGNvbnRhaW5lciAoYW5kIGRlc2NlbmRhbnRzKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmxleExheW91dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihmbGV4Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX2ZsZXhDb250YWluZXIgPSBmbGV4Q29udGFpbmVyO1xuXG4gICAgICAgIHRoaXMuX2xpbmVMYXlvdXRlciA9IG5ldyBMaW5lTGF5b3V0ZXIodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fcmVzaXppbmdNYWluQXhpcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXNpemluZ0Nyb3NzQXhpcyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlZE1haW5BeGlzU2l6ZUFmdGVyTGF5b3V0ID0gMDtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ3Jvc3NBeGlzU2l6ZUFmdGVyTGF5b3V0ID0gMDtcblxuICAgICAgICB0aGlzLl9zaHJ1bmsgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgc2hydW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hydW5rO1xuICAgIH1cblxuICAgIGdldCByZWNhbGMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0ucmVjYWxjO1xuICAgIH1cblxuICAgIGxheW91dFRyZWUoKSB7XG4gICAgICAgIGNvbnN0IGlzU3ViVHJlZSA9ICh0aGlzLml0ZW0uZmxleFBhcmVudCAhPT0gbnVsbCk7XG4gICAgICAgIGlmIChpc1N1YlRyZWUpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgZGltZW5zaW9ucyBzZXQgYnkgdGhlIHBhcmVudCBmbGV4IHRyZWUuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTdWJUcmVlTGF5b3V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyZWVMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1Db29yZHMoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVUcmVlTGF5b3V0KCkge1xuICAgICAgICBpZiAodGhpcy5yZWNhbGMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVMYXlvdXRUcmVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlTGF5b3V0VHJlZUZyb21DYWNoZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3BlcmZvcm1VcGRhdGVMYXlvdXRUcmVlKCkge1xuICAgICAgICB0aGlzLl9zZXRJbml0aWFsQXhpc1NpemVzKCk7XG4gICAgICAgIHRoaXMuX2xheW91dEF4ZXMoKTtcbiAgICAgICAgdGhpcy5fcmVmcmVzaExheW91dENhY2hlKCk7XG4gICAgfVxuXG4gICAgX3JlZnJlc2hMYXlvdXRDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkTWFpbkF4aXNTaXplQWZ0ZXJMYXlvdXQgPSB0aGlzLm1haW5BeGlzU2l6ZTtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ3Jvc3NBeGlzU2l6ZUFmdGVyTGF5b3V0ID0gdGhpcy5jcm9zc0F4aXNTaXplO1xuICAgIH1cblxuICAgIF9wZXJmb3JtVXBkYXRlTGF5b3V0VHJlZUZyb21DYWNoZSgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZU1pZ2h0SGF2ZUNoYW5nZWQgPSAodGhpcy5pdGVtLmZ1bmNXIHx8IHRoaXMuaXRlbS5mdW5jSCk7XG4gICAgICAgIGlmIChzaXplTWlnaHRIYXZlQ2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGFmdGVyIGFsbC5cbiAgICAgICAgICAgIHRoaXMuaXRlbS5lbmFibGVMb2NhbFJlY2FsY0ZsYWcoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVMYXlvdXRUcmVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW5BeGlzU2l6ZSA9IHRoaXMuX2NhY2hlZE1haW5BeGlzU2l6ZUFmdGVyTGF5b3V0O1xuICAgICAgICAgICAgdGhpcy5jcm9zc0F4aXNTaXplID0gdGhpcy5fY2FjaGVkQ3Jvc3NBeGlzU2l6ZUFmdGVyTGF5b3V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSXRlbUNvb3JkcygpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlciA9IG5ldyBJdGVtQ29vcmRpbmF0ZXNVcGRhdGVyKHRoaXMpO1xuICAgICAgICB1cGRhdGVyLmZpbmFsaXplKCk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZVN1YlRyZWVMYXlvdXQoKSB7XG4gICAgICAgIC8vIFRoZSBkaW1lbnNpb25zIG9mIHRoaXMgY29udGFpbmVyIGFyZSBndWFyYW50ZWVkIG5vdCB0byBoYXZlIGNoYW5nZWQuXG4gICAgICAgIC8vIFRoYXQncyB3aHkgd2UgY2FuIHNhZmVseSAncmV1c2UnIHRob3NlIGFuZCByZS1sYXlvdXQgdGhlIGNvbnRlbnRzLlxuICAgICAgICBjb25zdCBjcm9zc0F4aXNTaXplID0gdGhpcy5jcm9zc0F4aXNTaXplO1xuICAgICAgICB0aGlzLl9sYXlvdXRNYWluQXhpcygpO1xuICAgICAgICB0aGlzLnBlcmZvcm1SZXNpemVDcm9zc0F4aXMoY3Jvc3NBeGlzU2l6ZSk7XG4gICAgfVxuXG4gICAgX3NldEluaXRpYWxBeGlzU2l6ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW0uaXNGbGV4SXRlbUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtLmZsZXhJdGVtLl9yZXNldExheW91dFNpemUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbkF4aXNTaXplID0gdGhpcy5fZ2V0TWFpbkF4aXNCYXNpcygpO1xuICAgICAgICAgICAgdGhpcy5jcm9zc0F4aXNTaXplID0gdGhpcy5fZ2V0Q3Jvc3NBeGlzQmFzaXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNpemluZ01haW5BeGlzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jlc2l6aW5nQ3Jvc3NBeGlzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NocnVuayA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9sYXlvdXRBeGVzKCkge1xuICAgICAgICB0aGlzLl9sYXlvdXRNYWluQXhpcygpO1xuICAgICAgICB0aGlzLl9sYXlvdXRDcm9zc0F4aXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJlIG1haW5BeGlzU2l6ZSBzaG91bGQgZXhjbHVkZSBwYWRkaW5nLlxuICAgICAqL1xuICAgIF9sYXlvdXRNYWluQXhpcygpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0TGluZXMoKTtcbiAgICAgICAgdGhpcy5fZml0TWFpbkF4aXNTaXplVG9Db250ZW50cygpO1xuICAgIH1cblxuICAgIF9sYXlvdXRMaW5lcygpIHtcbiAgICAgICAgdGhpcy5fbGluZUxheW91dGVyLmxheW91dExpbmVzKCk7XG4gICAgfVxuXG4gICAgZ2V0IF9saW5lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVMYXlvdXRlci5saW5lcztcbiAgICB9XG5cbiAgICBfZml0TWFpbkF4aXNTaXplVG9Db250ZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXNpemluZ01haW5BeGlzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc01haW5BeGlzRml0VG9Db250ZW50cygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluQXhpc1NpemUgPSB0aGlzLl9saW5lTGF5b3V0ZXIubWFpbkF4aXNDb250ZW50U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcmUgY3Jvc3NBeGlzU2l6ZSBzaG91bGQgZXhjbHVkZSBwYWRkaW5nLlxuICAgICAqL1xuICAgIF9sYXlvdXRDcm9zc0F4aXMoKSB7XG4gICAgICAgIGNvbnN0IGFsaWduZXIgPSBuZXcgQ29udGVudEFsaWduZXIodGhpcyk7XG4gICAgICAgIGFsaWduZXIuaW5pdCgpO1xuICAgICAgICB0aGlzLl90b3RhbENyb3NzQXhpc1NpemUgPSBhbGlnbmVyLnRvdGFsQ3Jvc3NBeGlzU2l6ZTtcbiAgICAgICAgdGhpcy5fZml0Q3Jvc3NBeGlzU2l6ZVRvQ29udGVudHMoKTtcbiAgICAgICAgYWxpZ25lci5hbGlnbigpO1xuICAgIH1cblxuICAgIF9maXRDcm9zc0F4aXNTaXplVG9Db250ZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXNpemluZ0Nyb3NzQXhpcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDcm9zc0F4aXNGaXRUb0NvbnRlbnRzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzQXhpc1NpemUgPSB0aGlzLl90b3RhbENyb3NzQXhpc1NpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc1dyYXBwaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmxleENvbnRhaW5lci53cmFwO1xuICAgIH1cblxuICAgIGlzQXhpc0ZpdFRvQ29udGVudHMoaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCA9PT0gaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNNYWluQXhpc0ZpdFRvQ29udGVudHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQ3Jvc3NBeGlzRml0VG9Db250ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNNYWluQXhpc0ZpdFRvQ29udGVudHMoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc1dyYXBwaW5nKCkgJiYgIXRoaXMuX2hhc0ZpeGVkTWFpbkF4aXNCYXNpcygpO1xuICAgIH1cblxuICAgIGlzQ3Jvc3NBeGlzRml0VG9Db250ZW50cygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9oYXNGaXhlZENyb3NzQXhpc0Jhc2lzKCk7XG4gICAgfVxuXG4gICAgX2hhc0ZpeGVkTWFpbkF4aXNCYXNpcygpIHtcbiAgICAgICAgcmV0dXJuICFGbGV4VXRpbHMuaXNaZXJvQXhpc1NpemUodGhpcy5pdGVtLCB0aGlzLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfaGFzRml4ZWRDcm9zc0F4aXNCYXNpcygpIHtcbiAgICAgICAgcmV0dXJuICFGbGV4VXRpbHMuaXNaZXJvQXhpc1NpemUodGhpcy5pdGVtLCAhdGhpcy5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgZ2V0QXhpc01pblNpemUoaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCA9PT0gaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1haW5BeGlzTWluU2l6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENyb3NzQXhpc01pblNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc01pblNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lTGF5b3V0ZXIubWFpbkF4aXNNaW5TaXplO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNNaW5TaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZUxheW91dGVyLmNyb3NzQXhpc01pblNpemU7XG4gICAgfVxuXG4gICAgcmVzaXplTWFpbkF4aXMoc2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5tYWluQXhpc1NpemUgIT09IHNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY2FsYyA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1SZXNpemVNYWluQXhpcyhzaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoZWNrVmFsaWRDYWNoZU1haW5BeGlzUmVzaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluQXhpc1NpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXRDcm9zc0F4aXNTaXplVG9Db250ZW50cygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIG1pc3MuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbS5lbmFibGVMb2NhbFJlY2FsY0ZsYWcoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtUmVzaXplTWFpbkF4aXMoc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NoZWNrVmFsaWRDYWNoZU1haW5BeGlzUmVzaXplKHNpemUpIHtcbiAgICAgICAgY29uc3QgaXNGaW5hbE1haW5BeGlzU2l6ZSA9IChzaXplID09PSB0aGlzLnRhcmdldE1haW5BeGlzU2l6ZSk7XG4gICAgICAgIGlmIChpc0ZpbmFsTWFpbkF4aXNTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5JZ25vcmVDYWNoZU1pc3MgPSAhdGhpcy5pc0Nyb3NzQXhpc0ZpdFRvQ29udGVudHMoKTtcbiAgICAgICAgaWYgKGNhbklnbm9yZUNhY2hlTWlzcykge1xuICAgICAgICAgICAgLy8gQWxsb3cgb3RoZXIgbWFpbiBheGlzIHJlc2l6ZXMgYW5kIGNoZWNrIGlmIGZpbmFsIHJlc2l6ZSBtYXRjaGVzIHRoZSB0YXJnZXQgbWFpbiBheGlzIHNpemVcbiAgICAgICAgICAgIC8vICAoSXRlbUNvb3JkaW5hdGVzVXBkYXRlcikuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcGVyZm9ybVJlc2l6ZU1haW5BeGlzKHNpemUpIHtcbiAgICAgICAgY29uc3QgaXNTaHJpbmtpbmcgPSAoc2l6ZSA8IHRoaXMubWFpbkF4aXNTaXplKTtcbiAgICAgICAgdGhpcy5fc2hydW5rID0gaXNTaHJpbmtpbmc7XG5cbiAgICAgICAgdGhpcy5tYWluQXhpc1NpemUgPSBzaXplO1xuXG4gICAgICAgIHRoaXMuX3Jlc2l6aW5nTWFpbkF4aXMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sYXlvdXRBeGVzKCk7XG4gICAgICAgIHRoaXMuX3Jlc2l6aW5nTWFpbkF4aXMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXNpemVDcm9zc0F4aXMoc2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5jcm9zc0F4aXNTaXplICE9PSBzaXplKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWNhbGMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtUmVzaXplQ3Jvc3NBeGlzKHNpemUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzQXhpc1NpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGVyZm9ybVJlc2l6ZUNyb3NzQXhpcyhzaXplKSB7XG4gICAgICAgIHRoaXMuY3Jvc3NBeGlzU2l6ZSA9IHNpemU7XG5cbiAgICAgICAgdGhpcy5fcmVzaXppbmdDcm9zc0F4aXMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sYXlvdXRDcm9zc0F4aXMoKTtcbiAgICAgICAgdGhpcy5fcmVzaXppbmdDcm9zc0F4aXMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgdGFyZ2V0TWFpbkF4aXNTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9yaXpvbnRhbCA/IHRoaXMuaXRlbS50YXJnZXQudyA6IHRoaXMuaXRlbS50YXJnZXQuaDtcbiAgICB9XG5cbiAgICBnZXQgdGFyZ2V0Q3Jvc3NBeGlzU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvcml6b250YWwgPyB0aGlzLml0ZW0udGFyZ2V0LmggOiB0aGlzLml0ZW0udGFyZ2V0Lnc7XG4gICAgfVxuXG4gICAgZ2V0UGFyZW50RmxleENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5pc0ZsZXhJdGVtRW5hYmxlZCgpID8gdGhpcy5pdGVtLmZsZXhJdGVtLmN0ciA6IG51bGw7XG4gICAgfVxuXG4gICAgX2dldEhvcml6b250YWxQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldFRvdGFsUGFkZGluZyh0aGlzLml0ZW0sIHRydWUpO1xuICAgIH1cblxuICAgIF9nZXRWZXJ0aWNhbFBhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0VG90YWxQYWRkaW5nKHRoaXMuaXRlbSwgZmFsc2UpO1xuICAgIH1cblxuICAgIF9nZXRIb3Jpem9udGFsUGFkZGluZ09mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRQYWRkaW5nT2Zmc2V0KHRoaXMuaXRlbSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgX2dldFZlcnRpY2FsUGFkZGluZ09mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRQYWRkaW5nT2Zmc2V0KHRoaXMuaXRlbSwgZmFsc2UpO1xuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc0Jhc2lzKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldFJlbEF4aXNTaXplKHRoaXMuaXRlbSwgdGhpcy5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc0Jhc2lzKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldFJlbEF4aXNTaXplKHRoaXMuaXRlbSwgIXRoaXMuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIGdldCBfaG9yaXpvbnRhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsZXhDb250YWluZXIuX2hvcml6b250YWw7XG4gICAgfVxuXG4gICAgZ2V0IF9yZXZlcnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmxleENvbnRhaW5lci5fcmV2ZXJzZTtcbiAgICB9XG5cbiAgICBnZXQgaXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsZXhDb250YWluZXIuaXRlbTtcbiAgICB9XG5cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0uaXRlbXM7XG4gICAgfVxuXG4gICAgZ2V0IHJlc2l6aW5nTWFpbkF4aXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNpemluZ01haW5BeGlzO1xuICAgIH1cblxuICAgIGdldCByZXNpemluZ0Nyb3NzQXhpcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6aW5nQ3Jvc3NBeGlzO1xuICAgIH1cblxuICAgIGdldCBudW1iZXJPZkl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgZ2V0IG1haW5BeGlzU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0U2l6ZSh0aGlzLml0ZW0sIHRoaXMuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIGdldCBjcm9zc0F4aXNTaXplKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRTaXplKHRoaXMuaXRlbSwgIXRoaXMuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIHNldCBtYWluQXhpc1NpemUodikge1xuICAgICAgICBGbGV4VXRpbHMuc2V0QXhpc0xheW91dFNpemUodGhpcy5pdGVtLCB0aGlzLl9ob3Jpem9udGFsLCB2KTtcbiAgICB9XG5cbiAgICBzZXQgY3Jvc3NBeGlzU2l6ZSh2KSB7XG4gICAgICAgIEZsZXhVdGlscy5zZXRBeGlzTGF5b3V0U2l6ZSh0aGlzLml0ZW0sICF0aGlzLl9ob3Jpem9udGFsLCB2KTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBGbGV4VXRpbHMgZnJvbSBcIi4uL0ZsZXhVdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSXRlbUNvb3JkaW5hdGVzVXBkYXRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB0aGlzLl9pc1JldmVyc2UgPSB0aGlzLl9mbGV4Q29udGFpbmVyLl9yZXZlcnNlO1xuICAgICAgICB0aGlzLl9ob3Jpem9udGFsUGFkZGluZ09mZnNldCA9IHRoaXMuX2xheW91dC5fZ2V0SG9yaXpvbnRhbFBhZGRpbmdPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5fdmVydGljYWxQYWRkaW5nT2Zmc2V0ID0gdGhpcy5fbGF5b3V0Ll9nZXRWZXJ0aWNhbFBhZGRpbmdPZmZzZXQoKTtcbiAgICB9XG5cbiAgICBnZXQgX2ZsZXhDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQuX2ZsZXhDb250YWluZXI7XG4gICAgfVxuXG4gICAgZmluYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEZsZXggPSB0aGlzLl9sYXlvdXQuZ2V0UGFyZW50RmxleENvbnRhaW5lcigpO1xuICAgICAgICBpZiAocGFyZW50RmxleCkge1xuICAgICAgICAgICAgLy8gV2UgbXVzdCB1cGRhdGUgaXQgZnJvbSB0aGUgcGFyZW50IHRvIHNldCBwYWRkaW5nIG9mZnNldHMgYW5kIHJldmVyc2UgcG9zaXRpb24uXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVyID0gbmV3IEl0ZW1Db29yZGluYXRlc1VwZGF0ZXIocGFyZW50RmxleC5fbGF5b3V0KTtcbiAgICAgICAgICAgIHVwZGF0ZXIuX2ZpbmFsaXplSXRlbUFuZENoaWxkcmVuKHRoaXMuX2ZsZXhDb250YWluZXIuaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6ZVJvb3QoKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXplSXRlbXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9maW5hbGl6ZVJvb3QoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9mbGV4Q29udGFpbmVyLml0ZW07XG4gICAgICAgIGxldCB4ID0gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRQb3MoaXRlbSwgdHJ1ZSk7XG4gICAgICAgIGxldCB5ID0gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRQb3MoaXRlbSwgZmFsc2UpO1xuICAgICAgICBsZXQgdyA9IEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0U2l6ZShpdGVtLCB0cnVlKTtcbiAgICAgICAgbGV0IGggPSBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFNpemUoaXRlbSwgZmFsc2UpO1xuXG4gICAgICAgIHcgKz0gdGhpcy5fbGF5b3V0Ll9nZXRIb3Jpem9udGFsUGFkZGluZygpO1xuICAgICAgICBoICs9IHRoaXMuX2xheW91dC5fZ2V0VmVydGljYWxQYWRkaW5nKCk7XG5cbiAgICAgICAgaXRlbS5jbGVhclJlY2FsY0ZsYWcoKTtcblxuICAgICAgICBpdGVtLnNldExheW91dCh4LCB5LCB3LCBoKTtcbiAgICB9XG5cbiAgICBfZmluYWxpemVJdGVtcygpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYXlvdXQuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBjb25zdCB2YWxpZENhY2hlID0gdGhpcy5fdmFsaWRhdGVJdGVtQ2FjaGUoaXRlbSk7XG5cbiAgICAgICAgICAgIC8vIE5vdGljZSB0aGF0IHdlIG11c3QgYWxzbyBmaW5hbGl6ZSBhIGNhY2hlZCBpdGVtcywgYXMgaXQncyBjb29yZGluYXRlcyBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAgICAgdGhpcy5fZmluYWxpemVJdGVtKGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5hbGl6ZUl0ZW1DaGlsZHJlbihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF92YWxpZGF0ZUl0ZW1DYWNoZShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnJlY2FsYyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaXNGbGV4RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF5b3V0ID0gaXRlbS5fZmxleC5fbGF5b3V0O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uc01hdGNoUHJldmlvdXNSZXN1bHQgPSAoaXRlbS53ID09PSBpdGVtLnRhcmdldC53ICYmIGl0ZW0uaCA9PT0gaXRlbS50YXJnZXQuaCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnNNYXRjaFByZXZpb3VzUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcm9zc0F4aXNTaXplID0gbGF5b3V0LmNyb3NzQXhpc1NpemU7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dC5wZXJmb3JtUmVzaXplTWFpbkF4aXMobGF5b3V0Lm1haW5BeGlzU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dC5wZXJmb3JtUmVzaXplQ3Jvc3NBeGlzKGNyb3NzQXhpc1NpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgX2ZpbmFsaXplSXRlbUFuZENoaWxkcmVuKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9maW5hbGl6ZUl0ZW1DaGlsZHJlbihpdGVtKTtcbiAgICB9XG5cbiAgICBfZmluYWxpemVJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUmV2ZXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZU1haW5BeGlzTGF5b3V0UG9zKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHggPSBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFBvcyhpdGVtLCB0cnVlKTtcbiAgICAgICAgbGV0IHkgPSBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFBvcyhpdGVtLCBmYWxzZSk7XG4gICAgICAgIGxldCB3ID0gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRTaXplKGl0ZW0sIHRydWUpO1xuICAgICAgICBsZXQgaCA9IEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0U2l6ZShpdGVtLCBmYWxzZSk7XG5cbiAgICAgICAgeCArPSB0aGlzLl9ob3Jpem9udGFsUGFkZGluZ09mZnNldDtcbiAgICAgICAgeSArPSB0aGlzLl92ZXJ0aWNhbFBhZGRpbmdPZmZzZXQ7XG5cbiAgICAgICAgY29uc3QgZmxleCA9IGl0ZW0uZmxleDtcbiAgICAgICAgaWYgKGZsZXgpIHtcbiAgICAgICAgICAgIHcgKz0gaXRlbS5fZmxleC5fbGF5b3V0Ll9nZXRIb3Jpem9udGFsUGFkZGluZygpO1xuICAgICAgICAgICAgaCArPSBpdGVtLl9mbGV4Ll9sYXlvdXQuX2dldFZlcnRpY2FsUGFkZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmxleEl0ZW0gPSBpdGVtLmZsZXhJdGVtO1xuICAgICAgICBpZiAoZmxleEl0ZW0pIHtcbiAgICAgICAgICAgIHggKz0gZmxleEl0ZW0uX2dldEhvcml6b250YWxNYXJnaW5PZmZzZXQoKTtcbiAgICAgICAgICAgIHkgKz0gZmxleEl0ZW0uX2dldFZlcnRpY2FsTWFyZ2luT2Zmc2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLmNsZWFyUmVjYWxjRmxhZygpO1xuICAgICAgICBpdGVtLnNldExheW91dCh4LCB5LCB3LCBoKTtcbiAgICB9XG5cbiAgICBfZmluYWxpemVJdGVtQ2hpbGRyZW4oaXRlbSkge1xuICAgICAgICBjb25zdCBmbGV4ID0gaXRlbS5fZmxleDtcbiAgICAgICAgaWYgKGZsZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXIgPSBuZXcgSXRlbUNvb3JkaW5hdGVzVXBkYXRlcihmbGV4Ll9sYXlvdXQpO1xuICAgICAgICAgICAgdXBkYXRlci5fZmluYWxpemVJdGVtcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3JldmVyc2VNYWluQXhpc0xheW91dFBvcyhpdGVtKSB7XG4gICAgICAgIGNvbnN0IGVuZFBvcyA9IChpdGVtLmZsZXhJdGVtLl9nZXRNYWluQXhpc0xheW91dFBvcygpICsgaXRlbS5mbGV4SXRlbS5fZ2V0TWFpbkF4aXNMYXlvdXRTaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKSk7XG4gICAgICAgIGNvbnN0IHJldmVyc2VkUG9zID0gdGhpcy5fbGF5b3V0Lm1haW5BeGlzU2l6ZSAtIGVuZFBvcztcbiAgICAgICAgaXRlbS5mbGV4SXRlbS5fc2V0TWFpbkF4aXNMYXlvdXRQb3MocmV2ZXJzZWRQb3MpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpbmVMYXlvdXQgZnJvbSBcIi4vbGluZS9MaW5lTGF5b3V0Lm1qc1wiO1xuXG4vKipcbiAqIERpc3RyaWJ1dGVzIGl0ZW1zIG92ZXIgbGF5b3V0IGxpbmVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lTGF5b3V0ZXIge1xuXG4gICAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgICAgIHRoaXMuX2xheW91dCA9IGxheW91dDtcbiAgICAgICAgdGhpcy5fbWFpbkF4aXNNaW5TaXplID0gLTE7XG4gICAgICAgIHRoaXMuX2Nyb3NzQXhpc01pblNpemUgPSAtMTtcbiAgICAgICAgdGhpcy5fbWFpbkF4aXNDb250ZW50U2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IGxpbmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXM7XG4gICAgfVxuXG4gICAgZ2V0IG1haW5BeGlzTWluU2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21haW5BeGlzTWluU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX21haW5BeGlzTWluU2l6ZSA9IHRoaXMuX2dldE1haW5BeGlzTWluU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWluQXhpc01pblNpemU7XG4gICAgfVxuXG4gICAgZ2V0IGNyb3NzQXhpc01pblNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jcm9zc0F4aXNNaW5TaXplID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY3Jvc3NBeGlzTWluU2l6ZSA9IHRoaXMuX2dldENyb3NzQXhpc01pblNpemUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3Jvc3NBeGlzTWluU2l6ZTtcbiAgICB9XG5cbiAgICBnZXQgbWFpbkF4aXNDb250ZW50U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21haW5BeGlzQ29udGVudFNpemU7XG4gICAgfVxuXG4gICAgbGF5b3V0TGluZXMoKSB7XG4gICAgICAgIHRoaXMuX3NldHVwKCk7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGF5b3V0Lml0ZW1zO1xuICAgICAgICBjb25zdCB3cmFwID0gdGhpcy5fbGF5b3V0LmlzV3JhcHBpbmcoKTtcblxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBuID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgICAgIHRoaXMuX2xheW91dEZsZXhJdGVtKGl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBHZXQgcHJlZGljdGVkIG1haW4gYXhpcyBzaXplLlxuICAgICAgICAgICAgY29uc3QgaXRlbU1haW5BeGlzU2l6ZSA9IGl0ZW0uZmxleEl0ZW0uX2dldE1haW5BeGlzTGF5b3V0U2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCk7XG5cbiAgICAgICAgICAgIGlmICh3cmFwICYmIChpID4gc3RhcnRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc092ZXJmbG93aW5nID0gKHRoaXMuX2N1ck1haW5BeGlzUG9zICsgaXRlbU1haW5BeGlzU2l6ZSA+IHRoaXMuX21haW5BeGlzU2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0TGluZShzdGFydEluZGV4LCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1ck1haW5BeGlzUG9zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hZGRUb01haW5BeGlzUG9zKGl0ZW1NYWluQXhpc1NpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBpKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRMaW5lKHN0YXJ0SW5kZXgsIGkgLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9sYXlvdXRGbGV4SXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLmlzRmxleEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgaXRlbS5mbGV4TGF5b3V0LnVwZGF0ZVRyZWVMYXlvdXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0uZmxleEl0ZW0uX3Jlc2V0TGF5b3V0U2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldHVwKCkge1xuICAgICAgICB0aGlzLl9tYWluQXhpc1NpemUgPSB0aGlzLl9sYXlvdXQubWFpbkF4aXNTaXplO1xuICAgICAgICB0aGlzLl9jdXJNYWluQXhpc1BvcyA9IDA7XG4gICAgICAgIHRoaXMuX21heE1haW5BeGlzUG9zID0gMDtcbiAgICAgICAgdGhpcy5fbGluZXMgPSBbXTtcblxuICAgICAgICB0aGlzLl9tYWluQXhpc01pblNpemUgPSAtMTtcbiAgICAgICAgdGhpcy5fY3Jvc3NBeGlzTWluU2l6ZSA9IC0xO1xuICAgICAgICB0aGlzLl9tYWluQXhpc0NvbnRlbnRTaXplID0gMDtcbiAgICB9XG5cbiAgICBfYWRkVG9NYWluQXhpc1BvcyhpdGVtTWFpbkF4aXNTaXplKSB7XG4gICAgICAgIHRoaXMuX2N1ck1haW5BeGlzUG9zICs9IGl0ZW1NYWluQXhpc1NpemU7XG4gICAgICAgIGlmICh0aGlzLl9jdXJNYWluQXhpc1BvcyA+IHRoaXMuX21heE1haW5BeGlzUG9zKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXhNYWluQXhpc1BvcyA9IHRoaXMuX2N1ck1haW5BeGlzUG9zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2xheW91dExpbmUoc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlU3BhY2UgPSB0aGlzLl9nZXRBdmFpbGFibGVNYWluQXhpc0xheW91dFNwYWNlKCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBuZXcgTGluZUxheW91dCh0aGlzLl9sYXlvdXQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBhdmFpbGFibGVTcGFjZSk7XG4gICAgICAgIGxpbmUucGVyZm9ybUxheW91dCgpO1xuICAgICAgICB0aGlzLl9saW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgICAgIGlmICh0aGlzLl9tYWluQXhpc0NvbnRlbnRTaXplID09PSAwIHx8ICh0aGlzLl9jdXJNYWluQXhpc1BvcyA+IHRoaXMuX21haW5BeGlzQ29udGVudFNpemUpKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWluQXhpc0NvbnRlbnRTaXplID0gdGhpcy5fY3VyTWFpbkF4aXNQb3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0QXZhaWxhYmxlTWFpbkF4aXNMYXlvdXRTcGFjZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sYXlvdXQucmVzaXppbmdNYWluQXhpcyAmJiB0aGlzLl9sYXlvdXQuaXNNYWluQXhpc0ZpdFRvQ29udGVudHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFpbkF4aXNTaXplIC0gdGhpcy5fY3VyTWFpbkF4aXNQb3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzTWluU2l6ZSgpIHtcbiAgICAgICAgbGV0IGNyb3NzQXhpc01pblNpemUgPSAwO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xheW91dC5pdGVtcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1Dcm9zc0F4aXNNaW5TaXplID0gaXRlbS5mbGV4SXRlbS5fZ2V0Q3Jvc3NBeGlzTWluU2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCk7XG4gICAgICAgICAgICBjcm9zc0F4aXNNaW5TaXplID0gTWF0aC5tYXgoY3Jvc3NBeGlzTWluU2l6ZSwgaXRlbUNyb3NzQXhpc01pblNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcm9zc0F4aXNNaW5TaXplO1xuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc01pblNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lc1swXS5nZXRNYWluQXhpc01pblNpemUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdyYXBwaW5nIGxpbmVzOiBzcGVjaWZpZWQgd2lkdGggaXMgdXNlZCBhcyBtaW4gd2lkdGggKGluIGFjY29yZGFuY2UgdG8gVzNDIGZsZXhib3gpLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5tYWluQXhpc1NpemU7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwYWNpbmdDYWxjdWxhdG9yIHtcblxuICAgIHN0YXRpYyBnZXRTcGFjaW5nKG1vZGUsIG51bWJlck9mSXRlbXMsIHJlbWFpbmluZ1NwYWNlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1HYXBzID0gKG51bWJlck9mSXRlbXMgLSAxKTtcbiAgICAgICAgbGV0IHNwYWNlUGVyR2FwO1xuXG4gICAgICAgIGxldCBzcGFjaW5nQmVmb3JlLCBzcGFjaW5nQmV0d2VlbjtcblxuICAgICAgICBzd2l0Y2gobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBcImZsZXgtc3RhcnRcIjpcbiAgICAgICAgICAgICAgICBzcGFjaW5nQmVmb3JlID0gMDtcbiAgICAgICAgICAgICAgICBzcGFjaW5nQmV0d2VlbiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmxleC1lbmRcIjpcbiAgICAgICAgICAgICAgICBzcGFjaW5nQmVmb3JlID0gcmVtYWluaW5nU3BhY2U7XG4gICAgICAgICAgICAgICAgc3BhY2luZ0JldHdlZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICAgICAgICAgIHNwYWNpbmdCZWZvcmUgPSByZW1haW5pbmdTcGFjZSAvIDI7XG4gICAgICAgICAgICAgICAgc3BhY2luZ0JldHdlZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNwYWNlLWJldHdlZW5cIjpcbiAgICAgICAgICAgICAgICBzcGFjaW5nQmVmb3JlID0gMDtcbiAgICAgICAgICAgICAgICBzcGFjaW5nQmV0d2VlbiA9IE1hdGgubWF4KDAsIHJlbWFpbmluZ1NwYWNlKSAvIGl0ZW1HYXBzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNwYWNlLWFyb3VuZFwiOlxuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdTcGFjZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3BhY2luZyhcImNlbnRlclwiLCBudW1iZXJPZkl0ZW1zLCByZW1haW5pbmdTcGFjZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VQZXJHYXAgPSByZW1haW5pbmdTcGFjZSAvIChpdGVtR2FwcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICBzcGFjaW5nQmVmb3JlID0gMC41ICogc3BhY2VQZXJHYXA7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmdCZXR3ZWVuID0gc3BhY2VQZXJHYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNwYWNlLWV2ZW5seVwiOlxuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdTcGFjZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3BhY2luZyhcImNlbnRlclwiLCBudW1iZXJPZkl0ZW1zLCByZW1haW5pbmdTcGFjZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VQZXJHYXAgPSByZW1haW5pbmdTcGFjZSAvIChpdGVtR2FwcyArIDIpO1xuICAgICAgICAgICAgICAgICAgICBzcGFjaW5nQmVmb3JlID0gc3BhY2VQZXJHYXA7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmdCZXR3ZWVuID0gc3BhY2VQZXJHYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmV0Y2hcIjpcbiAgICAgICAgICAgICAgICBzcGFjaW5nQmVmb3JlID0gMDtcbiAgICAgICAgICAgICAgICBzcGFjaW5nQmV0d2VlbiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kZTogXCIgKyBtb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7c3BhY2luZ0JlZm9yZSwgc3BhY2luZ0JldHdlZW59XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJdGVtQWxpZ25lciB7XG5cbiAgICBjb25zdHJ1Y3RvcihsaW5lKSB7XG4gICAgICAgIHRoaXMuX2xpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLl9jcm9zc0F4aXNMYXlvdXRTaXplID0gMDtcbiAgICAgICAgdGhpcy5fY3Jvc3NBeGlzTGF5b3V0T2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5fYWxpZ25JdGVtc1NldHRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmVSZXNpemVPY2N1cmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ3Jvc3NBeGlzRml0VG9Db250ZW50cyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBfbGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZS5fbGF5b3V0O1xuICAgIH1cblxuICAgIGdldCBfZmxleENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5fZmxleENvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBzZXRDcm9zc0F4aXNMYXlvdXRTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5fY3Jvc3NBeGlzTGF5b3V0U2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgc2V0Q3Jvc3NBeGlzTGF5b3V0T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB0aGlzLl9jcm9zc0F4aXNMYXlvdXRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgYWxpZ24oKSB7XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXNTZXR0aW5nID0gdGhpcy5fZmxleENvbnRhaW5lci5hbGlnbkl0ZW1zO1xuXG4gICAgICAgIHRoaXMuX2lzQ3Jvc3NBeGlzRml0VG9Db250ZW50cyA9IHRoaXMuX2xheW91dC5pc0F4aXNGaXRUb0NvbnRlbnRzKCF0aGlzLl9mbGV4Q29udGFpbmVyLl9ob3Jpem9udGFsKTtcblxuICAgICAgICB0aGlzLl9yZWN1cnNpdmVSZXNpemVPY2N1cmVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGluZS5pdGVtcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2xpbmUuc3RhcnRJbmRleDsgaSA8PSB0aGlzLl9saW5lLmVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIHRoaXMuX2FsaWduSXRlbShpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCByZWN1cnNpdmVSZXNpemVPY2N1cmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjdXJzaXZlUmVzaXplT2NjdXJlZDtcbiAgICB9XG5cbiAgICBfYWxpZ25JdGVtKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgZmxleEl0ZW0gPSBpdGVtLmZsZXhJdGVtO1xuICAgICAgICBsZXQgYWxpZ24gPSBmbGV4SXRlbS5hbGlnblNlbGYgfHwgdGhpcy5fYWxpZ25JdGVtc1NldHRpbmc7XG5cbiAgICAgICAgaWYgKGFsaWduID09PSBcInN0cmV0Y2hcIiAmJiB0aGlzLl9wcmV2ZW50U3RyZXRjaChmbGV4SXRlbSkpIHtcbiAgICAgICAgICAgIGFsaWduID0gXCJmbGV4LXN0YXJ0XCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxpZ24gIT09IFwic3RyZXRjaFwiICYmICF0aGlzLl9pc0Nyb3NzQXhpc0ZpdFRvQ29udGVudHMpIHtcbiAgICAgICAgICAgIGlmIChmbGV4SXRlbS5faGFzUmVsQ3Jvc3NBeGlzU2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gQXMgY3Jvc3MgYXhpcyBzaXplIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0byByZWNhbGMgdGhlIHJlbGF0aXZlIGZsZXggaXRlbSdzIHNpemUuXG4gICAgICAgICAgICAgICAgZmxleEl0ZW0uX3Jlc2V0Q3Jvc3NBeGlzTGF5b3V0U2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoKGFsaWduKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmxleC1zdGFydFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FsaWduSXRlbUZsZXhTdGFydChmbGV4SXRlbSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmxleC1lbmRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGlnbkl0ZW1GbGV4RW5kKGZsZXhJdGVtKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGlnbkl0ZW1GbGV4Q2VudGVyKGZsZXhJdGVtKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJldGNoXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxpZ25JdGVtU3RyZXRjaChmbGV4SXRlbSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYWxpZ25JdGVtRmxleFN0YXJ0KGZsZXhJdGVtKSB7XG4gICAgICAgIGZsZXhJdGVtLl9zZXRDcm9zc0F4aXNMYXlvdXRQb3ModGhpcy5fY3Jvc3NBeGlzTGF5b3V0T2Zmc2V0KTtcbiAgICB9XG5cbiAgICBfYWxpZ25JdGVtRmxleEVuZChmbGV4SXRlbSkge1xuICAgICAgICBjb25zdCBpdGVtQ3Jvc3NBeGlzU2l6ZSA9IGZsZXhJdGVtLl9nZXRDcm9zc0F4aXNMYXlvdXRTaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKTtcbiAgICAgICAgZmxleEl0ZW0uX3NldENyb3NzQXhpc0xheW91dFBvcyh0aGlzLl9jcm9zc0F4aXNMYXlvdXRPZmZzZXQgKyAodGhpcy5fY3Jvc3NBeGlzTGF5b3V0U2l6ZSAtIGl0ZW1Dcm9zc0F4aXNTaXplKSk7XG4gICAgfVxuXG4gICAgX2FsaWduSXRlbUZsZXhDZW50ZXIoZmxleEl0ZW0pIHtcbiAgICAgICAgY29uc3QgaXRlbUNyb3NzQXhpc1NpemUgPSBmbGV4SXRlbS5fZ2V0Q3Jvc3NBeGlzTGF5b3V0U2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCk7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9ICh0aGlzLl9jcm9zc0F4aXNMYXlvdXRTaXplIC0gaXRlbUNyb3NzQXhpc1NpemUpIC8gMjtcbiAgICAgICAgZmxleEl0ZW0uX3NldENyb3NzQXhpc0xheW91dFBvcyh0aGlzLl9jcm9zc0F4aXNMYXlvdXRPZmZzZXQgKyBjZW50ZXIpO1xuICAgIH1cblxuICAgIF9hbGlnbkl0ZW1TdHJldGNoKGZsZXhJdGVtKSB7XG4gICAgICAgIGZsZXhJdGVtLl9zZXRDcm9zc0F4aXNMYXlvdXRQb3ModGhpcy5fY3Jvc3NBeGlzTGF5b3V0T2Zmc2V0KTtcblxuICAgICAgICBjb25zdCBtYWluQXhpc0xheW91dFNpemVCZWZvcmVSZXNpemUgPSBmbGV4SXRlbS5fZ2V0TWFpbkF4aXNMYXlvdXRTaXplKCk7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5fY3Jvc3NBeGlzTGF5b3V0U2l6ZSAtIGZsZXhJdGVtLl9nZXRDcm9zc0F4aXNNYXJnaW4oKSAtIGZsZXhJdGVtLl9nZXRDcm9zc0F4aXNQYWRkaW5nKCk7XG5cbiAgICAgICAgY29uc3QgY3Jvc3NBeGlzTWluU2l6ZVNldHRpbmcgPSBmbGV4SXRlbS5fZ2V0Q3Jvc3NBeGlzTWluU2l6ZVNldHRpbmcoKTtcbiAgICAgICAgaWYgKGNyb3NzQXhpc01pblNpemVTZXR0aW5nID4gMCkge1xuICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIGNyb3NzQXhpc01pblNpemVTZXR0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNyb3NzQXhpc01heFNpemVTZXR0aW5nID0gZmxleEl0ZW0uX2dldENyb3NzQXhpc01heFNpemVTZXR0aW5nKCk7XG4gICAgICAgIGNvbnN0IGNyb3NzQXhpc01heFNpemVTZXR0aW5nRW5hYmxlZCA9IChjcm9zc0F4aXNNYXhTaXplU2V0dGluZyA+IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzTWF4U2l6ZVNldHRpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICBzaXplID0gTWF0aC5taW4oc2l6ZSwgY3Jvc3NBeGlzTWF4U2l6ZVNldHRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxleEl0ZW0uX3Jlc2l6ZUNyb3NzQXhpcyhzaXplKTtcbiAgICAgICAgY29uc3QgbWFpbkF4aXNMYXlvdXRTaXplQWZ0ZXJSZXNpemUgPSBmbGV4SXRlbS5fZ2V0TWFpbkF4aXNMYXlvdXRTaXplKCk7XG5cbiAgICAgICAgY29uc3QgcmVjdXJzaXZlUmVzaXplID0gKG1haW5BeGlzTGF5b3V0U2l6ZUFmdGVyUmVzaXplICE9PSBtYWluQXhpc0xheW91dFNpemVCZWZvcmVSZXNpemUpO1xuICAgICAgICBpZiAocmVjdXJzaXZlUmVzaXplKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmUgcmVzaXplIGNhbiBoYXBwZW4gd2hlbiB0aGlzIGZsZXggaXRlbSBoYXMgdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiB0aGFuIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgIC8vIGFuZCBpcyB3cmFwcGluZyBhbmQgYXV0by1zaXppbmcuIER1ZSB0byBpdGVtL2NvbnRlbnQgc3RyZXRjaGluZyB0aGUgbWFpbiBheGlzIHNpemUgb2YgdGhlIGZsZXhcbiAgICAgICAgICAgIC8vIGl0ZW0gbWF5IGRlY3JlYXNlLiBJZiBpdCBkb2VzIHNvLCB3ZSBtdXN0IHJlLWp1c3RpZnktY29udGVudCB0aGUgY29tcGxldGUgbGluZS5cbiAgICAgICAgICAgIC8vIE5vdGljZSB0aGF0IHdlIGRvbid0IGFjY291bnQgZm9yIGNoYW5nZXMgdG8gdGhlIChpZiBhdXRvc2l6ZWQpIG1haW4gYXhpcyBzaXplIGNhdXNlZCBieSByZWN1cnNpdmVcbiAgICAgICAgICAgIC8vIHJlc2l6ZSwgd2hpY2ggbWF5IGNhdXNlIHRoZSBjb250YWluZXIncyBtYWluIGF4aXMgdG8gbm90IHNocmluayB0byB0aGUgY29udGVudHMgcHJvcGVybHkuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGJ5IGRlc2lnbiwgYmVjYXVzZSBpZiB3ZSBoYWQgcmUtcnVuIHRoZSBtYWluIGF4aXMgbGF5b3V0LCB3ZSBjb3VsZCBydW4gaW50byBpc3N1ZXMgc3VjaFxuICAgICAgICAgICAgLy8gYXMgc2xvdyBsYXlvdXQgb3IgZW5kbGVzcyBsb29wcy5cbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVJlc2l6ZU9jY3VyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3ByZXZlbnRTdHJldGNoKGZsZXhJdGVtKSB7XG4gICAgICAgIGNvbnN0IGhhc0ZpeGVkQ3Jvc3NBeGlzU2l6ZSA9IGZsZXhJdGVtLl9oYXNGaXhlZENyb3NzQXhpc1NpemUoKTtcbiAgICAgICAgY29uc3QgZm9yY2VTdHJldGNoID0gKGZsZXhJdGVtLmFsaWduU2VsZiA9PT0gXCJzdHJldGNoXCIpO1xuICAgICAgICByZXR1cm4gaGFzRml4ZWRDcm9zc0F4aXNTaXplICYmICFmb3JjZVN0cmV0Y2g7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU3BhY2luZ0NhbGN1bGF0b3IgZnJvbSBcIi4uL1NwYWNpbmdDYWxjdWxhdG9yLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJdGVtUG9zaXRpb25lciB7XG5cbiAgICBjb25zdHJ1Y3RvcihsaW5lTGF5b3V0KSB7XG4gICAgICAgIHRoaXMuX2xpbmUgPSBsaW5lTGF5b3V0O1xuICAgIH1cblxuICAgIGdldCBfbGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZS5fbGF5b3V0O1xuICAgIH1cblxuICAgIHBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCB7c3BhY2luZ0JlZm9yZSwgc3BhY2luZ0JldHdlZW59ID0gdGhpcy5fZ2V0U3BhY2luZygpO1xuXG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gc3BhY2luZ0JlZm9yZTtcblxuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xpbmUuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9saW5lLnN0YXJ0SW5kZXg7IGkgPD0gdGhpcy5fbGluZS5lbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgICAgIGl0ZW0uZmxleEl0ZW0uX3NldE1haW5BeGlzTGF5b3V0UG9zKGN1cnJlbnRQb3MpO1xuICAgICAgICAgICAgY3VycmVudFBvcyArPSBpdGVtLmZsZXhJdGVtLl9nZXRNYWluQXhpc0xheW91dFNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpO1xuICAgICAgICAgICAgY3VycmVudFBvcyArPSBzcGFjaW5nQmV0d2VlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRTcGFjaW5nKCkge1xuICAgICAgICBjb25zdCByZW1haW5pbmdTcGFjZSA9IHRoaXMuX2xpbmUuX2F2YWlsYWJsZVNwYWNlO1xuICAgICAgICBsZXQgbW9kZSA9IHRoaXMuX2xheW91dC5fZmxleENvbnRhaW5lci5qdXN0aWZ5Q29udGVudDtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZJdGVtcyA9IHRoaXMuX2xpbmUubnVtYmVyT2ZJdGVtcztcblxuICAgICAgICByZXR1cm4gU3BhY2luZ0NhbGN1bGF0b3IuZ2V0U3BhY2luZyhtb2RlLCBudW1iZXJPZkl0ZW1zLCByZW1haW5pbmdTcGFjZSk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU2l6ZVNocmlua2VyIGZyb20gXCIuL1NpemVTaHJpbmtlci5tanNcIjtcbmltcG9ydCBTaXplR3Jvd2VyIGZyb20gXCIuL1NpemVHcm93ZXIubWpzXCI7XG5pbXBvcnQgSXRlbVBvc2l0aW9uZXIgZnJvbSBcIi4vSXRlbVBvc2l0aW9uZXIubWpzXCI7XG5pbXBvcnQgSXRlbUFsaWduZXIgZnJvbSBcIi4vSXRlbUFsaWduZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVMYXlvdXQge1xuXG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBzdGFydEluZGV4LCBlbmRJbmRleCwgYXZhaWxhYmxlU3BhY2UpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB0aGlzLml0ZW1zID0gbGF5b3V0Lml0ZW1zO1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZVNwYWNlID0gYXZhaWxhYmxlU3BhY2U7XG4gICAgfVxuXG4gICAgcGVyZm9ybUxheW91dCgpIHtcbiAgICAgICAgdGhpcy5fc2V0SXRlbVNpemVzKCk7XG4gICAgICAgIHRoaXMuc2V0SXRlbVBvc2l0aW9ucygpO1xuICAgICAgICB0aGlzLl9jYWxjTGF5b3V0SW5mbygpO1xuICAgIH1cblxuICAgIF9zZXRJdGVtU2l6ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hdmFpbGFibGVTcGFjZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3dJdGVtU2l6ZXModGhpcy5fYXZhaWxhYmxlU3BhY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2F2YWlsYWJsZVNwYWNlIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5fc2hyaW5rSXRlbVNpemVzKC10aGlzLl9hdmFpbGFibGVTcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ3Jvd0l0ZW1TaXplcyhhbW91bnQpIHtcbiAgICAgICAgY29uc3QgZ3Jvd2VyID0gbmV3IFNpemVHcm93ZXIodGhpcyk7XG4gICAgICAgIGdyb3dlci5ncm93KGFtb3VudCk7XG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZVNwYWNlIC09IGdyb3dlci5nZXRHcm93blNpemUoKTtcbiAgICB9XG5cbiAgICBfc2hyaW5rSXRlbVNpemVzKGFtb3VudCkge1xuICAgICAgICBjb25zdCBzaHJpbmtlciA9IG5ldyBTaXplU2hyaW5rZXIodGhpcyk7XG4gICAgICAgIHNocmlua2VyLnNocmluayhhbW91bnQpO1xuICAgICAgICB0aGlzLl9hdmFpbGFibGVTcGFjZSArPSBzaHJpbmtlci5nZXRTaHJ1bmtTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0SXRlbVBvc2l0aW9ucygpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25lciA9IG5ldyBJdGVtUG9zaXRpb25lcih0aGlzKTtcbiAgICAgICAgcG9zaXRpb25lci5wb3NpdGlvbigpO1xuICAgIH1cblxuICAgIGNyZWF0ZUl0ZW1BbGlnbmVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZW1BbGlnbmVyKHRoaXMpO1xuICAgIH1cblxuICAgIF9jYWxjTGF5b3V0SW5mbygpIHtcbiAgICAgICAgdGhpcy5fY2FsY0Nyb3NzQXhpc01heExheW91dFNpemUoKTtcbiAgICB9XG5cbiAgICBnZXRNYWluQXhpc01pblNpemUoKSB7XG4gICAgICAgIGxldCBtYWluQXhpc01pblNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGFydEluZGV4OyBpIDw9IHRoaXMuZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNbaV07XG4gICAgICAgICAgICBtYWluQXhpc01pblNpemUgKz0gaXRlbS5mbGV4SXRlbS5fZ2V0TWFpbkF4aXNNaW5TaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFpbkF4aXNNaW5TaXplO1xuICAgIH1cbiAgICBcbiAgICBnZXQgbnVtYmVyT2ZJdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXggKyAxO1xuICAgIH1cblxuICAgIGdldCBjcm9zc0F4aXNMYXlvdXRTaXplKCkge1xuICAgICAgICBjb25zdCBub1NwZWNpZmllZENyb3NzQXhpc1NpemUgPSAodGhpcy5fbGF5b3V0LmlzQ3Jvc3NBeGlzRml0VG9Db250ZW50cygpICYmICF0aGlzLl9sYXlvdXQucmVzaXppbmdDcm9zc0F4aXMpO1xuICAgICAgICBjb25zdCBzaG91bGRGaXRUb0NvbnRlbnRzID0gKHRoaXMuX2xheW91dC5pc1dyYXBwaW5nKCkgfHwgbm9TcGVjaWZpZWRDcm9zc0F4aXNTaXplKTtcbiAgICAgICAgaWYgKHNob3VsZEZpdFRvQ29udGVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcm9zc0F4aXNNYXhMYXlvdXRTaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5jcm9zc0F4aXNTaXplO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NhbGNDcm9zc0F4aXNNYXhMYXlvdXRTaXplKCkge1xuICAgICAgICB0aGlzLl9jcm9zc0F4aXNNYXhMYXlvdXRTaXplID0gdGhpcy5fZ2V0Q3Jvc3NBeGlzTWF4TGF5b3V0U2l6ZSgpO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNNYXhMYXlvdXRTaXplKCkge1xuICAgICAgICBsZXQgY3Jvc3NBeGlzTWF4U2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXJ0SW5kZXg7IGkgPD0gdGhpcy5lbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtc1tpXTtcbiAgICAgICAgICAgIGNyb3NzQXhpc01heFNpemUgPSBNYXRoLm1heChjcm9zc0F4aXNNYXhTaXplLCBpdGVtLmZsZXhJdGVtLl9nZXRDcm9zc0F4aXNMYXlvdXRTaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyb3NzQXhpc01heFNpemU7XG4gICAgfVxuXG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpemVHcm93ZXIge1xuXG4gICAgY29uc3RydWN0b3IobGluZSkge1xuICAgICAgICB0aGlzLl9saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5fYW1vdW50UmVtYWluaW5nID0gMDtcbiAgICAgICAgdGhpcy5fZ3Jvd25TaXplID0gMDtcbiAgICB9XG5cbiAgICBncm93KGFtb3VudCkge1xuICAgICAgICB0aGlzLl9ncm93blNpemUgPSAwO1xuXG4gICAgICAgIHRoaXMuX2Ftb3VudFJlbWFpbmluZyA9IGFtb3VudDtcbiAgICAgICAgbGV0IHRvdGFsR3Jvd0Ftb3VudCA9IHRoaXMuX2dldFRvdGFsR3Jvd0Ftb3VudCgpO1xuICAgICAgICBpZiAodG90YWxHcm93QW1vdW50KSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xpbmUuaXRlbXM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGFtb3VudFBlckdyb3cgPSB0aGlzLl9hbW91bnRSZW1haW5pbmcgLyB0b3RhbEdyb3dBbW91bnQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2xpbmUuc3RhcnRJbmRleDsgaSA8PSB0aGlzLl9saW5lLmVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGV4SXRlbSA9IGl0ZW0uZmxleEl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyb3dBbW91bnQgPSBmbGV4SXRlbS5ncm93O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0dyb3dhYmxlSXRlbSA9IChncm93QW1vdW50ID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0dyb3dhYmxlSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGdyb3cgPSBncm93QW1vdW50ICogYW1vdW50UGVyR3JvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFNpemUgPSBmbGV4SXRlbS5fZ2V0TWFpbkF4aXNNYXhTaXplU2V0dGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGZsZXhJdGVtLl9nZXRNYWluQXhpc0xheW91dFNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhTaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplID49IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBmdWxseSBncm93bi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4R3JvdyA9IG1heFNpemUgLSBzaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0Z1bGx5R3Jvd24gPSAoZ3JvdyA+PSBtYXhHcm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVsbHlHcm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdyA9IG1heEdyb3c7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlc3RyaWJ1dGUgcmVtYWluaW5nIGFtb3VudCBvdmVyIHRoZSBvdGhlciBmbGV4IGl0ZW1zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxHcm93QW1vdW50IC09IGdyb3dBbW91bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm93ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU2l6ZSA9IHNpemUgKyBncm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhJdGVtLl9yZXNpemVNYWluQXhpcyhmaW5hbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3Jvd25TaXplICs9IGdyb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW1vdW50UmVtYWluaW5nIC09IGdyb3c7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fYW1vdW50UmVtYWluaW5nKSA8IDEwZS02KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlKHRvdGFsR3Jvd0Ftb3VudCAmJiAoTWF0aC5hYnModGhpcy5fYW1vdW50UmVtYWluaW5nKSA+IDEwZS02KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0VG90YWxHcm93QW1vdW50KCkge1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xpbmUuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9saW5lLnN0YXJ0SW5kZXg7IGkgPD0gdGhpcy5fbGluZS5lbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBjb25zdCBmbGV4SXRlbSA9IGl0ZW0uZmxleEl0ZW07XG5cbiAgICAgICAgICAgIGlmIChmbGV4SXRlbS5ncm93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U2l6ZSA9IGZsZXhJdGVtLl9nZXRNYWluQXhpc01heFNpemVTZXR0aW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGZsZXhJdGVtLl9nZXRNYWluQXhpc0xheW91dFNpemUoKTtcblxuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgdGhvc2UgYWxyZWFkeSBmdWxseSBncm93bi5cbiAgICAgICAgICAgICAgICBpZiAobWF4U2l6ZSA9PT0gMCB8fCBzaXplIDwgbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSBmbGV4SXRlbS5ncm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuXG4gICAgZ2V0R3Jvd25TaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3Jvd25TaXplO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2l6ZVNocmlua2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKGxpbmUpIHtcbiAgICAgICAgdGhpcy5fbGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuX2Ftb3VudFJlbWFpbmluZyA9IDA7XG4gICAgICAgIHRoaXMuX3NocnVua1NpemUgPSAwO1xuICAgIH1cblxuICAgIHNocmluayhhbW91bnQpIHtcbiAgICAgICAgdGhpcy5fc2hydW5rU2l6ZSA9IDA7XG5cbiAgICAgICAgdGhpcy5fYW1vdW50UmVtYWluaW5nID0gYW1vdW50O1xuICAgICAgICBsZXQgdG90YWxTaHJpbmtBbW91bnQgPSB0aGlzLl9nZXRUb3RhbFNocmlua0Ftb3VudCgpO1xuICAgICAgICBpZiAodG90YWxTaHJpbmtBbW91bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGluZS5pdGVtcztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsZXQgYW1vdW50UGVyU2hyaW5rID0gdGhpcy5fYW1vdW50UmVtYWluaW5nIC8gdG90YWxTaHJpbmtBbW91bnQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2xpbmUuc3RhcnRJbmRleDsgaSA8PSB0aGlzLl9saW5lLmVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGV4SXRlbSA9IGl0ZW0uZmxleEl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNocmlua0Ftb3VudCA9IGZsZXhJdGVtLnNocmluaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTaHJpbmthYmxlSXRlbSA9IChzaHJpbmtBbW91bnQgPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2hyaW5rYWJsZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaHJpbmsgPSBzaHJpbmtBbW91bnQgKiBhbW91bnRQZXJTaHJpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5TaXplID0gZmxleEl0ZW0uX2dldE1haW5BeGlzTWluU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGZsZXhJdGVtLl9nZXRNYWluQXhpc0xheW91dFNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gbWluU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFNocmluayA9IHNpemUgLSBtaW5TaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRnVsbHlTaHJ1bmsgPSAoc2hyaW5rID49IG1heFNocmluayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVsbHlTaHJ1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rID0gbWF4U2hyaW5rO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlc3RyaWJ1dGUgcmVtYWluaW5nIGFtb3VudCBvdmVyIHRoZSBvdGhlciBmbGV4IGl0ZW1zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNocmlua0Ftb3VudCAtPSBzaHJpbmtBbW91bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxTaXplID0gc2l6ZSAtIHNocmluaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4SXRlbS5fcmVzaXplTWFpbkF4aXMoZmluYWxTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NocnVua1NpemUgKz0gc2hyaW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Ftb3VudFJlbWFpbmluZyAtPSBzaHJpbms7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fYW1vdW50UmVtYWluaW5nKSA8IDEwZS02KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlKHRvdGFsU2hyaW5rQW1vdW50ICYmIChNYXRoLmFicyh0aGlzLl9hbW91bnRSZW1haW5pbmcpID4gMTBlLTYpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRUb3RhbFNocmlua0Ftb3VudCgpIHtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9saW5lLml0ZW1zO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fbGluZS5zdGFydEluZGV4OyBpIDw9IHRoaXMuX2xpbmUuZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgY29uc3QgZmxleEl0ZW0gPSBpdGVtLmZsZXhJdGVtO1xuXG4gICAgICAgICAgICBpZiAoZmxleEl0ZW0uc2hyaW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWluU2l6ZSA9IGZsZXhJdGVtLl9nZXRNYWluQXhpc01pblNpemUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gZmxleEl0ZW0uX2dldE1haW5BeGlzTGF5b3V0U2l6ZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRXhjbHVkZSB0aG9zZSBhbHJlYWR5IGZ1bGx5IHNocnVuay5cbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IG1pblNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gZmxleEl0ZW0uc2hyaW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuXG4gICAgZ2V0U2hydW5rU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NocnVua1NpemU7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQXBwbGljYXRpb24gZnJvbSBcIi4vYXBwbGljYXRpb24vQXBwbGljYXRpb24ubWpzXCI7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2FwcGxpY2F0aW9uL0NvbXBvbmVudC5tanNcIjtcbmltcG9ydCBCYXNlIGZyb20gXCIuL3RyZWUvQmFzZS5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi90cmVlL1V0aWxzLm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4vdHJlZS9FbGVtZW50Lm1qc1wiO1xuaW1wb3J0IEVsZW1lbnRDb3JlIGZyb20gXCIuL3RyZWUvY29yZS9FbGVtZW50Q29yZS5tanNcIjtcbmltcG9ydCBFbGVtZW50VGV4dHVyaXplciBmcm9tIFwiLi90cmVlL2NvcmUvRWxlbWVudFRleHR1cml6ZXIubWpzXCI7XG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi90cmVlL1RleHR1cmUubWpzXCI7XG5cbmltcG9ydCBUb29scyBmcm9tIFwiLi90b29scy9Ub29scy5tanNcIjtcbmltcG9ydCBPYmpNZXJnZXIgZnJvbSBcIi4vdG9vbHMvT2JqTWVyZ2VyLm1qc1wiO1xuaW1wb3J0IE9iamVjdExpc3RQcm94eSBmcm9tIFwiLi90b29scy9PYmplY3RMaXN0UHJveHkubWpzXCI7XG5pbXBvcnQgT2JqZWN0TGlzdFdyYXBwZXIgZnJvbSBcIi4vdG9vbHMvT2JqZWN0TGlzdFdyYXBwZXIubWpzXCI7XG5cbmltcG9ydCBSZWN0YW5nbGVUZXh0dXJlIGZyb20gXCIuL3RleHR1cmVzL1JlY3RhbmdsZVRleHR1cmUubWpzXCI7XG5pbXBvcnQgTm9pc2VUZXh0dXJlIGZyb20gXCIuL3RleHR1cmVzL05vaXNlVGV4dHVyZS5tanNcIjtcbmltcG9ydCBUZXh0VGV4dHVyZSBmcm9tIFwiLi90ZXh0dXJlcy9UZXh0VGV4dHVyZS5tanNcIjtcbmltcG9ydCBJbWFnZVRleHR1cmUgZnJvbSBcIi4vdGV4dHVyZXMvSW1hZ2VUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IEh0bWxUZXh0dXJlIGZyb20gXCIuL3RleHR1cmVzL0h0bWxUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IFN0YXRpY1RleHR1cmUgZnJvbSBcIi4vdGV4dHVyZXMvU3RhdGljVGV4dHVyZS5tanNcIjtcbmltcG9ydCBTdGF0aWNDYW52YXNUZXh0dXJlIGZyb20gXCIuL3RleHR1cmVzL1N0YXRpY0NhbnZhc1RleHR1cmUubWpzXCI7XG5pbXBvcnQgU291cmNlVGV4dHVyZSBmcm9tIFwiLi90ZXh0dXJlcy9Tb3VyY2VUZXh0dXJlLm1qc1wiO1xuXG5pbXBvcnQgTGlzdENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRzL0xpc3RDb21wb25lbnQubWpzXCI7XG5pbXBvcnQgRmFzdEJsdXJDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50cy9GYXN0Qmx1ckNvbXBvbmVudC5tanNcIjtcbmltcG9ydCBCbG9vbUNvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRzL0Jsb29tQ29tcG9uZW50Lm1qc1wiO1xuaW1wb3J0IFNtb290aFNjYWxlQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudHMvU21vb3RoU2NhbGVDb21wb25lbnQubWpzXCI7XG5pbXBvcnQgQm9yZGVyQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudHMvQm9yZGVyQ29tcG9uZW50Lm1qc1wiO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiLi9FdmVudEVtaXR0ZXIubWpzXCI7XG5cbmltcG9ydCBXZWJHTFNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9XZWJHTFNoYWRlci5tanNcIjtcbmltcG9ydCBXZWJHTERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IHsgV2ViR0xHcmF5c2NhbGVTaGFkZXIgfSBmcm9tIFwiLi9yZW5kZXJlci9jb21tb24vc2hhZGVycy9HcmF5c2NhbGVTaGFkZXIubWpzXCI7XG5pbXBvcnQgQm94Qmx1clNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0JveEJsdXJTaGFkZXIubWpzXCI7XG5pbXBvcnQgRGl0aGVyaW5nU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvRGl0aGVyaW5nU2hhZGVyLm1qc1wiO1xuaW1wb3J0IENpcmN1bGFyUHVzaFNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0NpcmN1bGFyUHVzaFNoYWRlci5tanNcIjtcbmltcG9ydCBJbnZlcnNpb25TaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9JbnZlcnNpb25TaGFkZXIubWpzXCI7XG5pbXBvcnQgTGluZWFyQmx1clNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0xpbmVhckJsdXJTaGFkZXIubWpzXCI7XG5pbXBvcnQgT3V0bGluZVNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL091dGxpbmVTaGFkZXIubWpzXCI7XG5pbXBvcnQgUGl4ZWxhdGVTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9QaXhlbGF0ZVNoYWRlci5tanNcIjtcbmltcG9ydCBSYWRpYWxGaWx0ZXJTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9SYWRpYWxGaWx0ZXJTaGFkZXIubWpzXCI7XG5pbXBvcnQgUm91bmRlZFJlY3RhbmdsZVNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1JvdW5kZWRSZWN0YW5nbGVTaGFkZXIubWpzXCI7XG5pbXBvcnQgRmFkZU91dFNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0ZhZGVPdXRTaGFkZXIubWpzXCI7XG5pbXBvcnQgVmlnbmV0dGVTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9WaWduZXR0ZVNoYWRlci5tanNcIjtcbmltcG9ydCBTcGlubmVyU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvU3Bpbm5lclNoYWRlci5tanNcIjtcbmltcG9ydCBIb2xlU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvSG9sZVNoYWRlci5tanNcIjtcbmltcG9ydCBSYWRpYWxHcmFkaWVudFNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1JhZGlhbEdyYWRpZW50U2hhZGVyLm1qc1wiO1xuaW1wb3J0IExpZ2h0M2RTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9MaWdodDNkU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFBlcnNwZWN0aXZlU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvUGVyc3BlY3RpdmVTaGFkZXIubWpzXCI7XG5pbXBvcnQgTWFnbmlmaWVyU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvTWFnbmlmaWVyU2hhZGVyLm1qc1wiO1xuXG5pbXBvcnQgQzJkU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL2MyZC9DMmRTaGFkZXIubWpzXCI7XG5pbXBvcnQgQzJkRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci9jMmQvc2hhZGVycy9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IHsgQzJkR3JheXNjYWxlU2hhZGVyIH0gZnJvbSBcIi4vcmVuZGVyZXIvY29tbW9uL3NoYWRlcnMvR3JheXNjYWxlU2hhZGVyLm1qc1wiO1xuaW1wb3J0IEMyZEJsdXJTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvYzJkL3NoYWRlcnMvQmx1clNoYWRlci5tanNcIjtcblxuaW1wb3J0IFN0YWdlIGZyb20gXCIuL3RyZWUvU3RhZ2UubWpzXCI7XG5pbXBvcnQgU3Bpbm5lclNoYWRlcjIgZnJvbSAnLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1NwaW5uZXJTaGFkZXIyLm1qcyc7XG5cbmNvbnN0IGxpZ2h0bmluZyA9IHtcbiAgICBBcHBsaWNhdGlvbixcbiAgICBDb21wb25lbnQsXG4gICAgQmFzZSxcbiAgICBVdGlscyxcbiAgICBTdGFnZVV0aWxzLFxuICAgIEVsZW1lbnQsXG4gICAgVG9vbHMsXG4gICAgU3RhZ2UsXG4gICAgRWxlbWVudENvcmUsXG4gICAgRWxlbWVudFRleHR1cml6ZXIsXG4gICAgVGV4dHVyZSxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgc2hhZGVyczoge1xuICAgICAgICBHcmF5c2NhbGU6IFdlYkdMR3JheXNjYWxlU2hhZGVyLFxuICAgICAgICBCb3hCbHVyOiBCb3hCbHVyU2hhZGVyLFxuICAgICAgICBEaXRoZXJpbmc6IERpdGhlcmluZ1NoYWRlcixcbiAgICAgICAgQ2lyY3VsYXJQdXNoOiBDaXJjdWxhclB1c2hTaGFkZXIsXG4gICAgICAgIEludmVyc2lvbjogSW52ZXJzaW9uU2hhZGVyLFxuICAgICAgICBMaW5lYXJCbHVyOiBMaW5lYXJCbHVyU2hhZGVyLFxuICAgICAgICBPdXRsaW5lOiBPdXRsaW5lU2hhZGVyLFxuICAgICAgICBQaXhlbGF0ZTogUGl4ZWxhdGVTaGFkZXIsXG4gICAgICAgIFJhZGlhbEZpbHRlcjogUmFkaWFsRmlsdGVyU2hhZGVyLFxuICAgICAgICBSb3VuZGVkUmVjdGFuZ2xlOiBSb3VuZGVkUmVjdGFuZ2xlU2hhZGVyLFxuICAgICAgICBTcGlubmVyMjogU3Bpbm5lclNoYWRlcjIsXG4gICAgICAgIEZhZGVPdXQ6IEZhZGVPdXRTaGFkZXIsXG4gICAgICAgIEhvbGU6IEhvbGVTaGFkZXIsXG4gICAgICAgIFZpZ25ldHRlOiBWaWduZXR0ZVNoYWRlcixcbiAgICAgICAgU3Bpbm5lcjogU3Bpbm5lclNoYWRlcixcbiAgICAgICAgUmFkaWFsR3JhZGllbnQ6IFJhZGlhbEdyYWRpZW50U2hhZGVyLFxuICAgICAgICBMaWdodDNkOiBMaWdodDNkU2hhZGVyLFxuICAgICAgICBQZXJzcGVjdGl2ZTogUGVyc3BlY3RpdmVTaGFkZXIsXG4gICAgICAgIE1hZ25pZmllcjogTWFnbmlmaWVyU2hhZGVyLFxuICAgICAgICBXZWJHTFNoYWRlcixcbiAgICAgICAgV2ViR0xEZWZhdWx0U2hhZGVyLFxuICAgICAgICBDMmRTaGFkZXIsXG4gICAgICAgIEMyZERlZmF1bHRTaGFkZXIsXG4gICAgICAgIGMyZDoge1xuICAgICAgICAgICAgR3JheXNjYWxlOiBDMmRHcmF5c2NhbGVTaGFkZXIsXG4gICAgICAgICAgICBCbHVyOiBDMmRCbHVyU2hhZGVyXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRleHR1cmVzOiB7XG4gICAgICAgIFJlY3RhbmdsZVRleHR1cmUsXG4gICAgICAgIE5vaXNlVGV4dHVyZSxcbiAgICAgICAgVGV4dFRleHR1cmUsXG4gICAgICAgIEltYWdlVGV4dHVyZSxcbiAgICAgICAgSHRtbFRleHR1cmUsXG4gICAgICAgIFN0YXRpY1RleHR1cmUsXG4gICAgICAgIFN0YXRpY0NhbnZhc1RleHR1cmUsXG4gICAgICAgIFNvdXJjZVRleHR1cmVcbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgRmFzdEJsdXJDb21wb25lbnQsXG4gICAgICAgIEJsb29tQ29tcG9uZW50LFxuICAgICAgICBTbW9vdGhTY2FsZUNvbXBvbmVudCxcbiAgICAgICAgQm9yZGVyQ29tcG9uZW50LFxuICAgICAgICBMaXN0Q29tcG9uZW50XG4gICAgfSxcbiAgICB0b29sczoge1xuICAgICAgICBPYmpNZXJnZXIsXG4gICAgICAgIE9iamVjdExpc3RQcm94eSxcbiAgICAgICAgT2JqZWN0TGlzdFdyYXBwZXJcbiAgICB9XG59O1xuXG5pZiAoVXRpbHMuaXNXZWIpIHtcbiAgICB3aW5kb3cubG5nID0gbGlnaHRuaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaWdodG5pbmc7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgV2ViUGxhdGZvcm0gZnJvbSBcIi4vYnJvd3Nlci9XZWJQbGF0Zm9ybS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxhdGZvcm1Mb2FkZXIge1xuICAgIHN0YXRpYyBsb2FkKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucGxhdGZvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnBsYXRmb3JtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFdlYlBsYXRmb3JtO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1hZ2VXb3JrZXIge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9pZCA9IDA7XG5cbiAgICAgICAgdGhpcy5faW5pdFdvcmtlcigpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9pbml0V29ya2VyKCkge1xuICAgICAgICBjb25zdCBjb2RlID0gYCgke2NyZWF0ZVdvcmtlci50b1N0cmluZygpfSkoKWA7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY29kZS5yZXBsYWNlKCdcInVzZSBzdHJpY3RcIjsnLCAnJyldKTsgLy8gZmlyZWZveCBhZGRzIFwidXNlIHN0cmljdFwiOyB0byBhbnkgZnVuY3Rpb24gd2hpY2ggbWlnaHQgYmxvY2sgd29ya2VyIGV4ZWN1dGlvbiBzbyBrbm9jayBpdCBvZmZcbiAgICAgICAgY29uc3QgYmxvYlVSTCA9ICh3aW5kb3cuVVJMID8gVVJMIDogd2Via2l0VVJMKS5jcmVhdGVPYmplY3RVUkwoYmxvYiwge1xuICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQ7IGNoYXJzZXQ9dXRmLTgnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl93b3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVUkwpO1xuXG4gICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTogJ2NvbmZpZycsIGNvbmZpZzoge3BhdGg6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBwcm90b2NvbDogd2luZG93LmxvY2F0aW9uLnByb3RvY29sfX0pO1xuXG4gICAgICAgIHRoaXMuX3dvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUuZGF0YSAmJiBlLmRhdGEuaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGUuZGF0YS5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaChpdGVtLCBlLmRhdGEuaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGl0ZW0sIGUuZGF0YS5pbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZShzcmMpIHtcbiAgICAgICAgY29uc3QgaWQgPSArK3RoaXMuX2lkO1xuICAgICAgICBjb25zdCBpdGVtID0gbmV3IEltYWdlV29ya2VySW1hZ2UodGhpcywgaWQsIHNyYyk7XG4gICAgICAgIHRoaXMuX2l0ZW1zLnNldChpZCwgaXRlbSk7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTogXCJhZGRcIiwgaWQ6IGlkLCBzcmM6IHNyY30pO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBjYW5jZWwoaW1hZ2UpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOiBcImNhbmNlbFwiLCBpZDogaW1hZ2UuaWR9KTtcbiAgICAgICAgdGhpcy5faXRlbXMuZGVsZXRlKGltYWdlLmlkKTtcbiAgICB9XG5cbiAgICBlcnJvcihpbWFnZSwgaW5mbykge1xuICAgICAgICBpbWFnZS5lcnJvcihpbmZvKTtcbiAgICAgICAgdGhpcy5faXRlbXMuZGVsZXRlKGltYWdlLmlkKTtcbiAgICB9XG5cbiAgICBmaW5pc2goaW1hZ2UsIGluZm8pIHtcbiAgICAgICAgaW1hZ2UubG9hZChpbmZvKTtcbiAgICAgICAgdGhpcy5faXRlbXMuZGVsZXRlKGltYWdlLmlkKTtcbiAgICB9XG5cbn1cblxuY2xhc3MgSW1hZ2VXb3JrZXJJbWFnZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBpZCwgc3JjKSB7XG4gICAgICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9zcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuX29uRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl9vbkxvYWQgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cblxuICAgIGdldCBzcmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcmM7XG4gICAgfVxuXG4gICAgc2V0IG9uRXJyb3IoZikge1xuICAgICAgICB0aGlzLl9vbkVycm9yID0gZjtcbiAgICB9XG5cbiAgICBzZXQgb25Mb2FkKGYpIHtcbiAgICAgICAgdGhpcy5fb25Mb2FkID0gZjtcbiAgICB9XG5cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuX21hbmFnZXIuY2FuY2VsKHRoaXMpO1xuICAgIH1cblxuICAgIGxvYWQoaW5mbykge1xuICAgICAgICBpZiAodGhpcy5fb25Mb2FkKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkxvYWQoaW5mbyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlcnJvcihpbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKGluZm8pO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbi8qKlxuICogTm90aWNlIHRoYXQsIHdpdGhpbiB0aGUgY3JlYXRlV29ya2VyIGZ1bmN0aW9uLCB3ZSBtdXN0IG9ubHkgdXNlIEVTNSBjb2RlIHRvIGtlZXAgaXQgRVM1LXZhbGlkIGFmdGVyIGJhYmVsaWZ5aW5nLCBhc1xuICogIHRoZSBjb252ZXJ0ZWQgY29kZSBvZiB0aGlzIHNlY3Rpb24gaXMgY29udmVydGVkIHRvIGEgYmxvYiBhbmQgdXNlZCBhcyB0aGUganMgb2YgdGhlIHdlYiB3b3JrZXIgdGhyZWFkLlxuICovXG5jb25zdCBjcmVhdGVXb3JrZXIgPSBmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIEltYWdlV29ya2VyU2VydmVyKCkge1xuXG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICBvbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0Ll9yZWNlaXZlTWVzc2FnZShlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXIuaXNQYXRoQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiAvXig/OlxcL3xbYS16XSs6XFwvXFwvKS8udGVzdChwYXRoKSB8fCBwYXRoLnN1YnN0cigwLCA1KSA9PSAnZGF0YTonO1xuICAgIH07XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlci5wcm90b3R5cGUuX3JlY2VpdmVNZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdjb25maWcnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IGUuZGF0YS5jb25maWc7XG5cbiAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5jb25maWcucGF0aDtcbiAgICAgICAgICAgIC8vIHRoZSBjb25zdHJ1Y3Rpbmcgb2YgdGhlIGJhc2VwYXRoIGZhaWxzXG4gICAgICAgICAgICAvLyBpZiBsb2NhdGlvbi5oYXNoIGNvbnRhaW5zIGEgc2xhc2hcbiAgICAgICAgICAgIHZhciBoYXNIYXNoUGF0aCA9IC8jLio/XFwvLztcbiAgICAgICAgICAgIGlmKGhhc0hhc2hQYXRoLnRlc3QoYmFzZSkpe1xuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UoLyMuKiQvLCcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcnRzID0gYmFzZS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbGF0aXZlQmFzZSA9IHBhcnRzLmpvaW4oXCIvXCIpICsgXCIvXCI7XG5cbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEudHlwZSA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGUuZGF0YS5pZCwgZS5kYXRhLnNyYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLnR5cGUgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbChlLmRhdGEuaWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlV29ya2VyU2VydmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpZCwgc3JjKSB7XG4gICAgICAgIC8vIENvbnZlcnQgcmVsYXRpdmUgVVJMcy5cbiAgICAgICAgaWYgKCFJbWFnZVdvcmtlclNlcnZlci5pc1BhdGhBYnNvbHV0ZShzcmMpKSB7XG4gICAgICAgICAgICBzcmMgPSB0aGlzLl9yZWxhdGl2ZUJhc2UgKyBzcmM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjLnN1YnN0cigwLDIpID09PSBcIi8vXCIpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lc24ndCB3b3JrIGZvciBpbWFnZSB3b3JrZXJzLlxuICAgICAgICAgICAgc3JjID0gdGhpcy5jb25maWcucHJvdG9jb2wgKyBzcmM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbSA9IG5ldyBJbWFnZVdvcmtlclNlcnZlckl0ZW0oaWQsIHNyYyk7XG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgaXRlbS5vbkZpbmlzaCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgdC5maW5pc2goaXRlbSwgcmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgaXRlbS5vbkVycm9yID0gZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgdC5lcnJvcihpdGVtLCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pdGVtcy5zZXQoaWQsIGl0ZW0pO1xuICAgICAgICBpdGVtLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIEltYWdlV29ya2VyU2VydmVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0uY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oaXRlbSwge2ltYWdlQml0bWFwLCBoYXNBbHBoYUNoYW5uZWx9KSB7XG4gICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgICAgaW1hZ2VCaXRtYXAsXG4gICAgICAgICAgICAgICAgaGFzQWxwaGFDaGFubmVsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtpbWFnZUJpdG1hcF0pO1xuICAgICAgICB0aGlzLml0ZW1zLmRlbGV0ZShpdGVtLmlkKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oaXRlbSwge3R5cGUsIG1lc3NhZ2V9KSB7XG4gICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pdGVtcy5kZWxldGUoaXRlbS5pZCk7XG4gICAgfTtcblxuICAgIEltYWdlV29ya2VyU2VydmVyLmlzV1BFQnJvd3NlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIldQRVwiKSAhPT0gLTEpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJbWFnZVdvcmtlclNlcnZlckl0ZW0oaWQsIHNyYykge1xuXG4gICAgICAgIHRoaXMuX29uRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX29uRmluaXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9zcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuX3hociA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtLnByb3RvdHlwZSwgJ2lkJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtLnByb3RvdHlwZSwgJ29uRmluaXNoJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uRmluaXNoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoID0gZjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEltYWdlV29ya2VyU2VydmVySXRlbS5wcm90b3R5cGUsICdvbkVycm9yJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uRXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvciA9IGY7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIEltYWdlV29ya2VyU2VydmVySXRlbS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5feGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHRoaXMuX3hoci5vcGVuKFwiR0VUXCIsIHRoaXMuX3NyYywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3hoci5yZXNwb25zZVR5cGUgPSBcImJsb2JcIjtcblxuICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3hoci5vbmVycm9yID0gZnVuY3Rpb24ob0V2ZW50KSB7XG4gICAgICAgICAgICB0LmVycm9yKHt0eXBlOiBcImNvbm5lY3Rpb25cIiwgbWVzc2FnZTogXCJDb25uZWN0aW9uIGVycm9yXCJ9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl94aHIub25sb2FkID0gZnVuY3Rpb24ob0V2ZW50KSB7XG4gICAgICAgICAgICB2YXIgYmxvYiA9IHQuX3hoci5yZXNwb25zZTtcbiAgICAgICAgICAgIHQuX21pbWVUeXBlID0gYmxvYi50eXBlO1xuXG4gICAgICAgICAgICB0Ll9jcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl94aHIuc2VuZCgpO1xuICAgIH07XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlckl0ZW0ucHJvdG90eXBlLl9jcmVhdGVJbWFnZUJpdG1hcCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCB7cHJlbXVsdGlwbHlBbHBoYTogJ3ByZW11bHRpcGx5JywgY29sb3JTcGFjZUNvbnZlcnNpb246ICdub25lJywgaW1hZ2VPcmllbnRhdGlvbjogJ25vbmUnfSkudGhlbihmdW5jdGlvbihpbWFnZUJpdG1hcCkge1xuICAgICAgICAgICAgdC5maW5pc2goe1xuICAgICAgICAgICAgICAgIGltYWdlQml0bWFwLFxuICAgICAgICAgICAgICAgIGhhc0FscGhhQ2hhbm5lbDogdC5faGFzQWxwaGFDaGFubmVsKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0LmVycm9yKHt0eXBlOiBcInBhcnNlXCIsIG1lc3NhZ2U6IFwiRXJyb3IgcGFyc2luZyBpbWFnZSBkYXRhXCJ9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIEltYWdlV29ya2VyU2VydmVySXRlbS5wcm90b3R5cGUuX2hhc0FscGhhQ2hhbm5lbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoSW1hZ2VXb3JrZXJTZXJ2ZXIuaXNXUEVCcm93c2VyKCkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdXNpbmcgdW5hY2NlbGVyYXRlZCByZW5kZXJpbmcgaW1hZ2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJQbGF0Zm9ybUZvckVtYmVkZGVkL1dQRVdlYktpdC9ibG9iL3dwZS0yMDE3MDcyOC9Tb3VyY2UvV2ViQ29yZS9odG1sL0ltYWdlQml0bWFwLmNwcCNMNTIpLFxuICAgICAgICAgICAgLy8gZXZlcnl0aGluZyBpbmNsdWRpbmcgSlBHIGltYWdlcyBhcmUgaW4gUkdCQSBmb3JtYXQuIFVwbG9hZCBpcyB3YXkgZmFzdGVyIHdoZW4gdXNpbmcgYW4gYWxwaGEgY2hhbm5lbC5cbiAgICAgICAgICAgIC8vIEB0b2RvOiBhZnRlciBoYXJkd2FyZSBhY2NlbGVyYXRpb24gaXMgZml4ZWQgYW5kIHJlLWVuYWJsZWQsIEpQRyBzaG91bGQgYmUgdXBsb2FkZWQgaW4gUkdCIHRvIGdldCB0aGUgYmVzdCBwb3NzaWJsZSBwZXJmb3JtYW5jZSBhbmQgbWVtb3J5IHVzYWdlLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX21pbWVUeXBlLmluZGV4T2YoXCJpbWFnZS9wbmdcIikgIT09IC0xKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlckl0ZW0ucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FuY2VsZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX3hocikge1xuICAgICAgICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlckl0ZW0ucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24odHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbmNlbGVkICYmIHRoaXMuX29uRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3Ioe3R5cGUsIG1lc3NhZ2V9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlckl0ZW0ucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYW5jZWxlZCAmJiB0aGlzLl9vbkZpbmlzaCkge1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goaW5mbyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHdvcmtlciA9IG5ldyBJbWFnZVdvcmtlclNlcnZlcigpO1xufTtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vLi4vdHJlZS9VdGlscy5tanNcIjtcbmltcG9ydCBJbWFnZVdvcmtlciBmcm9tIFwiLi9JbWFnZVdvcmtlci5tanNcIjtcblxuLyoqXG4gKiBQbGF0Zm9ybS1zcGVjaWZpYyBmdW5jdGlvbmFsaXR5LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJQbGF0Zm9ybSB7XG5cbiAgICBpbml0KHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgICAgICAgdGhpcy5fbG9vcGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hd2FpdGluZ0xvb3AgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5zdGFnZS5nZXRPcHRpb24oXCJ1c2VJbWFnZVdvcmtlclwiKSkge1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXAgfHwgIXdpbmRvdy5Xb3JrZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBDYW4ndCB1c2UgaW1hZ2Ugd29ya2VyIGJlY2F1c2UgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGNyZWF0ZUltYWdlQml0bWFwIGFuZCBXZWIgV29ya2VyIHN1cHBvcnRcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlV29ya2VyID0gbmV3IEltYWdlV29ya2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5faW1hZ2VXb3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlV29ya2VyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdmVLZXlIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUNsaWNrSGFuZGxlcigpO1xuICAgICAgICB0aGlzLl9yZW1vdmVIb3ZlckhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2Nyb2xsV2hlZWxIYW5kbGVyKCk7XG4gICAgfVxuXG4gICAgc3RhcnRMb29wKCkge1xuICAgICAgICB0aGlzLl9sb29waW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9hd2FpdGluZ0xvb3ApIHtcbiAgICAgICAgICAgIHRoaXMubG9vcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcExvb3AoKSB7XG4gICAgICAgIHRoaXMuX2xvb3BpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsb29wKCkge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBscCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fYXdhaXRpbmdMb29wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsZi5fbG9vcGluZykge1xuICAgICAgICAgICAgICAgIHNlbGYuc3RhZ2UuZHJhd0ZyYW1lKCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxwKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9hd2FpdGluZ0xvb3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShscCk7XG4gICAgfVxuXG4gICAgdXBsb2FkR2xUZXh0dXJlKGdsLCB0ZXh0dXJlU291cmNlLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8IHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgfHwgKHdpbmRvdy5JbWFnZUJpdG1hcCAmJiBzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkpIHtcbiAgICAgICAgICAgIC8vIFdlYi1zcGVjaWZpYyBkYXRhIHR5cGVzLlxuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBvcHRpb25zLmludGVybmFsRm9ybWF0LCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBzb21lIGJyb3dzZXJzIChlLmcuIFRpemVuKSBhcyB0aGV5IGRvIG5vdCBjb252ZXJ0IGNhbnZhcyBkYXRhIHRvIHRleHR1cmUgY29ycmVjdGx5LCBzb21ldGltZXMgY2F1c2luZyBhcnRpZmFjdHMuXG4gICAgICAgICAgICBjb25zdCBjdHggPSBzb3VyY2UuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCwgdGV4dHVyZVNvdXJjZS53LCB0ZXh0dXJlU291cmNlLmgsIDAsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2FkU3JjVGV4dHVyZSh7c3JjLCBoYXNBbHBoYX0sIGNiKSB7XG4gICAgICAgIGxldCBjYW5jZWxDYiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGlzUG5nID0gKHNyYy5pbmRleE9mKFwiLnBuZ1wiKSA+PSAwKSB8fCBzcmMuc3Vic3RyKDAsIDIxKSA9PSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0JztcbiAgICAgICAgaWYgKHRoaXMuX2ltYWdlV29ya2VyKSB7XG4gICAgICAgICAgICAvLyBXUEUtc3BlY2lmaWMgaW1hZ2UgcGFyc2VyLlxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLl9pbWFnZVdvcmtlci5jcmVhdGUoc3JjKTtcbiAgICAgICAgICAgIGltYWdlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoXCJJbWFnZSBsb2FkIGVycm9yXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlLm9uTG9hZCA9IGZ1bmN0aW9uKHtpbWFnZUJpdG1hcCwgaGFzQWxwaGFDaGFubmVsfSkge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBpbWFnZUJpdG1hcCxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVySW5mbzoge3NyYzogc3JjfSxcbiAgICAgICAgICAgICAgICAgICAgaGFzQWxwaGE6IGhhc0FscGhhQ2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbmNlbENiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICAgICAgLy8gT24gdGhlIFBTNCBwbGF0Zm9ybSBzZXR0aW5nIHRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBvblxuICAgICAgICAgICAgLy8gaW1hZ2VzIGNhbiBjYXVzZSBDT1JTIGZhaWx1cmVzLlxuICAgICAgICAgICAgaWYgKCEoc3JjLnN1YnN0cigwLDUpID09IFwiZGF0YTpcIikgJiYgIVV0aWxzLmlzUFM0KSB7XG4gICAgICAgICAgICAgICAgLy8gQmFzZTY0LlxuICAgICAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3IgbWVzc2FnZSB3aGVuIGNhbmNlbGxlZC5cbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2Uuc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihcIkltYWdlIGxvYWQgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVySW5mbzoge3NyYzogc3JjfSxcbiAgICAgICAgICAgICAgICAgICAgaGFzQWxwaGE6IGlzUG5nIHx8IGhhc0FscGhhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuXG4gICAgICAgICAgICBjYW5jZWxDYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaW1hZ2UucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYW5jZWxDYjtcbiAgICB9XG5cbiAgICBjcmVhdGVXZWJHTENvbnRleHQodywgaCkge1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5zdGFnZS5nZXRPcHRpb24oJ2NhbnZhcycpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgICAgIGlmICh3ICYmIGgpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHc7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvcHRzID0ge1xuICAgICAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRzKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0cyk7XG4gICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgd2ViR0wuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2w7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2FudmFzQ29udGV4dCh3LCBoKSB7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnN0YWdlLmdldE9wdGlvbignY2FudmFzJykgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAgICAgaWYgKHcgJiYgaCkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdztcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGMyZCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWMyZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCAyZCBjYW52YXMuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYzJkO1xuICAgIH1cblxuICAgIGdldEhyVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZSA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgZ2V0RHJhd2luZ0NhbnZhcygpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgcmV1c2UgdGhpcyBjYW52YXMgYmVjYXVzZSB0ZXh0dXJlcyBtYXkgbG9hZCBhc3luYy5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cblxuICAgIGdldFRleHR1cmVPcHRpb25zRm9yRHJhd2luZ0NhbnZhcyhjYW52YXMpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2UgPSBjYW52YXM7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIG5leHRGcmFtZShjaGFuZ2VzKSB7XG4gICAgICAgIC8qIFdlYkdMIGJsaXRzIGF1dG9tYXRpY2FsbHkgKi9cbiAgICB9XG5cbiAgICByZWdpc3RlcktleWRvd25IYW5kbGVyKGtleWhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fa2V5ZG93bkxpc3RlbmVyID0gKGUpID0+IHtcbiAgICAgICAgICAgIGtleWhhbmRsZXIoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICByZWdpc3RlcktleXVwSGFuZGxlcihrZXloYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2tleXVwTGlzdGVuZXIgPSAoZSkgPT4ge1xuICAgICAgICAgICAga2V5aGFuZGxlcihlKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fa2V5dXBMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgX3JlbW92ZUtleUhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9rZXlkb3duTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkxpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9rZXl1cExpc3RlbmVyKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9rZXl1cExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyQ2xpY2tIYW5kbGVyKGNsaWNrSGFuZGxlcikge1xuICAgICAgICB0aGlzLl9jbGlja0xpc3RlbmVyID0gZSA9PiB7XG4gICAgICAgICAgICBjbGlja0hhbmRsZXIoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9jbGlja0xpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlQ2xpY2tIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2NsaWNrTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJIb3ZlckhhbmRsZXIoaG92ZXJIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2hvdmVyTGlzdGVuZXIgPSBlID0+IHtcbiAgICAgICAgICAgIGhvdmVySGFuZGxlcihlKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hvdmVyTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIF9yZW1vdmVIb3ZlckhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ob3Zlckxpc3RlbmVyKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faG92ZXJMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3RlclNjcm9sbFdoZWVsSGFuZGxlcihyZWdpc3RlclNjcm9sbFdoZWVsSGFuZGxlcikge1xuICAgICAgICB0aGlzLl9zY3JvbGxXaGVlbExpc3RlbmVyID0gZSA9PiB7XG4gICAgICAgICAgICByZWdpc3RlclNjcm9sbFdoZWVsSGFuZGxlcihlKTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9zY3JvbGxXaGVlbExpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlU2Nyb2xsV2hlZWxIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsV2hlZWxMaXN0ZW5lcikge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fc2Nyb2xsV2hlZWxMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFNoYWRlciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnYyhhZ2dyZXNzaXZlKSB7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICB9XG5cbiAgICBnZXREZWZhdWx0U2hhZGVyKGN0eCA9IHRoaXMuc3RhZ2UuY3R4KSB7XG4gICAgICAgIGlmICghdGhpcy5fZGVmYXVsdFNoYWRlcikge1xuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFNoYWRlciA9IHRoaXMuX2NyZWF0ZURlZmF1bHRTaGFkZXIoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFNoYWRlcjtcbiAgICB9XG5cbiAgICBfY3JlYXRlRGVmYXVsdFNoYWRlcihjdHgpIHtcbiAgICB9XG5cbiAgICBpc1ZhbGlkU2hhZGVyVHlwZShzaGFkZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiAoc2hhZGVyVHlwZS5wcm90b3R5cGUgaW5zdGFuY2VvZiB0aGlzLl9nZXRTaGFkZXJCYXNlVHlwZSgpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVTaGFkZXIoY3R4LCBzZXR0aW5ncykge1xuICAgICAgICBjb25zdCBzaGFkZXJUeXBlID0gc2V0dGluZ3MudHlwZTtcbiAgICAgICAgLy8gSWYgc2hhZGVyIHR5cGUgaXMgbm90IGNvcnJlY3QsIHVzZSBhIGRpZmZlcmVudCBwbGF0Zm9ybS5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRTaGFkZXJUeXBlKHNoYWRlclR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRTaGFkZXJUeXBlID0gdGhpcy5fZ2V0U2hhZGVyQWx0ZXJuYXRpdmUoc2hhZGVyVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWNvbnZlcnRlZFNoYWRlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBTaGFkZXIgaGFzIG5vIGltcGxlbWVudGF0aW9uIGZvciByZW5kZXIgdGFyZ2V0OiBcIiArIHNoYWRlclR5cGUubmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZURlZmF1bHRTaGFkZXIoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgY29udmVydGVkU2hhZGVyVHlwZShjdHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IHNoYWRlclR5cGUoY3R4KTtcbiAgICAgICAgICAgIEJhc2UucGF0Y2hPYmplY3QodGhpcywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRTaGFkZXJCYXNlVHlwZSgpIHtcbiAgICB9XG5cbiAgICBfZ2V0U2hhZGVyQWx0ZXJuYXRpdmUoc2hhZGVyVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2hhZGVyKCk7XG4gICAgfVxuXG4gICAgY29weVJlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZSwgbmF0aXZlVGV4dHVyZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tMaWdodG5pbmddIGNvcHlSZW5kZXJUZXh0dXJlIG5vdCBzdXBwb3J0ZWQgYnkgcmVuZGVyZXInKTtcbiAgICB9XG59XG5cbmltcG9ydCBCYXNlIGZyb20gXCIuLi90cmVlL0Jhc2UubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29yZVF1YWRMaXN0IGZyb20gXCIuLi8uLi90cmVlL2NvcmUvQ29yZVF1YWRMaXN0Lm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDMmRDb3JlUXVhZExpc3QgZXh0ZW5kcyBDb3JlUXVhZExpc3Qge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJDb250ZXh0cyA9IFtdO1xuICAgICAgICB0aGlzLm1vZGVzID0gW107XG4gICAgfVxuXG4gICAgc2V0UmVuZGVyQ29udGV4dChpbmRleCwgdikge1xuICAgICAgICB0aGlzLnJlbmRlckNvbnRleHRzW2luZGV4XSA9IHY7XG4gICAgfVxuXG4gICAgc2V0U2ltcGxlVGMoaW5kZXgsIHYpIHtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZXNbaW5kZXhdIHw9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVzW2luZGV4XSAtPSAodGhpcy5tb2Rlc1tpbmRleF0gJiAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFdoaXRlKGluZGV4LCB2KSB7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVzW2luZGV4XSB8PSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2Rlc1tpbmRleF0gLT0gKHRoaXMubW9kZXNbaW5kZXhdICYgMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRSZW5kZXJDb250ZXh0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckNvbnRleHRzW2luZGV4XTtcbiAgICB9XG5cbiAgICBnZXRTaW1wbGVUYyhpbmRleCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubW9kZXNbaW5kZXhdICYgMSk7XG4gICAgfVxuXG4gICAgZ2V0V2hpdGUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGVzW2luZGV4XSAmIDIpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvcmVRdWFkT3BlcmF0aW9uIGZyb20gXCIuLi8uLi90cmVlL2NvcmUvQ29yZVF1YWRPcGVyYXRpb24ubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEMyZENvcmVRdWFkT3BlcmF0aW9uIGV4dGVuZHMgQ29yZVF1YWRPcGVyYXRpb24ge1xuXG4gICAgZ2V0UmVuZGVyQ29udGV4dChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkcy5nZXRSZW5kZXJDb250ZXh0KHRoaXMuaW5kZXggKyBpbmRleCk7XG4gICAgfVxuXG4gICAgZ2V0U2ltcGxlVGMoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHMuZ2V0U2ltcGxlVGModGhpcy5pbmRleCArIGluZGV4KTtcbiAgICB9XG5cbiAgICBnZXRXaGl0ZShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkcy5nZXRXaGl0ZSh0aGlzLmluZGV4ICsgaW5kZXgpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvcmVSZW5kZXJFeGVjdXRvciBmcm9tIFwiLi4vLi4vdHJlZS9jb3JlL0NvcmVSZW5kZXJFeGVjdXRvci5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi8uLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uLy4uL3RyZWUvVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEMyZENvcmVSZW5kZXJFeGVjdXRvciBleHRlbmRzIENvcmVSZW5kZXJFeGVjdXRvciB7XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLl9tYWluUmVuZGVyVGV4dHVyZSA9IHRoaXMuY3R4LnN0YWdlLmdldENhbnZhcygpO1xuICAgIH1cblxuICAgIF9yZW5kZXJRdWFkT3BlcmF0aW9uKG9wKSB7XG4gICAgICAgIGxldCBzaGFkZXIgPSBvcC5zaGFkZXI7XG5cbiAgICAgICAgaWYgKG9wLmxlbmd0aCB8fCBvcC5zaGFkZXIuYWRkRW1wdHkoKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fcmVuZGVyVGV4dHVyZSB8fCB0aGlzLl9tYWluUmVuZGVyVGV4dHVyZTtcbiAgICAgICAgICAgIHNoYWRlci5iZWZvcmVEcmF3KG9wLCB0YXJnZXQpO1xuICAgICAgICAgICAgc2hhZGVyLmRyYXcob3AsIHRhcmdldCk7XG4gICAgICAgICAgICBzaGFkZXIuYWZ0ZXJEcmF3KG9wLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NsZWFyUmVuZGVyVGV4dHVyZSgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0Q29udGV4dCgpO1xuXG4gICAgICAgIGxldCBjbGVhckNvbG9yID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBpZiAodGhpcy5fbWFpblJlbmRlclRleHR1cmUuY3R4ID09PSBjdHgpIHtcbiAgICAgICAgICAgIGNsZWFyQ29sb3IgPSB0aGlzLmN0eC5zdGFnZS5nZXRDbGVhckNvbG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZW5kZXJUZXh0dXJlID0gY3R4LmNhbnZhcztcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgaWYgKCFjbGVhckNvbG9yWzBdICYmICFjbGVhckNvbG9yWzFdICYmICFjbGVhckNvbG9yWzJdICYmICFjbGVhckNvbG9yWzNdKSB7XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHJlbmRlclRleHR1cmUud2lkdGgsIHJlbmRlclRleHR1cmUuaGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmdGcm9tQXJyYXkoY2xlYXJDb2xvcik7XG4gICAgICAgICAgICAvLyBEbyBub3QgdXNlIGZpbGxSZWN0IGJlY2F1c2UgaXQgcHJvZHVjZXMgYXJ0aWZhY3RzLlxuICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yZWN0KDAsIDAsIHJlbmRlclRleHR1cmUud2lkdGgsIHJlbmRlclRleHR1cmUuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBfZ2V0Q29udGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUZXh0dXJlLmN0eDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWluUmVuZGVyVGV4dHVyZS5jdHg7XG4gICAgICAgIH0gXG4gICAgfVxuXG4gICAgX3Jlc3RvcmVDb250ZXh0KCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRDb250ZXh0KCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5fc2Npc3NvciA9IG51bGw7XG4gICAgfVxuXG4gICAgX3NldFNjaXNzb3IoYXJlYSkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRDb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKCFDMmRDb3JlUmVuZGVyRXhlY3V0b3IuX2VxdWFsU2Npc3NvckFyZWFzKGN0eC5jYW52YXMsIGN0eC5fc2Npc3NvciwgYXJlYSkpIHtcbiAgICAgICAgICAgIC8vIENsaXBwaW5nIGlzIHN0b3JlZCBpbiB0aGUgY2FudmFzIGNvbnRleHQgc3RhdGUuXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCByZXNldCBjbGlwcGluZyBhbG9uZSBzbyB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIGZ1bGwgY29udGV4dC5cbiAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB0aGlzLmN0eC5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcbiAgICAgICAgICAgIGlmIChhcmVhKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KE1hdGgucm91bmQoYXJlYVswXSAqIHByZWNpc2lvbiksIE1hdGgucm91bmQoYXJlYVsxXSAqIHByZWNpc2lvbiksIE1hdGgucm91bmQoYXJlYVsyXSAqIHByZWNpc2lvbiksIE1hdGgucm91bmQoYXJlYVszXSAqIHByZWNpc2lvbikpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4Ll9zY2lzc29yID0gYXJlYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBfZXF1YWxTY2lzc29yQXJlYXMoY2FudmFzLCBhcmVhLCBjdXJyZW50KSB7XG4gICAgICAgIGlmICghYXJlYSkge1xuICAgICAgICAgICAgYXJlYSA9IFswLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRdXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gWzAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVXRpbHMuZXF1YWxWYWx1ZXMoYXJlYSwgY3VycmVudClcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDMmRDb3JlUXVhZExpc3QgZnJvbSBcIi4vQzJkQ29yZVF1YWRMaXN0Lm1qc1wiO1xuaW1wb3J0IEMyZENvcmVRdWFkT3BlcmF0aW9uIGZyb20gXCIuL0MyZENvcmVRdWFkT3BlcmF0aW9uLm1qc1wiO1xuaW1wb3J0IEMyZENvcmVSZW5kZXJFeGVjdXRvciBmcm9tIFwiLi9DMmRDb3JlUmVuZGVyRXhlY3V0b3IubWpzXCI7XG5pbXBvcnQgQ29yZVJlbmRlclN0YXRlIGZyb20gXCIuLi8uLi90cmVlL2NvcmUvQ29yZVJlbmRlclN0YXRlLm1qc1wiO1xuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vc2hhZGVycy9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IEMyZFNoYWRlciBmcm9tIFwiLi9DMmRTaGFkZXIubWpzXCI7XG5pbXBvcnQgUmVuZGVyZXIgZnJvbSBcIi4uL1JlbmRlcmVyLm1qc1wiO1xuaW1wb3J0IFRleHR1cmVUaW50TWFuYWdlciBmcm9tIFwiLi9DMmRUZXh0dXJlVGludE1hbmFnZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEMyZFJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuXG4gICAgICAgIHRoaXMudGludE1hbmFnZXIgPSBuZXcgVGV4dHVyZVRpbnRNYW5hZ2VyKHN0YWdlKTtcblxuICAgICAgICB0aGlzLnNldHVwQzJkKHRoaXMuc3RhZ2UuYzJkLmNhbnZhcyk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50aW50TWFuYWdlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZURlZmF1bHRTaGFkZXIoY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdFNoYWRlcihjdHgpO1xuICAgIH1cblxuICAgIF9nZXRTaGFkZXJCYXNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIEMyZFNoYWRlclxuICAgIH1cblxuICAgIF9nZXRTaGFkZXJBbHRlcm5hdGl2ZShzaGFkZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiBzaGFkZXJUeXBlLmdldEMyZCAmJiBzaGFkZXJUeXBlLmdldEMyZCgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvcmVRdWFkTGlzdChjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDMmRDb3JlUXVhZExpc3QoY3R4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVDb3JlUXVhZE9wZXJhdGlvbihjdHgsIHNoYWRlciwgc2hhZGVyT3duZXIsIHJlbmRlclRleHR1cmVJbmZvLCBzY2lzc29yLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEMyZENvcmVRdWFkT3BlcmF0aW9uKGN0eCwgc2hhZGVyLCBzaGFkZXJPd25lciwgcmVuZGVyVGV4dHVyZUluZm8sIHNjaXNzb3IsIGluZGV4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVDb3JlUmVuZGVyRXhlY3V0b3IoY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgQzJkQ29yZVJlbmRlckV4ZWN1dG9yKGN0eCk7XG4gICAgfVxuICAgIFxuICAgIGNyZWF0ZUNvcmVSZW5kZXJTdGF0ZShjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb3JlUmVuZGVyU3RhdGUoY3R4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVSZW5kZXJUZXh0dXJlKHcsIGgsIHB3LCBwaCkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gcHc7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBwaDtcbiAgICAgICAgdGhpcy5zZXR1cEMyZChjYW52YXMpO1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cbiAgICBcbiAgICBmcmVlUmVuZGVyVGV4dHVyZShuYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGludE1hbmFnZXIuZGVsZXRlKG5hdGl2ZVRleHR1cmUpO1xuICAgIH1cblxuICAgIGdjKGFnZ3Jlc3NpdmUpIHtcbiAgICAgICAgdGhpcy50aW50TWFuYWdlci5nYyhhZ2dyZXNzaXZlKTtcbiAgICB9XG5cbiAgICB1cGxvYWRUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRm9yIGNhbnZhcywgd2UgZG8gbm90IG5lZWQgdG8gdXBsb2FkLlxuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2UuYnVmZmVyKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IFJHQkEgYnVmZmVyIHRvIGNhbnZhcy5cbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gb3B0aW9ucy53O1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuaDtcblxuICAgICAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkob3B0aW9ucy5zb3VyY2UuYnVmZmVyKSwgb3B0aW9ucy53LCBvcHRpb25zLmgpO1xuICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc291cmNlO1xuICAgIH1cblxuICAgIGZyZWVUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgdGhpcy50aW50TWFuYWdlci5kZWxldGUodGV4dHVyZVNvdXJjZS5uYXRpdmVUZXh0dXJlKTtcbiAgICB9XG5cbiAgICBhZGRRdWFkKHJlbmRlclN0YXRlLCBxdWFkcywgaW5kZXgpIHtcbiAgICAgICAgLy8gUmVuZGVyIGNvbnRleHQgY2hhbmdlcyB3aGlsZSB0cmF2ZXJzaW5nIHNvIHdlIHNhdmUgaXQgYnkgcmVmLlxuICAgICAgICBjb25zdCBlbGVtZW50Q29yZSA9IHF1YWRzLnF1YWRFbGVtZW50c1tpbmRleF07XG4gICAgICAgIHF1YWRzLnNldFJlbmRlckNvbnRleHQoaW5kZXgsIGVsZW1lbnRDb3JlLl9yZW5kZXJDb250ZXh0KTtcbiAgICAgICAgcXVhZHMuc2V0V2hpdGUoaW5kZXgsIGVsZW1lbnRDb3JlLmlzV2hpdGUoKSk7XG4gICAgICAgIHF1YWRzLnNldFNpbXBsZVRjKGluZGV4LCBlbGVtZW50Q29yZS5oYXNTaW1wbGVUZXhDb29yZHMoKSk7XG4gICAgfVxuXG4gICAgaXNSZW5kZXJUZXh0dXJlUmV1c2FibGUocmVuZGVyU3RhdGUsIHJlbmRlclRleHR1cmVJbmZvKSB7XG4gICAgICAgIC8vIEB0b2RvOiBjaGVjayByZW5kZXIgY29vcmRzL21hdHJpeCwgbWF5YmUgbW92ZSB0aGlzIHRvIGNvcmU/XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmaW5pc2hSZW5kZXJTdGF0ZShyZW5kZXJTdGF0ZSkge1xuICAgIH1cblxuICAgIHNldHVwQzJkKGNhbnZhcykge1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY2FudmFzLmN0eCA9IGN0eDtcblxuICAgICAgICBjdHguX3NjaXNzb3IgPSBudWxsO1xuXG4gICAgICAgIC8vIFNhdmUgYmFzZSBzdGF0ZSBzbyB3ZSBjYW4gcmVzdG9yZSB0aGUgZGVmYXVsdHMgbGF0ZXIuXG4gICAgICAgIGNhbnZhcy5jdHguc2F2ZSgpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFNoYWRlciBmcm9tIFwiLi4vLi4vdHJlZS9TaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEMyZFNoYWRlciBleHRlbmRzIFNoYWRlciB7XG5cbiAgICBiZWZvcmVEcmF3KG9wZXJhdGlvbikge1xuICAgIH1cblxuICAgIGRyYXcob3BlcmF0aW9uKSB7XG4gICAgfVxuXG4gICAgYWZ0ZXJEcmF3KG9wZXJhdGlvbikge1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQzJkVGV4dHVyZVRpbnRNYW5hZ2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgICAgICAgdGhpcy5fdXNlZE1lbW9yeSA9IDA7XG4gICAgICAgIHRoaXMuX2NhY2hlZE5hdGl2ZVRleHR1cmVzID0gbmV3IFNldCgpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZ2ModHJ1ZSk7XG4gICAgfVxuXG4gICAgX2FkZE1lbW9yeVVzYWdlKGRlbHRhKSB7XG4gICAgICAgIHRoaXMuX3VzZWRNZW1vcnkgKz0gZGVsdGE7XG5cbiAgICAgICAgdGhpcy5zdGFnZS5hZGRNZW1vcnlVc2FnZShkZWx0YSk7XG4gICAgfVxuXG4gICAgZGVsZXRlKG5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgLy8gU2hvdWxkIGJlIGNhbGxlZCB3aGVuIG5hdGl2ZSB0ZXh0dXJlIGlzIGNsZWFuZWQgdXAuXG4gICAgICAgIGlmICh0aGlzLl9oYXNDYWNoZShuYXRpdmVUZXh0dXJlKSkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLl9nZXRDYWNoZShuYXRpdmVUZXh0dXJlKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZNZW1Vc2FnZSA9IGNhY2hlLm1lbW9yeVVzYWdlO1xuICAgICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZE5hdGl2ZVRleHR1cmVzLmRlbGV0ZShuYXRpdmVUZXh0dXJlKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lbW9yeVVzYWdlKGNhY2hlLm1lbW9yeVVzYWdlIC0gcHJldk1lbVVzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFRpbnRUZXh0dXJlKG5hdGl2ZVRleHR1cmUsIGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5zdGFnZS5mcmFtZUNvdW50ZXI7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkTmF0aXZlVGV4dHVyZXMuYWRkKG5hdGl2ZVRleHR1cmUpO1xuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fZ2V0Q2FjaGUobmF0aXZlVGV4dHVyZSk7XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IGNhY2hlLmdldChjb2xvcik7XG4gICAgICAgIGl0ZW0ubGYgPSBmcmFtZTtcblxuICAgICAgICBpZiAoaXRlbS50eCkge1xuICAgICAgICAgICAgaWYgKG5hdGl2ZVRleHR1cmUudXBkYXRlID4gaXRlbS51KSB7XG4gICAgICAgICAgICAgICAgLy8gTmF0aXZlIHRleHR1cmUgd2FzIHVwZGF0ZWQgaW4gdGhlIG1lYW4gdGltZTogcmVuZXcuXG4gICAgICAgICAgICAgICAgdGhpcy5fdGludFRleHR1cmUoaXRlbS50eCwgbmF0aXZlVGV4dHVyZSwgY29sb3IpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtLnR4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gY2FjaGUubWVtb3J5VXNhZ2U7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgYmxhbmNvIHRpbnQgdGV4dHVyZS5cbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBjYWNoZS5yZXVzZVRleHR1cmUoZnJhbWUpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5jdHguY2xlYXJSZWN0KDAsIDAsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFsbG9jYXRlIG5ldy5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQud2lkdGggPSBuYXRpdmVUZXh0dXJlLnc7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmhlaWdodCA9IG5hdGl2ZVRleHR1cmUuaDtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY3R4ID0gdGFyZ2V0LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RpbnRUZXh0dXJlKHRhcmdldCwgbmF0aXZlVGV4dHVyZSwgY29sb3IpO1xuICAgICAgICAgICAgY2FjaGUuc2V0KGNvbG9yLCB0YXJnZXQsIGZyYW1lKTtcblxuICAgICAgICAgICAgY29uc3QgYWZ0ZXIgPSBjYWNoZS5tZW1vcnlVc2FnZTtcblxuICAgICAgICAgICAgaWYgKGFmdGVyICE9PSBiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZW1vcnlVc2FnZShhZnRlciAtIGJlZm9yZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdGludFRleHR1cmUodGFyZ2V0LCBzb3VyY2UsIGNvbG9yKSB7XG4gICAgICAgIGxldCBjb2wgPSBjb2xvci50b1N0cmluZygxNik7XG4gICAgICAgIHdoaWxlIChjb2wubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgY29sID0gXCIwXCIgKyBjb2w7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmN0eC5maWxsU3R5bGUgPSAnIycgKyBjb2w7XG4gICAgICAgIHRhcmdldC5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICB0YXJnZXQuY3R4LmZpbGxSZWN0KDAsIDAsIHNvdXJjZS53LCBzb3VyY2UuaCk7XG4gICAgICAgIHRhcmdldC5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ211bHRpcGx5JztcbiAgICAgICAgdGFyZ2V0LmN0eC5kcmF3SW1hZ2Uoc291cmNlLCAwLCAwLCBzb3VyY2Uudywgc291cmNlLmgsIDAsIDAsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodCk7XG5cbiAgICAgICAgLy8gQWxwaGEtbWl4IHRoZSB0ZXh0dXJlLlxuICAgICAgICB0YXJnZXQuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgICAgIHRhcmdldC5jdHguZHJhd0ltYWdlKHNvdXJjZSwgMCwgMCwgc291cmNlLncsIHNvdXJjZS5oLCAwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQpO1xuICAgIH1cblxuICAgIF9oYXNDYWNoZShuYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgIHJldHVybiAhIW5hdGl2ZVRleHR1cmUuX3RpbnRDYWNoZTtcbiAgICB9XG5cbiAgICBfZ2V0Q2FjaGUobmF0aXZlVGV4dHVyZSkge1xuICAgICAgICBpZiAoIW5hdGl2ZVRleHR1cmUuX3RpbnRDYWNoZSkge1xuICAgICAgICAgICAgbmF0aXZlVGV4dHVyZS5fdGludENhY2hlID0gbmV3IEMyZFRpbnRDYWNoZShuYXRpdmVUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlVGV4dHVyZS5fdGludENhY2hlO1xuICAgIH1cblxuICAgIGdjKGFnZ3Jlc3NpdmUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuc3RhZ2UuZnJhbWVDb3VudGVyO1xuICAgICAgICBsZXQgZGVsdGEgPSAwO1xuICAgICAgICB0aGlzLl9jYWNoZWROYXRpdmVUZXh0dXJlcy5mb3JFYWNoKHRleHR1cmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLl9nZXRDYWNoZSh0ZXh0dXJlKTtcbiAgICAgICAgICAgIGlmIChhZ2dyZXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgKz0gY2FjaGUubWVtb3J5VXNhZ2U7XG4gICAgICAgICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gY2FjaGUubWVtb3J5VXNhZ2U7XG4gICAgICAgICAgICAgICAgY2FjaGUuY2xlYW51cChmcmFtZSk7XG4gICAgICAgICAgICAgICAgY2FjaGUucmVsZWFzZUJsYW5jb1RleHR1cmVzKCk7XG4gICAgICAgICAgICAgICAgZGVsdGEgKz0gKGNhY2hlLm1lbW9yeVVzYWdlIC0gYmVmb3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGFnZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZE5hdGl2ZVRleHR1cmVzLmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lbW9yeVVzYWdlKGRlbHRhKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5jbGFzcyBDMmRUaW50Q2FjaGUge1xuXG4gICAgY29uc3RydWN0b3IobmF0aXZlVGV4dHVyZSkge1xuICAgICAgICB0aGlzLl90eCA9IG5hdGl2ZVRleHR1cmU7XG4gICAgICAgIHRoaXMuX2NvbG9ycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYmxhbmNvVGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0Q2xlYW51cEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5fbWVtVGV4dHVyZXMgPSAwO1xuICAgIH1cblxuICAgIGdldCBtZW1vcnlVc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lbVRleHR1cmVzICogdGhpcy5fdHgudyAqIHRoaXMuX3R4Lmg7XG4gICAgfVxuXG4gICAgcmVsZWFzZUJsYW5jb1RleHR1cmVzKCkge1xuICAgICAgICB0aGlzLl9tZW1UZXh0dXJlcyAtPSB0aGlzLl9ibGFuY29UZXh0dXJlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2JsYW5jb1RleHR1cmVzID0gW107XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIC8vIERlcmVmZXJlbmNlIHRoZSB0ZXh0dXJlcy5cbiAgICAgICAgdGhpcy5fYmxhbmNvVGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jb2xvcnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbWVtVGV4dHVyZXMgPSAwO1xuICAgIH1cblxuICAgIGdldChjb2xvcikge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX2NvbG9ycy5nZXQoY29sb3IpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSB7bGY6IC0xLCB0eDogdW5kZWZpbmVkLCB1OiAtMX07XG4gICAgICAgICAgICB0aGlzLl9jb2xvcnMuc2V0KGNvbG9yLCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBzZXQoY29sb3IsIHRleHR1cmUsIGZyYW1lKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldChjb2xvcik7XG4gICAgICAgIGl0ZW0ubGYgPSBmcmFtZTtcbiAgICAgICAgaXRlbS50eCA9IHRleHR1cmU7XG4gICAgICAgIGl0ZW0udSA9IGZyYW1lO1xuICAgICAgICB0aGlzLl9tZW1UZXh0dXJlcysrO1xuICAgIH1cblxuICAgIGNsZWFudXAoZnJhbWUpIHtcbiAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIGNsZWFuIHVwIG9uY2UgcGVyIGZyYW1lLlxuICAgICAgICBpZiAodGhpcy5fbGFzdENsZWFudXBGcmFtZSAhPT0gZnJhbWUpIHtcblxuICAgICAgICAgICAgLy8gV2UgbGltaXQgYmxhbmNvIHRleHR1cmVzIHJldXNlIHRvIG9uZSBmcmFtZSBvbmx5IHRvIHByZXZlbnQgbWVtb3J5IHVzYWdlIGdyb3d0aC5cbiAgICAgICAgICAgIHRoaXMuX2JsYW5jb1RleHR1cmVzID0gW107XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbG9ycy5mb3JFYWNoKChpdGVtLCBjb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGVudHJpZXMgdGhhdCB3ZXJlIG5vdCB1c2VkIGxhc3QgZnJhbWUuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ubGYgPCBmcmFtZSAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgYXMgcmV1c2FibGUgYmxhbmNvIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibGFuY29UZXh0dXJlcy5wdXNoKGl0ZW0udHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9ycy5kZWxldGUoY29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9sYXN0Q2xlYW51cEZyYW1lID0gZnJhbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXVzZVRleHR1cmUoZnJhbWUpIHtcbiAgICAgICAgLy8gVHJ5IHRvIHJldXNlIHRleHR1cmVzLCBiZWNhdXNlIGNyZWF0aW5nIHRoZW0gZXZlcnkgZnJhbWUgaXMgZXhwZW5zaXZlLlxuICAgICAgICB0aGlzLmNsZWFudXAoZnJhbWUpO1xuICAgICAgICBpZiAodGhpcy5fYmxhbmNvVGV4dHVyZXMgJiYgdGhpcy5fYmxhbmNvVGV4dHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9tZW1UZXh0dXJlcy0tO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JsYW5jb1RleHR1cmVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsdXJTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX2tlcm5lbFJhZGl1cyA9IDE7XG4gICAgfVxuXG4gICAgZ2V0IGtlcm5lbFJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tlcm5lbFJhZGl1cztcbiAgICB9XG5cbiAgICBzZXQga2VybmVsUmFkaXVzKHYpIHtcbiAgICAgICAgdGhpcy5fa2VybmVsUmFkaXVzID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50ID09PSAwO1xuICAgIH1cblxuICAgIF9iZWZvcmVEcmF3RWwoe3RhcmdldH0pIHtcbiAgICAgICAgdGFyZ2V0LmN0eC5maWx0ZXIgPSBcImJsdXIoXCIgKyB0aGlzLl9rZXJuZWxSYWRpdXMgKyBcInB4KVwiO1xuICAgIH1cblxuICAgIF9hZnRlckRyYXdFbCh7dGFyZ2V0fSkge1xuICAgICAgICB0YXJnZXQuY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cblxufVxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQzJkU2hhZGVyIGZyb20gXCIuLi9DMmRTaGFkZXIubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vLi4vLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZhdWx0U2hhZGVyIGV4dGVuZHMgQzJkU2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuICAgICAgICB0aGlzLl9yZWN0YW5nbGVUZXh0dXJlID0gY3R4LnN0YWdlLnJlY3RhbmdsZVRleHR1cmUuc291cmNlLm5hdGl2ZVRleHR1cmU7XG4gICAgICAgIHRoaXMuX3RpbnRNYW5hZ2VyID0gdGhpcy5jdHguc3RhZ2UucmVuZGVyZXIudGludE1hbmFnZXI7XG4gICAgfVxuXG4gICAgZHJhdyhvcGVyYXRpb24sIHRhcmdldCkge1xuICAgICAgICBjb25zdCBjdHggPSB0YXJnZXQuY3R4O1xuICAgICAgICBsZXQgbGVuZ3RoID0gb3BlcmF0aW9uLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdHggPSBvcGVyYXRpb24uZ2V0VGV4dHVyZShpKTtcbiAgICAgICAgICAgIGNvbnN0IHZjID0gb3BlcmF0aW9uLmdldEVsZW1lbnRDb3JlKGkpO1xuICAgICAgICAgICAgY29uc3QgcmMgPSBvcGVyYXRpb24uZ2V0UmVuZGVyQ29udGV4dChpKTtcbiAgICAgICAgICAgIGNvbnN0IHdoaXRlID0gb3BlcmF0aW9uLmdldFdoaXRlKGkpO1xuICAgICAgICAgICAgY29uc3Qgc3RjID0gb3BlcmF0aW9uLmdldFNpbXBsZVRjKGkpO1xuXG4gICAgICAgICAgICAvL0B0b2RvOiB0cnkgdG8gb3B0aW1pemUgb3V0IHBlci1kcmF3IHRyYW5zZm9ybSBzZXR0aW5nLiBzcGxpdCB0cmFuc2xhdGUsIHRyYW5zZm9ybS5cbiAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuY3R4LnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybShyYy50YSAqIHByZWNpc2lvbiwgcmMudGMgKiBwcmVjaXNpb24sIHJjLnRiICogcHJlY2lzaW9uLCByYy50ZCAqIHByZWNpc2lvbiwgcmMucHggKiBwcmVjaXNpb24sIHJjLnB5ICogcHJlY2lzaW9uKTtcblxuICAgICAgICAgICAgY29uc3QgcmVjdCA9ICh0eCA9PT0gdGhpcy5fcmVjdGFuZ2xlVGV4dHVyZSk7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0ge29wZXJhdGlvbiwgdGFyZ2V0LCBpbmRleDogaSwgcmVjdH07XG5cbiAgICAgICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGdyYWRpZW50LlxuICAgICAgICAgICAgICAgIGlmICh3aGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb2xvckdyYWRpZW50KGN0eCwgdmMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHJjLmFscGhhO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZURyYXdFbChpbmZvKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdmMudywgdmMuaCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWZ0ZXJEcmF3RWwoaW5mbyk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAdG9kbzogc2V0IGltYWdlIHNtb290aGluZyBiYXNlZCBvbiB0aGUgdGV4dHVyZS5cblxuICAgICAgICAgICAgICAgIC8vIEB0b2RvOiBvcHRpbWl6ZSBieSByZWdpc3RlcmluZyB3aGV0aGVyIGlkZW50aXR5IHRleGNvb3JkcyBhcmUgdXNlZC5cbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSByYy5hbHBoYTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVEcmF3RWwoaW5mbyk7XG5cbiAgICAgICAgICAgICAgICAvLyBAdG9kbzogdGVzdCBpZiByb3VuZGluZyB5aWVsZHMgYmV0dGVyIHBlcmZvcm1hbmNlLlxuXG4gICAgICAgICAgICAgICAgLy8gTm90aWNlIHRoYXQgc2ltcGxlIHRleHR1cmUgY29vcmRzIGNhbiBiZSB0dXJuZWQgb24gZXZlbiB0aG91Z2ggdmMuX3VseCBldGMgYXJlIG5vdCBzaW1wbGUsIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyAgd2UgYXJlIHJlbmRlcmluZyBhIHJlbmRlci10by10ZXh0dXJlICh0ZXhjb29yZHMgd2VyZSBzdGFzaGVkKS4gU2FtZSBpcyB0cnVlIGZvciAnd2hpdGUnIGNvbG9yIGJ0dy5cbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VYID0gc3RjID8gMCA6ICh2Yy5fdWx4ICogdHgudyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlWSA9IHN0YyA/IDAgOiAodmMuX3VseSAqIHR4LmgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVcgPSAoc3RjID8gMSA6ICh2Yy5fYnJ4IC0gdmMuX3VseCkpICogdHgudztcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VIID0gKHN0YyA/IDEgOiAodmMuX2JyeSAtIHZjLl91bHkpKSAqIHR4Lmg7XG5cbiAgICAgICAgICAgICAgICBsZXQgY29sb3JpemUgPSAhd2hpdGU7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvOiBjYWNoZSB0aGUgdGludCB0ZXh0dXJlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRHJhdyB0byBpbnRlcm1lZGlhdGUgdGV4dHVyZSB3aXRoIGJhY2tncm91bmQgY29sb3IvZ3JhZGllbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgdXMgZnJvbSBoYXZpbmcgdG8gY3JlYXRlIGEgbG90IG9mIHJlbmRlciB0ZXh0dXJlIGNhbnZhc2VzLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGljZSB0aGF0IHdlIGRvbid0IHN1cHBvcnQgKG5vbi1yZWN0KSBncmFkaWVudHMsIG9ubHkgY29sb3IgdGludGluZyBmb3IgYzJkLiBXZSdsbCBqdXN0IHRha2UgdGhlIGF2ZXJhZ2UgY29sb3IuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IHZjLl9jb2xvclVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmMuX2NvbG9yVWwgIT09IHZjLl9jb2xvclVyIHx8IHZjLl9jb2xvclVyICE9PSB2Yy5fY29sb3JCbCB8fCB2Yy5fY29sb3JCciAhPT0gdmMuX2NvbG9yQmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gU3RhZ2VVdGlscy5tZXJnZU11bHRpQ29sb3JzRXF1YWwoW3ZjLl9jb2xvclVsLCB2Yy5fY29sb3JVciwgdmMuX2NvbG9yQmwsIHZjLl9jb2xvckJyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHBoYSA9ICgoY29sb3IgLyAxNjc3NzIxNikgfCAwKSAvIDI1NS4wO1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gYWxwaGE7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmdiID0gY29sb3IgJiAweDAwRkZGRkZGO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW50VGV4dHVyZSA9IHRoaXMuX3RpbnRNYW5hZ2VyLmdldFRpbnRUZXh0dXJlKHR4LCByZ2IpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5IGRyYXcgcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aW50VGV4dHVyZSwgc291cmNlWCwgc291cmNlWSwgc291cmNlVywgc291cmNlSCwgMCwgMCwgdmMudywgdmMuaCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodHgsIHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVcsIHNvdXJjZUgsIDAsIDAsIHZjLncsIHZjLmgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hZnRlckRyYXdFbChpbmZvKTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0Q29sb3JHcmFkaWVudChjdHgsIHZjLCB3ID0gdmMudywgaCA9IHZjLmgsIHRyYW5zcGFyZW5jeSA9IHRydWUpIHtcbiAgICAgICAgbGV0IGNvbG9yID0gdmMuX2NvbG9yVWw7XG4gICAgICAgIGxldCBncmFkaWVudDtcbiAgICAgICAgLy9AdG9kbzogcXVpY2sgc2luZ2xlIGNvbG9yIGNoZWNrLlxuICAgICAgICAvL0B0b2RvOiBjYWNoZSBncmFkaWVudC9maWxsIHN0eWxlIChpZiBwb3NzaWJsZSwgcHJvYmFibHkgY29udGV4dC1zcGVjaWZpYykuXG5cbiAgICAgICAgaWYgKHZjLl9jb2xvclVsID09PSB2Yy5fY29sb3JVcikge1xuICAgICAgICAgICAgaWYgKHZjLl9jb2xvckJsID09PSB2Yy5fY29sb3JCcikge1xuICAgICAgICAgICAgICAgIGlmICh2Yy5fY29sb3JVbCA9PT0gdmMuY29sb3JCbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUgY29sb3IuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmVydGljYWwgZ3JhZGllbnQuXG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNwYXJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHZjLl9jb2xvclVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHZjLl9jb2xvckJsKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgU3RhZ2VVdGlscy5nZXRSZ2JTdHJpbmcodmMuX2NvbG9yVWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBTdGFnZVV0aWxzLmdldFJnYlN0cmluZyh2Yy5fY29sb3JCbCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBzdXBwb3J0ZWQgZ3JhZGllbnQuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmMuX2NvbG9yVWwgPT09IHZjLl9jb2xvckJsICYmIHZjLl9jb2xvclVyID09PSB2Yy5fY29sb3JCcikge1xuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgZ3JhZGllbnQuXG4gICAgICAgICAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgdywgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zcGFyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHZjLl9jb2xvclVsKSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcodmMuX2NvbG9yQnIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgU3RhZ2VVdGlscy5nZXRSZ2JTdHJpbmcodmMuX2NvbG9yVWwpKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFN0YWdlVXRpbHMuZ2V0UmdiU3RyaW5nKHZjLl9jb2xvckJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyYWRpZW50KSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdHJhbnNwYXJlbmN5ID8gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKGNvbG9yKSA6IFN0YWdlVXRpbHMuZ2V0UmdiU3RyaW5nKGNvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9iZWZvcmVEcmF3RWwoaW5mbykge1xuICAgIH1cblxuICAgIF9hZnRlckRyYXdFbChpbmZvKSB7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQzJkRGVmYXVsdFNoYWRlciBmcm9tIFwiLi4vLi4vYzJkL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanNcIjtcbmltcG9ydCBXZWJHTERlZmF1bHRTaGFkZXIgZnJvbSBcIi4uLy4uL3dlYmdsL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGNsYXNzIFdlYkdMR3JheXNjYWxlU2hhZGVyIGV4dGVuZHMgV2ViR0xEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IDE7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEMyZCgpIHtcbiAgICAgICAgcmV0dXJuIEMyZEdyYXlzY2FsZVNoYWRlcjtcbiAgICB9XG5cblxuICAgIHNldCBhbW91bnQodikge1xuICAgICAgICB0aGlzLl9hbW91bnQgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBhbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQ7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudCA9PT0gMDtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJhbW91bnRcIiwgdGhpcy5fYW1vdW50LCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgfVxuXG59XG5cbldlYkdMR3JheXNjYWxlU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSBmbG9hdCBhbW91bnQ7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcbiAgICAgICAgZmxvYXQgZ3JheW5lc3MgPSAwLjIgKiBjb2xvci5yICsgMC42ICogY29sb3IuZyArIDAuMiAqIGNvbG9yLmI7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYW1vdW50ICogdmVjMyhncmF5bmVzcywgZ3JheW5lc3MsIGdyYXluZXNzKSArICgxLjAgLSBhbW91bnQpICogY29sb3IucmdiLCBjb2xvci5hKTtcbiAgICB9XG5gO1xuXG5leHBvcnQgY2xhc3MgQzJkR3JheXNjYWxlU2hhZGVyIGV4dGVuZHMgQzJkRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9hbW91bnQgPSAxO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRXZWJHTCgpIHtcbiAgICAgICAgcmV0dXJuIFdlYkdMR3JheXNjYWxlU2hhZGVyO1xuICAgIH1cblxuXG4gICAgc2V0IGFtb3VudCh2KSB7XG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudDtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50ID09PSAwO1xuICAgIH1cblxuICAgIF9iZWZvcmVEcmF3RWwoe3RhcmdldH0pIHtcbiAgICAgICAgdGFyZ2V0LmN0eC5maWx0ZXIgPSBcImdyYXlzY2FsZShcIiArIHRoaXMuX2Ftb3VudCArIFwiKVwiO1xuICAgIH1cblxuICAgIF9hZnRlckRyYXdFbCh7dGFyZ2V0fSkge1xuICAgICAgICB0YXJnZXQuY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSBcIi4uL3dlYmdsL1dlYkdMUmVuZGVyZXIubWpzXCI7XG5pbXBvcnQgU3BhcmtTaGFkZXIgZnJvbSBcIi4vc2hhZGVycy9TcGFya1NoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BhcmtSZW5kZXJlciBleHRlbmRzIFdlYkdMUmVuZGVyZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuICAgIH1cblxuICAgIF9jcmVhdGVEZWZhdWx0U2hhZGVyKGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IFNwYXJrU2hhZGVyKGN0eCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ29yZVJlbmRlckV4ZWN1dG9yKGN0eCkge1xuICAgICAgICBnbG9iYWwuYmVnaW5EcmF3aW5nKCk7XG4gICAgICAgIGxldCByZXQgPSBzdXBlci5jcmVhdGVDb3JlUmVuZGVyRXhlY3V0b3IoY3R4KTtcbiAgICAgICAgZ2xvYmFsLmVuZERyYXdpbmcoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgV2ViR0xTaGFkZXIgZnJvbSBcIi4uLy4uL3dlYmdsL1dlYkdMU2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGFya1NoYWRlciBleHRlbmRzIFdlYkdMU2hhZGVyIHtcblxuICAgIGVuYWJsZUF0dHJpYnMoKSB7XG4gICAgICAgIC8vIEVuYWJsZXMgdGhlIGF0dHJpYnMgaW4gdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYihcImFWZXJ0ZXhQb3NpdGlvblwiKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgMCk7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFWZXJ0ZXhQb3NpdGlvblwiKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYihcImFUZXh0dXJlQ29vcmRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYihcImFUZXh0dXJlQ29vcmRcIiksIDIsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDIgKiA0KTtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFUZXh0dXJlQ29vcmRcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYihcImFDb2xvclwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgc2hhZGVycyBtYXkgaWdub3JlIHRoZSBjb2xvci5cbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliKFwiYUNvbG9yXCIpLCA0LCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCAyMCwgNCAqIDQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYUNvbG9yXCIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2FibGVBdHRyaWJzKCkge1xuICAgICAgICAvLyBEaXNhYmxlcyB0aGUgYXR0cmlicyBpbiB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhVmVydGV4UG9zaXRpb25cIikpO1xuXG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZUNvb3JkXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFUZXh0dXJlQ29vcmRcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYihcImFDb2xvclwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhQ29sb3JcIikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInByb2plY3Rpb25cIiwgdGhpcy5fZ2V0UHJvamVjdGlvbihvcGVyYXRpb24pLCB0aGlzLmdsLnVuaWZvcm0yZnYsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBkcmF3KG9wZXJhdGlvbikge1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSBvcGVyYXRpb24ubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBnbFRleHR1cmUgPSBvcGVyYXRpb24uZ2V0VGV4dHVyZSgwKTtcbiAgICAgICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB0eCA9IG9wZXJhdGlvbi5nZXRUZXh0dXJlKGkpO1xuICAgICAgICAgICAgICAgIGlmIChnbFRleHR1cmUgIT09IHR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbFRleHR1cmUub3B0aW9ucyAmJiBnbFRleHR1cmUub3B0aW9ucy5pbWFnZVJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnRQb3N0aW9uID0gKGkgPiAwKSA/IChpIC0gMSkgOiBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5jdHguc3RhZ2UuZ2V0T3B0aW9uKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YyA9IG9wZXJhdGlvbi5nZXRFbGVtZW50Q29yZShlbGVtZW50UG9zdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5zdGFnZS5wbGF0Zm9ybS5wYWludChnbCwgZ2xUZXh0dXJlLm9wdGlvbnMuaW1hZ2VSZWYsIHZjLl93b3JsZENvbnRleHQucHgqcHJlY2lzaW9uLCB2Yy5fd29ybGRDb250ZXh0LnB5KnByZWNpc2lvbiwgdmMuX2NvbG9yVWwsIHZjKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2ICogKGkgLSBwb3MpLCBnbC5VTlNJR05FRF9TSE9SVCwgKHBvcyArIG9wZXJhdGlvbi5pbmRleCkgKiA2ICogMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2xUZXh0dXJlID0gdHg7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChnbFRleHR1cmUub3B0aW9ucyAmJiBnbFRleHR1cmUub3B0aW9ucy5pbWFnZVJlZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLmN0eC5zdGFnZS5nZXRPcHRpb24oJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmMgPSBvcGVyYXRpb24uZ2V0RWxlbWVudENvcmUocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguc3RhZ2UucGxhdGZvcm0ucGFpbnQoZ2wsIGdsVGV4dHVyZS5vcHRpb25zLmltYWdlUmVmLCB2Yy5fd29ybGRDb250ZXh0LnB4KnByZWNpc2lvbiwgdmMuX3dvcmxkQ29udGV4dC5weSpwcmVjaXNpb24sIHZjLl9jb2xvclVsLCB2Yyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiAqIChsZW5ndGggLSBwb3MpLCBnbC5VTlNJR05FRF9TSE9SVCwgKHBvcyArIG9wZXJhdGlvbi5pbmRleCkgKiA2ICogMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cblNwYXJrU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4UG9zaXRpb24ueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgYVZlcnRleFBvc2l0aW9uLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgIH1cbmA7XG5cblNwYXJrU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yO1xuICAgIH1cbmA7XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb3JlUXVhZExpc3QgZnJvbSBcIi4uLy4uL3RyZWUvY29yZS9Db3JlUXVhZExpc3QubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMQ29yZVF1YWRMaXN0IGV4dGVuZHMgQ29yZVF1YWRMaXN0IHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuXG4gICAgICAgIC8vIEFsbG9jYXRlIGEgZmFpcmx5IGJpZyBjaHVuayBvZiBtZW1vcnkgdGhhdCBzaG91bGQgYmUgZW5vdWdoIHRvIHN1cHBvcnQgfjEwMDAwMCAoZGVmYXVsdCkgcXVhZHMuXG4gICAgICAgIC8vIFdlIGRvIG5vdCAod2FudCB0bykgaGFuZGxlIG1lbW9yeSBvdmVyZmxvdy5cbiAgICAgICAgY29uc3QgYnl0ZVNpemUgPSBjdHguc3RhZ2UuZ2V0T3B0aW9uKCdidWZmZXJNZW1vcnknKTtcblxuICAgICAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU2l6ZSk7XG4gICAgICAgIHRoaXMuZmxvYXRzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRhdGEpO1xuICAgICAgICB0aGlzLnVpbnRzID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgZ2V0QXR0cmlic0RhdGFCeXRlT2Zmc2V0KGluZGV4KSB7XG4gICAgICAgIC8vIFdoZXJlIHRoaXMgcXVhZCBjYW4gYmUgZm91bmQgaW4gdGhlIGF0dHJpYnMgYnVmZmVyLlxuICAgICAgICByZXR1cm4gaW5kZXggKiA4MDtcbiAgICB9XG5cbiAgICBnZXRRdWFkQ29udGVudHMoKSB7XG4gICAgICAgIC8vIERlYnVnOiBsb2cgY29udGVudHMgb2YgcXVhZCBidWZmZXIuXG4gICAgICAgIGxldCBmbG9hdHMgPSB0aGlzLmZsb2F0cztcbiAgICAgICAgbGV0IHVpbnRzID0gdGhpcy51aW50cztcbiAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSAnZW50cnkgJyArIGkgKyAnOiAnO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYiA9IGkgKiAyMCArIGogKiA0O1xuICAgICAgICAgICAgICAgIHN0ciArPSBmbG9hdHNbYl0gKyAnLCcgKyBmbG9hdHNbYisxXSArICc6JyArIGZsb2F0c1tiKzJdICsgJywnICsgZmxvYXRzW2IrM10gKyAnWycgKyB1aW50c1tiKzRdLnRvU3RyaW5nKDE2KSArICddICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lcy5wdXNoKHN0cik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuXG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb3JlUXVhZE9wZXJhdGlvbiBmcm9tIFwiLi4vLi4vdHJlZS9jb3JlL0NvcmVRdWFkT3BlcmF0aW9uLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTENvcmVRdWFkT3BlcmF0aW9uIGV4dGVuZHMgQ29yZVF1YWRPcGVyYXRpb24ge1xuXG4gICAgY29uc3RydWN0b3IoY3R4LCBzaGFkZXIsIHNoYWRlck93bmVyLCByZW5kZXJUZXh0dXJlSW5mbywgc2Npc3NvciwgaW5kZXgpIHtcbiAgICAgICAgc3VwZXIoY3R4LCBzaGFkZXIsIHNoYWRlck93bmVyLCByZW5kZXJUZXh0dXJlSW5mbywgc2Npc3NvciwgaW5kZXgpO1xuXG4gICAgICAgIHRoaXMuZXh0cmFBdHRyaWJzRGF0YUJ5dGVPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGdldEF0dHJpYnNEYXRhQnl0ZU9mZnNldChpbmRleCkge1xuICAgICAgICAvLyBXaGVyZSB0aGlzIHF1YWQgY2FuIGJlIGZvdW5kIGluIHRoZSBhdHRyaWJzIGJ1ZmZlci5cbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHMuZ2V0QXR0cmlic0RhdGFCeXRlT2Zmc2V0KHRoaXMuaW5kZXggKyBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVsYXRpdmUgcGl4ZWwgY29vcmRpbmF0ZXMgaW4gdGhlIHNoYWRlciBvd25lciB0byBnbCBwb3NpdGlvbiBjb29yZGluYXRlcyBpbiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm4ge251bWJlcltdfVxuICAgICAqL1xuICAgIGdldE5vcm1hbFJlbmRlclRleHR1cmVDb29yZHMoeCwgeSkge1xuICAgICAgICBsZXQgY29vcmRzID0gdGhpcy5zaGFkZXJPd25lci5nZXRSZW5kZXJUZXh0dXJlQ29vcmRzKHgsIHkpO1xuICAgICAgICBjb29yZHNbMF0gLz0gdGhpcy5nZXRSZW5kZXJXaWR0aCgpO1xuICAgICAgICBjb29yZHNbMV0gLz0gdGhpcy5nZXRSZW5kZXJIZWlnaHQoKTtcbiAgICAgICAgY29vcmRzWzBdID0gY29vcmRzWzBdICogMiAtIDE7XG4gICAgICAgIGNvb3Jkc1sxXSA9IDEgLSBjb29yZHNbMV0gKiAyO1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgIH1cblxuICAgIGdldFByb2plY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlclRleHR1cmVJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHgucmVuZGVyRXhlYy5fcHJvamVjdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclRleHR1cmVJbmZvLm5hdGl2ZVRleHR1cmUucHJvamVjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvcmVSZW5kZXJFeGVjdXRvciBmcm9tIFwiLi4vLi4vdHJlZS9jb3JlL0NvcmVSZW5kZXJFeGVjdXRvci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xDb3JlUmVuZGVyRXhlY3V0b3IgZXh0ZW5kcyBDb3JlUmVuZGVyRXhlY3V0b3Ige1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eClcblxuICAgICAgICB0aGlzLmdsID0gdGhpcy5jdHguc3RhZ2UuZ2w7XG5cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcblxuICAgICAgICAvLyBDcmVhdGUgbmV3IHNoYXJhYmxlIGJ1ZmZlciBmb3IgcGFyYW1zLlxuICAgICAgICB0aGlzLl9hdHRyaWJzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAgICAgbGV0IG1heFF1YWRzID0gTWF0aC5mbG9vcih0aGlzLnJlbmRlclN0YXRlLnF1YWRzLmRhdGEuYnl0ZUxlbmd0aCAvIDgwKTtcblxuICAgICAgICAvLyBJbml0IHdlYmdsIGFycmF5cy5cbiAgICAgICAgbGV0IGFsbEluZGljZXMgPSBuZXcgVWludDE2QXJyYXkobWF4UXVhZHMgKiA2KTtcblxuICAgICAgICAvLyBmaWxsIHRoZSBpbmRpY2VzIHdpdGggdGhlIHF1YWRzIHRvIGRyYXcuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IG1heFF1YWRzOyBpICs9IDYsIGogKz0gNCkge1xuICAgICAgICAgICAgYWxsSW5kaWNlc1tpXSA9IGo7XG4gICAgICAgICAgICBhbGxJbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xuICAgICAgICAgICAgYWxsSW5kaWNlc1tpICsgMl0gPSBqICsgMjtcbiAgICAgICAgICAgIGFsbEluZGljZXNbaSArIDNdID0gajtcbiAgICAgICAgICAgIGFsbEluZGljZXNbaSArIDRdID0gaiArIDI7XG4gICAgICAgICAgICBhbGxJbmRpY2VzW2kgKyA1XSA9IGogKyAzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHF1YWRzIGJ1ZmZlciBjYW4gYmUgKHJlKXVzZWQgdG8gZHJhdyBhIHJhbmdlIG9mIHF1YWRzLlxuICAgICAgICB0aGlzLl9xdWFkc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLl9xdWFkc0J1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGFsbEluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICAvLyBUaGUgbWF0cml4IHRoYXQgY2F1c2VzIHRoZSBbMCwwIC0gVyxIXSBib3ggdG8gbWFwIHRvIFstMSwtMSAtIDEsMV0gaW4gdGhlIGVuZCByZXN1bHRzLlxuICAgICAgICB0aGlzLl9wcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheShbMi90aGlzLmN0eC5zdGFnZS5jb29yZHNXaWR0aCwgLTIvdGhpcy5jdHguc3RhZ2UuY29vcmRzSGVpZ2h0XSk7XG5cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuX2F0dHJpYnNCdWZmZXIpO1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl9xdWFkc0J1ZmZlcik7XG4gICAgfVxuXG4gICAgX3Jlc2V0KCkge1xuICAgICAgICBzdXBlci5fcmVzZXQoKTtcblxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblxuICAgICAgICB0aGlzLl9zdG9wU2hhZGVyUHJvZ3JhbSgpO1xuICAgICAgICB0aGlzLl9zZXR1cEJ1ZmZlcnMoKTtcbiAgICB9XG5cbiAgICBfc2V0dXBCdWZmZXJzKCkge1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLl9xdWFkc0J1ZmZlcik7XG4gICAgICAgIGxldCBlbGVtZW50ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnJlbmRlclN0YXRlLnF1YWRzLmRhdGEsIDAsIHRoaXMucmVuZGVyU3RhdGUucXVhZHMuZGF0YUxlbmd0aCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLl9hdHRyaWJzQnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGVsZW1lbnQsIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgfVxuXG4gICAgX3NldHVwUXVhZE9wZXJhdGlvbihxdWFkT3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLl9zZXR1cFF1YWRPcGVyYXRpb24ocXVhZE9wZXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3VzZVNoYWRlclByb2dyYW0ocXVhZE9wZXJhdGlvbi5zaGFkZXIsIHF1YWRPcGVyYXRpb24pO1xuICAgIH1cblxuICAgIF9yZW5kZXJRdWFkT3BlcmF0aW9uKG9wKSB7XG4gICAgICAgIGxldCBzaGFkZXIgPSBvcC5zaGFkZXI7XG5cbiAgICAgICAgaWYgKG9wLmxlbmd0aCB8fCBvcC5zaGFkZXIuYWRkRW1wdHkoKSkge1xuICAgICAgICAgICAgc2hhZGVyLmJlZm9yZURyYXcob3ApO1xuICAgICAgICAgICAgc2hhZGVyLmRyYXcob3ApO1xuICAgICAgICAgICAgc2hhZGVyLmFmdGVyRHJhdyhvcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyfSBzaGFkZXI7XG4gICAgICogQHBhcmFtIHtDb3JlUXVhZE9wZXJhdGlvbn0gb3BlcmF0aW9uO1xuICAgICAqL1xuICAgIF91c2VTaGFkZXJQcm9ncmFtKHNoYWRlciwgb3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICghc2hhZGVyLmhhc1NhbWVQcm9ncmFtKHRoaXMuX2N1cnJlbnRTaGFkZXJQcm9ncmFtKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTaGFkZXJQcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFNoYWRlclByb2dyYW0uc3RvcFByb2dyYW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoYWRlci51c2VQcm9ncmFtKCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U2hhZGVyUHJvZ3JhbSA9IHNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgICBzaGFkZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgIH1cblxuICAgIF9zdG9wU2hhZGVyUHJvZ3JhbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTaGFkZXJQcm9ncmFtKSB7XG4gICAgICAgICAgICAvLyBUaGUgY3VycmVudGx5IHVzZWQgc2hhZGVyIHByb2dyYW0gc2hvdWxkIGJlIHN0b3BwZWQgZ3JhY2VmdWxseS5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTaGFkZXJQcm9ncmFtLnN0b3BQcm9ncmFtKCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U2hhZGVyUHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYmluZFJlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZSkge1xuICAgICAgICBzdXBlci5fYmluZFJlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZSk7XG5cbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwwLHRoaXMuY3R4LnN0YWdlLncsdGhpcy5jdHguc3RhZ2UuaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX3JlbmRlclRleHR1cmUuZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwwLHRoaXMuX3JlbmRlclRleHR1cmUudywgdGhpcy5fcmVuZGVyVGV4dHVyZS5oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jbGVhclJlbmRlclRleHR1cmUoKSB7XG4gICAgICAgIHN1cGVyLl9jbGVhclJlbmRlclRleHR1cmUoKTtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICBsZXQgZ2xDbGVhckNvbG9yID0gdGhpcy5jdHguc3RhZ2UuZ2V0Q2xlYXJDb2xvcigpO1xuICAgICAgICAgICAgaWYgKGdsQ2xlYXJDb2xvcikge1xuICAgICAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IoZ2xDbGVhckNvbG9yWzBdICogZ2xDbGVhckNvbG9yWzNdLCBnbENsZWFyQ29sb3JbMV0gKiBnbENsZWFyQ29sb3JbM10sIGdsQ2xlYXJDb2xvclsyXSAqIGdsQ2xlYXJDb2xvclszXSwgZ2xDbGVhckNvbG9yWzNdKTtcbiAgICAgICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRleHR1cmUuXG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0U2Npc3NvcihhcmVhKSB7XG4gICAgICAgIHN1cGVyLl9zZXRTY2lzc29yKGFyZWEpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zY2lzc29yID09PSBhcmVhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2Npc3NvciA9IGFyZWE7XG5cbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgaWYgKCFhcmVhKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB0aGlzLmN0eC5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcbiAgICAgICAgICAgIGxldCB5ID0gYXJlYVsxXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJUZXh0dXJlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRmxpcC5cbiAgICAgICAgICAgICAgICB5ID0gKHRoaXMuY3R4LnN0YWdlLmggLyBwcmVjaXNpb24gLSAoYXJlYVsxXSArIGFyZWFbM10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsLnNjaXNzb3IoTWF0aC5yb3VuZChhcmVhWzBdICogcHJlY2lzaW9uKSwgTWF0aC5yb3VuZCh5ICogcHJlY2lzaW9uKSwgTWF0aC5yb3VuZChhcmVhWzJdICogcHJlY2lzaW9uKSwgTWF0aC5yb3VuZChhcmVhWzNdICogcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vLi4vdHJlZS9VdGlscy5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi8uLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgV2ViR0xDb3JlUXVhZExpc3QgZnJvbSBcIi4vV2ViR0xDb3JlUXVhZExpc3QubWpzXCI7XG5pbXBvcnQgV2ViR0xDb3JlUXVhZE9wZXJhdGlvbiBmcm9tIFwiLi9XZWJHTENvcmVRdWFkT3BlcmF0aW9uLm1qc1wiO1xuaW1wb3J0IFdlYkdMQ29yZVJlbmRlckV4ZWN1dG9yIGZyb20gXCIuL1dlYkdMQ29yZVJlbmRlckV4ZWN1dG9yLm1qc1wiO1xuaW1wb3J0IENvcmVSZW5kZXJTdGF0ZSBmcm9tIFwiLi4vLi4vdHJlZS9jb3JlL0NvcmVSZW5kZXJTdGF0ZS5tanNcIjtcbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanNcIjtcbmltcG9ydCBXZWJHTFNoYWRlciBmcm9tIFwiLi9XZWJHTFNoYWRlci5tanNcIjtcbmltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi4vUmVuZGVyZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG4gICAgICAgIHRoaXMuc2hhZGVyUHJvZ3JhbXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zaGFkZXJQcm9ncmFtcy5mb3JFYWNoKHNoYWRlclByb2dyYW0gPT4gc2hhZGVyUHJvZ3JhbS5kZXN0cm95KCkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVEZWZhdWx0U2hhZGVyKGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRTaGFkZXIoY3R4KTtcbiAgICB9XG5cbiAgICBfZ2V0U2hhZGVyQmFzZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBXZWJHTFNoYWRlclxuICAgIH1cblxuICAgIF9nZXRTaGFkZXJBbHRlcm5hdGl2ZShzaGFkZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiBzaGFkZXJUeXBlLmdldFdlYkdMICYmIHNoYWRlclR5cGUuZ2V0V2ViR0woKTtcbiAgICB9XG5cbiAgICBjcmVhdGVDb3JlUXVhZExpc3QoY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViR0xDb3JlUXVhZExpc3QoY3R4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVDb3JlUXVhZE9wZXJhdGlvbihjdHgsIHNoYWRlciwgc2hhZGVyT3duZXIsIHJlbmRlclRleHR1cmVJbmZvLCBzY2lzc29yLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFdlYkdMQ29yZVF1YWRPcGVyYXRpb24oY3R4LCBzaGFkZXIsIHNoYWRlck93bmVyLCByZW5kZXJUZXh0dXJlSW5mbywgc2Npc3NvciwgaW5kZXgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvcmVSZW5kZXJFeGVjdXRvcihjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvcmVSZW5kZXJFeGVjdXRvcihjdHgpO1xuICAgIH1cbiAgICBcbiAgICBjcmVhdGVDb3JlUmVuZGVyU3RhdGUoY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29yZVJlbmRlclN0YXRlKGN0eCk7XG4gICAgfVxuXG4gICAgY3JlYXRlUmVuZGVyVGV4dHVyZSh3LCBoLCBwdywgcGgpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnN0YWdlLmdsO1xuICAgICAgICBjb25zdCBnbFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSk7XG5cbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBwdywgcGgsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgICAgIGdsVGV4dHVyZS5wYXJhbXMgPSB7fTtcbiAgICAgICAgZ2xUZXh0dXJlLnBhcmFtc1tnbC5URVhUVVJFX01BR19GSUxURVJdID0gZ2wuTElORUFSO1xuICAgICAgICBnbFRleHR1cmUucGFyYW1zW2dsLlRFWFRVUkVfTUlOX0ZJTFRFUl0gPSBnbC5MSU5FQVI7XG4gICAgICAgIGdsVGV4dHVyZS5wYXJhbXNbZ2wuVEVYVFVSRV9XUkFQX1NdID0gZ2wuQ0xBTVBfVE9fRURHRTtcbiAgICAgICAgZ2xUZXh0dXJlLnBhcmFtc1tnbC5URVhUVVJFX1dSQVBfVF0gPSBnbC5DTEFNUF9UT19FREdFO1xuICAgICAgICBnbFRleHR1cmUub3B0aW9ucyA9IHtmb3JtYXQ6IGdsLlJHQkEsIGludGVybmFsRm9ybWF0OiBnbC5SR0JBLCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFfTtcblxuICAgICAgICAvLyBXZSBuZWVkIGEgc3BlY2lmaWMgZnJhbWVidWZmZXIgZm9yIGV2ZXJ5IHJlbmRlciB0ZXh0dXJlLlxuICAgICAgICBnbFRleHR1cmUuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICBnbFRleHR1cmUucHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoWzIvdywgMi9oXSk7XG5cbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbFRleHR1cmUuZnJhbWVidWZmZXIpO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIGdsVGV4dHVyZTtcbiAgICB9XG4gICAgXG4gICAgZnJlZVJlbmRlclRleHR1cmUoZ2xUZXh0dXJlKSB7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuc3RhZ2UuZ2w7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGdsVGV4dHVyZS5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUoZ2xUZXh0dXJlKTtcbiAgICB9XG5cbiAgICB1cGxvYWRUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnN0YWdlLmdsO1xuXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xuXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHtcbiAgICAgICAgICAgIHByZW11bHRpcGx5QWxwaGE6IHRydWUsXG4gICAgICAgICAgICBoYXNBbHBoYTogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3ByZW11bHRpcGx5QWxwaGEnKSkge1xuICAgICAgICAgICAgZm9ybWF0LnByZW11bHRpcGx5QWxwaGEgPSBvcHRpb25zLnByZW11bHRpcGx5QWxwaGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCdmbGlwQmx1ZVJlZCcpKSB7XG4gICAgICAgICAgICBmb3JtYXQuZmxpcEJsdWVSZWQgPSBvcHRpb25zLmZsaXBCbHVlUmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnaGFzQWxwaGEnKSkge1xuICAgICAgICAgICAgZm9ybWF0Lmhhc0FscGhhID0gb3B0aW9ucy5oYXNBbHBoYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm9ybWF0Lmhhc0FscGhhKSB7XG4gICAgICAgICAgICBmb3JtYXQucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0LnRleFBhcmFtcyA9IG9wdGlvbnMudGV4UGFyYW1zIHx8IHt9XG4gICAgICAgIGZvcm1hdC50ZXhPcHRpb25zID0gb3B0aW9ucy50ZXhPcHRpb25zIHx8IHt9XG5cbiAgICAgICAgbGV0IGdsVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKTtcblxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZvcm1hdC5wcmVtdWx0aXBseUFscGhhKTtcblxuICAgICAgICBpZiAoVXRpbHMuaXNOb2RlKSB7XG4gICAgICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9CTFVFX1JFRCwgISFmb3JtYXQuZmxpcEJsdWVSZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGV4UGFyYW1zID0gZm9ybWF0LnRleFBhcmFtcztcbiAgICAgICAgaWYgKCF0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9NQUdfRklMVEVSXSkgdGV4UGFyYW1zW2dsLlRFWFRVUkVfTUFHX0ZJTFRFUl0gPSBnbC5MSU5FQVI7XG4gICAgICAgIGlmICghdGV4UGFyYW1zW2dsLlRFWFRVUkVfTUlOX0ZJTFRFUl0pIHRleFBhcmFtc1tnbC5URVhUVVJFX01JTl9GSUxURVJdID0gZ2wuTElORUFSO1xuICAgICAgICBpZiAoIXRleFBhcmFtc1tnbC5URVhUVVJFX1dSQVBfU10pIHRleFBhcmFtc1tnbC5URVhUVVJFX1dSQVBfU10gPSBnbC5DTEFNUF9UT19FREdFO1xuICAgICAgICBpZiAoIXRleFBhcmFtc1tnbC5URVhUVVJFX1dSQVBfVF0pIHRleFBhcmFtc1tnbC5URVhUVVJFX1dSQVBfVF0gPSBnbC5DTEFNUF9UT19FREdFO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHRleFBhcmFtcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0ZXhQYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgcGFyc2VJbnQoa2V5KSwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0ZXhPcHRpb25zID0gZm9ybWF0LnRleE9wdGlvbnM7XG4gICAgICAgIHRleE9wdGlvbnMuZm9ybWF0ID0gdGV4T3B0aW9ucy5mb3JtYXQgfHwgKGZvcm1hdC5oYXNBbHBoYSA/IGdsLlJHQkEgOiBnbC5SR0IpO1xuICAgICAgICB0ZXhPcHRpb25zLnR5cGUgPSB0ZXhPcHRpb25zLnR5cGUgfHwgZ2wuVU5TSUdORURfQllURTtcbiAgICAgICAgdGV4T3B0aW9ucy5pbnRlcm5hbEZvcm1hdCA9IHRleE9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgdGV4T3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW1hZ2VSZWYpIHtcbiAgICAgICAgICAgIHRleE9wdGlvbnMuaW1hZ2VSZWYgPSBvcHRpb25zLmltYWdlUmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFnZS5wbGF0Zm9ybS51cGxvYWRHbFRleHR1cmUoZ2wsIHRleHR1cmVTb3VyY2UsIHNvdXJjZSwgdGV4T3B0aW9ucyk7XG5cbiAgICAgICAgZ2xUZXh0dXJlLnBhcmFtcyA9IFV0aWxzLmNsb25lT2JqU2hhbGxvdyh0ZXhQYXJhbXMpO1xuICAgICAgICBnbFRleHR1cmUub3B0aW9ucyA9IFV0aWxzLmNsb25lT2JqU2hhbGxvdyh0ZXhPcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gZ2xUZXh0dXJlO1xuICAgIH1cblxuICAgIGZyZWVUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZS5nbC5kZWxldGVUZXh0dXJlKHRleHR1cmVTb3VyY2UubmF0aXZlVGV4dHVyZSk7XG4gICAgfVxuXG4gICAgYWRkUXVhZChyZW5kZXJTdGF0ZSwgcXVhZHMsIGluZGV4KSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSAoaW5kZXggKiAyMCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRDb3JlID0gcXVhZHMucXVhZEVsZW1lbnRzW2luZGV4XTtcblxuICAgICAgICBsZXQgciA9IGVsZW1lbnRDb3JlLl9yZW5kZXJDb250ZXh0O1xuXG4gICAgICAgIGxldCBmbG9hdHMgPSByZW5kZXJTdGF0ZS5xdWFkcy5mbG9hdHM7XG4gICAgICAgIGxldCB1aW50cyA9IHJlbmRlclN0YXRlLnF1YWRzLnVpbnRzO1xuICAgICAgICBjb25zdCBtY2EgPSBTdGFnZVV0aWxzLm1lcmdlQ29sb3JBbHBoYTtcblxuICAgICAgICBpZiAoci50YiAhPT0gMCB8fCByLnRjICE9PSAwKSB7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB5O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl91bHg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX3VseTtcbiAgICAgICAgICAgIHVpbnRzW29mZnNldCsrXSA9IG1jYShlbGVtZW50Q29yZS5fY29sb3JVbCwgci5hbHBoYSk7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weCArIGVsZW1lbnRDb3JlLl93ICogci50YTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB5ICsgZWxlbWVudENvcmUuX3cgKiByLnRjO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl9icng7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX3VseTtcbiAgICAgICAgICAgIHVpbnRzW29mZnNldCsrXSA9IG1jYShlbGVtZW50Q29yZS5fY29sb3JVciwgci5hbHBoYSk7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weCArIGVsZW1lbnRDb3JlLl93ICogci50YSArIGVsZW1lbnRDb3JlLl9oICogci50YjtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB5ICsgZWxlbWVudENvcmUuX3cgKiByLnRjICsgZWxlbWVudENvcmUuX2ggKiByLnRkO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl9icng7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX2JyeTtcbiAgICAgICAgICAgIHVpbnRzW29mZnNldCsrXSA9IG1jYShlbGVtZW50Q29yZS5fY29sb3JCciwgci5hbHBoYSk7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weCArIGVsZW1lbnRDb3JlLl9oICogci50YjtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB5ICsgZWxlbWVudENvcmUuX2ggKiByLnRkO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl91bHg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX2JyeTtcbiAgICAgICAgICAgIHVpbnRzW29mZnNldF0gPSBtY2EoZWxlbWVudENvcmUuX2NvbG9yQmwsIHIuYWxwaGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2ltcGxlLlxuICAgICAgICAgICAgbGV0IGN4ID0gci5weCArIGVsZW1lbnRDb3JlLl93ICogci50YTtcbiAgICAgICAgICAgIGxldCBjeSA9IHIucHkgKyBlbGVtZW50Q29yZS5faCAqIHIudGQ7XG5cbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHk7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX3VseDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fdWx5O1xuICAgICAgICAgICAgdWludHNbb2Zmc2V0KytdID0gbWNhKGVsZW1lbnRDb3JlLl9jb2xvclVsLCByLmFscGhhKTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBjeDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB5O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl9icng7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX3VseTtcbiAgICAgICAgICAgIHVpbnRzW29mZnNldCsrXSA9IG1jYShlbGVtZW50Q29yZS5fY29sb3JVciwgci5hbHBoYSk7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gY3g7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gY3k7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX2JyeDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fYnJ5O1xuICAgICAgICAgICAgdWludHNbb2Zmc2V0KytdID0gbWNhKGVsZW1lbnRDb3JlLl9jb2xvckJyLCByLmFscGhhKTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGN5O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl91bHg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX2JyeTtcbiAgICAgICAgICAgIHVpbnRzW29mZnNldF0gPSBtY2EoZWxlbWVudENvcmUuX2NvbG9yQmwsIHIuYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNSZW5kZXJUZXh0dXJlUmV1c2FibGUocmVuZGVyU3RhdGUsIHJlbmRlclRleHR1cmVJbmZvKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSAocmVuZGVyU3RhdGUuX3JlbmRlclRleHR1cmVJbmZvLm9mZnNldCAqIDgwKSAvIDQ7XG4gICAgICAgIGxldCBmbG9hdHMgPSByZW5kZXJTdGF0ZS5xdWFkcy5mbG9hdHM7XG4gICAgICAgIGxldCB1aW50cyA9IHJlbmRlclN0YXRlLnF1YWRzLnVpbnRzO1xuICAgICAgICByZXR1cm4gKChmbG9hdHNbb2Zmc2V0XSA9PT0gMCkgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgMV0gPT09IDApICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDJdID09PSAwKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAzXSA9PT0gMCkgJiZcbiAgICAgICAgICAgICh1aW50c1tvZmZzZXQgKyA0XSA9PT0gMHhGRkZGRkZGRikgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgNV0gPT09IHJlbmRlclRleHR1cmVJbmZvLncpICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDZdID09PSAwKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyA3XSA9PT0gMSkgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgOF0gPT09IDApICYmXG4gICAgICAgICAgICAodWludHNbb2Zmc2V0ICsgOV0gPT09IDB4RkZGRkZGRkYpICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDEwXSA9PT0gcmVuZGVyVGV4dHVyZUluZm8udykgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgMTFdID09PSByZW5kZXJUZXh0dXJlSW5mby5oKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAxMl0gPT09IDEpICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDEzXSA9PT0gMSkgJiZcbiAgICAgICAgICAgICh1aW50c1tvZmZzZXQgKyAxNF0gPT09IDB4RkZGRkZGRkYpICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDE1XSA9PT0gMCkgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgMTZdID09PSByZW5kZXJUZXh0dXJlSW5mby5oKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAxN10gPT09IDApICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDE4XSA9PT0gMSkgJiZcbiAgICAgICAgICAgICh1aW50c1tvZmZzZXQgKyAxOV0gPT09IDB4RkZGRkZGRkYpKTtcbiAgICB9XG5cbiAgICBmaW5pc2hSZW5kZXJTdGF0ZShyZW5kZXJTdGF0ZSkge1xuICAgICAgICAvLyBTZXQgZXh0cmEgc2hhZGVyIGF0dHJpYnV0ZSBkYXRhLlxuICAgICAgICBsZXQgb2Zmc2V0ID0gcmVuZGVyU3RhdGUubGVuZ3RoICogODA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gcmVuZGVyU3RhdGUucXVhZE9wZXJhdGlvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5xdWFkT3BlcmF0aW9uc1tpXS5leHRyYUF0dHJpYnNEYXRhQnl0ZU9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGxldCBleHRyYSA9IHJlbmRlclN0YXRlLnF1YWRPcGVyYXRpb25zW2ldLnNoYWRlci5nZXRFeHRyYUF0dHJpYkJ5dGVzUGVyVmVydGV4KCkgKiA0ICogcmVuZGVyU3RhdGUucXVhZE9wZXJhdGlvbnNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGV4dHJhO1xuICAgICAgICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucXVhZE9wZXJhdGlvbnNbaV0uc2hhZGVyLnNldEV4dHJhQXR0cmlic0luQnVmZmVyKHJlbmRlclN0YXRlLnF1YWRPcGVyYXRpb25zW2ldLCByZW5kZXJTdGF0ZS5xdWFkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyU3RhdGUucXVhZHMuZGF0YUxlbmd0aCA9IG9mZnNldDtcbiAgICB9XG5cbiAgICBjb3B5UmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlLCBuYXRpdmVUZXh0dXJlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5zdGFnZS5nbDtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbmF0aXZlVGV4dHVyZSk7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGV4dHVyZS5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IHJlbmRlclRleHR1cmUucHJlY2lzaW9uO1xuICAgICAgICBnbC5jb3B5VGV4U3ViSW1hZ2UyRChcbiAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgcHJlY2lzaW9uICogKG9wdGlvbnMuc3ggfHwgMCksXG4gICAgICAgICAgICBwcmVjaXNpb24gKiAob3B0aW9ucy5zeSB8fCAwKSxcbiAgICAgICAgICAgIHByZWNpc2lvbiAqIChvcHRpb25zLnggfHwgMCksXG4gICAgICAgICAgICBwcmVjaXNpb24gKiAob3B0aW9ucy55IHx8IDApLFxuICAgICAgICAgICAgcHJlY2lzaW9uICogKG9wdGlvbnMudyB8fCByZW5kZXJUZXh0dXJlLm93KSxcbiAgICAgICAgICAgIHByZWNpc2lvbiAqIChvcHRpb25zLmggfHwgcmVuZGVyVGV4dHVyZS5vaCkpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFdlYkdMU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi9XZWJHTFNoYWRlclByb2dyYW0ubWpzXCI7XG5pbXBvcnQgU2hhZGVyIGZyb20gXCIuLi8uLi90cmVlL1NoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xTaGFkZXIgZXh0ZW5kcyBTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG5cbiAgICAgICAgY29uc3Qgc3RhZ2UgPSBjdHguc3RhZ2U7XG5cbiAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IHN0YWdlLnJlbmRlcmVyLnNoYWRlclByb2dyYW1zLmdldCh0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtID0gbmV3IFdlYkdMU2hhZGVyUHJvZ3JhbSh0aGlzLmNvbnN0cnVjdG9yLnZlcnRleFNoYWRlclNvdXJjZSwgdGhpcy5jb25zdHJ1Y3Rvci5mcmFnbWVudFNoYWRlclNvdXJjZSk7XG5cbiAgICAgICAgICAgIC8vIExldCB0aGUgdmJvIGNvbnRleHQgcGVyZm9ybSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICBzdGFnZS5yZW5kZXJlci5zaGFkZXJQcm9ncmFtcy5zZXQodGhpcy5jb25zdHJ1Y3RvciwgdGhpcy5fcHJvZ3JhbSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdsID0gc3RhZ2UuZ2w7XG4gICAgfVxuXG4gICAgZ2V0IGdsUHJvZ3JhbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyYW0uZ2xQcm9ncmFtO1xuICAgIH1cblxuICAgIF9pbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuX3Byb2dyYW0uY29tcGlsZSh0aGlzLmdsKTtcbiAgICB9XG5cbiAgICBnZXQgaW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0aWFsaXplZDtcbiAgICB9XG5cbiAgICBfdW5pZm9ybShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmFtLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB9XG5cbiAgICBfYXR0cmliKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyYW0uZ2V0QXR0cmliTG9jYXRpb24obmFtZSk7XG4gICAgfVxuXG4gICAgX3NldFVuaWZvcm0obmFtZSwgdmFsdWUsIGdsRnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRVbmlmb3JtVmFsdWUobmFtZSwgdmFsdWUsIGdsRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIHVzZVByb2dyYW0oKSB7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMuZ2xQcm9ncmFtKTtcbiAgICAgICAgdGhpcy5iZWZvcmVVc2FnZSgpO1xuICAgICAgICB0aGlzLmVuYWJsZUF0dHJpYnMoKTtcbiAgICB9XG5cbiAgICBzdG9wUHJvZ3JhbSgpIHtcbiAgICAgICAgdGhpcy5hZnRlclVzYWdlKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUF0dHJpYnMoKTtcbiAgICB9XG5cbiAgICBoYXNTYW1lUHJvZ3JhbShvdGhlcikge1xuICAgICAgICAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgZmlyc3QgY2hlY2sgZm9yIGlkZW50aWNhbCByZWZlcmVuY2VzLlxuICAgICAgICByZXR1cm4gKG90aGVyICYmICgob3RoZXIgPT09IHRoaXMpIHx8IChvdGhlci5fcHJvZ3JhbSA9PT0gdGhpcy5fcHJvZ3JhbSkpKTtcbiAgICB9XG5cbiAgICBiZWZvcmVVc2FnZSgpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdG8gc2V0IHNldHRpbmdzIG90aGVyIHRoYW4gdGhlIGRlZmF1bHQgc2V0dGluZ3MgKGJsZW5kIG1vZGUgZXRjKS5cbiAgICB9XG5cbiAgICBhZnRlclVzYWdlKCkge1xuICAgICAgICAvLyBBbGwgc2V0dGluZ3MgY2hhbmdlZCBpbiBiZWZvcmVVc2FnZSBzaG91bGQgYmUgcmVzZXQgaGVyZS5cbiAgICB9XG5cbiAgICBlbmFibGVBdHRyaWJzKCkge1xuXG4gICAgfVxuXG4gICAgZGlzYWJsZUF0dHJpYnMoKSB7XG5cbiAgICB9XG5cbiAgICBnZXRFeHRyYUF0dHJpYkJ5dGVzUGVyVmVydGV4KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBnZXRWZXJ0ZXhBdHRyaWJQb2ludGVyT2Zmc2V0KG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uLmV4dHJhQXR0cmlic0RhdGFCeXRlT2Zmc2V0IC0gb3BlcmF0aW9uLmluZGV4ICogNCAqIHRoaXMuZ2V0RXh0cmFBdHRyaWJCeXRlc1BlclZlcnRleCgpO1xuICAgIH1cblxuICAgIHNldEV4dHJhQXR0cmlic0luQnVmZmVyKG9wZXJhdGlvbikge1xuICAgICAgICAvLyBTZXQgZXh0cmEgYXR0cmliIGRhdGEgaW4gaW4gb3BlcmF0aW9uLnF1YWRzLmRhdGEvZmxvYXRzL3VpbnRzLCBzdGFydGluZyBmcm9tXG4gICAgICAgIC8vIG9wZXJhdGlvbi5leHRyYUF0dHJpYnNCdWZmZXJCeXRlT2Zmc2V0LlxuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIC8vIFNldCBhbGwgc2hhZGVyLXNwZWNpZmljIHVuaWZvcm1zLlxuICAgICAgICAvLyBOb3RpY2UgdGhhdCBhbGwgdW5pZm9ybXMgc2hvdWxkIGJlIHNldCwgZXZlbiBpZiB0aGV5IGhhdmUgbm90IGJlZW4gY2hhbmdlZCB3aXRoaW4gdGhpcyBzaGFkZXIgaW5zdGFuY2UuXG4gICAgICAgIC8vIFRoZSB1bmlmb3JtcyBhcmUgc2hhcmVkIGJ5IGFsbCBzaGFkZXJzIHRoYXQgaGF2ZSB0aGUgc2FtZSB0eXBlIChhbmQgc2hhZGVyIHByb2dyYW0pLlxuICAgIH1cblxuICAgIF9nZXRQcm9qZWN0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uLmdldFByb2plY3Rpb24oKTtcbiAgICB9XG5cbiAgICBnZXRGbGlwWShvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb2plY3Rpb24ob3BlcmF0aW9uKVsxXSA8IDA7XG4gICAgfVxuXG4gICAgYmVmb3JlRHJhdyhvcGVyYXRpb24pIHtcbiAgICB9XG5cbiAgICBkcmF3KG9wZXJhdGlvbikge1xuICAgIH1cblxuICAgIGFmdGVyRHJhdyhvcGVyYXRpb24pIHtcbiAgICB9XG5cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvLyBQcm9ncmFtIHRha2VzIGxpdHRsZSByZXNvdXJjZXMsIHNvIGl0IGlzIG9ubHkgZGVzdHJveWVkIHdoZW4gdGhlIGZ1bGwgc3RhZ2UgaXMgZGVzdHJveWVkLlxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBCYXNlIGZ1bmN0aW9uYWxpdHkgZm9yIHNoYWRlciBzZXR1cC9kZXN0cm95LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFNoYWRlclByb2dyYW0ge1xuXG4gICAgY29uc3RydWN0b3IodmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuXG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyU291cmNlID0gdmVydGV4U2hhZGVyU291cmNlO1xuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlID0gZnJhZ21lbnRTaGFkZXJTb3VyY2U7XG5cbiAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fdW5pZm9ybUxvY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlTG9jYXRpb25zID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRVbmlmb3JtVmFsdWVzID0ge307XG4gICAgfVxuXG4gICAgY29tcGlsZShnbCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvZ3JhbSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgICAgICB0aGlzLl9wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgICAgIGxldCBnbFZlcnRTaGFkZXIgPSB0aGlzLl9nbENvbXBpbGUoZ2wuVkVSVEVYX1NIQURFUiwgdGhpcy52ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuICAgICAgICBsZXQgZ2xGcmFnU2hhZGVyID0gdGhpcy5fZ2xDb21waWxlKGdsLkZSQUdNRU5UX1NIQURFUiwgdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZSk7XG5cbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHRoaXMuX3Byb2dyYW0sIGdsVmVydFNoYWRlcik7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcih0aGlzLl9wcm9ncmFtLCBnbEZyYWdTaGFkZXIpO1xuICAgICAgICBnbC5saW5rUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKTtcblxuICAgICAgICAvLyBpZiBsaW5raW5nIGZhaWxzLCB0aGVuIGxvZyBhbmQgY2xlYW51cFxuICAgICAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5fcHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbTGlnaHRuaW5nXSBFcnJvcjogQ291bGQgbm90IGluaXRpYWxpemUgc2hhZGVyLicpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0xpZ2h0bmluZ10gZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLl9wcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tMaWdodG5pbmddIGdsLmdldEVycm9yKCknLCBnbC5nZXRFcnJvcigpKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBwcm9ncmFtIGluZm8gbG9nLCBsb2cgaXRcbiAgICAgICAgICAgIGlmIChnbC5nZXRQcm9ncmFtSW5mb0xvZyh0aGlzLl9wcm9ncmFtKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tMaWdodG5pbmddIFdhcm5pbmc6IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBnbC5nZXRQcm9ncmFtSW5mb0xvZyh0aGlzLl9wcm9ncmFtKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0odGhpcy5fcHJvZ3JhbSk7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFuIHVwIHNvbWUgc2hhZGVyc1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0U2hhZGVyKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGdsRnJhZ1NoYWRlcik7XG4gICAgfVxuXG4gICAgX2dsQ29tcGlsZSh0eXBlLCBzcmMpIHtcbiAgICAgICAgbGV0IHNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuXG4gICAgICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcbiAgICAgICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgICAgICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbTGlnaHRuaW5nXScsIHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ1R5cGU6ICcgKyAodHlwZSA9PT0gdGhpcy5nbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCBzaGFkZXInIDogJ2ZyYWdtZW50IHNoYWRlcicpICk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbTGlnaHRuaW5nXScsIHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgICAgICAgIGxldCBpZHggPSAwO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0xpZ2h0bmluZ10nLCBcIj09PT09PT09PT0gc291cmNlID09PT09PT09PT1cXG5cIiArIHNyYy5zcGxpdChcIlxcblwiKS5tYXAobGluZSA9PiBcIlwiICsgKCsraWR4KSArIFwiOiBcIiArIGxpbmUpLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2hhZGVyO1xuICAgIH1cblxuICAgIGdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKSB7XG4gICAgICAgIGxldCBsb2NhdGlvbiA9IHRoaXMuX3VuaWZvcm1Mb2NhdGlvbnMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAobG9jYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9wcm9ncmFtLCBuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3VuaWZvcm1Mb2NhdGlvbnMuc2V0KG5hbWUsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICBnZXRBdHRyaWJMb2NhdGlvbihuYW1lKSB7XG4gICAgICAgIGxldCBsb2NhdGlvbiA9IHRoaXMuX2F0dHJpYnV0ZUxvY2F0aW9ucy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVMb2NhdGlvbnMuc2V0KG5hbWUsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZ2xQcm9ncmFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBnZXQgY29tcGlsZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3Byb2dyYW07XG4gICAgfVxuXG4gICAgX3ZhbHVlRXF1YWxzKHYxLCB2Mikge1xuICAgICAgICAvLyBVbmlmb3JtIHZhbHVlIGlzIGVpdGhlciBhIHR5cGVkIGFycmF5IG9yIGEgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgaWYgKHYxLmxlbmd0aCAmJiB2Mi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdjEubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHYxW2ldICE9PSB2MltpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHYxID09PSB2Mik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdmFsdWVDbG9uZSh2KSB7XG4gICAgICAgIGlmICh2Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHYuc2xpY2UoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFVuaWZvcm1WYWx1ZShuYW1lLCB2YWx1ZSwgZ2xGdW5jdGlvbikge1xuICAgICAgICBsZXQgdiA9IHRoaXMuX2N1cnJlbnRVbmlmb3JtVmFsdWVzW25hbWVdO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLl92YWx1ZUVxdWFscyh2LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBjbG9uZWRWYWx1ZSA9IHRoaXMuX3ZhbHVlQ2xvbmUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFVuaWZvcm1WYWx1ZXNbbmFtZV0gPSBjbG9uZWRWYWx1ZTtcblxuICAgICAgICAgICAgbGV0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGxvYykge1xuICAgICAgICAgICAgICAgIGxldCBpc01hdHJpeCA9IChnbEZ1bmN0aW9uID09PSB0aGlzLmdsLnVuaWZvcm1NYXRyaXgyZnYgfHwgZ2xGdW5jdGlvbiA9PT0gdGhpcy5nbC51bmlmb3JtTWF0cml4M2Z2IHx8IGdsRnVuY3Rpb24gPT09IHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdik7XG4gICAgICAgICAgICAgICAgaWYgKGlzTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgIGdsRnVuY3Rpb24uY2FsbCh0aGlzLmdsLCBsb2MsIGZhbHNlLCBjbG9uZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xGdW5jdGlvbi5jYWxsKHRoaXMuZ2wsIGxvYywgY2xvbmVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuLyoqXG4gKiA0eDQgYm94IGJsdXIgc2hhZGVyIHdoaWNoIHdvcmtzIGluIGNvbmp1bmN0aW9uIHdpdGggYSA1MCUgcmVzY2FsZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm94Qmx1clNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICBjb25zdCBkeCA9IDEuMCAvIG9wZXJhdGlvbi5nZXRUZXh0dXJlV2lkdGgoMCk7XG4gICAgICAgIGNvbnN0IGR5ID0gMS4wIC8gb3BlcmF0aW9uLmdldFRleHR1cmVIZWlnaHQoMCk7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJzdGVwVGV4dHVyZUNvb3JkXCIsIG5ldyBGbG9hdDMyQXJyYXkoW2R4LCBkeV0pLCB0aGlzLmdsLnVuaWZvcm0yZnYpO1xuICAgIH1cblxufVxuXG5Cb3hCbHVyU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB1bmlmb3JtIHZlYzIgc3RlcFRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZFVsO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkVXI7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmRCbDtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZEJyO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54ICogcHJvamVjdGlvbi54IC0gMS4wLCBhVmVydGV4UG9zaXRpb24ueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgMC4wLCAxLjApO1xuICAgICAgICB2VGV4dHVyZUNvb3JkVWwgPSBhVGV4dHVyZUNvb3JkIC0gc3RlcFRleHR1cmVDb29yZDtcbiAgICAgICAgdlRleHR1cmVDb29yZEJyID0gYVRleHR1cmVDb29yZCArIHN0ZXBUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZUZXh0dXJlQ29vcmRVciA9IHZlYzIodlRleHR1cmVDb29yZEJyLngsIHZUZXh0dXJlQ29vcmRVbC55KTtcbiAgICAgICAgdlRleHR1cmVDb29yZEJsID0gdmVjMih2VGV4dHVyZUNvb3JkVWwueCwgdlRleHR1cmVDb29yZEJyLnkpO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICB9XG5gO1xuXG5Cb3hCbHVyU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkVWw7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmRVcjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZEJsO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkQnI7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIHZlYzQgY29sb3IgPSAwLjI1ICogKHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZFVsKSArIHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZFVyKSArIHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZEJsKSArIHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZEJyKSk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogdkNvbG9yO1xuICAgIH1cbmA7XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vLi4vLi4vdHJlZS9VdGlscy5tanNcIjtcbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENpcmN1bGFyUHVzaFNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG5cbiAgICAgICAgdGhpcy5faW5wdXRWYWx1ZSA9IDA7XG5cbiAgICAgICAgdGhpcy5fbWF4RGVyaXZhdGl2ZSA9IDAuMDE7XG5cbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZFZhbHVlID0gMDtcblxuICAgICAgICAvLyBUaGUgb2Zmc2V0IGJldHdlZW4gYnVja2V0cy4gQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICAgIHRoaXMuX29mZnNldCA9IDA7XG5cbiAgICAgICAgdGhpcy5fYW1vdW50ID0gMC4xO1xuXG4gICAgICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gMTtcblxuICAgICAgICB0aGlzLl9vZmZzZXRYID0gMDtcblxuICAgICAgICB0aGlzLl9vZmZzZXRZID0gMDtcblxuICAgICAgICB0aGlzLmJ1Y2tldHMgPSAxMDA7XG4gICAgfVxuXG4gICAgZ2V0IGFzcGVjdFJhdGlvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgc2V0IGFzcGVjdFJhdGlvKHYpIHtcbiAgICAgICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBvZmZzZXRYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WDtcbiAgICB9XG5cbiAgICBzZXQgb2Zmc2V0WCh2KSB7XG4gICAgICAgIHRoaXMuX29mZnNldFggPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBvZmZzZXRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WTtcbiAgICB9XG5cbiAgICBzZXQgb2Zmc2V0WSh2KSB7XG4gICAgICAgIHRoaXMuX29mZnNldFkgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCBhbW91bnQodikge1xuICAgICAgICB0aGlzLl9hbW91bnQgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBhbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQ7XG4gICAgfVxuXG4gICAgc2V0IGlucHV0VmFsdWUodikge1xuICAgICAgICB0aGlzLl9pbnB1dFZhbHVlID0gdjtcbiAgICB9XG5cbiAgICBnZXQgaW5wdXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0VmFsdWU7XG4gICAgfVxuXG4gICAgc2V0IG1heERlcml2YXRpdmUodikge1xuICAgICAgICB0aGlzLl9tYXhEZXJpdmF0aXZlID0gdjtcbiAgICB9XG5cbiAgICBnZXQgbWF4RGVyaXZhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heERlcml2YXRpdmU7XG4gICAgfVxuXG4gICAgc2V0IGJ1Y2tldHModikge1xuICAgICAgICBpZiAodiA+IDEwMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gQ2lyY3VsYXJQdXNoU2hhZGVyOiBzdXBwb3J0cyBtYXggMTAwIGJ1Y2tldHNcIik7XG4gICAgICAgICAgICB2ID0gMTAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgc2V0IGJlZm9yZSBzdGFydGluZy5cbiAgICAgICAgdGhpcy5fYnVja2V0cyA9IHY7XG5cbiAgICAgICAgLy8gSW5pdCB2YWx1ZXMgYXJyYXkgaW4gdGhlIGNvcnJlY3QgbGVuZ3RoLlxuICAgICAgICB0aGlzLl92YWx1ZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLl9nZXRWYWx1ZXModikpO1xuXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGJ1Y2tldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWNrZXRzO1xuICAgIH1cblxuICAgIF9nZXRWYWx1ZXMobikge1xuICAgICAgICBjb25zdCB2ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2LnB1c2godGhpcy5faW5wdXRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZ3Jlc3NlcyB0aGUgc2hhZGVyIHdpdGggdGhlIHNwZWNpZmllZCAoZnJhY3Rpb25hbCkgbnVtYmVyIG9mIGJ1Y2tldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG87XG4gICAgICogICBBIG51bWJlciBmcm9tIDAgdG8gMSAoMSA9IGFsbCBidWNrZXRzKS5cbiAgICAgKi9cbiAgICBwcm9ncmVzcyhvKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCArPSBvICogdGhpcy5fYnVja2V0cztcbiAgICAgICAgY29uc3QgZnVsbCA9IE1hdGguZmxvb3IodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0IC09IGZ1bGw7XG4gICAgICAgIHRoaXMuX3NoaWZ0QnVja2V0cyhmdWxsKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBfc2hpZnRCdWNrZXRzKG4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2J1Y2tldHMgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSBpIC0gbjtcbiAgICAgICAgICAgIGlmICh0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVkVmFsdWUgPSBNYXRoLm1pbih0aGlzLl9ub3JtYWxpemVkVmFsdWUgKyB0aGlzLl9tYXhEZXJpdmF0aXZlLCBNYXRoLm1heCh0aGlzLl9ub3JtYWxpemVkVmFsdWUgLSB0aGlzLl9tYXhEZXJpdmF0aXZlLCB0aGlzLl9pbnB1dFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2ldID0gMjU1ICogdGhpcy5fbm9ybWFsaXplZFZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSB0aGlzLl92YWx1ZXNbdGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IG9mZnNldCh2KSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiYXNwZWN0UmF0aW9cIiwgdGhpcy5fYXNwZWN0UmF0aW8sIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcIm9mZnNldFhcIiwgdGhpcy5fb2Zmc2V0WCwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwib2Zmc2V0WVwiLCB0aGlzLl9vZmZzZXRZLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJhbW91bnRcIiwgdGhpcy5fYW1vdW50LCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJvZmZzZXRcIiwgdGhpcy5fb2Zmc2V0LCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJidWNrZXRzXCIsIHRoaXMuX2J1Y2tldHMsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInVWYWx1ZVNhbXBsZXJcIiwgMSwgdGhpcy5nbC51bmlmb3JtMWkpO1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQgPT09IDA7XG4gICAgfVxuXG4gICAgYmVmb3JlRHJhdyhvcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZXNUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdmFsdWVzVGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc05vZGUpIHtcbiAgICAgICAgICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9CTFVFX1JFRCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl92YWx1ZXNUZXh0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwbG9hZCBuZXcgdmFsdWVzLlxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLkFMUEhBLCB0aGlzLl9idWNrZXRzLCAxLCAwLCBnbC5BTFBIQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5fdmFsdWVzKTtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgfVxuXG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc1RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLl92YWx1ZXNUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5cbkNpcmN1bGFyUHVzaFNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgb2Zmc2V0WDtcbiAgICB1bmlmb3JtIGZsb2F0IG9mZnNldFk7XG4gICAgdW5pZm9ybSBmbG9hdCBhc3BlY3RSYXRpbztcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzIgdlBvcztcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54ICogcHJvamVjdGlvbi54IC0gMS4wLCBhVmVydGV4UG9zaXRpb24ueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgMC4wLCAxLjApO1xuICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgdlBvcyA9IHZUZXh0dXJlQ29vcmQgKiAyLjAgLSAxLjA7XG4gICAgICAgIHZQb3MueSA9IHZQb3MueSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB2UG9zLnkgPSB2UG9zLnkgKyBvZmZzZXRZO1xuICAgICAgICB2UG9zLnggPSB2UG9zLnggKyBvZmZzZXRYO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICB9XG5gO1xuXG5DaXJjdWxhclB1c2hTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2YXJ5aW5nIHZlYzIgdlBvcztcbiAgICB1bmlmb3JtIGZsb2F0IGFtb3VudDtcbiAgICB1bmlmb3JtIGZsb2F0IG9mZnNldDtcbiAgICB1bmlmb3JtIGZsb2F0IHZhbHVlc1sxMDBdO1xuICAgIHVuaWZvcm0gZmxvYXQgYnVja2V0cztcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmFsdWVTYW1wbGVyO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZmxvYXQgbCA9IGxlbmd0aCh2UG9zKTtcbiAgICAgICAgZmxvYXQgbSA9IChsICogYnVja2V0cyAqIDAuNjc4IC0gb2Zmc2V0KSAvIGJ1Y2tldHM7XG4gICAgICAgIGZsb2F0IGYgPSB0ZXh0dXJlMkQodVZhbHVlU2FtcGxlciwgdmVjMihtLCAwLjApKS5hICogYW1vdW50O1xuICAgICAgICB2ZWMyIHVuaXQgPSB2UG9zIC8gbDtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkIC0gZiAqIHVuaXQpICogdkNvbG9yO1xuICAgIH1cbmA7XG5cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFdlYkdMU2hhZGVyIGZyb20gXCIuLi9XZWJHTFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmYXVsdFNoYWRlciBleHRlbmRzIFdlYkdMU2hhZGVyIHtcblxuICAgIGVuYWJsZUF0dHJpYnMoKSB7XG4gICAgICAgIC8vIEVuYWJsZXMgdGhlIGF0dHJpYnMgaW4gdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYihcImFWZXJ0ZXhQb3NpdGlvblwiKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgMCk7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFWZXJ0ZXhQb3NpdGlvblwiKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYihcImFUZXh0dXJlQ29vcmRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYihcImFUZXh0dXJlQ29vcmRcIiksIDIsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDIgKiA0KTtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFUZXh0dXJlQ29vcmRcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYihcImFDb2xvclwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgc2hhZGVycyBtYXkgaWdub3JlIHRoZSBjb2xvci5cbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliKFwiYUNvbG9yXCIpLCA0LCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCAyMCwgNCAqIDQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYUNvbG9yXCIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2FibGVBdHRyaWJzKCkge1xuICAgICAgICAvLyBEaXNhYmxlcyB0aGUgYXR0cmlicyBpbiB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhVmVydGV4UG9zaXRpb25cIikpO1xuXG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZUNvb3JkXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFUZXh0dXJlQ29vcmRcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYihcImFDb2xvclwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhQ29sb3JcIikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInByb2plY3Rpb25cIiwgdGhpcy5fZ2V0UHJvamVjdGlvbihvcGVyYXRpb24pLCB0aGlzLmdsLnVuaWZvcm0yZnYsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBkcmF3KG9wZXJhdGlvbikge1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSBvcGVyYXRpb24ubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBnbFRleHR1cmUgPSBvcGVyYXRpb24uZ2V0VGV4dHVyZSgwKTtcbiAgICAgICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB0eCA9IG9wZXJhdGlvbi5nZXRUZXh0dXJlKGkpO1xuICAgICAgICAgICAgICAgIGlmIChnbFRleHR1cmUgIT09IHR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYgKiAoaSAtIHBvcyksIGdsLlVOU0lHTkVEX1NIT1JULCAocG9zICsgb3BlcmF0aW9uLmluZGV4KSAqIDYgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgZ2xUZXh0dXJlID0gdHg7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiAqIChsZW5ndGggLSBwb3MpLCBnbC5VTlNJR05FRF9TSE9SVCwgKHBvcyArIG9wZXJhdGlvbi5pbmRleCkgKiA2ICogMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuRGVmYXVsdFNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIGFWZXJ0ZXhQb3NpdGlvbi55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCAwLjAsIDEuMCk7XG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICB9XG5gO1xuXG5EZWZhdWx0U2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yO1xuICAgIH1cbmA7XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBOb2lzZVRleHR1cmUgZnJvbSBcIi4uLy4uLy4uL3RleHR1cmVzL05vaXNlVGV4dHVyZS5tanNcIjtcbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbi8qKlxuICogVGhpcyBzaGFkZXIgY2FuIGJlIHVzZWQgdG8gZml4IGEgcHJvYmxlbSB0aGF0IGlzIGtub3duIGFzICdncmFkaWVudCBiYW5kaW5nJy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGl0aGVyaW5nU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcblxuICAgICAgICB0aGlzLl9ub2lzZVRleHR1cmUgPSBuZXcgTm9pc2VUZXh0dXJlKGN0eC5zdGFnZSk7XG5cbiAgICAgICAgdGhpcy5fZ3JhaW5pbmcgPSAxLzI1NjtcblxuICAgICAgICB0aGlzLl9yYW5kb20gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXQgZ3JhaW5pbmcodikge1xuICAgICAgICB0aGlzLl9ncmFpbmluZyA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IHJhbmRvbSh2KSB7XG4gICAgICAgIHRoaXMuX3JhbmRvbSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0RXh0cmFBdHRyaWJzSW5CdWZmZXIob3BlcmF0aW9uKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBub2lzZSB0ZXh0dXJlIGlzIHVwbG9hZGVkIHRvIHRoZSBHUFUuXG4gICAgICAgIHRoaXMuX25vaXNlVGV4dHVyZS5sb2FkKCk7XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IG9wZXJhdGlvbi5leHRyYUF0dHJpYnNEYXRhQnl0ZU9mZnNldCAvIDQ7XG4gICAgICAgIGxldCBmbG9hdHMgPSBvcGVyYXRpb24ucXVhZHMuZmxvYXRzO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSBvcGVyYXRpb24ubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG5vaXNlIHRleHR1cmUgY29vcmRpbmF0ZXMgc28gdGhhdCBpdCBzcGFucyB0aGUgZnVsbCBlbGVtZW50LlxuICAgICAgICAgICAgbGV0IGJyeCA9IG9wZXJhdGlvbi5nZXRFbGVtZW50V2lkdGgoaSkgLyB0aGlzLl9ub2lzZVRleHR1cmUuZ2V0UmVuZGVyV2lkdGgoKTtcbiAgICAgICAgICAgIGxldCBicnkgPSBvcGVyYXRpb24uZ2V0RWxlbWVudEhlaWdodChpKSAvIHRoaXMuX25vaXNlVGV4dHVyZS5nZXRSZW5kZXJIZWlnaHQoKTtcblxuICAgICAgICAgICAgbGV0IHVseCA9IDA7XG4gICAgICAgICAgICBsZXQgdWx5ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yYW5kb20pIHtcbiAgICAgICAgICAgICAgICB1bHggPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgICAgIHVseSA9IE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgICAgICAgICBicnggKz0gdWx4O1xuICAgICAgICAgICAgICAgIGJyeSArPSB1bHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGbGlwIGZvciBtb3JlIHJhbmRvbW5lc3MuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB1bHg7XG4gICAgICAgICAgICAgICAgICAgIHVseCA9IGJyeDtcbiAgICAgICAgICAgICAgICAgICAgYnJ4ID0gdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGbGlwIGZvciBtb3JlIHJhbmRvbW5lc3MuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB1bHk7XG4gICAgICAgICAgICAgICAgICAgIHVseSA9IGJyeTtcbiAgICAgICAgICAgICAgICAgICAgYnJ5ID0gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNwZWNpZnkgYWxsIGNvcm5lciBwb2ludHMuXG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0XSA9IHVseDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyAxXSA9IHVseTtcblxuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDJdID0gYnJ4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDNdID0gdWx5O1xuXG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgNF0gPSBicng7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgNV0gPSBicnk7XG5cbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA2XSA9IHVseDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA3XSA9IGJyeTtcblxuICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVEcmF3KG9wZXJhdGlvbikge1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYihcImFOb2lzZVRleHR1cmVDb29yZFwiKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA4LCB0aGlzLmdldFZlcnRleEF0dHJpYlBvaW50ZXJPZmZzZXQob3BlcmF0aW9uKSk7XG5cbiAgICAgICAgbGV0IGdsVGV4dHVyZSA9IHRoaXMuX25vaXNlVGV4dHVyZS5zb3VyY2UubmF0aXZlVGV4dHVyZTtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSk7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIH1cblxuICAgIGdldEV4dHJhQXR0cmliQnl0ZXNQZXJWZXJ0ZXgoKSB7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInVOb2lzZVNhbXBsZXJcIiwgMSwgdGhpcy5nbC51bmlmb3JtMWkpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiZ3JhaW5pbmdcIiwgMiAqIHRoaXMuX2dyYWluaW5nLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgfVxuXG4gICAgZW5hYmxlQXR0cmlicygpIHtcbiAgICAgICAgc3VwZXIuZW5hYmxlQXR0cmlicygpO1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhTm9pc2VUZXh0dXJlQ29vcmRcIikpO1xuICAgIH1cblxuICAgIGRpc2FibGVBdHRyaWJzKCkge1xuICAgICAgICBzdXBlci5kaXNhYmxlQXR0cmlicygpO1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYU5vaXNlVGV4dHVyZUNvb3JkXCIpKTtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhaW5pbmcgPT09IDA7XG4gICAgfVxuXG4gICAgYWZ0ZXJEcmF3KG9wZXJhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fcmFuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbkRpdGhlcmluZ1NoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzIgYU5vaXNlVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzIgdk5vaXNlVGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIGFWZXJ0ZXhQb3NpdGlvbi55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCAwLjAsIDEuMCk7XG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB2Tm9pc2VUZXh0dXJlQ29vcmQgPSBhTm9pc2VUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgIH1cbmA7XG5cbkRpdGhlcmluZ1NoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzIgdk5vaXNlVGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdU5vaXNlU2FtcGxlcjtcbiAgICB1bmlmb3JtIGZsb2F0IGdyYWluaW5nO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgdmVjNCBub2lzZSA9IHRleHR1cmUyRCh1Tm9pc2VTYW1wbGVyLCB2Tm9pc2VUZXh0dXJlQ29vcmQpO1xuICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gKGNvbG9yICogdkNvbG9yKSArIGdyYWluaW5nICogKG5vaXNlLnIgLSAwLjUpO1xuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tICcuL0RlZmF1bHRTaGFkZXIubWpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZU91dFNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX2ZhZGUgPSBbMCwgMCwgMCwgMF07XG4gICAgfVxuXG4gICAgc2V0IHRvcChudW0pIHtcbiAgICAgICAgdGhpcy5fZmFkZVswXSA9IG51bTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFkZVswXTtcbiAgICB9XG5cbiAgICBzZXQgcmlnaHQobnVtKSB7XG4gICAgICAgIHRoaXMuX2ZhZGVbMV0gPSBudW07XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFkZVsxXTtcbiAgICB9XG5cbiAgICBzZXQgYm90dG9tKG51bSkge1xuICAgICAgICB0aGlzLl9mYWRlWzJdID0gbnVtO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBib3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWRlWzJdO1xuICAgIH1cblxuICAgIHNldCBsZWZ0KG51bSkge1xuICAgICAgICB0aGlzLl9mYWRlWzNdID0gbnVtO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFkZVszXTtcbiAgICB9XG5cbiAgICBzZXQgZmFkZSh2KSB7XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGlmKHYubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmFkZSA9IFt2WzBdLCB2WzFdLCB2WzBdLCB2WzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWRlID0gW3ZbMF0sIHZbMV0sIHZbMl0sIHRoaXMuX2ZhZGVbM11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodi5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWRlID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZhZGUgPSBbdlswXSwgdlswXSwgdlswXSwgdlswXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9mYWRlID0gW3YsIHYsIHYsIHZdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGZhZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWRlO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgY29uc3Qgb3duZXIgPSBvcGVyYXRpb24uc2hhZGVyT3duZXI7XG5cbiAgICAgICAgY29uc3QgcmVuZGVyUHJlY2lzaW9uID0gdGhpcy5jdHguc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG4gICAgICAgIGNvbnN0IGZhZGUgPSB0aGlzLl9mYWRlLm1hcCgoZikgPT4gZiAqIHJlbmRlclByZWNpc2lvbik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2ZhZGUnLCAgbmV3IEZsb2F0MzJBcnJheShmYWRlKSwgdGhpcy5nbC51bmlmb3JtNGZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmVzb2x1dGlvbicsIG5ldyBGbG9hdDMyQXJyYXkoW293bmVyLl93ICogcmVuZGVyUHJlY2lzaW9uLCBvd25lci5faCAqIHJlbmRlclByZWNpc2lvbl0pLCB0aGlzLmdsLnVuaWZvcm0yZnYpO1xuICAgIH1cbn1cblxuRmFkZU91dFNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gdmVjNCBmYWRlO1xuICAgIFxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XG4gICAgICAgIHZlYzIgaGFsZlJlcyA9IDAuNSAqIHJlc29sdXRpb24ueHk7XG4gICAgICAgIHZlYzIgcG9pbnQgPSB2VGV4dHVyZUNvb3JkLnh5ICogcmVzb2x1dGlvbi54eTtcbiAgICAgICAgXG4gICAgICAgIHZlYzIgcG9zMTtcbiAgICAgICAgdmVjMiBwb3MyO1xuICAgICAgICB2ZWMyIGQ7XG4gICAgICAgIGZsb2F0IGM7XG4gICAgICAgIGZsb2F0IHQgPSAwLjA7XG4gICAgICAgICAgICAgXG4gICAgICAgIGlmKGZhZGVbMF0gPiAwLjApIHtcbiAgICAgICAgICAgIHBvczEgPSB2ZWMyKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgcG9zMiA9IHZlYzIocG9pbnQueCwgcG9pbnQueSArIGZhZGVbMF0pO1xuICAgICAgICAgICAgZCA9IHBvczIgLSBwb3MxO1xuICAgICAgICAgICAgYyA9IGRvdChwb3MxLCBkKSAvIGRvdChkLCBkKTtcbiAgICAgICAgICAgIHQgPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBjbGFtcChjLCAwLjAsIDEuMCkpO1xuICAgICAgICAgICAgY29sb3IgPSBtaXgodmVjNCgwLjApLCBjb2xvciwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGZhZGVbMV0gPiAwLjApIHtcbiAgICAgICAgICAgIHZlYzIgcG9zMSA9IHZlYzIocG9pbnQueCAtIHJlc29sdXRpb24ueCAtIGZhZGVbMV0sIHZUZXh0dXJlQ29vcmQueSk7XG4gICAgICAgICAgICB2ZWMyIHBvczIgPSB2ZWMyKHBvaW50LnggLSByZXNvbHV0aW9uLngsIHZUZXh0dXJlQ29vcmQueSk7XG4gICAgICAgICAgICBkID0gcG9zMSAtIHBvczI7XG4gICAgICAgICAgICBjID0gZG90KHBvczIsIGQpIC8gZG90KGQsIGQpO1xuICAgICAgICAgICAgdCA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIGNsYW1wKGMsIDAuMCwgMS4wKSk7XG4gICAgICAgICAgICBjb2xvciA9IG1peCh2ZWM0KDAuMCksIGNvbG9yLCB0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoZmFkZVsyXSA+IDAuMCkge1xuICAgICAgICAgICAgdmVjMiBwb3MxID0gdmVjMih2VGV4dHVyZUNvb3JkLngsIHBvaW50LnkgLSByZXNvbHV0aW9uLnkgLSBmYWRlWzJdKTtcbiAgICAgICAgICAgIHZlYzIgcG9zMiA9IHZlYzIodlRleHR1cmVDb29yZC54LCBwb2ludC55IC0gcmVzb2x1dGlvbi55KTtcbiAgICAgICAgICAgIGQgPSBwb3MxIC0gcG9zMjtcbiAgICAgICAgICAgIGMgPSBkb3QocG9zMiwgZCkgLyBkb3QoZCwgZCk7XG4gICAgICAgICAgICB0ID0gc21vb3Roc3RlcCgwLjAsIDEuMCwgY2xhbXAoYywgMC4wLCAxLjApKTtcbiAgICAgICAgICAgIGNvbG9yID0gbWl4KHZlYzQoMC4wKSwgY29sb3IsIHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihmYWRlWzNdID4gMC4wKSB7XG4gICAgICAgICAgICBwb3MxID0gdmVjMihwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgIHBvczIgPSB2ZWMyKHBvaW50LnggKyBmYWRlWzNdLCBwb2ludC55KTtcbiAgICAgICAgICAgIGQgPSBwb3MyIC0gcG9zMTtcbiAgICAgICAgICAgIGMgPSBkb3QocG9zMSwgZCkgLyBkb3QoZCwgZCk7XG4gICAgICAgICAgICB0ID0gc21vb3Roc3RlcCgwLjAsIDEuMCwgY2xhbXAoYywgMC4wLCAxLjApKTtcbiAgICAgICAgICAgIGNvbG9yID0gbWl4KHZlYzQoMC4wKSwgY29sb3IsIHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSG9sZVNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgICB0aGlzLl93ID0gMDtcbiAgICAgICAgdGhpcy5faCA9IDA7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH1cblxuICAgIHNldCB4KHYpIHtcbiAgICAgICAgdGhpcy5feCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH1cblxuICAgIHNldCB5KHYpIHtcbiAgICAgICAgdGhpcy5feSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93O1xuICAgIH1cblxuICAgIHNldCB3KHYpIHtcbiAgICAgICAgdGhpcy5fdyA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oO1xuICAgIH1cblxuICAgIHNldCBoKHYpIHtcbiAgICAgICAgdGhpcy5faCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgICB9XG5cbiAgICBzZXQgcmFkaXVzKHYpIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG5cbiAgICAgICAgY29uc3Qgb3duZXIgPSBvcGVyYXRpb24uc2hhZGVyT3duZXI7XG4gICAgICAgIGNvbnN0IHJlbmRlclByZWNpc2lvbiA9IHRoaXMuY3R4LnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpXG5cbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInhcIiwgdGhpcy5feCAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwieVwiLCB0aGlzLl95ICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJ3XCIsIHRoaXMuX3cgKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImhcIiwgdGhpcy5faCAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyYWRpdXMnLCAgKHRoaXMuX3JhZGl1cyArIC41KSAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyZXNvbHV0aW9uJywgbmV3IEZsb2F0MzJBcnJheShbb3duZXIuX3cgKiByZW5kZXJQcmVjaXNpb24sIG93bmVyLl9oICogcmVuZGVyUHJlY2lzaW9uXSksIHRoaXMuZ2wudW5pZm9ybTJmdik7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl94ID09PSAwICYmIHRoaXMuX3kgPT09IDAgJiYgdGhpcy5fdyA9PT0gMCAmJiB0aGlzLl9oID09PSAwKVxuICAgIH1cbn1cblxuSG9sZVNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBEZWZhdWx0U2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZTtcblxuSG9sZVNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSBmbG9hdCB4O1xuICAgIHVuaWZvcm0gZmxvYXQgeTtcbiAgICB1bmlmb3JtIGZsb2F0IHc7XG4gICAgdW5pZm9ybSBmbG9hdCBoO1xuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuXG4gICAgZmxvYXQgcm91bmRCb3godmVjMiBwLCB2ZWMyIGIsIGZsb2F0IHIpIHtcbiAgICAgICAgZmxvYXQgZCA9IGxlbmd0aChtYXgoYWJzKHApLWIrciwgMC4xKSktcjtcbiAgICAgICAgcmV0dXJuIHNtb290aHN0ZXAoMS4wLCAwLjAsIGQpO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgICAgIHZlYzIgcG9zID0gdlRleHR1cmVDb29yZC54eSAqIHJlc29sdXRpb24gLSB2ZWMyKHgsIHkpIC0gdmVjMih3LCBoKSAvIDIuMDtcbiAgICAgICAgdmVjMiBzaXplID0gdmVjMih3LCBoKSAvIDIuMDtcbiAgICAgICAgZmxvYXQgYiA9IHJvdW5kQm94KHBvcywgc2l6ZSwgcmFkaXVzKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGNvbG9yLCB2ZWM0KDAuMCksIGIpO1xuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZlcnNpb25TaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IDE7XG4gICAgfVxuXG4gICAgc2V0IGFtb3VudCh2KSB7XG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudDtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50ID09PSAwO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImFtb3VudFwiLCB0aGlzLl9hbW91bnQsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICB9XG5cbn1cblxuSW52ZXJzaW9uU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSBmbG9hdCBhbW91bnQ7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcbiAgICAgICAgY29sb3IucmdiID0gY29sb3IucmdiICogKDEuMCAtIGFtb3VudCkgKyBhbW91bnQgKiAoMS4wICogY29sb3IuYSAtIGNvbG9yLnJnYik7IFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIHZDb2xvcjtcbiAgICB9XG5gO1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaWdodDNkU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcblxuICAgICAgICB0aGlzLl9zdHJlbmd0aCA9IDAuNTtcbiAgICAgICAgdGhpcy5fYW1iaWVudCA9IDAuNTtcbiAgICAgICAgdGhpcy5fZnVkZ2UgPSAwLjQ7XG5cbiAgICAgICAgdGhpcy5fcnggPSAwO1xuICAgICAgICB0aGlzLl9yeSA9IDA7XG5cbiAgICAgICAgdGhpcy5feiA9IDA7XG4gICAgICAgIHRoaXMuX3Bpdm90WCA9IE5hTjtcbiAgICAgICAgdGhpcy5fcGl2b3RZID0gTmFOO1xuICAgICAgICB0aGlzLl9waXZvdFogPSAwO1xuXG4gICAgICAgIHRoaXMuX2xpZ2h0WSA9IDA7XG4gICAgICAgIHRoaXMuX2xpZ2h0WiA9IDA7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuXG4gICAgICAgIGxldCB2ciA9IG9wZXJhdGlvbi5zaGFkZXJPd25lcjtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSB2ci5lbGVtZW50O1xuXG4gICAgICAgIGxldCBwaXZvdFggPSBpc05hTih0aGlzLl9waXZvdFgpID8gZWxlbWVudC5waXZvdFggKiB2ci53IDogdGhpcy5fcGl2b3RYO1xuICAgICAgICBsZXQgcGl2b3RZID0gaXNOYU4odGhpcy5fcGl2b3RZKSA/IGVsZW1lbnQucGl2b3RZICogdnIuaCA6IHRoaXMuX3Bpdm90WTtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZyLmdldFJlbmRlclRleHR1cmVDb29yZHMocGl2b3RYLCBwaXZvdFkpO1xuXG4gICAgICAgIC8vIENvdW50ZXIgbm9ybWFsIHJvdGF0aW9uLlxuXG4gICAgICAgIGxldCByeiA9IC1NYXRoLmF0YW4yKHZyLl9yZW5kZXJDb250ZXh0LnRjLCB2ci5fcmVuZGVyQ29udGV4dC50YSk7XG5cbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInBpdm90XCIsIG5ldyBGbG9hdDMyQXJyYXkoW2Nvb3Jkc1swXSwgY29vcmRzWzFdLCB0aGlzLl9waXZvdFpdKSwgZ2wudW5pZm9ybTNmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJyb3RcIiwgbmV3IEZsb2F0MzJBcnJheShbdGhpcy5fcngsIHRoaXMuX3J5LCByel0pLCBnbC51bmlmb3JtM2Z2KTtcblxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwielwiLCB0aGlzLl96LCBnbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwibGlnaHRZXCIsIHRoaXMubGlnaHRZLCBnbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwibGlnaHRaXCIsIHRoaXMubGlnaHRaLCBnbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwic3RyZW5ndGhcIiwgdGhpcy5fc3RyZW5ndGgsIGdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJhbWJpZW50XCIsIHRoaXMuX2FtYmllbnQsIGdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJmdWRnZVwiLCB0aGlzLl9mdWRnZSwgZ2wudW5pZm9ybTFmKTtcbiAgICB9XG5cbiAgICBzZXQgc3RyZW5ndGgodikge1xuICAgICAgICB0aGlzLl9zdHJlbmd0aCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHN0cmVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyZW5ndGg7XG4gICAgfVxuXG4gICAgc2V0IGFtYmllbnQodikge1xuICAgICAgICB0aGlzLl9hbWJpZW50ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgYW1iaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FtYmllbnQ7XG4gICAgfVxuXG4gICAgc2V0IGZ1ZGdlKHYpIHtcbiAgICAgICAgdGhpcy5fZnVkZ2UgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBmdWRnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1ZGdlO1xuICAgIH1cblxuICAgIGdldCByeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J4O1xuICAgIH1cblxuICAgIHNldCByeCh2KSB7XG4gICAgICAgIHRoaXMuX3J4ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yeTtcbiAgICB9XG5cbiAgICBzZXQgcnkodikge1xuICAgICAgICB0aGlzLl9yeSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96O1xuICAgIH1cblxuICAgIHNldCB6KHYpIHtcbiAgICAgICAgdGhpcy5feiA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WDtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RYKHYpIHtcbiAgICAgICAgdGhpcy5fcGl2b3RYID0gdiArIDE7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WTtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RZKHYpIHtcbiAgICAgICAgdGhpcy5fcGl2b3RZID0gdiArIDE7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGxpZ2h0WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpZ2h0WTtcbiAgICB9XG5cbiAgICBzZXQgbGlnaHRZKHYpIHtcbiAgICAgICAgdGhpcy5fbGlnaHRZID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3RaKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RaO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFoodikge1xuICAgICAgICB0aGlzLl9waXZvdFogPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBsaWdodFooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saWdodFo7XG4gICAgfVxuXG4gICAgc2V0IGxpZ2h0Wih2KSB7XG4gICAgICAgIHRoaXMuX2xpZ2h0WiA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9yeCA9PT0gMCAmJiB0aGlzLl9yeSA9PT0gMCAmJiB0aGlzLl96ID09PSAwICYmIHRoaXMuX3N0cmVuZ3RoID09PSAwICYmIHRoaXMuX2FtYmllbnQgPT09IDEpO1xuICAgIH1cblxufVxuXG5MaWdodDNkU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcblxuICAgIHVuaWZvcm0gZmxvYXQgZnVkZ2U7XG4gICAgdW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcbiAgICB1bmlmb3JtIGZsb2F0IGFtYmllbnQ7XG4gICAgdW5pZm9ybSBmbG9hdCB6O1xuICAgIHVuaWZvcm0gZmxvYXQgbGlnaHRZO1xuICAgIHVuaWZvcm0gZmxvYXQgbGlnaHRaO1xuICAgIHVuaWZvcm0gdmVjMyBwaXZvdDtcbiAgICB1bmlmb3JtIHZlYzMgcm90O1xuICAgIHZhcnlpbmcgdmVjMyBwb3M7XG5cbiAgICB2b2lkIG1haW4odm9pZCkge1xuICAgICAgICBwb3MgPSB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbi54eSwgeik7XG4gICAgICAgIFxuICAgICAgICBwb3MgLT0gcGl2b3Q7XG4gICAgICAgIFxuICAgICAgICAvLyBVbmRvIFhZIHJvdGF0aW9uXG4gICAgICAgIG1hdDIgaVJvdFh5ID0gbWF0MiggY29zKHJvdC56KSwgc2luKHJvdC56KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAtc2luKHJvdC56KSwgY29zKHJvdC56KSk7XG4gICAgICAgIHBvcy54eSA9IGlSb3RYeSAqIHBvcy54eTtcbiAgICAgICAgXG4gICAgICAgIC8vIFBlcmZvcm0gM2Qgcm90YXRpb25zXG4gICAgICAgIGdsX1Bvc2l0aW9uLnggPSBjb3Mocm90LngpICogcG9zLnggLSBzaW4ocm90LngpICogcG9zLno7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSBwb3MueTtcbiAgICAgICAgZ2xfUG9zaXRpb24ueiA9IHNpbihyb3QueCkgKiBwb3MueCArIGNvcyhyb3QueCkgKiBwb3MuejtcbiAgICAgICAgXG4gICAgICAgIHBvcy54ID0gZ2xfUG9zaXRpb24ueDtcbiAgICAgICAgcG9zLnkgPSBjb3Mocm90LnkpICogZ2xfUG9zaXRpb24ueSAtIHNpbihyb3QueSkgKiBnbF9Qb3NpdGlvbi56O1xuICAgICAgICBwb3MueiA9IHNpbihyb3QueSkgKiBnbF9Qb3NpdGlvbi55ICsgY29zKHJvdC55KSAqIGdsX1Bvc2l0aW9uLno7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWRvIFhZIHJvdGF0aW9uXG4gICAgICAgIGlSb3RYeVswXVsxXSA9IC1pUm90WHlbMF1bMV07XG4gICAgICAgIGlSb3RYeVsxXVswXSA9IC1pUm90WHlbMV1bMF07XG4gICAgICAgIHBvcy54eSA9IGlSb3RYeSAqIHBvcy54eTsgXG5cbiAgICAgICAgLy8gVW5kbyB0cmFuc2xhdGUgdG8gcGl2b3QgcG9zaXRpb25cbiAgICAgICAgcG9zLnh5eiArPSBwaXZvdDtcblxuICAgICAgICBwb3MgPSB2ZWMzKHBvcy54ICogcHJvamVjdGlvbi54IC0gMS4wLCBwb3MueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgcG9zLnogKiBwcm9qZWN0aW9uLngpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGRlcHRoIHBlcnNwZWN0aXZlXG4gICAgICAgIGZsb2F0IHBlcnNwZWN0aXZlID0gMS4wICsgZnVkZ2UgKiBwb3MuejtcblxuICAgICAgICBwb3MueiArPSBsaWdodFogKiBwcm9qZWN0aW9uLng7XG5cbiAgICAgICAgLy8gTWFwIGNvb3JkcyB0byBnbCBjb29yZGluYXRlIHNwYWNlLlxuICAgICAgICAvLyBTZXQgeiB0byAwIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBwZXJmb3JtIHotY2xpcHBpbmdcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMC4wLCBwZXJzcGVjdGl2ZSk7XG5cbiAgICAgICAgLy8gQ29ycmVjdCBsaWdodCBzb3VyY2UgcG9zaXRpb24uXG4gICAgICAgIHBvcy55ICs9IGxpZ2h0WSAqIGFicyhwcm9qZWN0aW9uLnkpO1xuXG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIFxuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgfVxuYDtcblxuTGlnaHQzZFNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZhcnlpbmcgdmVjMyBwb3M7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSBmbG9hdCBhbWJpZW50O1xuICAgIHVuaWZvcm0gZmxvYXQgc3RyZW5ndGg7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICB2ZWM0IHJnYmEgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICBmbG9hdCBkID0gbGVuZ3RoKHBvcyk7XG4gICAgICAgIGZsb2F0IG4gPSAxLjAgLyBtYXgoMC4xLCBkKTtcbiAgICAgICAgcmdiYS5yZ2IgPSByZ2JhLnJnYiAqIChzdHJlbmd0aCAqIG4gKyBhbWJpZW50KTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gcmdiYSAqIHZDb2xvcjtcbiAgICB9XG5gO1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lYXJCbHVyU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDBdKTtcbiAgICAgICAgdGhpcy5fa2VybmVsUmFkaXVzID0gMTtcbiAgICB9XG5cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvblswXTtcbiAgICB9XG5cbiAgICBzZXQgeCh2KSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvblswXSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb25bMV07XG4gICAgfVxuXG4gICAgc2V0IHkodikge1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb25bMV0gPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBrZXJuZWxSYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXJuZWxSYWRpdXM7XG4gICAgfVxuXG4gICAgc2V0IGtlcm5lbFJhZGl1cyh2KSB7XG4gICAgICAgIHRoaXMuX2tlcm5lbFJhZGl1cyA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2tlcm5lbFJhZGl1cyA9PT0gMCk7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiZGlyZWN0aW9uXCIsIHRoaXMuX2RpcmVjdGlvbiwgdGhpcy5nbC51bmlmb3JtMmZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImtlcm5lbFJhZGl1c1wiLCB0aGlzLl9rZXJuZWxSYWRpdXMsIHRoaXMuZ2wudW5pZm9ybTFpKTtcblxuICAgICAgICBjb25zdCB3ID0gb3BlcmF0aW9uLmdldFJlbmRlcldpZHRoKCk7XG4gICAgICAgIGNvbnN0IGggPSBvcGVyYXRpb24uZ2V0UmVuZGVySGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJyZXNvbHV0aW9uXCIsIG5ldyBGbG9hdDMyQXJyYXkoW3csIGhdKSwgdGhpcy5nbC51bmlmb3JtMmZ2KTtcbiAgICB9XG59XG5cbkxpbmVhckJsdXJTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIHZlYzIgZGlyZWN0aW9uO1xuICAgIHVuaWZvcm0gaW50IGtlcm5lbFJhZGl1cztcbiAgICBcbiAgICB2ZWM0IGJsdXIxKHNhbXBsZXIyRCBpbWFnZSwgdmVjMiB1diwgdmVjMiByZXNvbHV0aW9uLCB2ZWMyIGRpcmVjdGlvbikge1xuICAgICAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xuICAgICAgICB2ZWMyIG9mZjEgPSB2ZWMyKDEuMzMzMzMzMzMzMzMzMzMzMykgKiBkaXJlY3Rpb247XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYpICogMC4yOTQxMTc2NDcwNTg4MjM1NDtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4zNTI5NDExNzY0NzA1ODgyNjtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4zNTI5NDExNzY0NzA1ODgyNjtcbiAgICAgICAgcmV0dXJuIGNvbG9yOyBcbiAgICB9XG4gICAgXG4gICAgdmVjNCBibHVyMihzYW1wbGVyMkQgaW1hZ2UsIHZlYzIgdXYsIHZlYzIgcmVzb2x1dGlvbiwgdmVjMiBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcbiAgICAgICAgdmVjMiBvZmYxID0gdmVjMigxLjM4NDYxNTM4NDYpICogZGlyZWN0aW9uO1xuICAgICAgICB2ZWMyIG9mZjIgPSB2ZWMyKDMuMjMwNzY5MjMwOCkgKiBkaXJlY3Rpb247XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYpICogMC4yMjcwMjcwMjcwO1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjMxNjIxNjIxNjI7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzE2MjE2MjE2MjtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wNzAyNzAyNzAzO1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjIgLyByZXNvbHV0aW9uKSkgKiAwLjA3MDI3MDI3MDM7XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgXG4gICAgdmVjNCBibHVyMyhzYW1wbGVyMkQgaW1hZ2UsIHZlYzIgdXYsIHZlYzIgcmVzb2x1dGlvbiwgdmVjMiBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcbiAgICAgICAgdmVjMiBvZmYxID0gdmVjMigxLjQxMTc2NDcwNTg4MjM1MykgKiBkaXJlY3Rpb247XG4gICAgICAgIHZlYzIgb2ZmMiA9IHZlYzIoMy4yOTQxMTc2NDcwNTg4MjM0KSAqIGRpcmVjdGlvbjtcbiAgICAgICAgdmVjMiBvZmYzID0gdmVjMig1LjE3NjQ3MDU4ODIzNTI5NCkgKiBkaXJlY3Rpb247XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYpICogMC4xOTY0ODI1NTAxNTExNDA0O1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjI5NjkwNjk2NDY3MjgzNDQ7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMjk2OTA2OTY0NjcyODM0NDtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wOTQ0NzAzOTc4NTA0NDczMjtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wOTQ0NzAzOTc4NTA0NDczMjtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYzIC8gcmVzb2x1dGlvbikpICogMC4wMTAzODEzNjI0MDExNDgwNTc7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMyAvIHJlc29sdXRpb24pKSAqIDAuMDEwMzgxMzYyNDAxMTQ4MDU3O1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfSAgICBcblxuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgaWYgKGtlcm5lbFJhZGl1cyA9PSAxKSB7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBibHVyMSh1U2FtcGxlciwgdlRleHR1cmVDb29yZCwgcmVzb2x1dGlvbiwgZGlyZWN0aW9uKSAqIHZDb2xvcjtcbiAgICAgICAgfSBlbHNlIGlmIChrZXJuZWxSYWRpdXMgPT0gMikge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gYmx1cjIodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQsIHJlc29sdXRpb24sIGRpcmVjdGlvbikgKiB2Q29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBibHVyMyh1U2FtcGxlciwgdlRleHR1cmVDb29yZCwgcmVzb2x1dGlvbiwgZGlyZWN0aW9uKSAqIHZDb2xvcjtcbiAgICAgICAgfVxuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWduaWZpZXJTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblx0Y29uc3RydWN0b3IoY29udGV4dCkge1xuXHQgIHN1cGVyKGNvbnRleHQpO1xuXHQgIHRoaXMuX3ggPSAwO1xuXHQgIHRoaXMuX3kgPSAwO1xuXHQgIHRoaXMuX3cgPSAwO1xuXHQgIHRoaXMuX2ggPSAwO1xuXHQgIHRoaXMuX3JhZGl1cyA9IDA7XG5cdCAgdGhpcy5fbWFnbmlmaWNhdGlvbiA9IDAuNjtcblx0fVxuICBcblx0Z2V0IHgoKSB7XG5cdCAgcmV0dXJuIHRoaXMuX3g7XG5cdH1cbiAgXG5cdHNldCB4KHYpIHtcblx0ICB0aGlzLl94ID0gdjtcblx0ICB0aGlzLnJlZHJhdygpO1xuXHR9XG4gIFxuXHRnZXQgeSgpIHtcblx0ICByZXR1cm4gdGhpcy5feTtcblx0fVxuICBcblx0c2V0IHkodikge1xuXHQgIHRoaXMuX3kgPSB2O1xuXHQgIHRoaXMucmVkcmF3KCk7XG5cdH1cbiAgXG5cdGdldCB3KCkge1xuXHQgIHJldHVybiB0aGlzLl93O1xuXHR9XG4gIFxuXHRzZXQgdyh2KSB7XG5cdCAgdGhpcy5fdyA9IHY7XG5cdCAgdGhpcy5yZWRyYXcoKTtcblx0fVxuICBcblx0Z2V0IGgoKSB7XG5cdCAgcmV0dXJuIHRoaXMuX2g7XG5cdH1cbiAgXG5cdHNldCBoKHYpIHtcblx0ICB0aGlzLl9oID0gdjtcblx0ICB0aGlzLnJlZHJhdygpO1xuXHR9XG4gIFxuXHRnZXQgbWFnbmlmaWNhdGlvbigpIHtcblx0ICByZXR1cm4gdGhpcy5fbWFnbmlmaWNhdGlvbjtcblx0fVxuICBcblx0c2V0IG1hZ25pZmljYXRpb24odikge1xuXHQgIHRoaXMuX21hZ25pZmljYXRpb24gPSB2O1xuXHQgIHRoaXMucmVkcmF3KCk7XG5cdH1cbiAgXG5cdGdldCByYWRpdXMoKSB7XG5cdCAgcmV0dXJuIHRoaXMuX3JhZGl1cztcblx0fVxuICBcblx0c2V0IHJhZGl1cyh2KSB7XG5cdCAgdGhpcy5fcmFkaXVzID0gdjtcblx0ICB0aGlzLnJlZHJhdygpO1xuXHR9XG4gIFxuXHRzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuXHQgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgXG5cdCAgY29uc3Qgb3duZXIgPSBvcGVyYXRpb24uc2hhZGVyT3duZXI7XG5cdCAgY29uc3QgcmVuZGVyUHJlY2lzaW9uID0gdGhpcy5jdHguc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG5cdCAgdGhpcy5fc2V0VW5pZm9ybSgneCcsIHRoaXMuX3ggKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcblx0ICB0aGlzLl9zZXRVbmlmb3JtKCd5JywgdGhpcy5feSAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuXHQgIHRoaXMuX3NldFVuaWZvcm0oJ3cnLCB0aGlzLl93ICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG5cdCAgdGhpcy5fc2V0VW5pZm9ybSgnaCcsIHRoaXMuX2ggKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcblx0ICB0aGlzLl9zZXRVbmlmb3JtKCdtYWduaWZpY2F0aW9uJywgdGhpcy5fbWFnbmlmaWNhdGlvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuXHQgIHRoaXMuX3NldFVuaWZvcm0oXG5cdFx0J3JhZGl1cycsXG5cdFx0KHRoaXMuX3JhZGl1cyArIDAuNSkgKiByZW5kZXJQcmVjaXNpb24sXG5cdFx0dGhpcy5nbC51bmlmb3JtMWZcblx0ICApO1xuXHQgIHRoaXMuX3NldFVuaWZvcm0oXG5cdFx0J3Jlc29sdXRpb24nLFxuXHRcdG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdCAgb3duZXIuX3cgKiByZW5kZXJQcmVjaXNpb24sXG5cdFx0ICBvd25lci5faCAqIHJlbmRlclByZWNpc2lvblxuXHRcdF0pLFxuXHRcdHRoaXMuZ2wudW5pZm9ybTJmdlxuXHQgICk7XG5cdH1cbiBcblx0dXNlRGVmYXVsdCgpIHtcblx0ICByZXR1cm4gdGhpcy5fdyA9PT0gMCAmJiB0aGlzLl9oID09PSAwO1xuXHR9XG4gIH1cbiAgXG4gIE1hZ25pZmllclNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBEZWZhdWx0U2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZTtcbiAgXG4gIE1hZ25pZmllclNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcblx0ICAjaWZkZWYgR0xfRVNcblx0XHQjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXHRcdCMgZWxzZVxuXHRcdHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuXHRcdCMgZW5kaWZcblx0ICAjZW5kaWZcblxuXHQgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXHQgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cdCAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cdCAgdW5pZm9ybSBmbG9hdCB4O1xuXHQgIHVuaWZvcm0gZmxvYXQgeTtcblx0ICB1bmlmb3JtIGZsb2F0IHc7XG5cdCAgdW5pZm9ybSBmbG9hdCBoO1xuXHQgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuXHQgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuXHQgIHVuaWZvcm0gZmxvYXQgbWFnbmlmaWNhdGlvbjtcbiAgXG5cdCAgZmxvYXQgcm91bmRCb3godmVjMiBwLCB2ZWMyIGIsIGZsb2F0IHIpIHtcblx0XHQgIGZsb2F0IGQgPSBsZW5ndGgobWF4KGFicyhwKS1iK3IsIDAuMSkpLXI7XG5cdFx0ICByZXR1cm4gc21vb3Roc3RlcCgxLjAsIDAuMCwgZCk7XG5cdCAgfVxuXG5cdCAgZmxvYXQgaW5zaWRlKHZlYzIgdikge1xuXHRcdHZlYzIgcyA9IHN0ZXAodmVjMigwLjAsIDAuMCksIHYpIC0gc3RlcCh2ZWMyKDEuMCwgMS4wKSwgdik7XG5cdFx0cmV0dXJuIHMueCAqIHMueTsgICBcbiAgICAgIH1cbiAgXG5cdCAgdm9pZCBtYWluKHZvaWQpIHtcblx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcblx0XHR2ZWMyIHBvcyA9IHZUZXh0dXJlQ29vcmQueHkgKiByZXNvbHV0aW9uIC0gdmVjMih4LCB5KSAtIHZlYzIodywgaCkgLyAyLjA7XG5cdFx0dmVjMiBzaXplID0gdmVjMih3LCBoKSAvIDIuMDtcblx0XHRmbG9hdCBiID0gcm91bmRCb3gocG9zLCBzaXplLCByYWRpdXMpO1xuXHRcdHZlYzIgcG9zMiA9ICh2VGV4dHVyZUNvb3JkLnh5ICogbWFnbmlmaWNhdGlvbiAqIHJlc29sdXRpb24gKyB2ZWMyKHgsIHkpICogbWFnbmlmaWNhdGlvbikgLyByZXNvbHV0aW9uO1xuXHRcdGdsX0ZyYWdDb2xvciA9IG1peChjb2xvciwgdGV4dHVyZTJEKHVTYW1wbGVyLCBwb3MyKSAqIGluc2lkZShwb3MyKSwgYikgKiB2Q29sb3I7XG5cdCAgfVxuICBgO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uLy4uLy4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE91dGxpbmVTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuICAgICAgICB0aGlzLl93aWR0aCA9IDU7XG4gICAgICAgIHRoaXMuX2NvbCA9IDB4RkZGRkZGRkY7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gWzEsMSwxLDFdO1xuICAgIH1cblxuICAgIHNldCB3aWR0aCh2KSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2w7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbCAhPT0gdikge1xuICAgICAgICAgICAgY29uc3QgY29sID0gU3RhZ2VVdGlscy5nZXRSZ2JhQ29tcG9uZW50c05vcm1hbGl6ZWQodik7XG4gICAgICAgICAgICBjb2xbMF0gPSBjb2xbMF0gKiBjb2xbM107XG4gICAgICAgICAgICBjb2xbMV0gPSBjb2xbMV0gKiBjb2xbM107XG4gICAgICAgICAgICBjb2xbMl0gPSBjb2xbMl0gKiBjb2xbM107XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gY29sO1xuXG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xuXG4gICAgICAgICAgICB0aGlzLl9jb2wgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl93aWR0aCA9PT0gMCB8fCB0aGlzLl9jb2xbM10gPT09IDApO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImNvbG9yXCIsIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fY29sb3IpLCBnbC51bmlmb3JtNGZ2KTtcbiAgICB9XG5cbiAgICBlbmFibGVBdHRyaWJzKCkge1xuICAgICAgICBzdXBlci5lbmFibGVBdHRyaWJzKCk7XG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYUNvcm5lclwiKSk7XG4gICAgfVxuXG4gICAgZGlzYWJsZUF0dHJpYnMoKSB7XG4gICAgICAgIHN1cGVyLmRpc2FibGVBdHRyaWJzKCk7XG4gICAgICAgIHRoaXMuZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFDb3JuZXJcIikpO1xuICAgIH1cblxuICAgIHNldEV4dHJhQXR0cmlic0luQnVmZmVyKG9wZXJhdGlvbikge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gb3BlcmF0aW9uLmV4dHJhQXR0cmlic0RhdGFCeXRlT2Zmc2V0IC8gNDtcbiAgICAgICAgbGV0IGZsb2F0cyA9IG9wZXJhdGlvbi5xdWFkcy5mbG9hdHM7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IG9wZXJhdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50Q29yZSA9IG9wZXJhdGlvbi5nZXRFbGVtZW50Q29yZShpKTtcblxuICAgICAgICAgICAgLy8gV2UgYXJlIHNldHRpbmcgYXR0cmlidXRlcyBzdWNoIHRoYXQgaWYgdGhlIHZhbHVlIGlzIDwgMCBvciA+IDEsIGEgYm9yZGVyIHNob3VsZCBiZSBkcmF3bi5cbiAgICAgICAgICAgIGNvbnN0IGRkdyA9IHRoaXMuX3dpZHRoIC8gZWxlbWVudENvcmUudztcbiAgICAgICAgICAgIGNvbnN0IGR3ID0gZGR3IC8gKDEgLSAyICogZGR3KTtcbiAgICAgICAgICAgIGNvbnN0IGRkaCA9IHRoaXMuX3dpZHRoIC8gZWxlbWVudENvcmUuaDtcbiAgICAgICAgICAgIGNvbnN0IGRoID0gZGRoIC8gKDEgLSAyICogZGRoKTtcblxuICAgICAgICAgICAgLy8gU3BlY2lmeSBhbGwgY29ybmVyIHBvaW50cy5cbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXRdID0gLWR3O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDFdID0gLWRoO1xuXG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgMl0gPSAxICsgZHc7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgM10gPSAtZGg7XG5cbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA0XSA9IDEgKyBkdztcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA1XSA9IDEgKyBkaDtcblxuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDZdID0gLWR3O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDddID0gMSArIGRoO1xuXG4gICAgICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJlZm9yZURyYXcob3BlcmF0aW9uKSB7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliKFwiYUNvcm5lclwiKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA4LCB0aGlzLmdldFZlcnRleEF0dHJpYlBvaW50ZXJPZmZzZXQob3BlcmF0aW9uKSk7XG4gICAgfVxuXG4gICAgZ2V0RXh0cmFBdHRyaWJCeXRlc1BlclZlcnRleCgpIHtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxuXG59XG5cbk91dGxpbmVTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhQ29ybmVyO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjMiB2Q29ybmVyO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIGFWZXJ0ZXhQb3NpdGlvbi55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCAwLjAsIDEuMCk7XG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB2Q29ybmVyID0gYUNvcm5lcjtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgfVxuYDtcblxuT3V0bGluZVNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZhcnlpbmcgdmVjMiB2Q29ybmVyO1xuICAgIHVuaWZvcm0gdmVjNCBjb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIHZlYzIgbSA9IG1pbih2Q29ybmVyLCAxLjAgLSB2Q29ybmVyKTtcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBzdGVwKDAuMCwgbWluKG0ueCwgbS55KSk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IG1peChjb2xvciwgdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvciwgdmFsdWUpO1xuICAgIH1cbmA7XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBlcnNwZWN0aXZlU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcblxuICAgICAgICB0aGlzLl9mdWRnZSA9IDAuMjtcbiAgICAgICAgdGhpcy5fcnggPSAwO1xuICAgICAgICB0aGlzLl9yeSA9IDA7XG4gICAgICAgIHRoaXMuX3ogPSAxLjA7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuXG4gICAgICAgIGNvbnN0IHZyID0gb3BlcmF0aW9uLnNoYWRlck93bmVyO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdnIuZWxlbWVudDtcblxuICAgICAgICBjb25zdCBwaXZvdFggPSBlbGVtZW50LnBpdm90WCAqIHZyLnc7XG4gICAgICAgIGNvbnN0IHBpdm90WSA9IGVsZW1lbnQucGl2b3RZICogdnIuaDtcbiAgICAgICAgY29uc3QgY29vcmRzID0gdnIuZ2V0UmVuZGVyVGV4dHVyZUNvb3JkcyhwaXZvdFgsIHBpdm90WSk7XG5cbiAgICAgICAgLy8gQ291bnRlciBub3JtYWwgcm90YXRpb24uXG4gICAgICAgIGNvbnN0IHJ6ID0gLU1hdGguYXRhbjIodnIuX3JlbmRlckNvbnRleHQudGMsIHZyLl9yZW5kZXJDb250ZXh0LnRhKTtcblxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJwaXZvdFwiLCBuZXcgRmxvYXQzMkFycmF5KFtjb29yZHNbMF0sIGNvb3Jkc1sxXSwgMF0pLCBnbC51bmlmb3JtM2Z2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInJvdFwiLCBuZXcgRmxvYXQzMkFycmF5KFt0aGlzLl9yeCwgdGhpcy5fcnksIHJ6XSksIGdsLnVuaWZvcm0zZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwielwiLCB0aGlzLl96LCBnbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiZnVkZ2VcIiwgdGhpcy5fZnVkZ2UsIGdsLnVuaWZvcm0xZik7XG4gICAgfVxuXG4gICAgc2V0IGZ1ZGdlKHYpIHtcbiAgICAgICAgdGhpcy5fZnVkZ2UgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBmdWRnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1ZGdlO1xuICAgIH1cblxuICAgIGdldCByeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J4O1xuICAgIH1cblxuICAgIHNldCByeCh2KSB7XG4gICAgICAgIHRoaXMuX3J4ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yeTtcbiAgICB9XG5cbiAgICBzZXQgcnkodikge1xuICAgICAgICB0aGlzLl9yeSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96O1xuICAgIH1cblxuICAgIHNldCB6KHYpIHtcbiAgICAgICAgdGhpcy5feiA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9yeCA9PT0gMCAmJiB0aGlzLl9yeSA9PT0gMCAmJiB0aGlzLl96ID09PSAwKTtcbiAgICB9XG5cbn1cblxuUGVyc3BlY3RpdmVTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG4gICAgdW5pZm9ybSBmbG9hdCB6O1xuICAgIHVuaWZvcm0gdmVjMyBwaXZvdDtcbiAgICB1bmlmb3JtIHZlYzMgcm90O1xuICAgIHZhcnlpbmcgdmVjMyBwb3M7XG5cbiAgICB2b2lkIG1haW4odm9pZCkge1xuICAgICAgICBwb3MgPSB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbi54eSwgeik7XG4gICAgICAgIFxuICAgICAgICBwb3MgLT0gcGl2b3Q7XG4gICAgICAgIFxuICAgICAgICAvLyBVbmRvIFhZIHJvdGF0aW9uXG4gICAgICAgIG1hdDIgaVJvdFh5ID0gbWF0MiggY29zKHJvdC56KSwgc2luKHJvdC56KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAtc2luKHJvdC56KSwgY29zKHJvdC56KSk7XG4gICAgICAgIHBvcy54eSA9IGlSb3RYeSAqIHBvcy54eTtcbiAgICAgICAgXG4gICAgICAgIC8vIFBlcmZvcm0gM2Qgcm90YXRpb25zXG4gICAgICAgIGdsX1Bvc2l0aW9uLnggPSBjb3Mocm90LngpICogcG9zLnggLSBzaW4ocm90LngpICogcG9zLno7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSBwb3MueTtcbiAgICAgICAgZ2xfUG9zaXRpb24ueiA9IHNpbihyb3QueCkgKiBwb3MueCArIGNvcyhyb3QueCkgKiBwb3MuejtcbiAgICAgICAgXG4gICAgICAgIHBvcy54ID0gZ2xfUG9zaXRpb24ueDtcbiAgICAgICAgcG9zLnkgPSBjb3Mocm90LnkpICogZ2xfUG9zaXRpb24ueSAtIHNpbihyb3QueSkgKiBnbF9Qb3NpdGlvbi56O1xuICAgICAgICBwb3MueiA9IHNpbihyb3QueSkgKiBnbF9Qb3NpdGlvbi55ICsgY29zKHJvdC55KSAqIGdsX1Bvc2l0aW9uLno7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWRvIFhZIHJvdGF0aW9uXG4gICAgICAgIGlSb3RYeVswXVsxXSA9IC1pUm90WHlbMF1bMV07XG4gICAgICAgIGlSb3RYeVsxXVswXSA9IC1pUm90WHlbMV1bMF07XG4gICAgICAgIHBvcy54eSA9IGlSb3RYeSAqIHBvcy54eTsgXG5cbiAgICAgICAgLy8gVW5kbyB0cmFuc2xhdGUgdG8gcGl2b3QgcG9zaXRpb25cbiAgICAgICAgcG9zLnh5eiArPSBwaXZvdDtcblxuICAgICAgICBwb3MgPSB2ZWMzKHBvcy54ICogcHJvamVjdGlvbi54IC0gMS4wLCBwb3MueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgcG9zLnogKiBwcm9qZWN0aW9uLngpO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFwIGNvb3JkcyB0byBnbCBjb29yZGluYXRlIHNwYWNlLlxuICAgICAgICAvLyBTZXQgeiB0byAwIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBwZXJmb3JtIHotY2xpcHBpbmdcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMC4wLCB6KTtcblxuICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICBcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgIH1cbmA7XG5cblBlcnNwZWN0aXZlU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cbiAgICB1bmlmb3JtIHZlYzMgcm90O1xuICAgIHVuaWZvcm0gZmxvYXQgZnVkZ2U7XG5cbiAgICB2b2lkIG1haW4odm9pZCkge1xuICAgICAgICB2ZWMyIGNvb3JkcyA9IHZUZXh0dXJlQ29vcmQ7XG5cbiAgICAgICAgY29vcmRzLnh5IC09IHZlYzIoMC41KTtcbiAgICAgICAgY29vcmRzLnkgPSBjb29yZHMueSArIChzaWduKHJvdFswXSkgKiAwLjUgLSBjb29yZHMueCkgKiBzaW4ocm90WzBdKSAqIGZ1ZGdlICogY29vcmRzLnk7XG4gICAgICAgIGNvb3Jkcy54ID0gY29vcmRzLnggKyAoc2lnbihyb3RbMV0pICogMC41IC0gY29vcmRzLnkpICogc2luKHJvdFsxXSkgKiBmdWRnZSAqIGNvb3Jkcy54O1xuICAgICAgICBjb29yZHMueHkgKz0gdmVjMigwLjUpO1xuXG4gICAgICAgIGlmIChjb29yZHMueCA8IDAuMCB8fCBjb29yZHMueCA+IDEuMCB8fCBjb29yZHMueSA8IDAuMCB8fCBjb29yZHMueSA+IDEuMCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb29yZHMpICogdkNvbG9yO1xuICAgICAgICB9XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGktZmlsdGVycy90cmVlL21hc3Rlci9maWx0ZXJzL3BpeGVsYXRlL3NyY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaXhlbGF0ZVNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG5cbiAgICAgICAgdGhpcy5fc2l6ZSA9IG5ldyBGbG9hdDMyQXJyYXkoWzQsIDRdKTtcbiAgICB9XG5cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemVbMF07XG4gICAgfVxuXG4gICAgc2V0IHgodikge1xuICAgICAgICB0aGlzLl9zaXplWzBdID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemVbMV07XG4gICAgfVxuXG4gICAgc2V0IHkodikge1xuICAgICAgICB0aGlzLl9zaXplWzFdID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemVbMF07XG4gICAgfVxuXG4gICAgc2V0IHNpemUodikge1xuICAgICAgICB0aGlzLl9zaXplWzBdID0gdjtcbiAgICAgICAgdGhpcy5fc2l6ZVsxXSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5fc2l6ZVswXSA9PT0gMCkgJiYgKHRoaXMuX3NpemVbMV0gPT09IDApKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0V2ViR0xJbXBsKCkge1xuICAgICAgICByZXR1cm4gV2ViR0xQaXhlbGF0ZVNoYWRlckltcGw7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwic2l6ZVwiLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX3NpemUpLCBnbC51bmlmb3JtMmZ2KTtcbiAgICB9XG5cbiAgICBnZXRFeHRyYUF0dHJpYkJ5dGVzUGVyVmVydGV4KCkge1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG5cbiAgICBlbmFibGVBdHRyaWJzKCkge1xuICAgICAgICBzdXBlci5lbmFibGVBdHRyaWJzKCk7XG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYVRleHR1cmVSZXNcIikpO1xuICAgIH1cblxuICAgIGRpc2FibGVBdHRyaWJzKCkge1xuICAgICAgICBzdXBlci5kaXNhYmxlQXR0cmlicygpO1xuICAgICAgICB0aGlzLmdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZVJlc1wiKSk7XG4gICAgfVxuXG4gICAgc2V0RXh0cmFBdHRyaWJzSW5CdWZmZXIob3BlcmF0aW9uKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBvcGVyYXRpb24uZXh0cmFBdHRyaWJzRGF0YUJ5dGVPZmZzZXQgLyA0O1xuICAgICAgICBsZXQgZmxvYXRzID0gb3BlcmF0aW9uLnF1YWRzLmZsb2F0cztcblxuICAgICAgICBsZXQgbGVuZ3RoID0gb3BlcmF0aW9uLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHcgPSBvcGVyYXRpb24ucXVhZHMuZ2V0VGV4dHVyZVdpZHRoKG9wZXJhdGlvbi5pbmRleCArIGkpO1xuICAgICAgICAgICAgbGV0IGggPSBvcGVyYXRpb24ucXVhZHMuZ2V0VGV4dHVyZUhlaWdodChvcGVyYXRpb24uaW5kZXggKyBpKTtcblxuICAgICAgICAgICAgZmxvYXRzW29mZnNldF0gPSB3O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDFdID0gaDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyAyXSA9IHc7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgM10gPSBoO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDRdID0gdztcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA1XSA9IGg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgNl0gPSB3O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDddID0gaDtcblxuICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVEcmF3KG9wZXJhdGlvbikge1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYihcImFUZXh0dXJlUmVzXCIpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIHRoaXMuZ2V0RXh0cmFBdHRyaWJCeXRlc1BlclZlcnRleCgpLCB0aGlzLmdldFZlcnRleEF0dHJpYlBvaW50ZXJPZmZzZXQob3BlcmF0aW9uKSk7XG4gICAgfVxufVxuXG5QaXhlbGF0ZVNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlUmVzO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlUmVzO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54ICogcHJvamVjdGlvbi54IC0gMS4wLCBhVmVydGV4UG9zaXRpb24ueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgMC4wLCAxLjApO1xuICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICB2VGV4dHVyZVJlcyA9IGFUZXh0dXJlUmVzO1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgfVxuYDtcblxuUGl4ZWxhdGVTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVSZXM7XG5cbiAgICB1bmlmb3JtIHZlYzIgc2l6ZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICBcbiAgICB2ZWMyIG1hcENvb3JkKCB2ZWMyIGNvb3JkIClcbiAgICB7XG4gICAgICAgIGNvb3JkICo9IHZUZXh0dXJlUmVzLnh5O1xuICAgICAgICByZXR1cm4gY29vcmQ7XG4gICAgfVxuICAgIFxuICAgIHZlYzIgdW5tYXBDb29yZCggdmVjMiBjb29yZCApXG4gICAge1xuICAgICAgICBjb29yZCAvPSB2VGV4dHVyZVJlcy54eTtcbiAgICAgICAgcmV0dXJuIGNvb3JkO1xuICAgIH1cbiAgICBcbiAgICB2ZWMyIHBpeGVsYXRlKHZlYzIgY29vcmQsIHZlYzIgc2l6ZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBmbG9vciggY29vcmQgLyBzaXplICkgKiBzaXplO1xuICAgIH1cbiAgICBcbiAgICB2b2lkIG1haW4odm9pZClcbiAgICB7XG4gICAgICAgIHZlYzIgY29vcmQgPSBtYXBDb29yZCh2VGV4dHVyZUNvb3JkKTtcbiAgICAgICAgY29vcmQgPSBwaXhlbGF0ZShjb29yZCwgc2l6ZSk7XG4gICAgICAgIGNvb3JkID0gdW5tYXBDb29yZChjb29yZCk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQpICogdkNvbG9yO1xuICAgIH1cbmA7XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlhbEZpbHRlclNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IDA7XG4gICAgICAgIHRoaXMuX2N1dG9mZiA9IDE7XG4gICAgfVxuXG4gICAgc2V0IHJhZGl1cyh2KSB7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgICB9XG5cbiAgICBzZXQgY3V0b2ZmKHYpIHtcbiAgICAgICAgdGhpcy5fY3V0b2ZmID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgY3V0b2ZmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3V0b2ZmO1xuICAgIH1cbiAgICBcbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzID09PSAwO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgLy8gV2Ugc3Vic3RyYWN0IGhhbGYgYSBwaXhlbCB0byBnZXQgYSBiZXR0ZXIgY3V0b2ZmIGVmZmVjdC5cbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInJhZGl1c1wiLCAyICogKHRoaXMuX3JhZGl1cyAtIDAuNSkgLyBvcGVyYXRpb24uZ2V0UmVuZGVyV2lkdGgoKSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiY3V0b2ZmXCIsIDAuNSAqIG9wZXJhdGlvbi5nZXRSZW5kZXJXaWR0aCgpIC8gdGhpcy5fY3V0b2ZmLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgfVxuXG59XG5cblJhZGlhbEZpbHRlclNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiBwb3M7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4UG9zaXRpb24ueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgYVZlcnRleFBvc2l0aW9uLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgICAgICBwb3MgPSBnbF9Qb3NpdGlvbi54eTtcbiAgICB9XG5gO1xuXG5SYWRpYWxGaWx0ZXJTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWMyIHBvcztcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuICAgIHVuaWZvcm0gZmxvYXQgY3V0b2ZmO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgICAgIGZsb2F0IGYgPSBtYXgoMC4wLCBtaW4oMS4wLCAxLjAgLSAobGVuZ3RoKHBvcykgLSByYWRpdXMpICogY3V0b2ZmKSk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3IgKiBmO1xuICAgIH1cbmA7XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vLi4vLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpYWxHcmFkaWVudFNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX3Bpdm90ID0gWzAsIDBdO1xuICAgICAgICB0aGlzLl9pYyA9IDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRJQyA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcih0aGlzLl9pYyk7XG4gICAgICAgIHRoaXMuX29jID0gMHgwMGZmZmZmZjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZE9DID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKHRoaXMuX29jKTtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gMDtcbiAgICB9XG5cbiAgICBzZXQgcmFkaXVzWCh2KSB7XG4gICAgICAgIHRoaXMucmFkaXVzID0gdjtcbiAgICB9XG5cbiAgICBnZXQgcmFkaXVzWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgICB9XG5cbiAgICBzZXQgcmFkaXVzWSh2KSB7XG4gICAgICAgIHRoaXMuX3JhZGl1c1kgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCByYWRpdXNZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzWTtcbiAgICB9XG5cbiAgICBzZXQgcmFkaXVzKHYpIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgaW5uZXJDb2xvcihhcmdiKSB7XG4gICAgICAgIHRoaXMuX2ljID0gYXJnYjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZElDID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKGFyZ2IpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBpbm5lckNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWM7XG4gICAgfVxuXG4gICAgc2V0IG91dGVyQ29sb3IoYXJnYikge1xuICAgICAgICB0aGlzLl9vYyA9IGFyZ2I7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRPQyA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcihhcmdiKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgY29sb3IoYXJnYikge1xuICAgICAgICB0aGlzLmlubmVyQ29sb3IgPSBhcmdiO1xuICAgIH1cblxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJDb2xvcjtcbiAgICB9XG5cbiAgICBnZXQgb3V0ZXJDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ljO1xuICAgIH1cblxuICAgIHNldCB4KGYpIHtcbiAgICAgICAgdGhpcy5feCA9IGY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IHkoZikge1xuICAgICAgICB0aGlzLl95ID0gZjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3Qodikge1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KHYpICYmIHYubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdCA9IFt2WzBdLCB2WzFdIHx8IHZbMF1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGl2b3QgPSBbdiwgdl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFswXTtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RZKGYpIHtcbiAgICAgICAgdGhpcy5fcGl2b3RbMV0gPSBmO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBwaXZvdFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFsxXTtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RYKGYpIHtcbiAgICAgICAgdGhpcy5fcGl2b3RbMF0gPSBmO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBwaXZvdFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFswXTtcbiAgICB9XG5cbiAgICBfZ2V0Tm9ybWFsaXplZENvbG9yKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IFN0YWdlVXRpbHMuZ2V0UmdiYUNvbXBvbmVudHNOb3JtYWxpemVkKGNvbG9yKTtcbiAgICAgICAgY29sWzBdICo9IGNvbFszXTtcbiAgICAgICAgY29sWzFdICo9IGNvbFszXTtcbiAgICAgICAgY29sWzJdICo9IGNvbFszXTtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoY29sKTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIGNvbnN0IG93bmVyID0gb3BlcmF0aW9uLnNoYWRlck93bmVyO1xuXG4gICAgICAgIGlmKHRoaXMuX3gpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90WzBdID0gdGhpcy5feCAvIG93bmVyLnc7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5feSkge1xuICAgICAgICAgICAgdGhpcy5fcGl2b3RbMV0gPSB0aGlzLl95IC8gb3duZXIuaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuX3JhZGl1cyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gb3duZXIudyAqIDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2lubmVyQ29sb3InLCB0aGlzLl9ub3JtYWxpemVkSUMsIHRoaXMuZ2wudW5pZm9ybTRmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2ZpbGwnLCBTdGFnZVV0aWxzLmdldFJnYmFDb21wb25lbnRzTm9ybWFsaXplZCh0aGlzLl9vYylbM10sIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnb3V0ZXJDb2xvcicsIHRoaXMuX25vcm1hbGl6ZWRPQywgdGhpcy5nbC51bmlmb3JtNGZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncGl2b3QnLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX3Bpdm90KSwgIHRoaXMuZ2wudW5pZm9ybTJmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3Jlc29sdXRpb24nLCBuZXcgRmxvYXQzMkFycmF5KFtvd25lci5fdywgb3duZXIuX2hdKSwgIHRoaXMuZ2wudW5pZm9ybTJmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2FscGhhJywgb3BlcmF0aW9uLmdldEVsZW1lbnRDb3JlKDApLnJlbmRlckNvbnRleHQuYWxwaGEsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmFkaXVzJywgIHRoaXMuX3JhZGl1cywgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyYWRpdXNZJywgICh0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1cyksIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICB9XG59XG5cblJhZGlhbEdyYWRpZW50U2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIFxuICAgICNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1OVxuICAgIFxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gICAgdW5pZm9ybSB2ZWMyIHBpdm90O1xuICAgIHVuaWZvcm0gdmVjNCBpbm5lckNvbG9yO1xuICAgIHVuaWZvcm0gdmVjNCBvdXRlckNvbG9yO1xuICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzWTtcbiAgICB1bmlmb3JtIGZsb2F0IGFscGhhO1xuICAgIHVuaWZvcm0gZmxvYXQgZmlsbDtcbiAgICB1bmlmb3JtIGZsb2F0IGFzcGVjdFJhdGlvO1xuICAgIFxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjMiBwb2ludCA9IHZUZXh0dXJlQ29vcmQueHkgKiByZXNvbHV0aW9uO1xuICAgICAgICB2ZWMyIHByb2plY3Rpb24gPSB2ZWMyKHBpdm90LnggKiByZXNvbHV0aW9uLngsIHBpdm90LnkgKiByZXNvbHV0aW9uLnkpO1xuICAgICAgICBmbG9hdCBkID0gbGVuZ3RoKChwb2ludCAtIHByb2plY3Rpb24pIC8gdmVjMihyYWRpdXMgKiAyLjAsIHJhZGl1c1kgKiAyLjApKTtcbiAgICAgICAgdmVjNCBjb2xvciA9IG1peCh0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yLCBvdXRlckNvbG9yICogYWxwaGEsIGZpbGwpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBtaXgoaW5uZXJDb2xvciAqIGFscGhhLCBjb2xvciwgc21vb3Roc3RlcCgwLjAsIDEuMCwgZCkpO1xuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uLy4uLy4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91bmRlZFJlY3RhbmdsZVNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX2JsZW5kID0gMDtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gWzEsIDEsIDEsIDFdO1xuICAgICAgICB0aGlzLl9zdHJva2UgPSAwO1xuICAgICAgICB0aGlzLl9mYyA9IDB4MDBmZmZmZmY7XG4gICAgICAgIHRoaXMuX2ZpbGxDb2xvciA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcigweGZmZmZmZmZmKTtcbiAgICAgICAgdGhpcy5fc3Ryb2tlQ29sb3IgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IoMHgwMGZmZmZmZik7XG4gICAgfVxuXG4gICAgc2V0IGJsZW5kKHApIHtcbiAgICAgICAgdGhpcy5fYmxlbmQgPSBNYXRoLm1pbihNYXRoLm1heChwLCAwKSwgMSk7XG4gICAgfVxuXG4gICAgc2V0IHJhZGl1cyh2KSB7XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGlmKHYubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gW3ZbMF0sIHZbMV0sIHZbMF0sIHZbMV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih2Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IFt2WzBdLCB2WzFdLCB2WzJdLCB0aGlzLl9yYWRpdXNbM11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodi5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYWRpdXMgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gW3ZbMF0sIHZbMF0sIHZbMF0sIHZbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gW3YsIHYsIHYsIHZdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgICB9XG5cbiAgICBzZXQgdG9wTGVmdChudW0pIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzWzBdID0gbnVtO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCB0b3BMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzWzBdO1xuICAgIH1cblxuICAgIHNldCB0b3BSaWdodChudW0pIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzWzFdID0gbnVtO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCB0b3BSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1c1sxXTtcbiAgICB9XG5cbiAgICBzZXQgYm90dG9tUmlnaHQobnVtKSB7XG4gICAgICAgIHRoaXMuX3JhZGl1c1syXSA9IG51bTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgYm90dG9tUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXNbMl07XG4gICAgfVxuXG4gICAgc2V0IGJvdHRvbUxlZnQobnVtKSB7XG4gICAgICAgIHRoaXMuX3JhZGl1c1szXSA9IG51bTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgYm90dG9tTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1c1s0XTtcbiAgICB9XG5cbiAgICBzZXQgc3Ryb2tlQ29sb3IoYXJnYikge1xuICAgICAgICB0aGlzLl9zYyA9IGFyZ2I7XG4gICAgICAgIHRoaXMuX3N0cm9rZUNvbG9yID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKGFyZ2IpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBzdHJva2VDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjO1xuICAgIH1cblxuICAgIHNldCBmaWxsQ29sb3IoYXJnYikge1xuICAgICAgICB0aGlzLl9mYyA9IGFyZ2I7XG4gICAgICAgIHRoaXMuX2ZpbGxDb2xvciA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcihhcmdiKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgZmlsbENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmM7XG4gICAgfVxuXG4gICAgc2V0IHN0cm9rZShudW0pIHtcbiAgICAgICAgdGhpcy5fc3Ryb2tlID0gbnVtO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBzdHJva2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJva2U7XG4gICAgfVxuXG4gICAgX2dldE5vcm1hbGl6ZWRDb2xvcihjb2xvcikge1xuICAgICAgICBjb25zdCBjb2wgPSBTdGFnZVV0aWxzLmdldFJnYmFDb21wb25lbnRzTm9ybWFsaXplZChjb2xvcik7XG4gICAgICAgIGNvbFswXSAqPSBjb2xbM107XG4gICAgICAgIGNvbFsxXSAqPSBjb2xbM107XG4gICAgICAgIGNvbFsyXSAqPSBjb2xbM107XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGNvbCk7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICBjb25zdCBvd25lciA9IG9wZXJhdGlvbi5zaGFkZXJPd25lcjtcbiAgICAgICAgY29uc3QgcmVuZGVyUHJlY2lzaW9uID0gdGhpcy5jdHguc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG4gICAgICAgIGNvbnN0IF9yYWRpdXMgPSB0aGlzLl9yYWRpdXMubWFwKChyKSA9PiAociArIDAuNSkgKiByZW5kZXJQcmVjaXNpb24pXG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3JhZGl1cycsIG5ldyBGbG9hdDMyQXJyYXkoX3JhZGl1cyksIHRoaXMuZ2wudW5pZm9ybTRmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2FscGhhJywgb3BlcmF0aW9uLmdldEVsZW1lbnRDb3JlKDApLnJlbmRlckNvbnRleHQuYWxwaGEsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnYmxlbmQnLCB0aGlzLl9ibGVuZCwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdzdHJva2VDb2xvcicsIHRoaXMuX3N0cm9rZUNvbG9yLCB0aGlzLmdsLnVuaWZvcm00ZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdmaWxsQ29sb3InLCB0aGlzLl9maWxsQ29sb3IsIHRoaXMuZ2wudW5pZm9ybTRmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3N0cm9rZScsICB0aGlzLl9zdHJva2UgKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmVzb2x1dGlvbicsIG5ldyBGbG9hdDMyQXJyYXkoW293bmVyLl93ICogcmVuZGVyUHJlY2lzaW9uLCBvd25lci5faCAqIHJlbmRlclByZWNpc2lvbl0pLCB0aGlzLmdsLnVuaWZvcm0yZnYpO1xuICAgIH1cbn1cblxuUm91bmRlZFJlY3RhbmdsZVNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5cbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcblxuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54ICogcHJvamVjdGlvbi54IC0gMS4wLCBhVmVydGV4UG9zaXRpb24ueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgMC4wLCAxLjApO1xuICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgfVxuYDtcblxuUm91bmRlZFJlY3RhbmdsZVNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcblxuICAgICNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1OVxuXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gdmVjNCByYWRpdXM7XG4gICAgdW5pZm9ybSBmbG9hdCBzdHJva2U7XG4gICAgdW5pZm9ybSB2ZWM0IHN0cm9rZUNvbG9yO1xuICAgIHVuaWZvcm0gdmVjNCBmaWxsQ29sb3I7XG4gICAgdW5pZm9ybSBmbG9hdCBhbHBoYTtcbiAgICB1bmlmb3JtIGZsb2F0IGZpbGw7XG4gICAgdW5pZm9ybSBmbG9hdCBibGVuZDtcbiAgICBcbiAgICBmbG9hdCBib3hEaXN0KHZlYzIgcCwgdmVjMiBzaXplLCBmbG9hdCByYWRpdXMpe1xuICAgICAgICBzaXplIC09IHZlYzIocmFkaXVzKTtcbiAgICAgICAgdmVjMiBkID0gYWJzKHApIC0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIG1pbihtYXgoZC54LCBkLnkpLCAwLjApICsgbGVuZ3RoKG1heChkLCAwLjApKSAtIHJhZGl1cztcbiAgICB9XG4gICAgXG4gICAgZmxvYXQgZmlsbE1hc2soZmxvYXQgZGlzdCl7XG4gICAgICAgIHJldHVybiBjbGFtcCgtZGlzdCwgMC4wLCAxLjApO1xuICAgIH1cbiAgICBcbiAgICBmbG9hdCBpbm5lckJvcmRlck1hc2soZmxvYXQgZGlzdCwgZmxvYXQgd2lkdGgpe1xuICAgICAgICBmbG9hdCBhbHBoYTEgPSBjbGFtcChkaXN0ICsgd2lkdGgsIDAuMCwgMS4wKTtcbiAgICAgICAgZmxvYXQgYWxwaGEyID0gY2xhbXAoZGlzdCwgMC4wLCAxLjApO1xuICAgICAgICByZXR1cm4gYWxwaGExIC0gYWxwaGEyO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjMiBoYWxmUmVzID0gMC41ICogcmVzb2x1dGlvbi54eTtcbiAgICAgICAgZmxvYXQgciA9IDAuMDtcbiAgICAgICAgaWYgKHZUZXh0dXJlQ29vcmQueCA8IDAuNSAmJiB2VGV4dHVyZUNvb3JkLnkgPCAwLjUpIHtcbiAgICAgICAgICAgIHIgPSByYWRpdXNbMF07XG4gICAgICAgIH0gZWxzZSBpZiAodlRleHR1cmVDb29yZC54ID49IDAuNSAmJiB2VGV4dHVyZUNvb3JkLnkgPCAwLjUpIHtcbiAgICAgICAgICAgIHIgPSByYWRpdXNbMV07XG4gICAgICAgIH0gZWxzZSBpZiAodlRleHR1cmVDb29yZC54ID49IDAuNSAmJiB2VGV4dHVyZUNvb3JkLnkgPj0gMC41KSB7XG4gICAgICAgICAgICByID0gcmFkaXVzWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IHJhZGl1c1szXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZmxvYXQgYiA9IGJveERpc3QodlRleHR1cmVDb29yZC54eSAqIHJlc29sdXRpb24gLSBoYWxmUmVzLCBoYWxmUmVzIC0gMC4wMDUsIHIpO1xuICAgICAgICB2ZWM0IHRleCA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XG4gICAgICAgIHZlYzQgYmxlbmQgPSBtaXgodmVjNCgxLjApICogYWxwaGEsIHRleCwgYmxlbmQpOyAgICAgXG4gICAgICAgIHZlYzQgbGF5ZXIxID0gbWl4KHZlYzQoMC4wKSwgdGV4ICogZmlsbENvbG9yLCBmaWxsTWFzayhiKSk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IG1peChsYXllcjEsIGJsZW5kICogc3Ryb2tlQ29sb3IsIGlubmVyQm9yZGVyTWFzayhiLCBzdHJva2UpKTtcbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gJy4uLy4uLy4uL3RyZWUvU3RhZ2VVdGlscy5tanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwaW5uZXJTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSAxMDA7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gNTA7XG4gICAgICAgIHRoaXMuX3BlcmlvZCA9IDE7XG4gICAgICAgIHRoaXMuX2FuZ2xlID0gMC41O1xuICAgICAgICB0aGlzLl9zbW9vdGggPSAwLjAwNTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSAweGZmMDAwMDAwO1xuICAgICAgICB0aGlzLl90aW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICBzZXQgcmFkaXVzKHYpIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgd2lkdGgodikge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IHBlcmlvZCh2KSB7XG4gICAgICAgIHRoaXMuX3BlcmlvZCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IGFuZ2xlKHYpIHtcbiAgICAgICAgdGhpcy5fYW5nbGUgPSB2XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IHNtb290aCh2KSB7XG4gICAgICAgIHRoaXMuX3Ntb290aCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yKHYpIHtcbiAgICAgICAgdGhpcy5fY29sb3IgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCBiYWNrZ3JvdW5kQ29sb3Iodikge1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgY29uc3Qgb3duZXIgPSBvcGVyYXRpb24uc2hhZGVyT3duZXJcblxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiaVRpbWVcIiwgRGF0ZS5ub3coKSAtIHRoaXMuX3RpbWUsIHRoaXMuZ2wudW5pZm9ybTFmKTtcblxuICAgICAgICBjb25zdCByZW5kZXJQcmVjaXNpb24gPSB0aGlzLmN0eC5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmFkaXVzJywgdGhpcy5fcmFkaXVzICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3dpZHRoJywgdGhpcy5fd2lkdGggKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncGVyaW9kJywgdGhpcy5fcGVyaW9kLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2FuZ2xlJywgdGhpcy5fYW5nbGUsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnc21vb3RoJywgdGhpcy5fc21vb3RoLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2NvbG9yJywgbmV3IEZsb2F0MzJBcnJheShTdGFnZVV0aWxzLmdldFJnYmFDb21wb25lbnRzTm9ybWFsaXplZCh0aGlzLl9jb2xvcikpLCB0aGlzLmdsLnVuaWZvcm00ZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdiYWNrZ3JvdW5kQ29sb3InLCBuZXcgRmxvYXQzMkFycmF5KFN0YWdlVXRpbHMuZ2V0UmdiYUNvbXBvbmVudHNOb3JtYWxpemVkKHRoaXMuX2JhY2tncm91bmRDb2xvcikpLCB0aGlzLmdsLnVuaWZvcm00ZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyZXNvbHV0aW9uJywgbmV3IEZsb2F0MzJBcnJheShbb3duZXIuX3cgKiByZW5kZXJQcmVjaXNpb24sIG93bmVyLl9oICogcmVuZGVyUHJlY2lzaW9uXSksIHRoaXMuZ2wudW5pZm9ybTJmdilcblxuICAgICAgICB0aGlzLnJlZHJhdygpXG4gICAgfVxufVxuXG5TcGlubmVyU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IERlZmF1bHRTaGFkZXIudmVydGV4U2hhZGVyU291cmNlO1xuXG5TcGlubmVyU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cbiAgICB1bmlmb3JtIGZsb2F0IGlUaW1lO1xuICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuICAgIHVuaWZvcm0gZmxvYXQgd2lkdGg7XG4gICAgdW5pZm9ybSBmbG9hdCBwZXJpb2Q7XG4gICAgdW5pZm9ybSBmbG9hdCBhbmdsZTtcbiAgICB1bmlmb3JtIGZsb2F0IHNtb290aDtcbiAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcblxuICAgIHVuaWZvcm0gdmVjNCBjb2xvcjtcbiAgICB1bmlmb3JtIHZlYzQgYmFja2dyb3VuZENvbG9yO1xuXG4gICAgZmxvYXQgcmF0aW8gPSByZXNvbHV0aW9uLnkgLyByZXNvbHV0aW9uLng7XG5cbiAgICB2ZWMyIHRyYW5zcG9zZV9wb3ModmVjMiBwb3MpIHtcbiAgICAgICAgaWYgKHJhdGlvIDwgMS4pIHtcbiAgICAgICAgICAgIGZsb2F0IGRpZmYgPSAwLjUgLSBwb3MueDtcbiAgICAgICAgICAgIHBvcy54ID0gMC41IC0gZGlmZiAvIHJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxvYXQgZGlmZiA9IDAuNSAtIHBvcy55O1xuICAgICAgICAgICAgcG9zLnkgPSAwLjUgLSBkaWZmICogcmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cbiAgICBmbG9hdCBnZXRfYW5nbGUodmVjMiBwb3MpIHtcbiAgICAgICAgcG9zID0gdHJhbnNwb3NlX3Bvcyhwb3MpO1xuICAgICAgICBmbG9hdCBhID0gYXRhbihwb3MueSAtIDAuNSwgcG9zLnggLSAwLjUpO1xuICAgICAgICBhID0gKDEuMCthLzMuMTQxNTkpLzIuMDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZsb2F0IGRpc3QodmVjMiBwb3MxLCB2ZWMyIHBvczIpIHtcbiAgICAgICAgcG9zMSA9IHRyYW5zcG9zZV9wb3MocG9zMSk7XG4gICAgICAgIHJldHVybiBkaXN0YW5jZShwb3MxLCBwb3MyKTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKVxuICAgIHtcbiAgICAgICAgdmVjMiBmcmFnQ29vcmQgPSB2VGV4dHVyZUNvb3JkO1xuICAgICAgICB2ZWM0IGZyYWdDb2xvciA9IHZDb2xvcjtcbiAgICAgICAgXG4gICAgICAgIHZlYzIgc3QgPSB2VGV4dHVyZUNvb3JkO1xuICAgICAgICBmbG9hdCBwY3QgPSBkaXN0KHN0LCB2ZWMyKDAuNSkpO1xuXG4gICAgICAgIGZsb2F0IGEgPSBnZXRfYW5nbGUoc3QpO1xuICAgICAgICBmbG9hdCB0ID0gaVRpbWUgLyAxMDAwLjAgLyBwZXJpb2Q7XG5cbiAgICAgICAgZmxvYXQgaW5uZXIgPSBtYXgoKHJhZGl1cyAtIHdpZHRoKSAvIHJlc29sdXRpb24ueCwgKHJhZGl1cyAtIHdpZHRoKSAvIHJlc29sdXRpb24ueSk7XG4gICAgICAgIGZsb2F0IG91dGVyID0gbWF4KHJhZGl1cyAvIHJlc29sdXRpb24ueCwgcmFkaXVzIC8gcmVzb2x1dGlvbi55KTtcblxuICAgICAgICBmbG9hdCB4MSA9IG1vZCh0LCAxLjApO1xuICAgICAgICBmbG9hdCB4MiA9IG1vZCh0ICsgYW5nbGUsIDEuMCk7XG5cbiAgICAgICAgaWYgKHgxIDwgeDIpIHtcbiAgICAgICAgICAgIGlmIChhID4geDEgJiYgYSA8IHgyKSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgdmFsID0gKDEuMCAtICh4MiAtIGEpIC8gYW5nbGUpICogc21vb3Roc3RlcCgwLjAsIDMuICogc21vb3RoLCAoeDIgLSBhKSk7XG4gICAgICAgICAgICAgICAgZnJhZ0NvbG9yID0gbWl4KGJhY2tncm91bmRDb2xvciwgY29sb3IsIHZhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWdDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhIDwgeDIpIHtcbiAgICAgICAgICAgICAgICBmbG9hdCB2YWwgPSAoMS4wIC0gKHgyIC0gYSkgLyBhbmdsZSkgKiBzbW9vdGhzdGVwKDAuMCwgMy4gKiBzbW9vdGgsICh4MiAtIGEpKTtcbiAgICAgICAgICAgICAgICBmcmFnQ29sb3IgPSBtaXgoYmFja2dyb3VuZENvbG9yLCBjb2xvciwgdmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYSA+IHgxKSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgdmFsID0gKDEuMCAtICgxLjAgKyB4MiAtIGEpIC8gYW5nbGUpICogc21vb3Roc3RlcCgwLjAsIDMuICogc21vb3RoLCAoMS4wICsgeDIgLSBhKSk7XG4gICAgICAgICAgICAgICAgZnJhZ0NvbG9yID0gbWl4KGJhY2tncm91bmRDb2xvciwgY29sb3IsIHZhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWdDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2F0IHMgPSBzbW9vdGhzdGVwKGlubmVyLCBpbm5lciArIHNtb290aCArIDAuMDAwMDEsIHBjdCkgKiAoMS4wIC0gc21vb3Roc3RlcChvdXRlciwgb3V0ZXIgKyBzbW9vdGggKyAwLjAwMDAxLCBwY3QpKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBmcmFnQ29vcmQpICogdkNvbG9yICogKDEuIC0gcyAqIGZyYWdDb2xvci5hKSArIGZyYWdDb2xvciAqIHM7XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vLi4vLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGlubmVyU2hhZGVyMiBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX3BlcmlvZCA9IDE7XG4gICAgICAgIHRoaXMuX3N0cm9rZSA9IDA7XG4gICAgICAgIHRoaXMuX3Nob3dEb3QgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jbG9ja3dpc2UgPSB0cnVlO1xuICAgICAgICB0aGlzLl9iYyA9IDB4ZmYwMDAwMDA7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRCQyA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcih0aGlzLl9iYyk7XG4gICAgICAgIHRoaXMuX2MgPSAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVkQyA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcih0aGlzLl9jKTtcbiAgICB9XG5cbiAgICBzZXQgcmFkaXVzKHYpIHtcbiAgICAgICAgaWYodiA9PT0gMCkge1xuICAgICAgICAgICAgdiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmFkaXVzID0gdjtcbiAgICB9XG5cbiAgICBzZXQgc3Ryb2tlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3N0cm9rZSA9IE1hdGguYWJzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBnZXQgc3Ryb2tlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xuICAgIH1cblxuICAgIHNldCBjb2xvcihhcmdiKSB7XG4gICAgICAgIHRoaXMuX2MgPSBhcmdiO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVkQyA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcihhcmdiKTtcbiAgICB9XG5cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jO1xuICAgIH1cblxuICAgIHNldCBiYWNrZ3JvdW5kQ29sb3IoYXJnYikge1xuICAgICAgICB0aGlzLl9iYyA9IGFyZ2I7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRCQyA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcihhcmdiKTtcbiAgICB9XG5cbiAgICBnZXQgYmFja2dyb3VuZENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2M7XG4gICAgfVxuXG4gICAgc2V0IHNob3dEb3QoYm9vbCkge1xuICAgICAgICB0aGlzLl9zaG93RG90ID0gYm9vbDtcbiAgICB9XG5cbiAgICBnZXQgc2hvd0RvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dEb3Q7XG4gICAgfVxuXG4gICAgc2V0IGNsb2Nrd2lzZShib29sKSB7XG4gICAgICAgIHRoaXMuX2Nsb2Nrd2lzZSA9IGJvb2w7XG4gICAgfVxuXG4gICAgZ2V0IGNsb2Nrd2lzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb2Nrd2lzZTtcbiAgICB9XG5cbiAgICBzZXQgcGVyaW9kKHYpIHtcbiAgICAgICAgdGhpcy5fcGVyaW9kID0gdjtcbiAgICB9XG5cbiAgICBnZXQgcGVyaW9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVyaW9kO1xuICAgIH1cblxuICAgIF9nZXROb3JtYWxpemVkQ29sb3IoY29sb3IpIHtcbiAgICAgICAgY29uc3QgY29sID0gU3RhZ2VVdGlscy5nZXRSZ2JhQ29tcG9uZW50c05vcm1hbGl6ZWQoY29sb3IpO1xuICAgICAgICBjb2xbMF0gKj0gY29sWzNdO1xuICAgICAgICBjb2xbMV0gKj0gY29sWzNdO1xuICAgICAgICBjb2xbMl0gKj0gY29sWzNdO1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShjb2wpO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgY29uc3Qgb3duZXIgPSBvcGVyYXRpb24uc2hhZGVyT3duZXI7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMuX3JhZGl1cyB8fCAob3duZXIuX3cgLyAyKTtcblxuICAgICAgICBpZih0aGlzLl9zdHJva2UgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZSA9IHJhZGl1cyAqIDAuMzM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyZXNvbHV0aW9uJywgbmV3IEZsb2F0MzJBcnJheShbb3duZXIuX3csIG93bmVyLl9oXSksICB0aGlzLmdsLnVuaWZvcm0yZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdjb2xvcicsIHRoaXMuX25vcm1hbGl6ZWRDLCB0aGlzLmdsLnVuaWZvcm00ZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdiYWNrZ3JvdW5kQ29sb3InLCB0aGlzLl9ub3JtYWxpemVkQkMsIHRoaXMuZ2wudW5pZm9ybTRmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3N0cm9rZScsICB0aGlzLl9zdHJva2UsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmFkaXVzJywgIHJhZGl1cywgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdkaXJlY3Rpb24nLCAgdGhpcy5fY2xvY2t3aXNlID8gLTEgOiAxLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3Nob3dEb3QnLCAhIXRoaXMuX3Nob3dEb3QsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgndGltZScsIERhdGUubm93KCkgLSBTcGlubmVyU2hhZGVyMi5zcGluU3luYywgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdwZXJpb2QnLCB0aGlzLl9wZXJpb2QsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnYWxwaGEnLCBvcGVyYXRpb24uZ2V0RWxlbWVudENvcmUoMCkucmVuZGVyQ29udGV4dC5hbHBoYSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuXG4gICAgICAgIGlmKHRoaXMuX3NjICE9PSB0aGlzLl9iYyB8fCB0aGlzLl9zdHJva2UgIT09IHJhZGl1cyAqIDAuNSkge1xuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuU3Bpbm5lclNoYWRlcjIuc3BpblN5bmMgPSBEYXRlLm5vdygpO1xuXG5TcGlubmVyU2hhZGVyMi5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBcbiAgICAjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcbiAgICBcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gdmVjNCBjb2xvcjtcbiAgICB1bmlmb3JtIHZlYzQgYmFja2dyb3VuZENvbG9yO1xuICAgIHVuaWZvcm0gZmxvYXQgZGlyZWN0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuICAgIHVuaWZvcm0gZmxvYXQgdGltZTtcbiAgICB1bmlmb3JtIGZsb2F0IHN0cm9rZTtcbiAgICB1bmlmb3JtIGZsb2F0IHNob3dEb3Q7XG4gICAgdW5pZm9ybSBmbG9hdCBwZXJpb2Q7XG4gICAgdW5pZm9ybSBmbG9hdCBhbHBoYTtcbiAgICBcbiAgICBmbG9hdCBjaXJjbGVEaXN0KHZlYzIgcCwgZmxvYXQgcmFkaXVzKXtcbiAgICAgICAgcmV0dXJuIGxlbmd0aChwKSAtIHJhZGl1cztcbiAgICB9XG4gICAgXG4gICAgZmxvYXQgZmlsbE1hc2soZmxvYXQgZGlzdCl7XG4gICAgICAgIHJldHVybiBjbGFtcCgtZGlzdCwgMC4wLCAxLjApO1xuICAgIH1cbiAgICBcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzIgaGFsZlJlcyA9IDAuNSAqIHJlc29sdXRpb24ueHk7XG4gICAgICAgIHZlYzIgY2VudGVyID0gdlRleHR1cmVDb29yZC54eSAqIHJlc29sdXRpb24gLSBoYWxmUmVzO1xuICAgICAgICBcbiAgICAgICAgZmxvYXQgYyA9IG1heCgtY2lyY2xlRGlzdChjZW50ZXIsIHJhZGl1cyAtIHN0cm9rZSksIGNpcmNsZURpc3QoY2VudGVyLCByYWRpdXMpKTtcbiAgICAgICAgZmxvYXQgcm90ID0gLSh0aW1lIC8gMTAwMC4wIC8gcGVyaW9kKSAqIDYuMCAqIGRpcmVjdGlvbjtcbiAgICAgICAgY2VudGVyICo9IG1hdDIoY29zKHJvdCksIHNpbihyb3QpLCAtc2luKHJvdCksIGNvcyhyb3QpKTtcbiAgICAgICAgXG4gICAgICAgIGZsb2F0IGEgPSBkaXJlY3Rpb24gKiBhdGFuKGNlbnRlci54LCBjZW50ZXIueSkgKiBQSSAqIDAuMDUgKyAwLjQ1O1xuICAgICAgICBcbiAgICAgICAgZmxvYXQgc3Ryb2tlUmFkID0gc3Ryb2tlICogMC41O1xuICAgICAgICBhID0gbWl4KGEsIG1heChhLCBmaWxsTWFzayhjaXJjbGVEaXN0KHZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgKHJhZGl1cyAtIHN0cm9rZVJhZCkpLCBzdHJva2VSYWQpKSksIHNob3dEb3QpO1xuICAgICAgICB2ZWM0IGJhc2UgPSBtaXgodmVjNCgwLjApLCBiYWNrZ3JvdW5kQ29sb3IgKiBhbHBoYSwgZmlsbE1hc2soYykpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBtaXgoYmFzZSwgY29sb3IgKiBhbHBoYSwgZmlsbE1hc2soYykgKiBhKTtcbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlnbmV0dGVTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9tYWduaXR1ZGUgPSAxLjM7XG4gICAgICAgIHRoaXMuX2ludGVuc2l0eSA9IDAuNztcbiAgICAgICAgdGhpcy5fcGl2b3QgPSBbMC41LCAwLjVdO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcblxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwibWFnbml0dWRlXCIsIHRoaXMuX21hZ25pdHVkZSAsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImludGVuc2l0eVwiLCB0aGlzLl9pbnRlbnNpdHksIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncGl2b3QnLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX3Bpdm90KSwgdGhpcy5nbC51bmlmb3JtMmZ2KTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKVxuICAgIH1cblxuICAgIHNldCBwaXZvdCh2KSB7XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90ID0gW3YsIHZdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WzBdO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFgodikge1xuICAgICAgICB0aGlzLl9waXZvdFswXSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WzFdO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFkodikge1xuICAgICAgICB0aGlzLl9waXZvdFsxXSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGludGVuc2l0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVuc2l0eTtcbiAgICB9XG5cbiAgICBzZXQgaW50ZW5zaXR5KHYpIHtcbiAgICAgICAgdGhpcy5faW50ZW5zaXR5ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgbWFnbml0dWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFnbml0dWRlO1xuXG4gICAgfVxuXG4gICAgc2V0IG1hZ25pdHVkZSh2KSB7XG4gICAgICAgIHRoaXMuX21hZ25pdHVkZSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxufVxuXG5WaWduZXR0ZVNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBEZWZhdWx0U2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZTtcblxuVmlnbmV0dGVTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcblxuICAgIHVuaWZvcm0gZmxvYXQgbWFnbml0dWRlO1xuICAgIHVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O1xuICAgIHVuaWZvcm0gdmVjMiBwaXZvdDtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjMiB1diA9IHZUZXh0dXJlQ29vcmQueHkgLSBwaXZvdCArIHZlYzIoMC41KTtcbiAgICAgICAgdXYueCA9IGNsYW1wKHV2LngsIDAuMCwgMS4wKTtcbiAgICAgICAgdXYueSA9IGNsYW1wKHV2LnksIDAuMCwgMS4wKTtcbiAgIFxuICAgICAgICB1diAqPSAgMS4wMCAtIHV2Lnl4O1xuICAgICAgICBmbG9hdCB2aWcgPSB1di54ICogdXYueSAqIDI1LjAgKiBpbnRlbnNpdHk7XG4gICAgICAgIHZpZyA9IHBvdyh2aWcsIDAuNDUgKiBtYWduaXR1ZGUpO1xuICAgICAgICB2ZWM0IGZyYWdDb2xvciA9IHZlYzQodmlnKSAqIHZDb2xvcjtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIGZyYWdDb2xvcjtcblxuICAgIH1cbmBcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuLi90cmVlL1RleHR1cmUubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEh0bWxUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG4gICAgICAgIHRoaXMuX2h0bWxFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zY2FsZSA9IDE7XG4gICAgfVxuXG4gICAgc2V0IGh0bWxFbGVtZW50KHYpIHtcbiAgICAgICAgdGhpcy5faHRtbEVsZW1lbnQgPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgZ2V0IGh0bWxFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faHRtbEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgc2V0IHNjYWxlKHYpIHtcbiAgICAgICAgdGhpcy5fc2NhbGUgPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gICAgfVxuXG4gICAgc2V0IGh0bWwodikge1xuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgIHRoaXMuaHRtbEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBkLmlubmVySFRNTCA9IFwiPGRpdj5cIiArIHYgKyBcIjwvZGl2PlwiO1xuICAgICAgICAgICAgdGhpcy5odG1sRWxlbWVudCA9IGQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaHRtbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2h0bWxFbGVtZW50LmlubmVySFRNTDtcbiAgICB9XG5cbiAgICBfZ2V0SXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHRtbEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgX2dldExvb2t1cElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGUgKyBcIjpcIiArIHRoaXMuX2h0bWxFbGVtZW50LmlubmVySFRNTDtcbiAgICB9XG5cbiAgICBfZ2V0U291cmNlTG9hZGVyKCkge1xuICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IHRoaXMuX2h0bWxFbGVtZW50O1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX3NjYWxlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgIGlmICghd2luZG93Lmh0bWwyY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihcIlBsZWFzZSBpbmNsdWRlIGh0bWwyY2FudmFzIChodHRwczovL2h0bWwyY2FudmFzLmhlcnR6ZW4uY29tLylcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhcmVhID0gSHRtbFRleHR1cmUuZ2V0UHJlbG9hZEFyZWEoKTtcbiAgICAgICAgICAgIGFyZWEuYXBwZW5kQ2hpbGQoaHRtbEVsZW1lbnQpO1xuXG4gICAgICAgICAgICBodG1sMmNhbnZhcyhodG1sRWxlbWVudCwge2JhY2tncm91bmRDb2xvcjogbnVsbCwgc2NhbGU6IHNjYWxlfSkudGhlbihmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgICAgICAgICAgICBhcmVhLnJlbW92ZUNoaWxkKGh0bWxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKFwiQ2FudmFzIGhlaWdodCBpcyAwXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2IobnVsbCwge3NvdXJjZTogY2FudmFzLCB3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHR9KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tMaWdodG5pbmddJywgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRQcmVsb2FkQXJlYSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcmVsb2FkQXJlYSkge1xuICAgICAgICAgICAgLy8gUHJlbG9hZCBhcmVhIG11c3QgYmUgaW5jbHVkZWQgaW4gZG9jdW1lbnQgYm9keSBhbmQgbXVzdCBiZSB2aXNpYmxlIHRvIHRyaWdnZXIgaHRtbCBlbGVtZW50IHJlbmRlcmluZy5cbiAgICAgICAgICAgIHRoaXMuX3ByZWxvYWRBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJlbG9hZEFyZWEuYXR0YWNoU2hhZG93KSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGEgc2hhZG93IERPTSBpZiBwb3NzaWJsZSB0byBwcmV2ZW50IHN0eWxpbmcgZnJvbSBpbnRlcmZlcmluZy5cbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVsb2FkQXJlYS5hdHRhY2hTaGFkb3coe21vZGU6ICdjbG9zZWQnfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcmVsb2FkQXJlYS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3ByZWxvYWRBcmVhLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLl9wcmVsb2FkQXJlYS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgICB0aGlzLl9wcmVsb2FkQXJlYS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRoaXMuX3ByZWxvYWRBcmVhLnN0eWxlLnRvcCA9ICcxMDB2aCc7XG4gICAgICAgICAgICB0aGlzLl9wcmVsb2FkQXJlYS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9wcmVsb2FkQXJlYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWxvYWRBcmVhO1xuICAgIH1cbn1cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4uL3RyZWUvVGV4dHVyZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1hZ2VUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG5cbiAgICAgICAgdGhpcy5fc3JjID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9oYXNBbHBoYSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBzcmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcmM7XG4gICAgfVxuXG4gICAgc2V0IHNyYyh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zcmMgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3NyYyA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaGFzQWxwaGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNBbHBoYTtcbiAgICB9XG5cbiAgICBzZXQgaGFzQWxwaGEodikge1xuICAgICAgICBpZiAodGhpcy5faGFzQWxwaGEgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc0FscGhhID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRJc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zcmM7XG4gICAgfVxuXG4gICAgX2dldExvb2t1cElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3JjO1xuICAgIH1cblxuICAgIF9nZXRTb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgIGxldCBzcmMgPSB0aGlzLl9zcmM7XG4gICAgICAgIGxldCBoYXNBbHBoYSA9IHRoaXMuX2hhc0FscGhhO1xuICAgICAgICBpZiAodGhpcy5zdGFnZS5nZXRPcHRpb24oJ3NyY0Jhc2VQYXRoJykpIHtcbiAgICAgICAgICAgIHZhciBmYyA9IHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKChzcmMuaW5kZXhPZihcIi8vXCIpID09PSAtMSkgJiYgKChmYyA+PSA2NSAmJiBmYyA8PSA5MCkgfHwgKGZjID49IDk3ICYmIGZjIDw9IDEyMikgfHwgZmMgPT0gNDYpKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxwaGFiZXRpY2FsIG9yIGRvdDogcHJlcGVuZCBiYXNlIHBhdGguXG4gICAgICAgICAgICAgICAgc3JjID0gdGhpcy5zdGFnZS5nZXRPcHRpb24oJ3NyY0Jhc2VQYXRoJykgKyBzcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGNiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFnZS5wbGF0Zm9ybS5sb2FkU3JjVGV4dHVyZSh7c3JjOiBzcmMsIGhhc0FscGhhOiBoYXNBbHBoYX0sIGNiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldE5vbkRlZmF1bHRzKCkge1xuICAgICAgICBjb25zdCBvYmogPSBzdXBlci5nZXROb25EZWZhdWx0cygpO1xuICAgICAgICBpZiAodGhpcy5fc3JjKSB7XG4gICAgICAgICAgICBvYmouc3JjID0gdGhpcy5fc3JjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG59XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuLi90cmVlL1RleHR1cmUubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vaXNlVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG4gICAgX2dldExvb2t1cElkKCkge1xuICAgICAgICByZXR1cm4gJ19fbm9pc2UnO1xuICAgIH1cblxuICAgIF9nZXRTb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5zdGFnZS5nbDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICBjb25zdCBub2lzZSA9IG5ldyBVaW50OEFycmF5KDEyOCAqIDEyOCAqIDQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjggKiAxMjggKiA0OyBpKz00KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgICAgICAgICAgICAgbm9pc2VbaV0gPSB2O1xuICAgICAgICAgICAgICAgIG5vaXNlW2krMV0gPSB2O1xuICAgICAgICAgICAgICAgIG5vaXNlW2krMl0gPSB2O1xuICAgICAgICAgICAgICAgIG5vaXNlW2krM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXhQYXJhbXMgPSB7fVxuXG4gICAgICAgICAgICBpZiAoZ2wpIHtcbiAgICAgICAgICAgICAgICB0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9XUkFQX1NdID0gZ2wuUkVQRUFUO1xuICAgICAgICAgICAgICAgIHRleFBhcmFtc1tnbC5URVhUVVJFX1dSQVBfVF0gPSBnbC5SRVBFQVQ7XG4gICAgICAgICAgICAgICAgdGV4UGFyYW1zW2dsLlRFWFRVUkVfTUlOX0ZJTFRFUl0gPSBnbC5ORUFSRVNUO1xuICAgICAgICAgICAgICAgIHRleFBhcmFtc1tnbC5URVhUVVJFX01BR19GSUxURVJdID0gZ2wuTkVBUkVTVDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2IobnVsbCwge3NvdXJjZTogbm9pc2UsIHc6IDEyOCwgaDogMTI4LCB0ZXhQYXJhbXM6IHRleFBhcmFtc30pO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi4vdHJlZS9UZXh0dXJlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0YW5nbGVUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cbiAgICBfZ2V0TG9va3VwSWQoKSB7XG4gICAgICAgIHJldHVybiAnX193aGl0ZXBpeCc7XG4gICAgfVxuXG4gICAgX2dldFNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICB2YXIgd2hpdGVQaXhlbCA9IG5ldyBVaW50OEFycmF5KFsyNTUsIDI1NSwgMjU1LCAyNTVdKTtcbiAgICAgICAgICAgIGNiKG51bGwsIHtzb3VyY2U6IHdoaXRlUGl4ZWwsIHc6IDEsIGg6IDEsIHBlcm1hbmVudDogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNBdXRvc2l6ZVRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi4vdHJlZS9UZXh0dXJlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb3VyY2VUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG5cbiAgICAgICAgdGhpcy5fdGV4dHVyZVNvdXJjZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXQgdGV4dHVyZVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVTb3VyY2U7XG4gICAgfVxuXG4gICAgc2V0IHRleHR1cmVTb3VyY2Uodikge1xuICAgICAgICBpZiAodiAhPT0gdGhpcy5fdGV4dHVyZVNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHYuaXNSZXN1bHRUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBhIHJlc3VsdCB0ZXh0dXJlLCBhdXRvbWF0aWNhbGx5IGluaGVyaXQgdGhlIHByZWNpc2lvbi5cbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSB0aGlzLnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZVNvdXJjZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0VGV4dHVyZVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVTb3VyY2U7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi4vdHJlZS9UZXh0dXJlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0aWNDYW52YXNUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG4gICAgICAgIHRoaXMuX2ZhY3RvcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2xvb2t1cElkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNldCBjb250ZW50KHtmYWN0b3J5LCBsb29rdXBJZCA9IHVuZGVmaW5lZH0pIHtcbiAgICAgICAgdGhpcy5fZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX2xvb2t1cElkID0gbG9va3VwSWQ7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBfZ2V0SXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZmFjdG9yeTtcbiAgICB9XG5cbiAgICBfZ2V0TG9va3VwSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb29rdXBJZDtcbiAgICB9XG5cbiAgICBfZ2V0U291cmNlTG9hZGVyKCkge1xuICAgICAgICBjb25zdCBmID0gdGhpcy5fZmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGYoKGVyciwgY2FudmFzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2IobnVsbCwgdGhpcy5zdGFnZS5wbGF0Zm9ybS5nZXRUZXh0dXJlT3B0aW9uc0ZvckRyYXdpbmdDYW52YXMoY2FudmFzKSk7XG4gICAgICAgICAgICB9LCB0aGlzLnN0YWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4uL3RyZWUvVGV4dHVyZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGljVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIHNldCBvcHRpb25zKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH1cblxuICAgIF9nZXRJc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9vcHRpb25zO1xuICAgIH1cblxuICAgIF9nZXRTb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgIHJldHVybiAoY2IpID0+IHtcbiAgICAgICAgICAgIGNiKG51bGwsIHRoaXMuX29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4uL3RyZWUvVGV4dHVyZS5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcblxuICAgICAgICAvLyBXZSB1c2UgdGhlIHN0YWdlIHByZWNpc2lvbiBhcyB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaW4gY2FzZSBvZiBhIHRleHQgdGV4dHVyZS5cbiAgICAgICAgdGhpcy5fcHJlY2lzaW9uID0gdGhpcy5zdGFnZS5nZXRPcHRpb24oJ3ByZWNpc2lvbicpO1xuICAgIH1cblxuICAgIHN0YXRpYyByZW5kZXJlcihzdGFnZSwgY2FudmFzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAodGhpcy5hZHZhbmNlZFJlbmRlcmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRUZXh0dXJlUmVuZGVyZXJBZHZhbmNlZChzdGFnZSwgY2FudmFzLCBzZXR0aW5ncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRUZXh0dXJlUmVuZGVyZXIoc3RhZ2UsIGNhbnZhcywgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgIH1cblxuICAgIHNldCB0ZXh0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSBcIlwiICsgdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdztcbiAgICB9XG5cbiAgICBzZXQgdyh2KSB7XG4gICAgICAgIGlmICh0aGlzLl93ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl93ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faDtcbiAgICB9XG5cbiAgICBzZXQgaCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9oICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9oID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBmb250U3R5bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250U3R5bGU7XG4gICAgfVxuXG4gICAgc2V0IGZvbnRTdHlsZSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9mb250U3R5bGUgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTdHlsZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZm9udFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgICB9XG5cbiAgICBzZXQgZm9udFNpemUodikge1xuICAgICAgICBpZiAodGhpcy5fZm9udFNpemUgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBmb250RmFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRGYWNlO1xuICAgIH1cblxuICAgIHNldCBmb250RmFjZSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9mb250RmFjZSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fZm9udEZhY2UgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHdvcmRXcmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd29yZFdyYXA7XG4gICAgfVxuXG4gICAgc2V0IHdvcmRXcmFwKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmRXcmFwICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl93b3JkV3JhcCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgd29yZFdyYXBXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwV2lkdGg7XG4gICAgfVxuXG4gICAgc2V0IHdvcmRXcmFwV2lkdGgodikge1xuICAgICAgICBpZiAodGhpcy5fd29yZFdyYXBXaWR0aCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fd29yZFdyYXBXaWR0aCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgd29yZEJyZWFrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd29yZEJyZWFrO1xuICAgIH1cblxuICAgIHNldCB3b3JkQnJlYWsodikge1xuICAgICAgICBpZiAodGhpcy5fd29yZEJyZWFrICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl93b3JkQnJlYWsgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRleHRPdmVyZmxvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRPdmVyZmxvdztcbiAgICB9XG5cbiAgICBzZXQgdGV4dE92ZXJmbG93KHYpIHtcbiAgICAgICAgaWYgKHYgIT0gdGhpcy5fdGV4dE92ZXJmbG93KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0T3ZlcmZsb3cgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lSGVpZ2h0O1xuICAgIH1cblxuICAgIHNldCBsaW5lSGVpZ2h0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVIZWlnaHQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVIZWlnaHQgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRleHRCYXNlbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRCYXNlbGluZTtcbiAgICB9XG5cbiAgICBzZXQgdGV4dEJhc2VsaW5lKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHRCYXNlbGluZSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fdGV4dEJhc2VsaW5lID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0ZXh0QWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0QWxpZ247XG4gICAgfVxuXG4gICAgc2V0IHRleHRBbGlnbih2KSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0QWxpZ24gIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRBbGlnbiA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdmVydGljYWxBbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsQWxpZ247XG4gICAgfVxuXG4gICAgc2V0IHZlcnRpY2FsQWxpZ24odikge1xuICAgICAgICBpZiAodGhpcy5fdmVydGljYWxBbGlnbiAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fdmVydGljYWxBbGlnbiA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgb2Zmc2V0WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldFk7XG4gICAgfVxuXG4gICAgc2V0IG9mZnNldFkodikge1xuICAgICAgICBpZiAodGhpcy5fb2Zmc2V0WSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbWF4TGluZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhMaW5lcztcbiAgICB9XG5cbiAgICBzZXQgbWF4TGluZXModikge1xuICAgICAgICBpZiAodGhpcy5fbWF4TGluZXMgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX21heExpbmVzID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBtYXhMaW5lc1N1ZmZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heExpbmVzU3VmZml4O1xuICAgIH1cblxuICAgIHNldCBtYXhMaW5lc1N1ZmZpeCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXhMaW5lc1N1ZmZpeCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fbWF4TGluZXNTdWZmaXggPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRleHRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRDb2xvcjtcbiAgICB9XG5cbiAgICBzZXQgdGV4dENvbG9yKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHRDb2xvciAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fdGV4dENvbG9yID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBwYWRkaW5nTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdMZWZ0O1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nTGVmdCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9wYWRkaW5nTGVmdCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fcGFkZGluZ0xlZnQgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHBhZGRpbmdSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdSaWdodDtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1JpZ2h0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhZGRpbmdSaWdodCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fcGFkZGluZ1JpZ2h0ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzaGFkb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkb3c7XG4gICAgfVxuXG4gICAgc2V0IHNoYWRvdyh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zaGFkb3cgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvdyA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2hhZG93Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkb3dDb2xvcjtcbiAgICB9XG5cbiAgICBzZXQgc2hhZG93Q29sb3Iodikge1xuICAgICAgICBpZiAodGhpcy5fc2hhZG93Q29sb3IgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NvbG9yID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzaGFkb3dPZmZzZXRYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZG93T2Zmc2V0WDtcbiAgICB9XG5cbiAgICBzZXQgc2hhZG93T2Zmc2V0WCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zaGFkb3dPZmZzZXRYICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRYID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzaGFkb3dPZmZzZXRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZG93T2Zmc2V0WTtcbiAgICB9XG5cbiAgICBzZXQgc2hhZG93T2Zmc2V0WSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zaGFkb3dPZmZzZXRZICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRZID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzaGFkb3dCbHVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZG93Qmx1cjtcbiAgICB9XG5cbiAgICBzZXQgc2hhZG93Qmx1cih2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zaGFkb3dCbHVyICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dCbHVyID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoaWdobGlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWdobGlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IGhpZ2hsaWdodCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9oaWdobGlnaHQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaGlnaGxpZ2h0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0SGVpZ2h0O1xuICAgIH1cblxuICAgIHNldCBoaWdobGlnaHRIZWlnaHQodikge1xuICAgICAgICBpZiAodGhpcy5faGlnaGxpZ2h0SGVpZ2h0ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRIZWlnaHQgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGhpZ2hsaWdodENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0Q29sb3I7XG4gICAgfVxuXG4gICAgc2V0IGhpZ2hsaWdodENvbG9yKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpZ2hsaWdodENvbG9yICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRDb2xvciA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaGlnaGxpZ2h0T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0T2Zmc2V0O1xuICAgIH1cblxuICAgIHNldCBoaWdobGlnaHRPZmZzZXQodikge1xuICAgICAgICBpZiAodGhpcy5faGlnaGxpZ2h0T2Zmc2V0ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRPZmZzZXQgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGhpZ2hsaWdodFBhZGRpbmdMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0UGFkZGluZ0xlZnQ7XG4gICAgfVxuXG4gICAgc2V0IGhpZ2hsaWdodFBhZGRpbmdMZWZ0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpZ2hsaWdodFBhZGRpbmdMZWZ0ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRQYWRkaW5nTGVmdCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0UGFkZGluZ1JpZ2h0O1xuICAgIH1cblxuICAgIHNldCBoaWdobGlnaHRQYWRkaW5nUmlnaHQodikge1xuICAgICAgICBpZiAodGhpcy5faGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRQYWRkaW5nUmlnaHQgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGN1dFN4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3V0U3g7XG4gICAgfVxuXG4gICAgc2V0IGN1dFN4KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1dFN4ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9jdXRTeCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY3V0RXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXRFeDtcbiAgICB9XG5cbiAgICBzZXQgY3V0RXgodikge1xuICAgICAgICBpZiAodGhpcy5fY3V0RXggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1dEV4ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjdXRTeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1dFN5O1xuICAgIH1cblxuICAgIHNldCBjdXRTeSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXRTeSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fY3V0U3kgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGN1dEV5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3V0RXk7XG4gICAgfVxuXG4gICAgc2V0IGN1dEV5KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1dEV5ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9jdXRFeSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgYWR2YW5jZWRSZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkdmFuY2VkUmVuZGVyZXI7XG4gICAgfVxuXG4gICAgc2V0IGFkdmFuY2VkUmVuZGVyZXIodikge1xuICAgICAgICBpZiAodGhpcy5fYWR2YW5jZWRSZW5kZXJlciAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZWRSZW5kZXJlciA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgbGV0dGVyU3BhY2luZyh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9sZXR0ZXJTcGFjaW5nICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGV0dGVyU3BhY2luZztcbiAgICB9XG5cbiAgICBzZXQgdGV4dEluZGVudCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0SW5kZW50ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0SW5kZW50ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0ZXh0SW5kZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEluZGVudDtcbiAgICB9XG5cbiAgICBnZXQgcHJlY2lzaW9uKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIucHJlY2lzaW9uO1xuICAgIH1cblxuICAgIHNldCBwcmVjaXNpb24odikge1xuICAgICAgICAvLyBXZSBhY3R1YWxseSBkcmF3IGRpZmZlcmVudGx5IHdoZW4gdGhlIHByZWNpc2lvbiBjaGFuZ2VzLlxuICAgICAgICBpZiAodGhpcy5wcmVjaXNpb24gIT09IHYpIHtcbiAgICAgICAgICAgIHN1cGVyLnByZWNpc2lvbiA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0SXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy50ZXh0O1xuICAgIH1cblxuICAgIF9nZXRMb29rdXBJZCgpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMudyAhPT0gMCkgcGFydHMucHVzaChcIncgXCIgKyB0aGlzLncpO1xuICAgICAgICBpZiAodGhpcy5oICE9PSAwKSBwYXJ0cy5wdXNoKFwiaCBcIiArIHRoaXMuaCk7XG4gICAgICAgIGlmICh0aGlzLmZvbnRTdHlsZSAhPT0gXCJub3JtYWxcIikgcGFydHMucHVzaChcImZTXCIgKyB0aGlzLmZvbnRTdHlsZSk7XG4gICAgICAgIGlmICh0aGlzLmZvbnRTaXplICE9PSA0MCkgcGFydHMucHVzaChcImZzXCIgKyB0aGlzLmZvbnRTaXplKTtcbiAgICAgICAgaWYgKHRoaXMuZm9udEZhY2UgIT09IG51bGwpIHBhcnRzLnB1c2goXCJmZlwiICsgKEFycmF5LmlzQXJyYXkodGhpcy5mb250RmFjZSkgPyB0aGlzLmZvbnRGYWNlLmpvaW4oXCIsXCIpIDogdGhpcy5mb250RmFjZSkpO1xuICAgICAgICBpZiAodGhpcy53b3JkV3JhcCAhPT0gdHJ1ZSkgcGFydHMucHVzaChcIndyXCIgKyAodGhpcy53b3JkV3JhcCA/IDEgOiAwKSk7XG4gICAgICAgIGlmICh0aGlzLndvcmRXcmFwV2lkdGggIT09IDApIHBhcnRzLnB1c2goXCJ3d1wiICsgdGhpcy53b3JkV3JhcFdpZHRoKTtcbiAgICAgICAgaWYgKHRoaXMud29yZEJyZWFrICE9PSBmYWxzZSkgcGFydHMucHVzaChcIndiXCIgKyB0aGlzLndvcmRCcmVhayA/IDEgOiAwKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dE92ZXJmbG93ICE9IFwiXCIpIHBhcnRzLnB1c2goXCJ0b1wiICsgdGhpcy50ZXh0T3ZlcmZsb3cpO1xuICAgICAgICBpZiAodGhpcy5saW5lSGVpZ2h0ICE9PSBudWxsKSBwYXJ0cy5wdXNoKFwibGhcIiArIHRoaXMubGluZUhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLnRleHRCYXNlbGluZSAhPT0gXCJhbHBoYWJldGljXCIpIHBhcnRzLnB1c2goXCJ0YlwiICsgdGhpcy50ZXh0QmFzZWxpbmUpO1xuICAgICAgICBpZiAodGhpcy50ZXh0QWxpZ24gIT09IFwibGVmdFwiKSBwYXJ0cy5wdXNoKFwidGFcIiArIHRoaXMudGV4dEFsaWduKTtcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWxBbGlnbiAhPT0gXCJ0b3BcIikgcGFydHMucHVzaChcInZhXCIgKyB0aGlzLnZlcnRpY2FsQWxpZ24pO1xuICAgICAgICBpZiAodGhpcy5vZmZzZXRZICE9PSBudWxsKSBwYXJ0cy5wdXNoKFwib3lcIiArIHRoaXMub2Zmc2V0WSk7XG4gICAgICAgIGlmICh0aGlzLm1heExpbmVzICE9PSAwKSBwYXJ0cy5wdXNoKFwibWxcIiArIHRoaXMubWF4TGluZXMpO1xuICAgICAgICBpZiAodGhpcy5tYXhMaW5lc1N1ZmZpeCAhPT0gXCIuLlwiKSBwYXJ0cy5wdXNoKFwibXNcIiArIHRoaXMubWF4TGluZXNTdWZmaXgpO1xuICAgICAgICBwYXJ0cy5wdXNoKFwicGNcIiArIHRoaXMucHJlY2lzaW9uKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dENvbG9yICE9PSAweGZmZmZmZmZmKSBwYXJ0cy5wdXNoKFwiY29cIiArIHRoaXMudGV4dENvbG9yLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGlmICh0aGlzLnBhZGRpbmdMZWZ0ICE9PSAwKSBwYXJ0cy5wdXNoKFwicGxcIiArIHRoaXMucGFkZGluZ0xlZnQpO1xuICAgICAgICBpZiAodGhpcy5wYWRkaW5nUmlnaHQgIT09IDApIHBhcnRzLnB1c2goXCJwclwiICsgdGhpcy5wYWRkaW5nUmlnaHQpO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3cgIT09IGZhbHNlKSBwYXJ0cy5wdXNoKFwic2hcIiArICh0aGlzLnNoYWRvdyA/IDEgOiAwKSk7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0NvbG9yICE9PSAweGZmMDAwMDAwKSBwYXJ0cy5wdXNoKFwic2NcIiArIHRoaXMuc2hhZG93Q29sb3IudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93T2Zmc2V0WCAhPT0gMCkgcGFydHMucHVzaChcInN4XCIgKyB0aGlzLnNoYWRvd09mZnNldFgpO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dPZmZzZXRZICE9PSAwKSBwYXJ0cy5wdXNoKFwic3lcIiArIHRoaXMuc2hhZG93T2Zmc2V0WSk7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0JsdXIgIT09IDUpIHBhcnRzLnB1c2goXCJzYlwiICsgdGhpcy5zaGFkb3dCbHVyKTtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ICE9PSBmYWxzZSkgcGFydHMucHVzaChcImhMXCIgKyAodGhpcy5oaWdobGlnaHQgPyAxIDogMCkpO1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRIZWlnaHQgIT09IDApIHBhcnRzLnB1c2goXCJoaFwiICsgdGhpcy5oaWdobGlnaHRIZWlnaHQpO1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRDb2xvciAhPT0gMHhmZjAwMDAwMCkgcGFydHMucHVzaChcImhjXCIgKyB0aGlzLmhpZ2hsaWdodENvbG9yLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodE9mZnNldCAhPT0gbnVsbCkgcGFydHMucHVzaChcImhvXCIgKyB0aGlzLmhpZ2hsaWdodE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodFBhZGRpbmdMZWZ0ICE9PSBudWxsKSBwYXJ0cy5wdXNoKFwiaGxcIiArIHRoaXMuaGlnaGxpZ2h0UGFkZGluZ0xlZnQpO1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRQYWRkaW5nUmlnaHQgIT09IG51bGwpIHBhcnRzLnB1c2goXCJoclwiICsgdGhpcy5oaWdobGlnaHRQYWRkaW5nUmlnaHQpO1xuICAgICAgICBpZiAodGhpcy5sZXR0ZXJTcGFjaW5nICE9PSBudWxsKSBwYXJ0cy5wdXNoKFwibHNcIiArIHRoaXMubGV0dGVyU3BhY2luZyk7XG4gICAgICAgIGlmICh0aGlzLnRleHRJbmRlbnQgIT09IG51bGwpIHBhcnRzLnB1c2goXCJ0aVwiICsgdGhpcy50ZXh0SW5kZW50KTtcblxuICAgICAgICBpZiAodGhpcy5jdXRTeCkgcGFydHMucHVzaChcImNzeFwiICsgdGhpcy5jdXRTeCk7XG4gICAgICAgIGlmICh0aGlzLmN1dEV4KSBwYXJ0cy5wdXNoKFwiY2V4XCIgKyB0aGlzLmN1dEV4KTtcbiAgICAgICAgaWYgKHRoaXMuY3V0U3kpIHBhcnRzLnB1c2goXCJjc3lcIiArIHRoaXMuY3V0U3kpO1xuICAgICAgICBpZiAodGhpcy5jdXRFeSkgcGFydHMucHVzaChcImNleVwiICsgdGhpcy5jdXRFeSk7XG5cbiAgICAgICAgaWYgKHRoaXMuYWR2YW5jZWRSZW5kZXJlcikgcGFydHMucHVzaChcImFSXCIgKyB0aGlzLmFkdmFuY2VkUmVuZGVyZXIgPyAxIDogMCk7XG5cbiAgICAgICAgbGV0IGlkID0gXCJUWCRcIiArIHBhcnRzLmpvaW4oXCJ8XCIpICsgXCI6XCIgKyB0aGlzLnRleHQ7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBfZ2V0U291cmNlTG9hZGVyKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5jbG9uZUFyZ3MoKTtcblxuICAgICAgICAvLyBJbmhlcml0IGZvbnQgZmFjZSBmcm9tIHN0YWdlLlxuICAgICAgICBpZiAoYXJncy5mb250RmFjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYXJncy5mb250RmFjZSA9IHRoaXMuc3RhZ2UuZ2V0T3B0aW9uKCdkZWZhdWx0Rm9udEZhY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5zdGFnZS5nbDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLnN0YWdlLnBsYXRmb3JtLmdldERyYXdpbmdDYW52YXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gKGFyZ3MuYWR2YW5jZWRSZW5kZXJlcilcbiAgICAgICAgICAgICAgPyBuZXcgVGV4dFRleHR1cmVSZW5kZXJlckFkdmFuY2VkKHRoaXMuc3RhZ2UsIGNhbnZhcywgYXJncylcbiAgICAgICAgICAgICAgOiBuZXcgVGV4dFRleHR1cmVSZW5kZXJlcih0aGlzLnN0YWdlLCBjYW52YXMsIGFyZ3MpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBwID0gcmVuZGVyZXIuZHJhdygpO1xuXG4gICAgICAgICAgICBjb25zdCB0ZXhQYXJhbXMgPSB7fTtcblxuICAgICAgICAgICAgY29uc3Qgc2hhcnBDZmcgPSB0aGlzLnN0YWdlLmdldE9wdGlvbignZm9udFNoYXJwJyk7XG4gICAgICAgICAgICBsZXQgc2hhcnBlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IHRleHQgYmx1ciB3aGVuIHRleHQgdGV4dHVyZSBpcyBkb3duc2NhbGVkXG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNCb29sZWFuKHNoYXJwQ2ZnKSkge1xuICAgICAgICAgICAgICAgIHNoYXJwZW4gPSBzaGFycENmZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3Qoc2hhcnBDZmcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcbiAgICAgICAgICAgICAgICBzaGFycGVuID0gcHJlY2lzaW9uIDw9IHNoYXJwQ2ZnLnByZWNpc2lvbiAmJiBhcmdzLmZvbnRTaXplIDw9IHNoYXJwQ2ZnLmZvbnRTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2wgJiYgc2hhcnBlbikge1xuICAgICAgICAgICAgICAgIHRleFBhcmFtc1tnbC5URVhUVVJFX01BR19GSUxURVJdID0gZ2wuTkVBUkVTVDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICBwLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBGSVhNRTogb24gc29tZSBwbGF0Zm9ybXMgKGUuZy4gUlBJKSwgdGhyb3R0bGluZyB0ZXh0IHRleHR1cmVzIGNhdXNlIGFydGlmYWN0cyAqL1xuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckluZm86IHJlbmRlcmVyLnJlbmRlckluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXhQYXJhbXM6IHRleFBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zdGFnZS5wbGF0Zm9ybS5nZXRUZXh0dXJlT3B0aW9uc0ZvckRyYXdpbmdDYW52YXMoY2FudmFzKSkpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2IobnVsbCwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckluZm86IHJlbmRlcmVyLnJlbmRlckluZm8sXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4UGFyYW1zOiB0ZXhQYXJhbXMsXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5zdGFnZS5wbGF0Zm9ybS5nZXRUZXh0dXJlT3B0aW9uc0ZvckRyYXdpbmdDYW52YXMoY2FudmFzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZ2V0Tm9uRGVmYXVsdHMoKSB7XG4gICAgICAgIGNvbnN0IG5vbkRlZmF1bHRzID0gc3VwZXIuZ2V0Tm9uRGVmYXVsdHMoKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dCAhPT0gXCJcIikgbm9uRGVmYXVsdHNbJ3RleHQnXSA9IHRoaXMudGV4dDtcbiAgICAgICAgaWYgKHRoaXMudyAhPT0gMCkgbm9uRGVmYXVsdHNbJ3cnXSA9IHRoaXMudztcbiAgICAgICAgaWYgKHRoaXMuaCAhPT0gMCkgbm9uRGVmYXVsdHNbJ2gnXSA9IHRoaXMuaDtcbiAgICAgICAgaWYgKHRoaXMuZm9udFN0eWxlICE9PSBcIm5vcm1hbFwiKSBub25EZWZhdWx0c1snZm9udFN0eWxlJ10gPSB0aGlzLmZvbnRTdHlsZTtcbiAgICAgICAgaWYgKHRoaXMuZm9udFNpemUgIT09IDQwKSBub25EZWZhdWx0c1tcImZvbnRTaXplXCJdID0gdGhpcy5mb250U2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuZm9udEZhY2UgIT09IG51bGwpIG5vbkRlZmF1bHRzW1wiZm9udEZhY2VcIl0gPSB0aGlzLmZvbnRGYWNlO1xuICAgICAgICBpZiAodGhpcy53b3JkV3JhcCAhPT0gdHJ1ZSkgbm9uRGVmYXVsdHNbXCJ3b3JkV3JhcFwiXSA9IHRoaXMud29yZFdyYXA7XG4gICAgICAgIGlmICh0aGlzLndvcmRXcmFwV2lkdGggIT09IDApIG5vbkRlZmF1bHRzW1wid29yZFdyYXBXaWR0aFwiXSA9IHRoaXMud29yZFdyYXBXaWR0aDtcbiAgICAgICAgaWYgKHRoaXMud29yZEJyZWFrICE9PSBmYWxzZSkgbm9uRGVmYXVsdHNbXCJ3b3JkQnJlYWtcIl0gPSB0aGlzLndvcmRCcmVhaztcbiAgICAgICAgaWYgKHRoaXMudGV4dE92ZXJmbG93ICE9IFwiXCIpIG5vbkRlZmF1bHRzW1widGV4dE92ZXJmbG93XCJdID0gdGhpcy50ZXh0T3ZlcmZsb3c7XG4gICAgICAgIGlmICh0aGlzLmxpbmVIZWlnaHQgIT09IG51bGwpIG5vbkRlZmF1bHRzW1wibGluZUhlaWdodFwiXSA9IHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMudGV4dEJhc2VsaW5lICE9PSBcImFscGhhYmV0aWNcIikgbm9uRGVmYXVsdHNbXCJ0ZXh0QmFzZWxpbmVcIl0gPSB0aGlzLnRleHRCYXNlbGluZTtcbiAgICAgICAgaWYgKHRoaXMudGV4dEFsaWduICE9PSBcImxlZnRcIikgbm9uRGVmYXVsdHNbXCJ0ZXh0QWxpZ25cIl0gPSB0aGlzLnRleHRBbGlnbjtcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWxBbGlnbiAhPT0gXCJ0b3BcIikgbm9uRGVmYXVsdHNbXCJ2ZXJ0aWNhbEFsaWduXCJdID0gdGhpcy52ZXJ0aWNhbEFsaWduO1xuICAgICAgICBpZiAodGhpcy5vZmZzZXRZICE9PSBudWxsKSBub25EZWZhdWx0c1tcIm9mZnNldFlcIl0gPSB0aGlzLm9mZnNldFk7XG4gICAgICAgIGlmICh0aGlzLm1heExpbmVzICE9PSAwKSBub25EZWZhdWx0c1tcIm1heExpbmVzXCJdID0gdGhpcy5tYXhMaW5lcztcbiAgICAgICAgaWYgKHRoaXMubWF4TGluZXNTdWZmaXggIT09IFwiLi5cIikgbm9uRGVmYXVsdHNbXCJtYXhMaW5lc1N1ZmZpeFwiXSA9IHRoaXMubWF4TGluZXNTdWZmaXg7XG4gICAgICAgIGlmICh0aGlzLnByZWNpc2lvbiAhPT0gdGhpcy5zdGFnZS5nZXRPcHRpb24oJ3ByZWNpc2lvbicpKSBub25EZWZhdWx0c1tcInByZWNpc2lvblwiXSA9IHRoaXMucHJlY2lzaW9uO1xuICAgICAgICBpZiAodGhpcy50ZXh0Q29sb3IgIT09IDB4ZmZmZmZmZmYpIG5vbkRlZmF1bHRzW1widGV4dENvbG9yXCJdID0gdGhpcy50ZXh0Q29sb3I7XG4gICAgICAgIGlmICh0aGlzLnBhZGRpbmdMZWZ0ICE9PSAwKSBub25EZWZhdWx0c1tcInBhZGRpbmdMZWZ0XCJdID0gdGhpcy5wYWRkaW5nTGVmdDtcbiAgICAgICAgaWYgKHRoaXMucGFkZGluZ1JpZ2h0ICE9PSAwKSBub25EZWZhdWx0c1tcInBhZGRpbmdSaWdodFwiXSA9IHRoaXMucGFkZGluZ1JpZ2h0O1xuICAgICAgICBpZiAodGhpcy5zaGFkb3cgIT09IGZhbHNlKSBub25EZWZhdWx0c1tcInNoYWRvd1wiXSA9IHRoaXMuc2hhZG93O1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dDb2xvciAhPT0gMHhmZjAwMDAwMCkgbm9uRGVmYXVsdHNbXCJzaGFkb3dDb2xvclwiXSA9IHRoaXMuc2hhZG93Q29sb3I7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd09mZnNldFggIT09IDApIG5vbkRlZmF1bHRzW1wic2hhZG93T2Zmc2V0WFwiXSA9IHRoaXMuc2hhZG93T2Zmc2V0WDtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93T2Zmc2V0WSAhPT0gMCkgbm9uRGVmYXVsdHNbXCJzaGFkb3dPZmZzZXRZXCJdID0gdGhpcy5zaGFkb3dPZmZzZXRZO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dCbHVyICE9PSA1KSBub25EZWZhdWx0c1tcInNoYWRvd0JsdXJcIl0gPSB0aGlzLnNoYWRvd0JsdXI7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodCAhPT0gZmFsc2UpIG5vbkRlZmF1bHRzW1wiaGlnaGxpZ2h0XCJdID0gdGhpcy5oaWdobGlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodEhlaWdodCAhPT0gMCkgbm9uRGVmYXVsdHNbXCJoaWdobGlnaHRIZWlnaHRcIl0gPSB0aGlzLmhpZ2hsaWdodEhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0Q29sb3IgIT09IDB4ZmYwMDAwMDApIG5vbkRlZmF1bHRzW1wiaGlnaGxpZ2h0Q29sb3JcIl0gPSB0aGlzLmhpZ2hsaWdodENvbG9yO1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRPZmZzZXQgIT09IDApIG5vbkRlZmF1bHRzW1wiaGlnaGxpZ2h0T2Zmc2V0XCJdID0gdGhpcy5oaWdobGlnaHRPZmZzZXQ7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodFBhZGRpbmdMZWZ0ICE9PSAwKSBub25EZWZhdWx0c1tcImhpZ2hsaWdodFBhZGRpbmdMZWZ0XCJdID0gdGhpcy5oaWdobGlnaHRQYWRkaW5nTGVmdDtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ICE9PSAwKSBub25EZWZhdWx0c1tcImhpZ2hsaWdodFBhZGRpbmdSaWdodFwiXSA9IHRoaXMuaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0O1xuICAgICAgICBpZiAodGhpcy5sZXR0ZXJTcGFjaW5nICE9PSAwKSBub25EZWZhdWx0c1tcImxldHRlclNwYWNpbmdcIl0gPSB0aGlzLmxldHRlclNwYWNpbmc7XG4gICAgICAgIGlmICh0aGlzLnRleHRJbmRlbnQgIT09IDApIG5vbkRlZmF1bHRzW1widGV4dEluZGVudFwiXSA9IHRoaXMudGV4dEluZGVudDtcblxuICAgICAgICBpZiAodGhpcy5jdXRTeCkgbm9uRGVmYXVsdHNbXCJjdXRTeFwiXSA9IHRoaXMuY3V0U3g7XG4gICAgICAgIGlmICh0aGlzLmN1dEV4KSBub25EZWZhdWx0c1tcImN1dEV4XCJdID0gdGhpcy5jdXRFeDtcbiAgICAgICAgaWYgKHRoaXMuY3V0U3kpIG5vbkRlZmF1bHRzW1wiY3V0U3lcIl0gPSB0aGlzLmN1dFN5O1xuICAgICAgICBpZiAodGhpcy5jdXRFeSkgbm9uRGVmYXVsdHNbXCJjdXRFeVwiXSA9IHRoaXMuY3V0RXk7XG5cbiAgICAgICAgaWYgKHRoaXMuYWR2YW5jZWRSZW5kZXJlcikgbm9uRGVmYXVsdHNbXCJyZW5kZXJlclwiXSA9IHRoaXMuYWR2YW5jZWRSZW5kZXJlcjtcbiAgICAgICAgcmV0dXJuIG5vbkRlZmF1bHRzO1xuICAgIH1cblxuICAgIGNsb25lQXJncygpIHtcbiAgICAgICAgbGV0IG9iaiA9IHt9O1xuICAgICAgICBvYmoudGV4dCA9IHRoaXMuX3RleHQ7XG4gICAgICAgIG9iai53ID0gdGhpcy5fdztcbiAgICAgICAgb2JqLmggPSB0aGlzLl9oO1xuICAgICAgICBvYmouZm9udFN0eWxlID0gdGhpcy5fZm9udFN0eWxlO1xuICAgICAgICBvYmouZm9udFNpemUgPSB0aGlzLl9mb250U2l6ZTtcbiAgICAgICAgb2JqLmZvbnRGYWNlID0gdGhpcy5fZm9udEZhY2U7XG4gICAgICAgIG9iai53b3JkV3JhcCA9IHRoaXMuX3dvcmRXcmFwO1xuICAgICAgICBvYmoud29yZFdyYXBXaWR0aCA9IHRoaXMuX3dvcmRXcmFwV2lkdGg7XG4gICAgICAgIG9iai53b3JkQnJlYWsgPSB0aGlzLl93b3JkQnJlYWs7XG4gICAgICAgIG9iai50ZXh0T3ZlcmZsb3cgPSB0aGlzLl90ZXh0T3ZlcmZsb3c7XG4gICAgICAgIG9iai5saW5lSGVpZ2h0ID0gdGhpcy5fbGluZUhlaWdodDtcbiAgICAgICAgb2JqLnRleHRCYXNlbGluZSA9IHRoaXMuX3RleHRCYXNlbGluZTtcbiAgICAgICAgb2JqLnRleHRBbGlnbiA9IHRoaXMuX3RleHRBbGlnbjtcbiAgICAgICAgb2JqLnZlcnRpY2FsQWxpZ24gPSB0aGlzLl92ZXJ0aWNhbEFsaWduO1xuICAgICAgICBvYmoub2Zmc2V0WSA9IHRoaXMuX29mZnNldFk7XG4gICAgICAgIG9iai5tYXhMaW5lcyA9IHRoaXMuX21heExpbmVzO1xuICAgICAgICBvYmoubWF4TGluZXNTdWZmaXggPSB0aGlzLl9tYXhMaW5lc1N1ZmZpeDtcbiAgICAgICAgb2JqLnByZWNpc2lvbiA9IHRoaXMuX3ByZWNpc2lvbjtcbiAgICAgICAgb2JqLnRleHRDb2xvciA9IHRoaXMuX3RleHRDb2xvcjtcbiAgICAgICAgb2JqLnBhZGRpbmdMZWZ0ID0gdGhpcy5fcGFkZGluZ0xlZnQ7XG4gICAgICAgIG9iai5wYWRkaW5nUmlnaHQgPSB0aGlzLl9wYWRkaW5nUmlnaHQ7XG4gICAgICAgIG9iai5zaGFkb3cgPSB0aGlzLl9zaGFkb3c7XG4gICAgICAgIG9iai5zaGFkb3dDb2xvciA9IHRoaXMuX3NoYWRvd0NvbG9yO1xuICAgICAgICBvYmouc2hhZG93T2Zmc2V0WCA9IHRoaXMuX3NoYWRvd09mZnNldFg7XG4gICAgICAgIG9iai5zaGFkb3dPZmZzZXRZID0gdGhpcy5fc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgb2JqLnNoYWRvd0JsdXIgPSB0aGlzLl9zaGFkb3dCbHVyO1xuICAgICAgICBvYmouaGlnaGxpZ2h0ID0gdGhpcy5faGlnaGxpZ2h0O1xuICAgICAgICBvYmouaGlnaGxpZ2h0SGVpZ2h0ID0gdGhpcy5faGlnaGxpZ2h0SGVpZ2h0O1xuICAgICAgICBvYmouaGlnaGxpZ2h0Q29sb3IgPSB0aGlzLl9oaWdobGlnaHRDb2xvcjtcbiAgICAgICAgb2JqLmhpZ2hsaWdodE9mZnNldCA9IHRoaXMuX2hpZ2hsaWdodE9mZnNldDtcbiAgICAgICAgb2JqLmhpZ2hsaWdodFBhZGRpbmdMZWZ0ID0gdGhpcy5faGlnaGxpZ2h0UGFkZGluZ0xlZnQ7XG4gICAgICAgIG9iai5oaWdobGlnaHRQYWRkaW5nUmlnaHQgPSB0aGlzLl9oaWdobGlnaHRQYWRkaW5nUmlnaHQ7XG4gICAgICAgIG9iai5sZXR0ZXJTcGFjaW5nID0gdGhpcy5fbGV0dGVyU3BhY2luZztcbiAgICAgICAgb2JqLnRleHRJbmRlbnQgPSB0aGlzLl90ZXh0SW5kZW50O1xuICAgICAgICBvYmouY3V0U3ggPSB0aGlzLl9jdXRTeDtcbiAgICAgICAgb2JqLmN1dEV4ID0gdGhpcy5fY3V0RXg7XG4gICAgICAgIG9iai5jdXRTeSA9IHRoaXMuX2N1dFN5O1xuICAgICAgICBvYmouY3V0RXkgPSB0aGlzLl9jdXRFeTtcbiAgICAgICAgb2JqLmFkdmFuY2VkUmVuZGVyZXIgPSB0aGlzLl9hZHZhbmNlZFJlbmRlcmVyO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuXG59XG5cbi8vIEJlY2F1c2UgdGhlcmUgYXJlIHNvIG1hbnkgcHJvcGVydGllcywgd2UgcHJlZmVyIHRvIHVzZSB0aGUgcHJvdG90eXBlIGZvciBkZWZhdWx0IHZhbHVlcy5cbi8vIFRoaXMgY2F1c2VzIGEgZGVjcmVhc2UgaW4gcGVyZm9ybWFuY2UsIGJ1dCBhbHNvIGEgZGVjcmVhc2UgaW4gbWVtb3J5IHVzYWdlLlxubGV0IHByb3RvID0gVGV4dFRleHR1cmUucHJvdG90eXBlO1xucHJvdG8uX3RleHQgPSBcIlwiO1xucHJvdG8uX3cgPSAwO1xucHJvdG8uX2ggPSAwO1xucHJvdG8uX2ZvbnRTdHlsZSA9IFwibm9ybWFsXCI7XG5wcm90by5fZm9udFNpemUgPSA0MDtcbnByb3RvLl9mb250RmFjZSA9IG51bGw7XG5wcm90by5fd29yZFdyYXAgPSB0cnVlO1xucHJvdG8uX3dvcmRXcmFwV2lkdGggPSAwO1xucHJvdG8uX3dvcmRCcmVhayA9IGZhbHNlO1xucHJvdG8uX3RleHRPdmVyZmxvdyA9IFwiXCI7XG5wcm90by5fbGluZUhlaWdodCA9IG51bGw7XG5wcm90by5fdGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG5wcm90by5fdGV4dEFsaWduID0gXCJsZWZ0XCI7XG5wcm90by5fdmVydGljYWxBbGlnbiA9IFwidG9wXCI7XG5wcm90by5fb2Zmc2V0WSA9IG51bGw7XG5wcm90by5fbWF4TGluZXMgPSAwO1xucHJvdG8uX21heExpbmVzU3VmZml4ID0gXCIuLlwiO1xucHJvdG8uX3RleHRDb2xvciA9IDB4RkZGRkZGRkY7XG5wcm90by5fcGFkZGluZ0xlZnQgPSAwO1xucHJvdG8uX3BhZGRpbmdSaWdodCA9IDA7XG5wcm90by5fc2hhZG93ID0gZmFsc2U7XG5wcm90by5fc2hhZG93Q29sb3IgPSAweEZGMDAwMDAwO1xucHJvdG8uX3NoYWRvd09mZnNldFggPSAwO1xucHJvdG8uX3NoYWRvd09mZnNldFkgPSAwO1xucHJvdG8uX3NoYWRvd0JsdXIgPSA1O1xucHJvdG8uX2hpZ2hsaWdodCA9IGZhbHNlO1xucHJvdG8uX2hpZ2hsaWdodEhlaWdodCA9IDA7XG5wcm90by5faGlnaGxpZ2h0Q29sb3IgPSAweEZGMDAwMDAwO1xucHJvdG8uX2hpZ2hsaWdodE9mZnNldCA9IDA7XG5wcm90by5faGlnaGxpZ2h0UGFkZGluZ0xlZnQgPSAwO1xucHJvdG8uX2hpZ2hsaWdodFBhZGRpbmdSaWdodCA9IDA7XG5wcm90by5fbGV0dGVyU3BhY2luZyA9IDA7XG5wcm90by5fdGV4dEluZGVudCA9IDA7XG5wcm90by5fY3V0U3ggPSAwO1xucHJvdG8uX2N1dEV4ID0gMDtcbnByb3RvLl9jdXRTeSA9IDA7XG5wcm90by5fY3V0RXkgPSAwO1xucHJvdG8uX2FkdmFuY2VkUmVuZGVyZXIgPSBmYWxzZTtcblxuXG5pbXBvcnQgVGV4dFRleHR1cmVSZW5kZXJlciBmcm9tIFwiLi9UZXh0VGV4dHVyZVJlbmRlcmVyLm1qc1wiO1xuaW1wb3J0IFRleHRUZXh0dXJlUmVuZGVyZXJBZHZhbmNlZCBmcm9tIFwiLi9UZXh0VGV4dHVyZVJlbmRlcmVyQWR2YW5jZWQubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0VGV4dHVyZVJlbmRlcmVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlLCBjYW52YXMsIHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX3N0YWdlID0gc3RhZ2U7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cblxuICAgIGdldFByZWNpc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnByZWNpc2lvbjtcbiAgICB9O1xuXG4gICAgc2V0Rm9udFByb3BlcnRpZXMoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZm9udCA9IFV0aWxzLmlzU3BhcmsgPyB0aGlzLl9zdGFnZS5wbGF0Zm9ybS5nZXRGb250U2V0dGluZyh0aGlzKSA6IHRoaXMuX2dldEZvbnRTZXR0aW5nKCk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQudGV4dEJhc2VsaW5lID0gdGhpcy5fc2V0dGluZ3MudGV4dEJhc2VsaW5lO1xuICAgIH07XG5cbiAgICBfZ2V0Rm9udFNldHRpbmcoKSB7XG4gICAgICAgIGxldCBmZiA9IHRoaXMuX3NldHRpbmdzLmZvbnRGYWNlO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmZikpIHtcbiAgICAgICAgICAgIGZmID0gW2ZmXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmZnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBmZi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmZltpXSA9PT0gXCJzZXJpZlwiIHx8IGZmW2ldID09PSBcInNhbnMtc2VyaWZcIikge1xuICAgICAgICAgICAgICAgIGZmcy5wdXNoKGZmW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmZzLnB1c2goYFwiJHtmZltpXX1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuX3NldHRpbmdzLmZvbnRTdHlsZX0gJHt0aGlzLl9zZXR0aW5ncy5mb250U2l6ZSAqIHRoaXMuZ2V0UHJlY2lzaW9uKCl9cHggJHtmZnMuam9pbihcIixcIil9YFxuICAgIH1cblxuICAgIF9sb2FkKCkge1xuICAgICAgICBpZiAoVXRpbHMuaXNXZWIgJiYgZG9jdW1lbnQuZm9udHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTZXR0aW5nID0gdGhpcy5fZ2V0Rm9udFNldHRpbmcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5mb250cy5jaGVjayhmb250U2V0dGluZywgdGhpcy5fc2V0dGluZ3MudGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgcHJvbWlzZSB0aGF0IHdhaXRzIGZvciBsb2FkaW5nLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZm9udHMubG9hZChmb250U2V0dGluZywgdGhpcy5fc2V0dGluZ3MudGV4dCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgbG9hZCB0aGUgZmFsbGJhY2sgZm9udC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0xpZ2h0bmluZ10gRm9udCBsb2FkIGVycm9yJywgZXJyLCBmb250U2V0dGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5mb250cy5jaGVjayhmb250U2V0dGluZywgdGhpcy5fc2V0dGluZ3MudGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tMaWdodG5pbmddIEZvbnQgbm90IGZvdW5kJywgZm9udFNldHRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBDYW4ndCBjaGVjayBmb250IGxvYWRpbmcgZm9yIFwiICsgZm9udFNldHRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHJhdygpIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IHVzZSBhIHByb21pc2Ugc28gdGhhdCBsb2FkaW5nIGlzIHBlcmZvcm1lZCBzeW5jcm9ub3VzIHdoZW4gcG9zc2libGUuXG4gICAgICAgIGNvbnN0IGxvYWRQcm9taXNlID0gdGhpcy5fbG9hZCgpO1xuICAgICAgICBpZiAoIWxvYWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuaXNTcGFyayA/IHRoaXMuX3N0YWdlLnBsYXRmb3JtLmRyYXdUZXh0KHRoaXMpIDogdGhpcy5fZHJhdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5pc1NwYXJrID8gdGhpcy5fc3RhZ2UucGxhdGZvcm0uZHJhd1RleHQodGhpcykgOiB0aGlzLl9kcmF3KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jYWxjdWxhdGVSZW5kZXJJbmZvKCkge1xuICAgICAgICBsZXQgcmVuZGVySW5mbyA9IHt9O1xuXG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuZ2V0UHJlY2lzaW9uKCk7XG5cbiAgICAgICAgY29uc3QgcGFkZGluZ0xlZnQgPSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nTGVmdCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgcGFkZGluZ1JpZ2h0ID0gdGhpcy5fc2V0dGluZ3MucGFkZGluZ1JpZ2h0ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3NldHRpbmdzLmZvbnRTaXplICogcHJlY2lzaW9uO1xuICAgICAgICBsZXQgb2Zmc2V0WSA9IHRoaXMuX3NldHRpbmdzLm9mZnNldFkgPT09IG51bGwgPyBudWxsIDogKHRoaXMuX3NldHRpbmdzLm9mZnNldFkgKiBwcmVjaXNpb24pO1xuICAgICAgICBsZXQgbGluZUhlaWdodCA9IHRoaXMuX3NldHRpbmdzLmxpbmVIZWlnaHQgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLl9zZXR0aW5ncy53ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5fc2V0dGluZ3MuaCAqIHByZWNpc2lvbjtcbiAgICAgICAgbGV0IHdvcmRXcmFwV2lkdGggPSB0aGlzLl9zZXR0aW5ncy53b3JkV3JhcFdpZHRoICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBjdXRTeCA9IHRoaXMuX3NldHRpbmdzLmN1dFN4ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBjdXRFeCA9IHRoaXMuX3NldHRpbmdzLmN1dEV4ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBjdXRTeSA9IHRoaXMuX3NldHRpbmdzLmN1dFN5ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBjdXRFeSA9IHRoaXMuX3NldHRpbmdzLmN1dEV5ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gKHRoaXMuX3NldHRpbmdzLmxldHRlclNwYWNpbmcgfHwgMCkgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IHRleHRJbmRlbnQgPSB0aGlzLl9zZXR0aW5ncy50ZXh0SW5kZW50ICogcHJlY2lzaW9uO1xuXG4gICAgICAgIC8vIFNldCBmb250IHByb3BlcnRpZXMuXG4gICAgICAgIHRoaXMuc2V0Rm9udFByb3BlcnRpZXMoKTtcblxuICAgICAgICAvLyBUb3RhbCB3aWR0aC5cbiAgICAgICAgbGV0IHdpZHRoID0gdyB8fCAoMjA0OCAvIHRoaXMuZ2V0UHJlY2lzaW9uKCkpO1xuXG4gICAgICAgIC8vIElubmVyIHdpZHRoLlxuICAgICAgICBsZXQgaW5uZXJXaWR0aCA9IHdpZHRoIC0gKHBhZGRpbmdMZWZ0KTtcbiAgICAgICAgaWYgKGlubmVyV2lkdGggPCAxMCkge1xuICAgICAgICAgICAgd2lkdGggKz0gKDEwIC0gaW5uZXJXaWR0aCk7XG4gICAgICAgICAgICBpbm5lcldpZHRoICs9ICgxMCAtIGlubmVyV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICB3b3JkV3JhcFdpZHRoID0gaW5uZXJXaWR0aFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGV4dCBvdmVyZmxvd1xuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MudGV4dE92ZXJmbG93ICYmICF0aGlzLl9zZXR0aW5ncy53b3JkV3JhcCkge1xuICAgICAgICAgICAgbGV0IHN1ZmZpeDtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fc2V0dGluZ3MudGV4dE92ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xpcCc6XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlbGxpcHNpcyc6XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHRoaXMuX3NldHRpbmdzLm1heExpbmVzU3VmZml4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSB0aGlzLl9zZXR0aW5ncy50ZXh0T3ZlcmZsb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5ncy50ZXh0ID0gdGhpcy53cmFwV29yZCh0aGlzLl9zZXR0aW5ncy50ZXh0LCB3b3JkV3JhcFdpZHRoIC0gdGV4dEluZGVudCwgc3VmZml4KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gd29yZCB3cmFwXG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIHRleHRcbiAgICAgICAgbGV0IGxpbmVzSW5mbztcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLndvcmRXcmFwKSB7XG4gICAgICAgICAgICBsaW5lc0luZm8gPSB0aGlzLndyYXBUZXh0KHRoaXMuX3NldHRpbmdzLnRleHQsIHdvcmRXcmFwV2lkdGgsIGxldHRlclNwYWNpbmcsIHRleHRJbmRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZXNJbmZvID0ge2w6IHRoaXMuX3NldHRpbmdzLnRleHQuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pLCBuOiBbXX07XG4gICAgICAgICAgICBsZXQgaSwgbiA9IGxpbmVzSW5mby5sLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpbmVzSW5mby5uLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVzID0gbGluZXNJbmZvLmw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1heExpbmVzICYmIGxpbmVzLmxlbmd0aCA+IHRoaXMuX3NldHRpbmdzLm1heExpbmVzKSB7XG4gICAgICAgICAgICBsZXQgdXNlZExpbmVzID0gbGluZXMuc2xpY2UoMCwgdGhpcy5fc2V0dGluZ3MubWF4TGluZXMpO1xuXG4gICAgICAgICAgICBsZXQgb3RoZXJMaW5lcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubWF4TGluZXNTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAvLyBXcmFwIGFnYWluIHdpdGggbWF4IGxpbmVzIHN1ZmZpeCBlbmFibGVkLlxuICAgICAgICAgICAgICAgIGxldCB3ID0gdGhpcy5fc2V0dGluZ3MubWF4TGluZXNTdWZmaXggPyB0aGlzLm1lYXN1cmVUZXh0KHRoaXMuX3NldHRpbmdzLm1heExpbmVzU3VmZml4KSA6IDA7XG4gICAgICAgICAgICAgICAgbGV0IGFsID0gdGhpcy53cmFwVGV4dCh1c2VkTGluZXNbdXNlZExpbmVzLmxlbmd0aCAtIDFdLCB3b3JkV3JhcFdpZHRoIC0gdywgbGV0dGVyU3BhY2luZywgdGV4dEluZGVudCk7XG4gICAgICAgICAgICAgICAgdXNlZExpbmVzW3VzZWRMaW5lcy5sZW5ndGggLSAxXSA9IGFsLmxbMF0gKyB0aGlzLl9zZXR0aW5ncy5tYXhMaW5lc1N1ZmZpeDtcbiAgICAgICAgICAgICAgICBvdGhlckxpbmVzID0gW2FsLmwubGVuZ3RoID4gMSA/IGFsLmxbMV0gOiAnJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyTGluZXMgPSBbJyddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZS1hc3NlbWJsZSB0aGUgcmVtYWluaW5nIHRleHQuXG4gICAgICAgICAgICBsZXQgaSwgbiA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgICAgIGxldCBtID0gbGluZXNJbmZvLm4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gdGhpcy5fc2V0dGluZ3MubWF4TGluZXM7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdGhlckxpbmVzW2pdICs9IChvdGhlckxpbmVzW2pdID8gXCIgXCIgOiBcIlwiKSArIGxpbmVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IG0gJiYgbGluZXNJbmZvLm5baSArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlckluZm8ucmVtYWluaW5nVGV4dCA9IG90aGVyTGluZXMuam9pbihcIlxcblwiKTtcblxuICAgICAgICAgICAgcmVuZGVySW5mby5tb3JlVGV4dExpbmVzID0gdHJ1ZTtcblxuICAgICAgICAgICAgbGluZXMgPSB1c2VkTGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJJbmZvLm1vcmVUZXh0TGluZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlbmRlckluZm8ucmVtYWluaW5nVGV4dCA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGV4dCB3aWR0aFxuICAgICAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICAgICAgbGV0IGxpbmVXaWR0aHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmVXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQobGluZXNbaV0sIGxldHRlclNwYWNpbmcpICsgKGkgPT09IDAgPyB0ZXh0SW5kZW50IDogMCk7XG4gICAgICAgICAgICBsaW5lV2lkdGhzLnB1c2gobGluZVdpZHRoKTtcbiAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlckluZm8ubGluZVdpZHRocyA9IGxpbmVXaWR0aHM7XG5cbiAgICAgICAgaWYgKCF3KSB7XG4gICAgICAgICAgICAvLyBBdXRvLXNldCB3aWR0aCB0byBtYXggdGV4dCBsZW5ndGguXG4gICAgICAgICAgICB3aWR0aCA9IG1heExpbmVXaWR0aCArIHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgaW5uZXJXaWR0aCA9IG1heExpbmVXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0ZXh0IGhlaWdodFxuICAgICAgICBsaW5lSGVpZ2h0ID0gbGluZUhlaWdodCB8fCBmb250U2l6ZTtcblxuICAgICAgICBsZXQgaGVpZ2h0O1xuICAgICAgICBpZiAoaCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VsaW5lT2Zmc2V0ID0gKHRoaXMuX3NldHRpbmdzLnRleHRCYXNlbGluZSAhPSAnYm90dG9tJykgPyAwLjUgKiBmb250U2l6ZSA6IDA7XG4gICAgICAgICAgICBoZWlnaHQgPSBsaW5lSGVpZ2h0ICogKGxpbmVzLmxlbmd0aCAtIDEpICsgYmFzZWxpbmVPZmZzZXQgKyBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250U2l6ZSkgKyBvZmZzZXRZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldFkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9mZnNldFkgPSBmb250U2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlckluZm8udyA9IHdpZHRoO1xuICAgICAgICByZW5kZXJJbmZvLmggPSBoZWlnaHQ7XG4gICAgICAgIHJlbmRlckluZm8ubGluZXMgPSBsaW5lcztcbiAgICAgICAgcmVuZGVySW5mby5wcmVjaXNpb24gPSBwcmVjaXNpb247XG5cbiAgICAgICAgaWYgKCF3aWR0aCkge1xuICAgICAgICAgICAgLy8gVG8gcHJldmVudCBjYW52YXMgZXJyb3JzLlxuICAgICAgICAgICAgd2lkdGggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGVycm9ycy5cbiAgICAgICAgICAgIGhlaWdodCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3V0U3ggfHwgY3V0RXgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGgsIGN1dEV4IC0gY3V0U3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1dFN5IHx8IGN1dEV5KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIGN1dEV5IC0gY3V0U3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVySW5mby53aWR0aCA9IHdpZHRoO1xuICAgICAgICByZW5kZXJJbmZvLmlubmVyV2lkdGggPSBpbm5lcldpZHRoO1xuICAgICAgICByZW5kZXJJbmZvLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmVuZGVySW5mby5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICByZW5kZXJJbmZvLmN1dFN4ID0gY3V0U3g7XG4gICAgICAgIHJlbmRlckluZm8uY3V0U3kgPSBjdXRTeTtcbiAgICAgICAgcmVuZGVySW5mby5jdXRFeCA9IGN1dEV4O1xuICAgICAgICByZW5kZXJJbmZvLmN1dEV5ID0gY3V0RXk7XG4gICAgICAgIHJlbmRlckluZm8ubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJlbmRlckluZm8ubGluZVdpZHRocyA9IGxpbmVXaWR0aHM7XG4gICAgICAgIHJlbmRlckluZm8ub2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgICAgIHJlbmRlckluZm8ucGFkZGluZ0xlZnQgPSBwYWRkaW5nTGVmdDtcbiAgICAgICAgcmVuZGVySW5mby5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nUmlnaHQ7XG4gICAgICAgIHJlbmRlckluZm8ubGV0dGVyU3BhY2luZyA9IGxldHRlclNwYWNpbmc7XG4gICAgICAgIHJlbmRlckluZm8udGV4dEluZGVudCA9IHRleHRJbmRlbnQ7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlckluZm87XG4gICAgfVxuXG4gICAgX2RyYXcoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlckluZm8gPSB0aGlzLl9jYWxjdWxhdGVSZW5kZXJJbmZvKCk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuZ2V0UHJlY2lzaW9uKCk7XG5cbiAgICAgICAgLy8gQWRkIGV4dHJhIG1hcmdpbiB0byBwcmV2ZW50IGlzc3VlIHdpdGggY2xpcHBlZCB0ZXh0IHdoZW4gc2NhbGluZy5cbiAgICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHJlbmRlckluZm8ud2lkdGggKyB0aGlzLl9zdGFnZS5nZXRPcHRpb24oJ3RleHRSZW5kZXJJc3N1ZU1hcmdpbicpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChyZW5kZXJJbmZvLmhlaWdodCk7XG5cbiAgICAgICAgLy8gQ2FudmFzIGNvbnRleHQgaGFzIGJlZW4gcmVzZXQuXG4gICAgICAgIHRoaXMuc2V0Rm9udFByb3BlcnRpZXMoKTtcblxuICAgICAgICBpZiAocmVuZGVySW5mby5mb250U2l6ZSA+PSAxMjgpIHtcbiAgICAgICAgICAgIC8vIFdwZVdlYktpdCBidWc6IG11c3QgZm9yY2UgY29tcG9zaXRpbmcgYmVjYXVzZSBjYWlyby10cmFwcy1jb21wb3NpdG9yIHdpbGwgbm90IHdvcmsgd2l0aCB0ZXh0IGZpcnN0LlxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5nbG9iYWxBbHBoYSA9IDAuMDE7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxSZWN0KDAsIDAsIDAuMDEsIDAuMDEpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5nbG9iYWxBbHBoYSA9IDEuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJJbmZvLmN1dFN4IHx8IHJlbmRlckluZm8uY3V0U3kpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQudHJhbnNsYXRlKC1yZW5kZXJJbmZvLmN1dFN4LCAtcmVuZGVySW5mby5jdXRTeSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGluZVBvc2l0aW9uWDtcbiAgICAgICAgbGV0IGxpbmVQb3NpdGlvblk7XG5cbiAgICAgICAgbGV0IGRyYXdMaW5lcyA9IFtdO1xuXG4gICAgICAgIC8vIERyYXcgbGluZXMgbGluZSBieSBsaW5lLlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHJlbmRlckluZm8ubGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YID0gaSA9PT0gMCA/IHJlbmRlckluZm8udGV4dEluZGVudCA6IDA7XG5cbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHRleHQgaXMgYWxpZ25lZCB0byB0b3BcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgPSAoaSAqIHJlbmRlckluZm8ubGluZUhlaWdodCkgKyByZW5kZXJJbmZvLm9mZnNldFk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy52ZXJ0aWNhbEFsaWduID09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWSArPSAocmVuZGVySW5mby5saW5lSGVpZ2h0IC0gcmVuZGVySW5mby5mb250U2l6ZSkgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zZXR0aW5ncy52ZXJ0aWNhbEFsaWduID09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWSArPSByZW5kZXJJbmZvLmxpbmVIZWlnaHQgLSByZW5kZXJJbmZvLmZvbnRTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MudGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAocmVuZGVySW5mby5pbm5lcldpZHRoIC0gcmVuZGVySW5mby5saW5lV2lkdGhzW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2V0dGluZ3MudGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKChyZW5kZXJJbmZvLmlubmVyV2lkdGggLSByZW5kZXJJbmZvLmxpbmVXaWR0aHNbaV0pIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IHJlbmRlckluZm8ucGFkZGluZ0xlZnQ7XG5cbiAgICAgICAgICAgIGRyYXdMaW5lcy5wdXNoKHt0ZXh0OiByZW5kZXJJbmZvLmxpbmVzW2ldLCB4OiBsaW5lUG9zaXRpb25YLCB5OiBsaW5lUG9zaXRpb25ZLCB3OiByZW5kZXJJbmZvLmxpbmVXaWR0aHNbaV19KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhpZ2hsaWdodC5cbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodCkge1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0Q29sb3IgfHwgMHgwMDAwMDAwMDtcblxuICAgICAgICAgICAgbGV0IGhsSGVpZ2h0ID0gKHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodEhlaWdodCAqIHByZWNpc2lvbiB8fCByZW5kZXJJbmZvLmZvbnRTaXplICogMS41KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodE9mZnNldCAqIHByZWNpc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IGhsUGFkZGluZ0xlZnQgPSAodGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0UGFkZGluZ0xlZnQgIT09IG51bGwgPyB0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRQYWRkaW5nTGVmdCAqIHByZWNpc2lvbiA6IHJlbmRlckluZm8ucGFkZGluZ0xlZnQpO1xuICAgICAgICAgICAgY29uc3QgaGxQYWRkaW5nUmlnaHQgPSAodGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ICE9PSBudWxsID8gdGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ICogcHJlY2lzaW9uIDogcmVuZGVySW5mby5wYWRkaW5nUmlnaHQpO1xuXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyhjb2xvcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyYXdMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBkcmF3TGluZSA9IGRyYXdMaW5lc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxSZWN0KChkcmF3TGluZS54IC0gaGxQYWRkaW5nTGVmdCksIChkcmF3TGluZS55IC0gcmVuZGVySW5mby5vZmZzZXRZICsgb2Zmc2V0KSwgKGRyYXdMaW5lLncgKyBobFBhZGRpbmdSaWdodCArIGhsUGFkZGluZ0xlZnQpLCBobEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXh0IHNoYWRvdy5cbiAgICAgICAgbGV0IHByZXZTaGFkb3dTZXR0aW5ncyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zaGFkb3cpIHtcbiAgICAgICAgICAgIHByZXZTaGFkb3dTZXR0aW5ncyA9IFt0aGlzLl9jb250ZXh0LnNoYWRvd0NvbG9yLCB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFgsIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WSwgdGhpcy5fY29udGV4dC5zaGFkb3dCbHVyXTtcblxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dDb2xvciA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyh0aGlzLl9zZXR0aW5ncy5zaGFkb3dDb2xvcik7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFggPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3dPZmZzZXRYICogcHJlY2lzaW9uO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRZID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93T2Zmc2V0WSAqIHByZWNpc2lvbjtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93Qmx1ciA9IHRoaXMuX3NldHRpbmdzLnNoYWRvd0JsdXIgKiBwcmVjaXNpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyh0aGlzLl9zZXR0aW5ncy50ZXh0Q29sb3IpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGRyYXdMaW5lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkcmF3TGluZSA9IGRyYXdMaW5lc1tpXTtcblxuICAgICAgICAgICAgaWYgKHJlbmRlckluZm8ubGV0dGVyU3BhY2luZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFRleHQoZHJhd0xpbmUudGV4dCwgZHJhd0xpbmUueCwgZHJhd0xpbmUueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRTcGxpdCA9IGRyYXdMaW5lLnRleHQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGxldCB4ID0gZHJhd0xpbmUueDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRleHRTcGxpdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsVGV4dCh0ZXh0U3BsaXRbaV0sIHgsIGRyYXdMaW5lLnkpO1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHRoaXMubWVhc3VyZVRleHQodGV4dFNwbGl0W2ldLCByZW5kZXJJbmZvLmxldHRlclNwYWNpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2U2hhZG93U2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93Q29sb3IgPSBwcmV2U2hhZG93U2V0dGluZ3NbMF07XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFggPSBwcmV2U2hhZG93U2V0dGluZ3NbMV07XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFkgPSBwcmV2U2hhZG93U2V0dGluZ3NbMl07XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd0JsdXIgPSBwcmV2U2hhZG93U2V0dGluZ3NbM107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVySW5mby5jdXRTeCB8fCByZW5kZXJJbmZvLmN1dFN5KSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnRyYW5zbGF0ZShyZW5kZXJJbmZvLmN1dFN4LCByZW5kZXJJbmZvLmN1dFN5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVySW5mbyA9IHJlbmRlckluZm87XG4gICAgfTtcblxuICAgIHdyYXBXb3JkKHdvcmQsIHdvcmRXcmFwV2lkdGgsIHN1ZmZpeCkge1xuICAgICAgICBjb25zdCBzdWZmaXhXaWR0aCA9IHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQoc3VmZml4KS53aWR0aDtcbiAgICAgICAgY29uc3Qgd29yZExlbiA9IHdvcmQubGVuZ3RoXG4gICAgICAgIGNvbnN0IHdvcmRXaWR0aCA9IHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQod29yZCkud2lkdGg7XG5cbiAgICAgICAgLyogSWYgd29yZCBmaXRzIHdyYXBXaWR0aCwgZG8gbm90aGluZyAqL1xuICAgICAgICBpZiAod29yZFdpZHRoIDw9IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogTWFrZSBpbml0aWFsIGd1ZXNzIGZvciB0ZXh0IGN1dHRvZmYgKi9cbiAgICAgICAgbGV0IGN1dG9mZkluZGV4ID0gTWF0aC5mbG9vcigod29yZFdyYXBXaWR0aCAqIHdvcmRMZW4pIC8gd29yZFdpZHRoKTtcbiAgICAgICAgbGV0IHRydW5jV29yZFdpZHRoID0gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh3b3JkLnN1YnN0cmluZygwLCBjdXRvZmZJbmRleCkpLndpZHRoICsgc3VmZml4V2lkdGg7XG5cbiAgICAgICAgLyogSW4gY2FzZSBndWVzcyB3YXMgb3ZlcmVzdGltYXRlZCwgc2hyaW5rIGl0IGxldHRlciBieSBsZXR0ZXIuICovXG4gICAgICAgIGlmICh0cnVuY1dvcmRXaWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgIHdoaWxlIChjdXRvZmZJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICB0cnVuY1dvcmRXaWR0aCA9IHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQod29yZC5zdWJzdHJpbmcoMCwgY3V0b2ZmSW5kZXgpKS53aWR0aCArIHN1ZmZpeFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh0cnVuY1dvcmRXaWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0b2ZmSW5kZXggLT0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLyogSW4gY2FzZSBndWVzcyB3YXMgdW5kZXJlc3RpbWF0ZWQsIGV4dGVuZCBpdCBsZXR0ZXIgYnkgbGV0dGVyLiAqL1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGN1dG9mZkluZGV4IDwgd29yZExlbikge1xuICAgICAgICAgICAgICAgIHRydW5jV29yZFdpZHRoID0gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh3b3JkLnN1YnN0cmluZygwLCBjdXRvZmZJbmRleCkpLndpZHRoICsgc3VmZml4V2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRydW5jV29yZFdpZHRoIDwgd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXRvZmZJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIHdoZW4gYm91bmQgaXMgY3Jvc3NlZCwgcmV0cmFjdCBsYXN0IGxldHRlci5cbiAgICAgICAgICAgICAgICAgICAgY3V0b2ZmSW5kZXggLT0xO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBJZiB3cmFwV2lkdGggaXMgdG9vIHNob3J0IHRvIGV2ZW4gY29udGFpbiBzdWZmaXggYWxvbmUsIHJldHVybiBlbXB0eSBzdHJpbmcgKi9cbiAgICAgICAgcmV0dXJuIHdvcmQuc3Vic3RyaW5nKDAsIGN1dG9mZkluZGV4KSArICh3b3JkV3JhcFdpZHRoID49IHN1ZmZpeFdpZHRoID8gc3VmZml4IDogJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgbmV3bGluZXMgdG8gYSBzdHJpbmcgdG8gaGF2ZSBpdCBvcHRpbWFsbHkgZml0IGludG8gdGhlIGhvcml6b250YWxcbiAgICAgKiBib3VuZHMgc2V0IGJ5IHRoZSBUZXh0IG9iamVjdCdzIHdvcmRXcmFwV2lkdGggcHJvcGVydHkuXG4gICAgICovXG4gICAgd3JhcFRleHQodGV4dCwgd29yZFdyYXBXaWR0aCwgbGV0dGVyU3BhY2luZywgaW5kZW50ID0gMCkge1xuICAgICAgICAvLyBHcmVlZHkgd3JhcHBpbmcgYWxnb3JpdGhtIHRoYXQgd2lsbCB3cmFwIHdvcmRzIGFzIHRoZSBsaW5lIGdyb3dzIGxvbmdlci5cbiAgICAgICAgLy8gdGhhbiBpdHMgaG9yaXpvbnRhbCBib3VuZHMuXG4gICAgICAgIGxldCBsaW5lcyA9IHRleHQuc3BsaXQoL1xccj9cXG4vZyk7XG4gICAgICAgIGxldCBhbGxMaW5lcyA9IFtdO1xuICAgICAgICBsZXQgcmVhbE5ld2xpbmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgbGV0IHNwYWNlTGVmdCA9IHdvcmRXcmFwV2lkdGggLSBpbmRlbnQ7XG4gICAgICAgICAgICBsZXQgd29yZHMgPSBsaW5lc1tpXS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3b3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQod29yZHNbal0sIGxldHRlclNwYWNpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRXaWR0aFdpdGhTcGFjZSA9IHdvcmRXaWR0aCArIHRoaXMubWVhc3VyZVRleHQoJyAnLGxldHRlclNwYWNpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwIHx8IHdvcmRXaWR0aFdpdGhTcGFjZSA+IHNwYWNlTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHByaW50aW5nIHRoZSBuZXdsaW5lIGlmIGl0J3MgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGxpbmUgdGhhdCBpcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ3JlYXRlciB0aGFuIHRoZSB3b3JkIHdyYXAgd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TGluZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdvcmRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBzcGFjZUxlZnQgPSB3b3JkV3JhcFdpZHRoIC0gd29yZFdpZHRoIC0gKGogPT09IDAgPyBpbmRlbnQgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlTGVmdCAtPSB3b3JkV2lkdGhXaXRoU3BhY2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICcgKyB3b3Jkc1tqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdExpbmVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgICAgICBhbGxMaW5lcyA9IGFsbExpbmVzLmNvbmNhdChyZXN1bHRMaW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChpIDwgbGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJlYWxOZXdsaW5lcy5wdXNoKGFsbExpbmVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge2w6IGFsbExpbmVzLCBuOiByZWFsTmV3bGluZXN9O1xuICAgIH07XG5cbiAgICBtZWFzdXJlVGV4dCh3b3JkLCBzcGFjZSA9IDApIHtcbiAgICAgICAgaWYgKCFzcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQod29yZCkud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmQuc3BsaXQoJycpLnJlZHVjZSgoYWNjLCBjaGFyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChjaGFyKS53aWR0aCArIHNwYWNlO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0VGV4dHVyZVJlbmRlcmVyQWR2YW5jZWQge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UsIGNhbnZhcywgc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fc3RhZ2UgPSBzdGFnZTtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgZ2V0UHJlY2lzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3MucHJlY2lzaW9uO1xuICAgIH07XG5cbiAgICBzZXRGb250UHJvcGVydGllcygpIHtcbiAgICAgICAgY29uc3QgZm9udCA9IFV0aWxzLmlzU3BhcmsgPyB0aGlzLl9zdGFnZS5wbGF0Zm9ybS5nZXRGb250U2V0dGluZyh0aGlzKSA6IHRoaXMuX2dldEZvbnRTZXR0aW5nKCk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgICAgIHRoaXMuX2NvbnRleHQudGV4dEJhc2VsaW5lID0gdGhpcy5fc2V0dGluZ3MudGV4dEJhc2VsaW5lO1xuICAgICAgICByZXR1cm4gZm9udDtcbiAgICB9O1xuXG4gICAgX2dldEZvbnRTZXR0aW5nKCkge1xuICAgICAgICBsZXQgZmYgPSB0aGlzLl9zZXR0aW5ncy5mb250RmFjZTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmYpKSB7XG4gICAgICAgICAgICBmZiA9IFtmZl07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmZzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZmYubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZmZbaV0gPT09IFwic2VyaWZcIiB8fCBmZltpXSA9PT0gXCJzYW5zLXNlcmlmXCIpIHtcbiAgICAgICAgICAgICAgICBmZnMucHVzaChmZltpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZmcy5wdXNoKGBcIiR7ZmZbaV19XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgJHt0aGlzLl9zZXR0aW5ncy5mb250U3R5bGV9ICR7dGhpcy5fc2V0dGluZ3MuZm9udFNpemUgKiB0aGlzLmdldFByZWNpc2lvbigpfXB4ICR7ZmZzLmpvaW4oXCIsXCIpfWBcbiAgICB9XG5cbiAgICBfbG9hZCgpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzV2ViICYmIGRvY3VtZW50LmZvbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBmb250U2V0dGluZyA9IHRoaXMuX2dldEZvbnRTZXR0aW5nKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuZm9udHMuY2hlY2soZm9udFNldHRpbmcsIHRoaXMuX3NldHRpbmdzLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhIHByb21pc2UgdGhhdCB3YWl0cyBmb3IgbG9hZGluZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmZvbnRzLmxvYWQoZm9udFNldHRpbmcsIHRoaXMuX3NldHRpbmdzLnRleHQpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGxvYWQgdGhlIGZhbGxiYWNrIGZvbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZvbnQgbG9hZCBlcnJvcicsIGVyciwgZm9udFNldHRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuZm9udHMuY2hlY2soZm9udFNldHRpbmcsIHRoaXMuX3NldHRpbmdzLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGb250IG5vdCBmb3VuZCcsIGZvbnRTZXR0aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ2FuJ3QgY2hlY2sgZm9udCBsb2FkaW5nIGZvciBcIiArIGZvbnRTZXR0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRyYXcoKSB7XG4gICAgICAgIC8vIFdlIGRvIG5vdCB1c2UgYSBwcm9taXNlIHNvIHRoYXQgbG9hZGluZyBpcyBwZXJmb3JtZWQgc3luY3Jvbm91cyB3aGVuIHBvc3NpYmxlLlxuICAgICAgICBjb25zdCBsb2FkUHJvbWlzZSA9IHRoaXMuX2xvYWQoKTtcbiAgICAgICAgaWYgKCFsb2FkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLmlzU3BhcmsgPyB0aGlzLl9zdGFnZS5wbGF0Zm9ybS5kcmF3VGV4dCh0aGlzKSA6IHRoaXMuX2RyYXcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMuaXNTcGFyayA/IHRoaXMuX3N0YWdlLnBsYXRmb3JtLmRyYXdUZXh0KHRoaXMpIDogdGhpcy5fZHJhdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlUmVuZGVySW5mbygpIHtcbiAgICAgICAgbGV0IHJlbmRlckluZm8gPSB7fTtcblxuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLmdldFByZWNpc2lvbigpO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmdMZWZ0ID0gdGhpcy5fc2V0dGluZ3MucGFkZGluZ0xlZnQgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IHRoaXMuX3NldHRpbmdzLnBhZGRpbmdSaWdodCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9zZXR0aW5ncy5mb250U2l6ZSAqIHByZWNpc2lvbjtcbiAgICAgICAgLy8gY29uc3Qgb2Zmc2V0WSA9IHRoaXMuX3NldHRpbmdzLm9mZnNldFkgPT09IG51bGwgPyBudWxsIDogKHRoaXMuX3NldHRpbmdzLm9mZnNldFkgKiBwcmVjaXNpb24pO1xuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhpcy5fc2V0dGluZ3MubGluZUhlaWdodCAqIHByZWNpc2lvbiB8fCBmb250U2l6ZTtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMuX3NldHRpbmdzLncgIT0gMCA/IHRoaXMuX3NldHRpbmdzLncgKiBwcmVjaXNpb24gOiAyMDQ4IC8gcHJlY2lzaW9uO1xuICAgICAgICAvLyBjb25zdCBoID0gdGhpcy5fc2V0dGluZ3MuaCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3Qgd29yZFdyYXBXaWR0aCA9IHRoaXMuX3NldHRpbmdzLndvcmRXcmFwV2lkdGggKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGN1dFN4ID0gdGhpcy5fc2V0dGluZ3MuY3V0U3ggKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGN1dEV4ID0gdGhpcy5fc2V0dGluZ3MuY3V0RXggKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGN1dFN5ID0gdGhpcy5fc2V0dGluZ3MuY3V0U3kgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGN1dEV5ID0gdGhpcy5fc2V0dGluZ3MuY3V0RXkgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGxldHRlclNwYWNpbmcgPSB0aGlzLl9zZXR0aW5ncy5sZXR0ZXJTcGFjaW5nIHx8IDA7XG5cbiAgICAgICAgLy8gU2V0IGZvbnQgcHJvcGVydGllcy5cbiAgICAgICAgcmVuZGVySW5mby5iYXNlRm9udCA9IHRoaXMuc2V0Rm9udFByb3BlcnRpZXMoKTtcblxuICAgICAgICByZW5kZXJJbmZvLncgPSB3O1xuICAgICAgICByZW5kZXJJbmZvLndpZHRoID0gdztcbiAgICAgICAgcmVuZGVySW5mby50ZXh0ID0gdGhpcy5fc2V0dGluZ3MudGV4dDtcbiAgICAgICAgcmVuZGVySW5mby5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICAgIHJlbmRlckluZm8uZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgcmVuZGVySW5mby5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgcmVuZGVySW5mby5sZXR0ZXJTcGFjaW5nID0gbGV0dGVyU3BhY2luZztcbiAgICAgICAgcmVuZGVySW5mby50ZXh0QWxpZ24gPSB0aGlzLl9zZXR0aW5ncy50ZXh0QWxpZ247XG4gICAgICAgIHJlbmRlckluZm8udGV4dENvbG9yID0gdGhpcy5fc2V0dGluZ3MudGV4dENvbG9yO1xuICAgICAgICByZW5kZXJJbmZvLnZlcnRpY2FsQWxpZ24gPSB0aGlzLl9zZXR0aW5ncy52ZXJ0aWNhbEFsaWduO1xuICAgICAgICByZW5kZXJJbmZvLmhpZ2hsaWdodCA9IHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodDtcbiAgICAgICAgcmVuZGVySW5mby5oaWdobGlnaHRDb2xvciA9IHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodENvbG9yO1xuICAgICAgICByZW5kZXJJbmZvLmhpZ2hsaWdodEhlaWdodCA9IHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodEhlaWdodDtcbiAgICAgICAgcmVuZGVySW5mby5oaWdobGlnaHRQYWRkaW5nTGVmdCA9IHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodFBhZGRpbmdMZWZ0O1xuICAgICAgICByZW5kZXJJbmZvLmhpZ2hsaWdodFBhZGRpbmdSaWdodCA9IHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodFBhZGRpbmdSaWdodDtcbiAgICAgICAgcmVuZGVySW5mby5oaWdobGlnaHRPZmZzZXQgPSB0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRPZmZzZXQ7XG4gICAgICAgIHJlbmRlckluZm8ucGFkZGluZ0xlZnQgPSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nTGVmdDtcbiAgICAgICAgcmVuZGVySW5mby5wYWRkaW5nUmlnaHQgPSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nUmlnaHQ7XG4gICAgICAgIHJlbmRlckluZm8ubWF4TGluZXMgPSB0aGlzLl9zZXR0aW5ncy5tYXhMaW5lcztcbiAgICAgICAgcmVuZGVySW5mby5tYXhMaW5lc1N1ZmZpeCA9IHRoaXMuX3NldHRpbmdzLm1heExpbmVzU3VmZml4O1xuICAgICAgICByZW5kZXJJbmZvLnRleHRPdmVyZmxvdyA9IHRoaXMuX3NldHRpbmdzLnRleHRPdmVyZmxvdztcbiAgICAgICAgcmVuZGVySW5mby53b3JkV3JhcCA9IHRoaXMuX3NldHRpbmdzLndvcmRXcmFwO1xuICAgICAgICByZW5kZXJJbmZvLndvcmRXcmFwV2lkdGggPSB3b3JkV3JhcFdpZHRoO1xuICAgICAgICByZW5kZXJJbmZvLnNoYWRvdyA9IHRoaXMuX3NldHRpbmdzLnNoYWRvdztcbiAgICAgICAgcmVuZGVySW5mby5zaGFkb3dDb2xvciA9IHRoaXMuX3NldHRpbmdzLnNoYWRvd0NvbG9yO1xuICAgICAgICByZW5kZXJJbmZvLnNoYWRvd09mZnNldFggPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3dPZmZzZXRYO1xuICAgICAgICByZW5kZXJJbmZvLnNoYWRvd09mZnNldFkgPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3dPZmZzZXRZO1xuICAgICAgICByZW5kZXJJbmZvLnNoYWRvd0JsdXIgPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3dCbHVyO1xuICAgICAgICByZW5kZXJJbmZvLmN1dFN4ID0gY3V0U3g7XG4gICAgICAgIHJlbmRlckluZm8uY3V0RXggPSBjdXRFeDtcbiAgICAgICAgcmVuZGVySW5mby5jdXRTeSA9IGN1dFN5O1xuICAgICAgICByZW5kZXJJbmZvLmN1dEV5ID0gY3V0RXk7XG4gICAgICAgIHJlbmRlckluZm8udGV4dEluZGVudCA9IHRoaXMuX3NldHRpbmdzLnRleHRJbmRlbnQgKiBwcmVjaXNpb247XG4gICAgICAgIHJlbmRlckluZm8ud29yZEJyZWFrID0gdGhpcy5fc2V0dGluZ3Mud29yZEJyZWFrO1xuXG4gICAgICAgIGxldCB0ZXh0ID0gcmVuZGVySW5mby50ZXh0O1xuICAgICAgICBsZXQgd3JhcFdpZHRoID0gcmVuZGVySW5mby53b3JkV3JhcCA/IChyZW5kZXJJbmZvLndvcmRXcmFwV2lkdGggfHwgcmVuZGVySW5mby53aWR0aCkgOiByZW5kZXJJbmZvLndpZHRoO1xuXG4gICAgICAgIC8vIFRleHQgb3ZlcmZsb3dcbiAgICAgICAgaWYgKHJlbmRlckluZm8udGV4dE92ZXJmbG93ICYmICFyZW5kZXJJbmZvLndvcmRXcmFwKSB7XG4gICAgICAgICAgICBsZXQgc3VmZml4O1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9zZXR0aW5ncy50ZXh0T3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjbGlwJzpcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VsbGlwc2lzJzpcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdGhpcy5fc2V0dGluZ3MubWF4TGluZXNTdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHRoaXMuX3NldHRpbmdzLnRleHRPdmVyZmxvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgPSB0aGlzLndyYXBXb3JkKHRleHQsIHdvcmRXcmFwV2lkdGggfHwgcmVuZGVySW5mby53LCBzdWZmaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IHRoaXMudG9rZW5pemUodGV4dCk7XG4gICAgICAgIHRleHQgPSB0aGlzLnBhcnNlKHRleHQpO1xuICAgICAgICB0ZXh0ID0gdGhpcy5tZWFzdXJlKHRleHQsIGxldHRlclNwYWNpbmcsIHJlbmRlckluZm8uYmFzZUZvbnQpO1xuXG4gICAgICAgIGlmIChyZW5kZXJJbmZvLnRleHRJbmRlbnQpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLmluZGVudCh0ZXh0LCByZW5kZXJJbmZvLnRleHRJbmRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlckluZm8ud29yZEJyZWFrKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZWR1Y2UoKGFjYywgdCkgPT4gYWNjLmNvbmNhdCh0aGlzLndvcmRCcmVhayh0LCB3cmFwV2lkdGgsIHJlbmRlckluZm8uYmFzZUZvbnQpKSwgW10pXG4gICAgICAgICAgICB0aGlzLnJlc2V0Rm9udFN0eWxlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkZXRhaWxlZCBkcmF3aW5nIGluZm9ybWF0aW9uXG4gICAgICAgIGxldCB4ID0gcGFkZGluZ0xlZnQ7XG4gICAgICAgIGxldCBsaW5lTm8gPSAwO1xuXG4gICAgICAgIGZvciAoY29uc3QgdCBvZiB0ZXh0KSB7XG4gICAgICAgICAgICAvLyBXcmFwIHRleHRcbiAgICAgICAgICAgIGlmIChyZW5kZXJJbmZvLndvcmRXcmFwICYmIHggKyB0LndpZHRoID4gd3JhcFdpZHRoIHx8IHQudGV4dCA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIHggPSBwYWRkaW5nTGVmdDtcbiAgICAgICAgICAgICAgICBsaW5lTm8gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQubGluZU5vID0gbGluZU5vO1xuXG4gICAgICAgICAgICBpZiAodC50ZXh0ID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHQueCA9IHg7XG4gICAgICAgICAgICB4ICs9IHQud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVySW5mby5saW5lTnVtID0gbGluZU5vICsgMTtcblxuICAgICAgICAvLyBWZXJ0aWNhbCBhbGlnblxuICAgICAgICBsZXQgdmFPZmZzZXQgPSAwO1xuICAgICAgICBpZiAocmVuZGVySW5mby52ZXJ0aWNhbEFsaWduID09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICB2YU9mZnNldCArPSAocmVuZGVySW5mby5saW5lSGVpZ2h0IC0gcmVuZGVySW5mby5mb250U2l6ZSkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3NldHRpbmdzLnZlcnRpY2FsQWxpZ24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHZhT2Zmc2V0ICs9IHJlbmRlckluZm8ubGluZUhlaWdodCAtIHJlbmRlckluZm8uZm9udFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgbGluZXMgaW5mb3JtYXRpb25cbiAgICAgICAgcmVuZGVySW5mby5saW5lcyA9IFtdXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVySW5mby5saW5lTnVtOyBpKyspIHtcbiAgICAgICAgICAgIHJlbmRlckluZm8ubGluZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiByZW5kZXJJbmZvLmxpbmVIZWlnaHQgKiBpICsgdmFPZmZzZXQsXG4gICAgICAgICAgICAgICAgdGV4dDogW10sXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCB0IG9mIHRleHQpIHtcbiAgICAgICAgICAgIHJlbmRlckluZm8ubGluZXNbdC5saW5lTm9dLnRleHQucHVzaCh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbHRlciBvdXQgd2hpdGUgc3BhY2VzIGF0IGJlZ2lubmluZyBhbmQgZW5kIG9mIGVhY2ggbGluZVxuICAgICAgICBmb3IgKGNvbnN0IGwgb2YgcmVuZGVySW5mby5saW5lcykge1xuICAgICAgICAgICAgaWYgKGwudGV4dC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmaXJzdFdvcmQgPSBsLnRleHRbMF0udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RXb3JkID0gbC50ZXh0W2wudGV4dC5sZW5ndGggLSAxXS50ZXh0O1xuXG4gICAgICAgICAgICBpZiAoZmlyc3RXb3JkID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgbC50ZXh0LnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdFdvcmQgPT0gJyAnIHx8IGxhc3RXb3JkID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgbC50ZXh0LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBDYWxjdWxhdGUgbGluZSB3aWR0aFxuICAgICAgICBmb3IgKGxldCBsIG9mIHJlbmRlckluZm8ubGluZXMpIHtcbiAgICAgICAgICAgIGwud2lkdGggPSBsLnRleHQucmVkdWNlKChhY2MsIHQpID0+IGFjYyArIHQud2lkdGgsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVySW5mby53aWR0aCA9IHRoaXMuX3NldHRpbmdzLncgIT0gMCA/IHRoaXMuX3NldHRpbmdzLncgKiBwcmVjaXNpb24gOiBNYXRoLm1heCguLi5yZW5kZXJJbmZvLmxpbmVzLm1hcCgobCkgPT4gbC53aWR0aCkpICsgcGFkZGluZ1JpZ2h0O1xuICAgICAgICByZW5kZXJJbmZvLncgPSByZW5kZXJJbmZvLndpZHRoO1xuXG4gICAgICAgIC8vIEFwcGx5IG1heExpbmVzU3VmZml4XG4gICAgICAgIGlmIChyZW5kZXJJbmZvLm1heExpbmVzICYmIHJlbmRlckluZm8ubGluZU51bSA+IHJlbmRlckluZm8ubWF4TGluZXMgJiYgcmVuZGVySW5mby5tYXhMaW5lc1N1ZmZpeCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSByZW5kZXJJbmZvLm1heExpbmVzIC0gMTtcbiAgICAgICAgICAgIGxldCBsYXN0TGluZVRleHQgPSB0ZXh0LmZpbHRlcigodCkgPT4gdC5saW5lTm8gPT0gaW5kZXgpXG4gICAgICAgICAgICBsZXQgc3VmZml4ID0gcmVuZGVySW5mby5tYXhMaW5lc1N1ZmZpeDtcbiAgICAgICAgICAgIHN1ZmZpeCA9IHRoaXMudG9rZW5pemUoc3VmZml4KTtcbiAgICAgICAgICAgIHN1ZmZpeCA9IHRoaXMucGFyc2Uoc3VmZml4KTtcbiAgICAgICAgICAgIHN1ZmZpeCA9IHRoaXMubWVhc3VyZShzdWZmaXgsIHJlbmRlckluZm8ubGV0dGVyU3BhY2luZywgcmVuZGVySW5mby5iYXNlRm9udClbMF07XG4gICAgICAgICAgICBzdWZmaXgubGluZU5vID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAobGFzdExpbmVUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeC54ID0gbGFzdExpbmVUZXh0W2xhc3RMaW5lVGV4dC5sZW5ndGggLSAxXS54ICsgbGFzdExpbmVUZXh0W2xhc3RMaW5lVGV4dC5sZW5ndGggLSAxXS53aWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VmZml4LnggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdExpbmVUZXh0LnB1c2goc3VmZml4KVxuXG4gICAgICAgICAgICBsZXQgX3cgPSBsYXN0TGluZVRleHQucmVkdWNlKChhY2MsIHQpID0+IGFjYyArIHQud2lkdGgsIDApO1xuICAgICAgICAgICAgd2hpbGUgKF93ID4gcmVuZGVySW5mby53aWR0aCB8fCBsYXN0TGluZVRleHRbbGFzdExpbmVUZXh0Lmxlbmd0aCAtIDJdLnRleHQgPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVUZXh0LnNwbGljZShsYXN0TGluZVRleHQubGVuZ3RoIC0gMiwgMSk7XG4gICAgICAgICAgICAgICAgX3cgPSBsYXN0TGluZVRleHQucmVkdWNlKChhY2MsIHQpID0+IGFjYyArIHQud2lkdGgsIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBsYXN0TGluZVRleHRbbGFzdExpbmVUZXh0Lmxlbmd0aCAtIDJdIHx8IHt4OiAwLCB3aWR0aDogMH1cbiAgICAgICAgICAgICAgICBzdWZmaXgueCA9IHByZXYueCArIHByZXYud2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMaW5lVGV4dC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVySW5mby5saW5lc1tpbmRleF0udGV4dCA9IGxhc3RMaW5lVGV4dDtcbiAgICAgICAgICAgIHJlbmRlckluZm8ubGluZXNbaW5kZXhdLndpZHRoID0gX3c7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuaCkge1xuICAgICAgICAgICAgcmVuZGVySW5mby5oID0gdGhpcy5fc2V0dGluZ3MuaDtcbiAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJJbmZvLm1heExpbmVzICYmIHJlbmRlckluZm8ubWF4TGluZXMgPCByZW5kZXJJbmZvLmxpbmVOdW0pIHtcbiAgICAgICAgICAgIHJlbmRlckluZm8uaCA9IHJlbmRlckluZm8ubWF4TGluZXMgKiByZW5kZXJJbmZvLmxpbmVIZWlnaHQgKyBmb250U2l6ZSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJJbmZvLmggPSByZW5kZXJJbmZvLmxpbmVOdW0gKiByZW5kZXJJbmZvLmxpbmVIZWlnaHQgKyBmb250U2l6ZSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIb3Jpem9udGFsIGFsaWdubWVudCBvZmZzZXRcbiAgICAgICAgaWYgKHJlbmRlckluZm8udGV4dEFsaWduID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBsIG9mIHJlbmRlckluZm8ubGluZXMpIHtcbiAgICAgICAgICAgICAgICBsLnggPSAocmVuZGVySW5mby53aWR0aCAtIGwud2lkdGggLSBwYWRkaW5nTGVmdCkgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlbmRlckluZm8udGV4dEFsaWduID09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGwgb2YgcmVuZGVySW5mby5saW5lcykge1xuICAgICAgICAgICAgICAgIGwueCA9IHJlbmRlckluZm8ud2lkdGggLSBsLndpZHRoIC0gcGFkZGluZ0xlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZGVySW5mbztcbiAgICB9XG5cbiAgICBfZHJhdygpIHtcbiAgICAgICAgY29uc3QgcmVuZGVySW5mbyA9IHRoaXMuX2NhbGN1bGF0ZVJlbmRlckluZm8oKTtcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5nZXRQcmVjaXNpb24oKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ0xlZnQgPSByZW5kZXJJbmZvLnBhZGRpbmdMZWZ0ICogcHJlY2lzaW9uO1xuXG4gICAgICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgICBsZXQgY2FudmFzV2lkdGggPSByZW5kZXJJbmZvLncgfHwgcmVuZGVySW5mby53aWR0aDtcbiAgICAgICAgaWYgKHJlbmRlckluZm8uY3V0U3ggfHwgcmVuZGVySW5mby5jdXRFeCkge1xuICAgICAgICAgICAgY2FudmFzV2lkdGggPSBNYXRoLm1pbihyZW5kZXJJbmZvLncsIHJlbmRlckluZm8uY3V0RXggLSByZW5kZXJJbmZvLmN1dFN4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYW52YXNIZWlnaHQgPSByZW5kZXJJbmZvLmg7XG4gICAgICAgIGlmIChyZW5kZXJJbmZvLmN1dFN5IHx8IHJlbmRlckluZm8uY3V0RXkpIHtcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IE1hdGgubWluKHJlbmRlckluZm8uaCwgcmVuZGVySW5mby5jdXRFeSAtIHJlbmRlckluZm8uY3V0U3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKGNhbnZhc1dpZHRoICsgdGhpcy5fc3RhZ2UuZ2V0T3B0aW9uKCd0ZXh0UmVuZGVySXNzdWVNYXJnaW4nKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoY2FudmFzSGVpZ2h0KTtcblxuICAgICAgICAvLyBDYW52YXMgY29udGV4dCBoYXMgYmVlbiByZXNldC5cbiAgICAgICAgdGhpcy5zZXRGb250UHJvcGVydGllcygpO1xuXG4gICAgICAgIGlmIChyZW5kZXJJbmZvLmZvbnRTaXplID49IDEyOCkge1xuICAgICAgICAgICAgLy8gV3BlV2ViS2l0IGJ1ZzogbXVzdCBmb3JjZSBjb21wb3NpdGluZyBiZWNhdXNlIGNhaXJvLXRyYXBzLWNvbXBvc2l0b3Igd2lsbCBub3Qgd29yayB3aXRoIHRleHQgZmlyc3QuXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0Lmdsb2JhbEFscGhhID0gMC4wMTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFJlY3QoMCwgMCwgMC4wMSwgMC4wMSk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0Lmdsb2JhbEFscGhhID0gMS4wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3V0XG4gICAgICAgIGlmIChyZW5kZXJJbmZvLmN1dFN4IHx8IHJlbmRlckluZm8uY3V0U3kpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQudHJhbnNsYXRlKC1yZW5kZXJJbmZvLmN1dFN4LCAtcmVuZGVySW5mby5jdXRTeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWdobGlnaHRcbiAgICAgICAgaWYgKHJlbmRlckluZm8uaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBobENvbG9yID0gcmVuZGVySW5mby5oaWdobGlnaHRDb2xvciB8fCAweDAwMDAwMDAwO1xuICAgICAgICAgICAgY29uc3QgaGxIZWlnaHQgPSByZW5kZXJJbmZvLmhpZ2hsaWdodEhlaWdodCA/IHJlbmRlckluZm8uaGlnaGxpZ2h0SGVpZ2h0ICogcHJlY2lzaW9uIDogIHJlbmRlckluZm8uZm9udFNpemUgKiAxLjU7XG4gICAgICAgICAgICBjb25zdCBobE9mZnNldCA9IHJlbmRlckluZm8uaGlnaGxpZ2h0T2Zmc2V0ID8gcmVuZGVySW5mby5oaWdobGlnaHRPZmZzZXQgKiBwcmVjaXNpb24gOiAwO1xuICAgICAgICAgICAgY29uc3QgaGxQYWRkaW5nTGVmdCA9IChyZW5kZXJJbmZvLmhpZ2hsaWdodFBhZGRpbmdMZWZ0ICE9PSBudWxsID8gcmVuZGVySW5mby5oaWdobGlnaHRQYWRkaW5nTGVmdCAqIHByZWNpc2lvbiA6IHJlbmRlckluZm8ucGFkZGluZ0xlZnQpO1xuICAgICAgICAgICAgY29uc3QgaGxQYWRkaW5nUmlnaHQgPSAocmVuZGVySW5mby5oaWdobGlnaHRQYWRkaW5nUmlnaHQgIT09IG51bGwgPyByZW5kZXJJbmZvLmhpZ2hsaWdodFBhZGRpbmdSaWdodCAqIHByZWNpc2lvbiA6IHJlbmRlckluZm8ucGFkZGluZ1JpZ2h0KTtcblxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcoaGxDb2xvcik7XG4gICAgICAgICAgICBjb25zdCBsaW5lTnVtID0gcmVuZGVySW5mby5tYXhMaW5lcyA/IE1hdGgubWluKHJlbmRlckluZm8ubWF4TGluZXMsIHJlbmRlckluZm8ubGluZU51bSkgOiByZW5kZXJJbmZvLmxpbmVOdW07IFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lTnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gcmVuZGVySW5mby5saW5lc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxSZWN0KGwueCAtIGhsUGFkZGluZ0xlZnQgKyBwYWRkaW5nTGVmdCwgbC55ICsgaGxPZmZzZXQsIGwud2lkdGggKyBobFBhZGRpbmdMZWZ0ICsgaGxQYWRkaW5nUmlnaHQsIGhsSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRleHQgc2hhZG93LlxuICAgICAgICBsZXQgcHJldlNoYWRvd1NldHRpbmdzID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnNoYWRvdykge1xuICAgICAgICAgICAgcHJldlNoYWRvd1NldHRpbmdzID0gW3RoaXMuX2NvbnRleHQuc2hhZG93Q29sb3IsIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WCwgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRZLCB0aGlzLl9jb250ZXh0LnNoYWRvd0JsdXJdO1xuXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd0NvbG9yID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHRoaXMuX3NldHRpbmdzLnNoYWRvd0NvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WCA9IHRoaXMuX3NldHRpbmdzLnNoYWRvd09mZnNldFggKiBwcmVjaXNpb247XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFkgPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3dPZmZzZXRZICogcHJlY2lzaW9uO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dCbHVyID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93Qmx1ciAqIHByZWNpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgdGV4dFxuICAgICAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcodGhpcy5fc2V0dGluZ3MudGV4dENvbG9yKTtcbiAgICAgICAgbGV0IGN1cnJlbnRDb2xvciA9IGRlZmF1bHRDb2xvcjtcbiAgICAgICAgdGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiByZW5kZXJJbmZvLmxpbmVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgbGluZS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGx4ID0gMDtcblxuICAgICAgICAgICAgICAgIGlmICh0LnRleHQgPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlckluZm8ubWF4TGluZXMgJiYgdC5saW5lTm8gPj0gcmVuZGVySW5mby5tYXhMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodC5jb2xvciAhPSBjdXJyZW50Q29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbG9yID0gdC5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gdC5mb250U3R5bGU7XG5cbiAgICAgICAgICAgICAgICAvLyBEcmF3IHdpdGggbGV0dGVyIHNwYWNpbmdcbiAgICAgICAgICAgICAgICBpZiAodC5sZXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGwgb2YgdC5sZXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfeCA9IHJlbmRlckluZm8ubGluZXNbdC5saW5lTm9dLnggKyB0LnggKyBseDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFRleHQobC50ZXh0LCBfeCwgcmVuZGVySW5mby5saW5lc1t0LmxpbmVOb10ueSArIHJlbmRlckluZm8uZm9udFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbHggKz0gbC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YW5kYXJkIGRyYXdpbmdcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfeCA9IHJlbmRlckluZm8ubGluZXNbdC5saW5lTm9dLnggKyB0Lng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFRleHQodC50ZXh0LCBfeCwgcmVuZGVySW5mby5saW5lc1t0LmxpbmVOb10ueSArIHJlbmRlckluZm8uZm9udFNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHRleHQgc2hhZG93XG4gICAgICAgIGlmIChwcmV2U2hhZG93U2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93Q29sb3IgPSBwcmV2U2hhZG93U2V0dGluZ3NbMF07XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFggPSBwcmV2U2hhZG93U2V0dGluZ3NbMV07XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFkgPSBwcmV2U2hhZG93U2V0dGluZ3NbMl07XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd0JsdXIgPSBwcmV2U2hhZG93U2V0dGluZ3NbM107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCBjdXQgdHJhbnNsYXRpb25cbiAgICAgICAgaWYgKHJlbmRlckluZm8uY3V0U3ggfHwgcmVuZGVySW5mby5jdXRTeSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC50cmFuc2xhdGUocmVuZGVySW5mby5jdXRTeCwgcmVuZGVySW5mby5jdXRTeSk7XG4gICAgICAgIH1cbiBcbiAgICAgICAgLy8gUG9zdHByb2Nlc3MgcmVuZGVySW5mby5saW5lcyB0byBiZSBjb21wYXRpYmxlIHdpdGggc3RhbmRhcmQgdmVyc2lvblxuICAgICAgICByZW5kZXJJbmZvLmxpbmVzID0gcmVuZGVySW5mby5saW5lcy5tYXAoKGwpID0+IGwudGV4dC5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICsgdi50ZXh0LCAnJykpO1xuICAgICAgICBpZiAocmVuZGVySW5mby5tYXhMaW5lcykge1xuICAgICAgICAgICAgcmVuZGVySW5mby5saW5lcyA9IHJlbmRlckluZm8ubGluZXMuc2xpY2UoMCwgcmVuZGVySW5mby5tYXhMaW5lcyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMucmVuZGVySW5mbyA9IHJlbmRlckluZm87XG5cbiAgICB9O1xuXG4gICAgbWVhc3VyZVRleHQod29yZCwgc3BhY2UgPSAwKSB7XG4gICAgICAgIGlmICghc3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmQpLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkLnNwbGl0KCcnKS5yZWR1Y2UoKGFjYywgY2hhcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQoY2hhcikud2lkdGggKyBzcGFjZTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgdG9rZW5pemUodGV4dCkge1xuICAgICAgICBjb25zdCByZSA9LyB8XFxufDxpPnw8XFwvaT58PGI+fDxcXC9iPnw8Y29sb3I9MFt4WF1bMC05YS1mQS1GXXs4fT58PFxcL2NvbG9yPi9nXG4gICAgXG4gICAgICAgIGNvbnN0IGRlbGltZXRlcnMgPSB0ZXh0Lm1hdGNoKHJlKSB8fCBbXTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSB0ZXh0LnNwbGl0KHJlKSB8fCBbXTtcbiAgICBcbiAgICAgICAgbGV0IGZpbmFsID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZpbmFsLnB1c2god29yZHNbaV0sIGRlbGltZXRlcnNbaV0pXG4gICAgICAgIH1cbiAgICAgICAgZmluYWwucG9wKClcbiAgICAgICAgcmV0dXJuIGZpbmFsLmZpbHRlcigod29yZCkgPT4gd29yZCAhPSAnJyk7XG4gICAgXG4gICAgfVxuICAgIFxuICAgIHBhcnNlKHRva2Vucykge1xuICAgICAgICBsZXQgaXRhbGljID0gMDtcbiAgICAgICAgbGV0IGJvbGQgPSAwO1xuICAgICAgICBsZXQgY29sb3JTdGFjayA9IFtTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcodGhpcy5fc2V0dGluZ3MudGV4dENvbG9yKV07XG4gICAgICAgIGxldCBjb2xvciA9IDA7XG5cbiAgICAgICAgY29uc3QgY29sb3JSZWdleHAgPSAvPGNvbG9yPSg/PGNvbG9yPjBbeFhdWzAtOWEtZkEtRl17OH0pLztcbiAgICBcbiAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0ID09ICc8aT4nKSB7XG4gICAgICAgICAgICAgICAgaXRhbGljICs9IDE7XG4gICAgICAgICAgICAgICAgdCA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ID09ICc8L2k+JyAmJiBpdGFsaWMgPiAwKSB7XG4gICAgICAgICAgICAgICAgaXRhbGljIC09IDE7XG4gICAgICAgICAgICAgICAgdCA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ID09ICc8Yj4nKSB7XG4gICAgICAgICAgICAgICAgYm9sZCArPSAxO1xuICAgICAgICAgICAgICAgIHQgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodCA9PSAnPC9iPicgJiYgYm9sZCA+IDApIHtcbiAgICAgICAgICAgICAgICBib2xkIC09IDE7XG4gICAgICAgICAgICAgICAgdCA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ID09ICc8L2NvbG9yPicpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JTdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sb3JSZWdleHAudGVzdCh0KSkge1xuICAgICAgICAgICAgICAgIGNvbG9yU3RhY2sucHVzaChTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcocGFyc2VJbnQoY29sb3JSZWdleHAuZXhlYyh0KS5ncm91cHNbJ2NvbG9yJ10pKSk7XG4gICAgICAgICAgICAgICAgY29sb3IgKz0gMTtcbiAgICAgICAgICAgICAgICB0ID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogdCxcbiAgICAgICAgICAgICAgICBpdGFsaWM6IGl0YWxpYyxcbiAgICAgICAgICAgICAgICBib2xkOiBib2xkLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvclN0YWNrW2NvbG9yXSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmZpbHRlcigobykgPT4gby50ZXh0ICE9ICcnKTtcbiAgICB9XG5cbiAgICBhcHBseUZvbnRTdHlsZSh3b3JkLCBiYXNlRm9udCkge1xuICAgICAgICBsZXQgZm9udCA9IGJhc2VGb250O1xuICAgICAgICBpZiAod29yZC5ib2xkKSB7XG4gICAgICAgICAgICBmb250ID0gJ2JvbGQgJyArIGZvbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmQuaXRhbGljKSB7XG4gICAgICAgICAgICBmb250ID0gJ2l0YWxpYyAnICsgZm9udDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0LmZvbnQgPSBmb250XG4gICAgICAgIHdvcmQuZm9udFN0eWxlID0gZm9udDtcbiAgICB9XG5cbiAgICByZXNldEZvbnRTdHlsZShiYXNlRm9udCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmZvbnQgPSBiYXNlRm9udDtcbiAgICB9XG5cbiAgICBtZWFzdXJlKHBhcnNlZCwgbGV0dGVyU3BhY2luZyA9IDAsIGJhc2VGb250KSB7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwYXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlGb250U3R5bGUocCwgYmFzZUZvbnQpO1xuICAgICAgICAgICAgcC53aWR0aCA9IHRoaXMubWVhc3VyZVRleHQocC50ZXh0LCBsZXR0ZXJTcGFjaW5nKTtcblxuICAgICAgICAgICAgLy8gTGV0dGVyIGJ5IGxldHRlciBkZXRhaWwgZm9yIGxldHRlciBzcGFjaW5nXG4gICAgICAgICAgICBpZiAobGV0dGVyU3BhY2luZyA+IDApIHtcbiAgICAgICAgICAgICAgICBwLmxldHRlcnMgPSBwLnRleHQuc3BsaXQoJycpLm1hcCgobCkgPT4ge3JldHVybiB7dGV4dDogbH19KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsIG9mIHAubGV0dGVycykge1xuICAgICAgICAgICAgICAgICAgICBsLndpZHRoID0gdGhpcy5tZWFzdXJlVGV4dChsLnRleHQsIGxldHRlclNwYWNpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRGb250U3R5bGUoYmFzZUZvbnQpO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cblxuICAgIGluZGVudChwYXJzZWQsIHRleHRJbmRlbnQpIHtcbiAgICAgICAgcGFyc2VkLnNwbGljZSgwLCAwLCB7dGV4dDogXCJcIiwgd2lkdGg6IHRleHRJbmRlbnR9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG5cbiAgICB3cmFwV29yZCh3b3JkLCB3b3JkV3JhcFdpZHRoLCBzdWZmaXgpIHtcbiAgICAgICAgY29uc3Qgc3VmZml4V2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHN1ZmZpeCkud2lkdGg7XG4gICAgICAgIGNvbnN0IHdvcmRMZW4gPSB3b3JkLmxlbmd0aFxuICAgICAgICBjb25zdCB3b3JkV2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmQpLndpZHRoO1xuXG4gICAgICAgIC8qIElmIHdvcmQgZml0cyB3cmFwV2lkdGgsIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgaWYgKHdvcmRXaWR0aCA8PSB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIE1ha2UgaW5pdGlhbCBndWVzcyBmb3IgdGV4dCBjdXR0b2ZmICovXG4gICAgICAgIGxldCBjdXRvZmZJbmRleCA9IE1hdGguZmxvb3IoKHdvcmRXcmFwV2lkdGggKiB3b3JkTGVuKSAvIHdvcmRXaWR0aCk7XG4gICAgICAgIGxldCB0cnVuY1dvcmRXaWR0aCA9IHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQod29yZC5zdWJzdHJpbmcoMCwgY3V0b2ZmSW5kZXgpKS53aWR0aCArIHN1ZmZpeFdpZHRoO1xuXG4gICAgICAgIC8qIEluIGNhc2UgZ3Vlc3Mgd2FzIG92ZXJlc3RpbWF0ZWQsIHNocmluayBpdCBsZXR0ZXIgYnkgbGV0dGVyLiAqL1xuICAgICAgICBpZiAodHJ1bmNXb3JkV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICB3aGlsZSAoY3V0b2ZmSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHJ1bmNXb3JkV2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmQuc3Vic3RyaW5nKDAsIGN1dG9mZkluZGV4KSkud2lkdGggKyBzdWZmaXhXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAodHJ1bmNXb3JkV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dG9mZkluZGV4IC09IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8qIEluIGNhc2UgZ3Vlc3Mgd2FzIHVuZGVyZXN0aW1hdGVkLCBleHRlbmQgaXQgbGV0dGVyIGJ5IGxldHRlci4gKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChjdXRvZmZJbmRleCA8IHdvcmRMZW4pIHtcbiAgICAgICAgICAgICAgICB0cnVuY1dvcmRXaWR0aCA9IHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQod29yZC5zdWJzdHJpbmcoMCwgY3V0b2ZmSW5kZXgpKS53aWR0aCArIHN1ZmZpeFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh0cnVuY1dvcmRXaWR0aCA8IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0b2ZmSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCB3aGVuIGJvdW5kIGlzIGNyb3NzZWQsIHJldHJhY3QgbGFzdCBsZXR0ZXIuXG4gICAgICAgICAgICAgICAgICAgIGN1dG9mZkluZGV4IC09MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogSWYgd3JhcFdpZHRoIGlzIHRvbyBzaG9ydCB0byBldmVuIGNvbnRhaW4gc3VmZml4IGFsb25lLCByZXR1cm4gZW1wdHkgc3RyaW5nICovXG4gICAgICAgIHJldHVybiB3b3JkLnN1YnN0cmluZygwLCBjdXRvZmZJbmRleCkgKyAod29yZFdyYXBXaWR0aCA+PSBzdWZmaXhXaWR0aCA/IHN1ZmZpeCA6ICcnKVxuICAgIH1cblxuICAgIF9nZXRCcmVha0luZGV4KHdvcmQsIHdpZHRoKSB7XG4gICAgICAgIGNvbnN0IHdvcmRMZW4gPSB3b3JkLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgd29yZFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dCh3b3JkKTtcblxuICAgICAgICBpZiAod29yZFdpZHRoIDw9IHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4ge2JyZWFrSW5kZXg6IHdvcmQubGVuZ3RoLCB0cnVuY1dvcmRXaWR0aDogd29yZFdpZHRofTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBicmVha0luZGV4ID0gTWF0aC5mbG9vcigod2lkdGggKiB3b3JkTGVuKSAvIHdvcmRXaWR0aCk7XG4gICAgICAgIGxldCB0cnVuY1dvcmRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQod29yZC5zdWJzdHJpbmcoMCwgYnJlYWtJbmRleCkpXG5cbiAgICAgICAgLyogSW4gY2FzZSBndWVzcyB3YXMgb3ZlcmVzdGltYXRlZCwgc2hyaW5rIGl0IGxldHRlciBieSBsZXR0ZXIuICovXG4gICAgICAgIGlmICh0cnVuY1dvcmRXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgICB3aGlsZSAoYnJlYWtJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICB0cnVuY1dvcmRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQod29yZC5zdWJzdHJpbmcoMCwgYnJlYWtJbmRleCkpO1xuICAgICAgICAgICAgICAgIGlmICh0cnVuY1dvcmRXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrSW5kZXggLT0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLyogSW4gY2FzZSBndWVzcyB3YXMgdW5kZXJlc3RpbWF0ZWQsIGV4dGVuZCBpdCBsZXR0ZXIgYnkgbGV0dGVyLiAqL1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGJyZWFrSW5kZXggPCB3b3JkTGVuKSB7XG4gICAgICAgICAgICAgICAgdHJ1bmNXb3JkV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KHdvcmQuc3Vic3RyaW5nKDAsIGJyZWFrSW5kZXgpKTtcbiAgICAgICAgICAgICAgICBpZiAodHJ1bmNXb3JkV2lkdGggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVha0luZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWxseSwgd2hlbiBib3VuZCBpcyBjcm9zc2VkLCByZXRyYWN0IGxhc3QgbGV0dGVyLlxuICAgICAgICAgICAgICAgICAgICBicmVha0luZGV4IC09MTtcbiAgICAgICAgICAgICAgICAgICAgdHJ1bmNXb3JkV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KHdvcmQuc3Vic3RyaW5nKDAsIGJyZWFrSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7YnJlYWtJbmRleCwgdHJ1bmNXb3JkV2lkdGh9O1xuXG4gICAgfVxuXG4gICAgd29yZEJyZWFrKHdvcmQsIHdpZHRoLCBiYXNlRm9udCkge1xuICAgICAgICBpZiAoIXdvcmQudGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHdvcmRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGx5Rm9udFN0eWxlKHdvcmQsIGJhc2VGb250KVxuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBsZXQgdGV4dCA9IHdvcmQudGV4dDtcbiAgICAgICAgaWYgKCF3b3JkLmxldHRlcnMpIHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qge2JyZWFrSW5kZXgsIHRydW5jV29yZFdpZHRofSA9IHRoaXMuX2dldEJyZWFrSW5kZXgodGV4dCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goey4uLndvcmR9KTtcbiAgICAgICAgICAgICAgICBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50ZXh0ID0gdGV4dC5zbGljZSgwLCBicmVha0luZGV4KTtcbiAgICAgICAgICAgICAgICBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS53aWR0aCA9IHRydW5jV29yZFdpZHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJyZWFrSW5kZXggPT09IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGJyZWFrSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRvdGFsV2lkdGggPSAwO1xuICAgICAgICAgICAgbGV0IGxldHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBicmVha0luZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbCBvZiB3b3JkLmxldHRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG90YWxXaWR0aCArIGwud2lkdGggPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh7Li4ud29yZH0pO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50ZXh0ID0gdGV4dC5zbGljZSgwLCBicmVha0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0ud2lkdGggPSB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5sZXR0ZXJzID0gbGV0dGVycztcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoYnJlYWtJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXR0ZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrSW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBsZXR0ZXJzLnB1c2gobCk7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gbC53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goey4uLndvcmR9KTtcbiAgICAgICAgICAgICAgICBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50ZXh0ID0gdGV4dC5zbGljZSgwLCBicmVha0luZGV4KTtcbiAgICAgICAgICAgICAgICBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS53aWR0aCA9IHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0ubGV0dGVycyA9IGxldHRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxufSIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXVsdGlTcGxpbmUge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgfVxuXG4gICAgX2NsZWFyKCkge1xuICAgICAgICB0aGlzLl9wID0gW107XG4gICAgICAgIHRoaXMuX3BlID0gW107XG4gICAgICAgIHRoaXMuX2lkcCA9IFtdO1xuICAgICAgICB0aGlzLl9mID0gW107XG4gICAgICAgIHRoaXMuX3YgPSBbXTtcbiAgICAgICAgdGhpcy5fbHYgPSBbXTtcbiAgICAgICAgdGhpcy5fc20gPSBbXTtcbiAgICAgICAgdGhpcy5fcyA9IFtdO1xuICAgICAgICB0aGlzLl92ZSA9IFtdO1xuICAgICAgICB0aGlzLl9zbWUgPSBbXTtcbiAgICAgICAgdGhpcy5fc2UgPSBbXTtcblxuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHBhcnNlKHJnYmEsIGRlZikge1xuICAgICAgICBsZXQgaSwgbjtcbiAgICAgICAgaWYgKCFVdGlscy5pc09iamVjdExpdGVyYWwoZGVmKSkge1xuICAgICAgICAgICAgZGVmID0gezA6IGRlZn1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkZWZhdWx0U21vb3RobmVzcyA9IDAuNTtcblxuICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGRlZikge1xuICAgICAgICAgICAgaWYgKGRlZi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9iaiA9IGRlZltrZXldO1xuICAgICAgICAgICAgICAgIGlmICghVXRpbHMuaXNPYmplY3RMaXRlcmFsKG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0ge3Y6IG9ian1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgcCA9IHBhcnNlRmxvYXQoa2V5KTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwic21cIikge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U21vb3RobmVzcyA9IG9iai52O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHApICYmIHAgPj0gMCAmJiBwIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnAgPSBwO1xuXG4gICAgICAgICAgICAgICAgICAgIG9iai5mID0gVXRpbHMuaXNGdW5jdGlvbihvYmoudik7XG4gICAgICAgICAgICAgICAgICAgIG9iai5sdiA9IG9iai5mID8gb2JqLnYoMCwgMCkgOiBvYmoudjtcblxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29ydCBieSBwcm9ncmVzcyB2YWx1ZS5cbiAgICAgICAgaXRlbXMgPSBpdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtyZXR1cm4gYS5wIC0gYi5wfSk7XG5cbiAgICAgICAgbiA9IGl0ZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IChpID09PSBuIC0gMSk7XG4gICAgICAgICAgICBpZiAoIWl0ZW1zW2ldLmhhc093blByb3BlcnR5KCdwZScpKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvZ3Jlc3MuXG4gICAgICAgICAgICAgICAgaXRlbXNbaV0ucGUgPSBsYXN0ID8gKGl0ZW1zW2ldLnAgPD0gMSA/IDEgOiAyIC8qIHN1cHBvcnQgb25ldG90d28gc3RvcCAqLykgOiBpdGVtc1tpICsgMV0ucDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IGkgPCBuIC0gMSA/IGl0ZW1zW2kgKyAxXS5wIDogMTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXNbaV0ucGUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0ucGUgPSBtYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW1zW2ldLnBlID09PSBpdGVtc1tpXS5wKSB7XG4gICAgICAgICAgICAgICAgaXRlbXNbaV0uaWRwID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbXNbaV0uaWRwID0gMSAvIChpdGVtc1tpXS5wZSAtIGl0ZW1zW2ldLnApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29sb3IgbWVyZ2VyOiB3ZSBuZWVkIHRvIHNwbGl0L2NvbWJpbmUgUkdCQSBjb21wb25lbnRzLlxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBiZXppZXIgaGVscGVyIHZhbHVlcy47XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghaXRlbXNbaV0uaGFzT3duUHJvcGVydHkoJ3NtJykpIHtcbiAgICAgICAgICAgICAgICAvLyBTbW9vdGhuZXNzLjtcbiAgICAgICAgICAgICAgICBpdGVtc1tpXS5zbSA9IGRlZmF1bHRTbW9vdGhuZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpdGVtc1tpXS5oYXNPd25Qcm9wZXJ0eSgncycpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2xvcGUuO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IG4gLSAxIHx8IChpdGVtc1tpXS5wID09PSAxIC8qIGZvciBvbmV0b3R3byAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBzbG9wZSBhdCBzdGFydCBhbmQgZW5kLjtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0ucyA9IHJnYmEgPyBbMCwgMCwgMCwgMF0gOiAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpID0gaXRlbXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuaSA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpLnAgPT09IG5pLnApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnMgPSByZ2JhID8gWzAsIDAsIDAsIDBdIDogMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZ2JhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmMgPSBNdWx0aVNwbGluZS5nZXRSZ2JhQ29tcG9uZW50cyhuaS5sdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGMgPSBNdWx0aVNwbGluZS5nZXRSZ2JhQ29tcG9uZW50cyhwaS5sdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IDEgLyAobmkucCAtIHBpLnApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgKiAobmNbMF0gLSBwY1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgKiAobmNbMV0gLSBwY1sxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgKiAobmNbMl0gLSBwY1syXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgKiAobmNbM10gLSBwY1szXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5zID0gKG5pLmx2IC0gcGkubHYpIC8gKG5pLnAgLSBwaS5wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdmFsdWUgZnVuY3Rpb24uO1xuICAgICAgICAgICAgaWYgKCFpdGVtc1tpXS5mKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IChpID09PSBuIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtc1tpXS5oYXNPd25Qcm9wZXJ0eSgndmUnKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS52ZSA9IGxhc3QgPyBpdGVtc1tpXS5sdiA6IGl0ZW1zW2kgKyAxXS5sdjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gb25seSBpbnRlcnBvbGF0ZSBvbiBudW1lcmljIHZhbHVlcy4gTm9uLW51bWVyaWMgdmFsdWVzIGFyZSBzZXQgbGl0ZXJhbGx5IHdoZW4gcmVhY2hlZCB0aW1lLlxuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc051bWJlcihpdGVtc1tpXS52KSAmJiBVdGlscy5pc051bWJlcihpdGVtc1tpXS5sdikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtc1tpXS5oYXNPd25Qcm9wZXJ0eSgnc21lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnNtZSA9IGxhc3QgPyBkZWZhdWx0U21vb3RobmVzcyA6IGl0ZW1zW2kgKyAxXS5zbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zW2ldLmhhc093blByb3BlcnR5KCdzZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5zZSA9IGxhc3QgPyAocmdiYSA/IFswLCAwLCAwLCAwXSA6IDApIDogaXRlbXNbaSArIDFdLnM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBzcGxpbmUuO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmdiYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0udiA9IE11bHRpU3BsaW5lLmdldFNwbGluZVJnYmFWYWx1ZUZ1bmN0aW9uKGl0ZW1zW2ldLnYsIGl0ZW1zW2ldLnZlLCBpdGVtc1tpXS5wLCBpdGVtc1tpXS5wZSwgaXRlbXNbaV0uc20sIGl0ZW1zW2ldLnNtZSwgaXRlbXNbaV0ucywgaXRlbXNbaV0uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0udiA9IE11bHRpU3BsaW5lLmdldFNwbGluZVZhbHVlRnVuY3Rpb24oaXRlbXNbaV0udiwgaXRlbXNbaV0udmUsIGl0ZW1zW2ldLnAsIGl0ZW1zW2ldLnBlLCBpdGVtc1tpXS5zbSwgaXRlbXNbaV0uc21lLCBpdGVtc1tpXS5zLCBpdGVtc1tpXS5zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5mID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGQoaXRlbXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2FkZChpdGVtKSB7XG4gICAgICAgIHRoaXMuX3AucHVzaChpdGVtLnAgfHwgMCk7XG4gICAgICAgIHRoaXMuX3BlLnB1c2goaXRlbS5wZSB8fCAwKTtcbiAgICAgICAgdGhpcy5faWRwLnB1c2goaXRlbS5pZHAgfHwgMCk7XG4gICAgICAgIHRoaXMuX2YucHVzaChpdGVtLmYgfHwgZmFsc2UpO1xuICAgICAgICB0aGlzLl92LnB1c2goaXRlbS5oYXNPd25Qcm9wZXJ0eSgndicpID8gaXRlbS52IDogMCAvKiB2IG1pZ2h0IGJlIGZhbHNlIG9yIG51bGwgKi8gKTtcbiAgICAgICAgdGhpcy5fbHYucHVzaChpdGVtLmx2IHx8IDApO1xuICAgICAgICB0aGlzLl9zbS5wdXNoKGl0ZW0uc20gfHwgMCk7XG4gICAgICAgIHRoaXMuX3MucHVzaChpdGVtLnMgfHwgMCk7XG4gICAgICAgIHRoaXMuX3ZlLnB1c2goaXRlbS52ZSB8fCAwKTtcbiAgICAgICAgdGhpcy5fc21lLnB1c2goaXRlbS5zbWUgfHwgMCk7XG4gICAgICAgIHRoaXMuX3NlLnB1c2goaXRlbS5zZSB8fCAwKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgfVxuXG4gICAgX2dldEl0ZW0ocCkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fbGVuZ3RoO1xuICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwIDwgdGhpcy5fcFswXSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BbaV0gPD0gcCAmJiBwIDwgdGhpcy5fcGVbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuIC0gMTtcbiAgICB9XG5cbiAgICBnZXRWYWx1ZShwKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRJdGVtKHApO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZltpXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCAocCAtIHRoaXMuX3BbaV0pICogdGhpcy5faWRwW2ldKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZbaV0obyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UmdiYUNvbXBvbmVudHMoYXJnYikge1xuICAgICAgICBsZXQgciA9ICgoYXJnYiAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgZyA9ICgoYXJnYiAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGIgPSBhcmdiICUgMjU2O1xuICAgICAgICBsZXQgYSA9ICgoYXJnYiAvIDE2Nzc3MjE2KSB8IDApO1xuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFdO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0U3BsaW5lVmFsdWVGdW5jdGlvbih2MSwgdjIsIHAxLCBwMiwgbzEsIGkyLCBzMSwgczIpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHNsb3BlcyBiZWNhdXNlIHdlIHVzZSBhIHNwbGluZSB0aGF0IGdvZXMgZnJvbSAwIHRvIDEuXG4gICAgICAgIGxldCBkcCA9IHAyIC0gcDE7XG4gICAgICAgIHMxICo9IGRwO1xuICAgICAgICBzMiAqPSBkcDtcblxuICAgICAgICBsZXQgaGVscGVycyA9IE11bHRpU3BsaW5lLmdldFNwbGluZUhlbHBlcnModjEsIHYyLCBvMSwgaTIsIHMxLCBzMik7XG4gICAgICAgIGlmICghaGVscGVycykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IDApIHJldHVybiB2MTtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gMSkgcmV0dXJuIHYyO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYyICogcCArIHYxICogKDEgLSBwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gMCkgcmV0dXJuIHYxO1xuICAgICAgICAgICAgICAgIGlmIChwID09PSAxKSByZXR1cm4gdjI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpU3BsaW5lLmNhbGN1bGF0ZVNwbGluZShoZWxwZXJzLCBwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFNwbGluZVJnYmFWYWx1ZUZ1bmN0aW9uKHYxLCB2MiwgcDEsIHAyLCBvMSwgaTIsIHMxLCBzMikge1xuICAgICAgICAvLyBOb3JtYWxpemUgc2xvcGVzIGJlY2F1c2Ugd2UgdXNlIGEgc3BsaW5lIHRoYXQgZ29lcyBmcm9tIDAgdG8gMS5cbiAgICAgICAgbGV0IGRwID0gcDIgLSBwMTtcbiAgICAgICAgczFbMF0gKj0gZHA7XG4gICAgICAgIHMxWzFdICo9IGRwO1xuICAgICAgICBzMVsyXSAqPSBkcDtcbiAgICAgICAgczFbM10gKj0gZHA7XG4gICAgICAgIHMyWzBdICo9IGRwO1xuICAgICAgICBzMlsxXSAqPSBkcDtcbiAgICAgICAgczJbMl0gKj0gZHA7XG4gICAgICAgIHMyWzNdICo9IGRwO1xuXG4gICAgICAgIGxldCBjdjEgPSBNdWx0aVNwbGluZS5nZXRSZ2JhQ29tcG9uZW50cyh2MSk7XG4gICAgICAgIGxldCBjdjIgPSBNdWx0aVNwbGluZS5nZXRSZ2JhQ29tcG9uZW50cyh2Mik7XG5cbiAgICAgICAgbGV0IGhlbHBlcnMgPSBbXG4gICAgICAgICAgICBNdWx0aVNwbGluZS5nZXRTcGxpbmVIZWxwZXJzKGN2MVswXSwgY3YyWzBdLCBvMSwgaTIsIHMxWzBdLCBzMlswXSksXG4gICAgICAgICAgICBNdWx0aVNwbGluZS5nZXRTcGxpbmVIZWxwZXJzKGN2MVsxXSwgY3YyWzFdLCBvMSwgaTIsIHMxWzFdLCBzMlsxXSksXG4gICAgICAgICAgICBNdWx0aVNwbGluZS5nZXRTcGxpbmVIZWxwZXJzKGN2MVsyXSwgY3YyWzJdLCBvMSwgaTIsIHMxWzJdLCBzMlsyXSksXG4gICAgICAgICAgICBNdWx0aVNwbGluZS5nZXRTcGxpbmVIZWxwZXJzKGN2MVszXSwgY3YyWzNdLCBvMSwgaTIsIHMxWzNdLCBzMlszXSlcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoIWhlbHBlcnNbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIC8vIExpbmVhci5cbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gMCkgcmV0dXJuIHYxO1xuICAgICAgICAgICAgICAgIGlmIChwID09PSAxKSByZXR1cm4gdjI7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlTcGxpbmUubWVyZ2VDb2xvcnModjIsIHYxLCBwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gMCkgcmV0dXJuIHYxO1xuICAgICAgICAgICAgICAgIGlmIChwID09PSAxKSByZXR1cm4gdjI7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlTcGxpbmUuZ2V0QXJnYk51bWJlcihbXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDI1NSwgTXVsdGlTcGxpbmUuY2FsY3VsYXRlU3BsaW5lKGhlbHBlcnNbMF0sIHApKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oMjU1LCBNdWx0aVNwbGluZS5jYWxjdWxhdGVTcGxpbmUoaGVscGVyc1sxXSwgcCkpLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbigyNTUsIE11bHRpU3BsaW5lLmNhbGN1bGF0ZVNwbGluZShoZWxwZXJzWzJdLCBwKSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDI1NSwgTXVsdGlTcGxpbmUuY2FsY3VsYXRlU3BsaW5lKGhlbHBlcnNbM10sIHApKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaGVscGVycyB0byBiZSB1c2VkIGluIHRoZSBzcGxpbmUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHYxXG4gICAgICogICBGcm9tIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2MlxuICAgICAqICAgVG8gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG8xXG4gICAgICogICBGcm9tIHNtb290aG5lc3MgKDAgPSBsaW5lYXIsIDEgPSBzbW9vdGgpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzMVxuICAgICAqICAgRnJvbSBzbG9wZSAoMCA9IGhvcml6b250YWwsIGluZmluaXRlID0gdmVydGljYWwpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpMlxuICAgICAqICAgVG8gc21vb3RobmVzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gczJcbiAgICAgKiAgIFRvIHNsb3BlLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX1cbiAgICAgKiAgIFRoZSBoZWxwZXIgdmFsdWVzIHRvIGJlIHN1cHBsaWVkIHRvIHRoZSBzcGxpbmUgZnVuY3Rpb24uXG4gICAgICogICBJZiB0aGUgY29uZmlndXJhdGlvbiBpcyBhY3R1YWxseSBsaW5lYXIsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgc3RhdGljIGdldFNwbGluZUhlbHBlcnModjEsIHYyLCBvMSwgaTIsIHMxLCBzMikge1xuICAgICAgICBpZiAoIW8xICYmICFpMikge1xuICAgICAgICAgICAgLy8gTGluZWFyLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdWJpYyBiZXppZXIgcG9pbnRzLlxuICAgICAgICAvLyBodHRwOi8vY3ViaWMtYmV6aWVyLmNvbS9cbiAgICAgICAgbGV0IGNzeCA9IG8xO1xuICAgICAgICBsZXQgY3N5ID0gdjEgKyBzMSAqIG8xO1xuICAgICAgICBsZXQgY2V4ID0gMSAtIGkyO1xuICAgICAgICBsZXQgY2V5ID0gdjIgLSBzMiAqIGkyO1xuXG4gICAgICAgIGxldCB4YSA9IDMgKiBjc3ggLSAzICogY2V4ICsgMTtcbiAgICAgICAgbGV0IHhiID0gLTYgKiBjc3ggKyAzICogY2V4O1xuICAgICAgICBsZXQgeGMgPSAzICogY3N4O1xuXG4gICAgICAgIGxldCB5YSA9IDMgKiBjc3kgLSAzICogY2V5ICsgdjIgLSB2MTtcbiAgICAgICAgbGV0IHliID0gMyAqIChjZXkgKyB2MSkgLSA2ICogY3N5O1xuICAgICAgICBsZXQgeWMgPSAzICogKGNzeSAtIHYxKTtcbiAgICAgICAgbGV0IHlkID0gdjE7XG5cbiAgICAgICAgcmV0dXJuIFt4YSwgeGIsIHhjLCB5YSwgeWIsIHljLCB5ZF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGludGVybWVkaWF0ZSBzcGxpbmUgdmFsdWUgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBoZWxwZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGhlbHBlcnNcbiAgICAgKiAgIE9idGFpbmVkIGZyb20gZ2V0U3BsaW5lSGVscGVycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlU3BsaW5lKGhlbHBlcnMsIHApIHtcbiAgICAgICAgbGV0IHhhID0gaGVscGVyc1swXTtcbiAgICAgICAgbGV0IHhiID0gaGVscGVyc1sxXTtcbiAgICAgICAgbGV0IHhjID0gaGVscGVyc1syXTtcbiAgICAgICAgbGV0IHlhID0gaGVscGVyc1szXTtcbiAgICAgICAgbGV0IHliID0gaGVscGVyc1s0XTtcbiAgICAgICAgbGV0IHljID0gaGVscGVyc1s1XTtcbiAgICAgICAgbGV0IHlkID0gaGVscGVyc1s2XTtcblxuICAgICAgICBpZiAoeGEgPT09IC0yICYmIHlhID09PSAtMiAmJiB4YyA9PT0gMCAmJiB5YyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTGluZWFyLlxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHQgZm9yIHAuXG4gICAgICAgIGxldCB0ID0gMC41LCBjYngsIGR4O1xuXG4gICAgICAgIGZvciAobGV0IGl0ID0gMDsgaXQgPCAyMDsgaXQrKykge1xuICAgICAgICAgICAgLy8gQ3ViaWMgYmV6aWVyIGZ1bmN0aW9uOiBmKHQpPXQqKHQqKHQqYStiKStjKS5cbiAgICAgICAgICAgIGNieCA9IHQgKiAodCAqICh0ICogeGEgKyB4YikgKyB4Yyk7XG5cbiAgICAgICAgICAgIGR4ID0gcCAtIGNieDtcbiAgICAgICAgICAgIGlmIChkeCA+IC0xZS04ICYmIGR4IDwgMWUtOCkge1xuICAgICAgICAgICAgICAgIC8vIFNvbHV0aW9uIGZvdW5kIVxuICAgICAgICAgICAgICAgIHJldHVybiB0ICogKHQgKiAodCAqIHlhICsgeWIpICsgeWMpICsgeWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEN1YmljIGJlemllciBkZXJpdmF0aXZlIGZ1bmN0aW9uOiBmJyh0KT10Kih0KigzKmEpKzIqYikrY1xuICAgICAgICAgICAgbGV0IGNieGQgPSB0ICogKHQgKiAoMyAqIHhhKSArIDIgKiB4YikgKyB4YztcblxuICAgICAgICAgICAgaWYgKGNieGQgPiAxZS0xMCAmJiBjYnhkIDwgMWUtMTApIHtcbiAgICAgICAgICAgICAgICAvLyBQcm9ibGVtYXRpYy4gRmFsbCBiYWNrIHRvIGJpbmFyeSBzZWFyY2ggbWV0aG9kLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ICs9IGR4IC8gY2J4ZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGxiYWNrOiBiaW5hcnkgc2VhcmNoIG1ldGhvZC4gVGhpcyBpcyBtb3JlIHJlbGlhYmxlIHdoZW4gdGhlcmUgYXJlIG5lYXItMCBzbG9wZXMuXG4gICAgICAgIGxldCBtaW5UID0gMDtcbiAgICAgICAgbGV0IG1heFQgPSAxO1xuICAgICAgICBmb3IgKGxldCBpdCA9IDA7IGl0IDwgMjA7IGl0KyspIHtcbiAgICAgICAgICAgIHQgPSAwLjUgKiAobWluVCArIG1heFQpO1xuXG4gICAgICAgICAgICAvLyBDdWJpYyBiZXppZXIgZnVuY3Rpb246IGYodCk9dCoodCoodCphK2IpK2MpK2QuXG4gICAgICAgICAgICBjYnggPSB0ICogKHQgKiAodCAqIHhhICsgeGIpICsgeGMpO1xuXG4gICAgICAgICAgICBkeCA9IHAgLSBjYng7XG4gICAgICAgICAgICBpZiAoZHggPiAtMWUtOCAmJiBkeCA8IDFlLTgpIHtcbiAgICAgICAgICAgICAgICAvLyBTb2x1dGlvbiBmb3VuZCFcbiAgICAgICAgICAgICAgICByZXR1cm4gdCAqICh0ICogKHQgKiB5YSArIHliKSArIHljKSArIHlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgbWF4VCA9IHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pblQgPSB0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcblxuICAgIHN0YXRpYyBtZXJnZUNvbG9ycyhjMSwgYzIsIHApIHtcbiAgICAgICAgbGV0IHIxID0gKChjMSAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgZzEgPSAoKGMxIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgYjEgPSBjMSAlIDI1NjtcbiAgICAgICAgbGV0IGExID0gKChjMSAvIDE2Nzc3MjE2KSB8IDApO1xuXG4gICAgICAgIGxldCByMiA9ICgoYzIgLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGcyID0gKChjMiAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGIyID0gYzIgJSAyNTY7XG4gICAgICAgIGxldCBhMiA9ICgoYzIgLyAxNjc3NzIxNikgfCAwKTtcblxuICAgICAgICBsZXQgciA9IHIxICogcCArIHIyICogKDEgLSBwKTtcbiAgICAgICAgbGV0IGcgPSBnMSAqIHAgKyBnMiAqICgxIC0gcCk7XG4gICAgICAgIGxldCBiID0gYjEgKiBwICsgYjIgKiAoMSAtIHApO1xuICAgICAgICBsZXQgYSA9IGExICogcCArIGEyICogKDEgLSBwKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhKSAqIDE2Nzc3MjE2ICsgTWF0aC5yb3VuZChyKSAqIDY1NTM2ICsgTWF0aC5yb3VuZChnKSAqIDI1NiArIE1hdGgucm91bmQoYik7XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRBcmdiTnVtYmVyKHJnYmEpIHtcbiAgICAgICAgcmdiYVswXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVswXSkpO1xuICAgICAgICByZ2JhWzFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzFdKSk7XG4gICAgICAgIHJnYmFbMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbMl0pKTtcbiAgICAgICAgcmdiYVszXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVszXSkpO1xuICAgICAgICBsZXQgdiA9ICgocmdiYVszXSB8IDApIDw8IDI0KSArICgocmdiYVswXSB8IDApIDw8IDE2KSArICgocmdiYVsxXSB8IDApIDw8IDgpICsgKHJnYmFbMl0gfCAwKTtcbiAgICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgICAgICB2ID0gMHhGRkZGRkZGRiArIHYgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9iak1lcmdlciB7XG5cbiAgICBzdGF0aWMgaXNNZihmKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5pc0Z1bmN0aW9uKGYpICYmIGYuX19tZjtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWYoZikge1xuICAgICAgICAvLyBTZXQgYXMgbWVyZ2UgZnVuY3Rpb24uXG4gICAgICAgIGYuX19tZiA9IHRydWU7XG4gICAgICAgIHJldHVybiBmO1xuICAgIH1cblxuICAgIHN0YXRpYyBtZXJnZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFrcyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBjb25zdCBia3MgPSBPYmplY3Qua2V5cyhiKTtcblxuICAgICAgICBpZiAoIWJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGluZGV4IGFycmF5IGZvciBhbGwgZWxlbWVudHMuXG4gICAgICAgIGNvbnN0IGFpID0ge307XG4gICAgICAgIGNvbnN0IGJpID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gYmtzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYmtzW2ldO1xuICAgICAgICAgICAgYWlba2V5XSA9IC0xO1xuICAgICAgICAgICAgYmlba2V5XSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBha3MubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBha3NbaV07XG4gICAgICAgICAgICBhaVtrZXldID0gaTtcbiAgICAgICAgICAgIGlmIChiaVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiaVtrZXldID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBha3NsID0gYWtzLmxlbmd0aDtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBia3MubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBia3NbaV07XG5cbiAgICAgICAgICAgIC8vIFByZXBlbmQgYWxsIGl0ZW1zIGluIGEgdGhhdCBhcmUgbm90IGluIGIgLSBiZWZvcmUgdGhlIG5vdyBhZGRlZCBiIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgIGNvbnN0IGFJbmRleCA9IGFpW2tleV07XG4gICAgICAgICAgICBsZXQgY3VySW5kZXggPSBhSW5kZXg7XG4gICAgICAgICAgICB3aGlsZSgtLWN1ckluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBha2V5ID0gYWtzW2N1ckluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYmlbYWtleV0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgZm91bmQ/IFN0b3AgcHJvY2Vzc2luZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHlldCBmb3VuZCBidXQgZXhpc3RzIGluIGI/IEFsc28gc3RvcCBwcm9jZXNzaW5nOiB3YWl0IHVudGlsIHdlIGZpbmQgaXQgaW4gYi5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUoKytjdXJJbmRleCA8IGFJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFrZXkgPSBha3NbY3VySW5kZXhdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtha2V5XSA9IGFbYWtleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGJ2ID0gYltrZXldO1xuICAgICAgICAgICAgY29uc3QgYXYgPSBhW2tleV07XG4gICAgICAgICAgICBsZXQgcjtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTWYoYnYpKSB7XG4gICAgICAgICAgICAgICAgciA9IGJ2KGF2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFVdGlscy5pc09iamVjdExpdGVyYWwoYXYpIHx8ICFVdGlscy5pc09iamVjdExpdGVyYWwoYnYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBidjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByID0gT2JqTWVyZ2VyLm1lcmdlKGF2LCBidik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGVuIG1hcmtlZCBhcyB1bmRlZmluZWQsIHByb3BlcnR5IGlzIGRlbGV0ZWQuXG4gICAgICAgICAgICBpZiAociAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIHJlbWFpbmluZyBmaW5hbCBpdGVtcyBpbiBhLlxuICAgICAgICBsZXQgY3VySW5kZXggPSBha3NsO1xuICAgICAgICB3aGlsZSgtLWN1ckluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFrZXkgPSBha3NbY3VySW5kZXhdO1xuICAgICAgICAgICAgaWYgKGJpW2FrZXldICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlKCsrY3VySW5kZXggPCBha3NsKSB7XG4gICAgICAgICAgICBjb25zdCBha2V5ID0gYWtzW2N1ckluZGV4XTtcbiAgICAgICAgICAgIHJlc3VsdFtha2V5XSA9IGFbYWtleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBsaXN0IG9mIGNoaWxkcmVuIGZvciBhbiBlbGVtZW50LlxuICovXG5cbmltcG9ydCBPYmplY3RMaXN0IGZyb20gXCIuLi90cmVlL09iamVjdExpc3QubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9iamVjdExpc3RQcm94eSBleHRlbmRzIE9iamVjdExpc3Qge1xuXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB9XG5cbiAgICBvbkFkZChpdGVtLCBpbmRleCkge1xuICAgICAgICB0aGlzLl90YXJnZXQuYWRkQXQoaXRlbSwgaW5kZXgpO1xuICAgIH1cblxuICAgIG9uUmVtb3ZlKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVBdChpbmRleCk7XG4gICAgfVxuXG4gICAgb25TeW5jKHJlbW92ZWQsIGFkZGVkLCBvcmRlcikge1xuICAgICAgICB0aGlzLl90YXJnZXQuX3NldEJ5QXJyYXkob3JkZXIpO1xuICAgIH1cblxuICAgIG9uU2V0KGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5zZXRBdChpdGVtLCBpbmRleCk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGl0ZW0sIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICB0aGlzLl90YXJnZXQuc2V0QXQoaXRlbSwgdG9JbmRleCk7XG4gICAgfVxuXG4gICAgY3JlYXRlSXRlbShvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldC5jcmVhdGVJdGVtKG9iamVjdCk7XG4gICAgfVxuXG4gICAgaXNJdGVtKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0LmlzSXRlbShvYmplY3QpO1xuICAgIH1cblxufVxuXG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogTWFuYWdlcyB0aGUgbGlzdCBvZiBjaGlsZHJlbiBmb3IgYW4gZWxlbWVudC5cbiAqL1xuXG5pbXBvcnQgT2JqZWN0TGlzdFByb3h5IGZyb20gXCIuL09iamVjdExpc3RQcm94eS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqZWN0TGlzdFdyYXBwZXIgZXh0ZW5kcyBPYmplY3RMaXN0UHJveHkge1xuXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCB3cmFwKSB7XG4gICAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgICAgIHRoaXMuX3dyYXAgPSB3cmFwO1xuICAgIH1cblxuICAgIHdyYXAoaXRlbSkge1xuICAgICAgICBsZXQgd3JhcHBlciA9IHRoaXMuX3dyYXAoaXRlbSk7XG4gICAgICAgIGl0ZW0uX3dyYXBwZXIgPSB3cmFwcGVyO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICBvbkFkZChpdGVtLCBpbmRleCkge1xuICAgICAgICBpdGVtID0gdGhpcy53cmFwKGl0ZW0pO1xuICAgICAgICBzdXBlci5vbkFkZChpdGVtLCBpbmRleCk7XG4gICAgfVxuXG4gICAgb25SZW1vdmUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgc3VwZXIub25SZW1vdmUoaXRlbSwgaW5kZXgpO1xuICAgIH1cblxuICAgIG9uU3luYyhyZW1vdmVkLCBhZGRlZCwgb3JkZXIpIHtcbiAgICAgICAgYWRkZWQuZm9yRWFjaChhID0+IHRoaXMud3JhcChhKSk7XG4gICAgICAgIG9yZGVyID0gb3JkZXIubWFwKGEgPT4gYS5fd3JhcHBlcik7XG4gICAgICAgIHN1cGVyLm9uU3luYyhyZW1vdmVkLCBhZGRlZCwgb3JkZXIpO1xuICAgIH1cblxuICAgIG9uU2V0KGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLndyYXAoaXRlbSk7XG4gICAgICAgIHN1cGVyLm9uU2V0KGl0ZW0sIGluZGV4KTtcbiAgICB9XG5cbiAgICBvbk1vdmUoaXRlbSwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIHN1cGVyLm9uTW92ZShpdGVtLCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBTdGF0aWNDYW52YXNUZXh0dXJlIGZyb20gXCIuLi90ZXh0dXJlcy9TdGF0aWNDYW52YXNUZXh0dXJlLm1qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2xzIHtcblxuICAgIHN0YXRpYyBnZXRDYW52YXNUZXh0dXJlKGNhbnZhc0ZhY3RvcnksIGxvb2t1cElkKSB7XG4gICAgICAgIHJldHVybiB7dHlwZTogU3RhdGljQ2FudmFzVGV4dHVyZSwgY29udGVudDoge2ZhY3Rvcnk6IGNhbnZhc0ZhY3RvcnksIGxvb2t1cElkOiBsb29rdXBJZH19XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFJvdW5kUmVjdCh3LCBoLCByYWRpdXMsIHN0cm9rZVdpZHRoLCBzdHJva2VDb2xvciwgZmlsbCwgZmlsbENvbG9yKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyYWRpdXMpKXtcbiAgICAgICAgICAgIC8vIHVwcGVyLWxlZnQsIHVwcGVyLXJpZ2h0LCBib3R0b20tcmlnaHQsIGJvdHRvbS1sZWZ0LlxuICAgICAgICAgICAgcmFkaXVzID0gW3JhZGl1cywgcmFkaXVzLCByYWRpdXMsIHJhZGl1c107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmFjdG9yeSA9IChjYiwgc3RhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc1NwYXJrKSB7XG4gICAgICAgICAgICAgICAgc3RhZ2UucGxhdGZvcm0uY3JlYXRlUm91bmRSZWN0KGNiLCBzdGFnZSwgdywgaCwgcmFkaXVzLCBzdHJva2VXaWR0aCwgc3Ryb2tlQ29sb3IsIGZpbGwsIGZpbGxDb2xvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIHRoaXMuY3JlYXRlUm91bmRSZWN0KHN0YWdlLCB3LCBoLCByYWRpdXMsIHN0cm9rZVdpZHRoLCBzdHJva2VDb2xvciwgZmlsbCwgZmlsbENvbG9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBpZCA9ICdyZWN0JyArIFt3LCBoLCBzdHJva2VXaWR0aCwgc3Ryb2tlQ29sb3IsIGZpbGwgPyAxIDogMCwgZmlsbENvbG9yXS5jb25jYXQocmFkaXVzKS5qb2luKFwiLFwiKTtcbiAgICAgICAgcmV0dXJuIFRvb2xzLmdldENhbnZhc1RleHR1cmUoZmFjdG9yeSwgaWQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVSb3VuZFJlY3Qoc3RhZ2UsIHcsIGgsIHJhZGl1cywgc3Ryb2tlV2lkdGgsIHN0cm9rZUNvbG9yLCBmaWxsLCBmaWxsQ29sb3IpIHtcbiAgICAgICAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkgZmlsbCA9IHRydWU7XG4gICAgICAgIGlmIChzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkKSBzdHJva2VXaWR0aCA9IDA7XG5cbiAgICAgICAgbGV0IGNhbnZhcyA9IHN0YWdlLnBsYXRmb3JtLmdldERyYXdpbmdDYW52YXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBjYW52YXMud2lkdGggPSB3ICsgc3Ryb2tlV2lkdGggKyAyO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaCArIHN0cm9rZVdpZHRoICsgMjtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGxldCB4ID0gMC41ICogc3Ryb2tlV2lkdGggKyAxLCB5ID0gMC41ICogc3Ryb2tlV2lkdGggKyAxO1xuXG4gICAgICAgIGN0eC5tb3ZlVG8oeCArIHJhZGl1c1swXSwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXNbMV0sIHkpO1xuICAgICAgICBjdHguYXJjVG8oeCArIHcsIHksIHggKyB3LCB5ICsgcmFkaXVzWzFdLCByYWRpdXNbMV0pO1xuICAgICAgICBjdHgubGluZVRvKHggKyB3LCB5ICsgaCAtIHJhZGl1c1syXSk7XG4gICAgICAgIGN0eC5hcmNUbyh4ICsgdywgeSArIGgsIHggKyB3IC0gcmFkaXVzWzJdLCB5ICsgaCwgcmFkaXVzWzJdKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzWzNdLCB5ICsgaCk7XG4gICAgICAgIGN0eC5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSByYWRpdXNbM10sIHJhZGl1c1szXSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJhZGl1c1swXSk7XG4gICAgICAgIGN0eC5hcmNUbyh4LCB5LCB4ICsgcmFkaXVzWzBdLCB5LCByYWRpdXNbMF0pO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc051bWJlcihmaWxsQ29sb3IpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyhmaWxsQ29sb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJva2VXaWR0aCkge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKHN0cm9rZUNvbG9yKSkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyhzdHJva2VDb2xvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFNoYWRvd1JlY3QodywgaCwgcmFkaXVzID0gMCwgYmx1ciA9IDUsIG1hcmdpbiA9IGJsdXIgKiAyKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyYWRpdXMpKXtcbiAgICAgICAgICAgIC8vIHVwcGVyLWxlZnQsIHVwcGVyLXJpZ2h0LCBib3R0b20tcmlnaHQsIGJvdHRvbS1sZWZ0LlxuICAgICAgICAgICAgcmFkaXVzID0gW3JhZGl1cywgcmFkaXVzLCByYWRpdXMsIHJhZGl1c107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmFjdG9yeSA9IChjYiwgc3RhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc1NwYXJrKSB7XG4gICAgICAgICAgICAgICAgc3RhZ2UucGxhdGZvcm0uY3JlYXRlU2hhZG93UmVjdChjYiwgc3RhZ2UsIHcsIGgsIHJhZGl1cywgYmx1ciwgbWFyZ2luKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2IobnVsbCwgdGhpcy5jcmVhdGVTaGFkb3dSZWN0KHN0YWdlLCB3LCBoLCByYWRpdXMsIGJsdXIsIG1hcmdpbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgaWQgPSAnc2hhZG93JyArIFt3LCBoLCBibHVyLCBtYXJnaW5dLmNvbmNhdChyYWRpdXMpLmpvaW4oXCIsXCIpO1xuICAgICAgICByZXR1cm4gVG9vbHMuZ2V0Q2FudmFzVGV4dHVyZShmYWN0b3J5LCBpZCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVNoYWRvd1JlY3Qoc3RhZ2UsIHcsIGgsIHJhZGl1cywgYmx1ciwgbWFyZ2luKSB7XG4gICAgICAgIGxldCBjYW52YXMgPSBzdGFnZS5wbGF0Zm9ybS5nZXREcmF3aW5nQ2FudmFzKCk7XG4gICAgICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gdyArIG1hcmdpbiAqIDI7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoICsgbWFyZ2luICogMjtcblxuICAgICAgICAvLyBXcGVXZWJLaXQgYnVnOiB3ZSBleHBlcmllbmNlZCBwcm9ibGVtcyB3aXRob3V0IHRoaXMgd2l0aCBzaGFkb3dzIGluIG5vbmNvbXBvc2l0ZWR3ZWJnbCBtb2RlLlxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjAxO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMC4wMSwgMC4wMSk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcblxuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcoMHhGRkZGRkZGRik7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcoMHhGRkZGRkZGRik7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gYmx1cjtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAodyArIDEwKSArIG1hcmdpbjtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBtYXJnaW47XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb25zdCB4ID0gLSh3ICsgMTApO1xuICAgICAgICBjb25zdCB5ID0gMDtcblxuICAgICAgICBjdHgubW92ZVRvKHggKyByYWRpdXNbMF0sIHkpO1xuICAgICAgICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzWzFdLCB5KTtcbiAgICAgICAgY3R4LmFyY1RvKHggKyB3LCB5LCB4ICsgdywgeSArIHJhZGl1c1sxXSwgcmFkaXVzWzFdKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByYWRpdXNbMl0pO1xuICAgICAgICBjdHguYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHJhZGl1c1syXSwgeSArIGgsIHJhZGl1c1syXSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHJhZGl1c1szXSwgeSArIGgpO1xuICAgICAgICBjdHguYXJjVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gcmFkaXVzWzNdLCByYWRpdXNbM10pO1xuICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXNbMF0pO1xuICAgICAgICBjdHguYXJjVG8oeCwgeSwgeCArIHJhZGl1c1swXSwgeSwgcmFkaXVzWzBdKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFN2Z1RleHR1cmUodXJsLCB3LCBoKSB7XG4gICAgICAgIGxldCBmYWN0b3J5ID0gKGNiLCBzdGFnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzU3BhcmspIHtcbiAgICAgICAgICAgICAgICBzdGFnZS5wbGF0Zm9ybS5jcmVhdGVTdmcoY2IsIHN0YWdlLCB1cmwsIHcsIGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVN2ZyhjYiwgc3RhZ2UsIHVybCwgdywgaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBpZCA9ICdzdmcnICsgW3csIGgsIHVybF0uam9pbihcIixcIik7XG4gICAgICAgIHJldHVybiBUb29scy5nZXRDYW52YXNUZXh0dXJlKGZhY3RvcnksIGlkKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlU3ZnKGNiLCBzdGFnZSwgdXJsLCB3LCBoKSB7XG4gICAgICAgIGxldCBjYW52YXMgPSBzdGFnZS5wbGF0Zm9ybS5nZXREcmF3aW5nQ2FudmFzKCk7XG4gICAgICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgbGV0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdztcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBjYihudWxsLCBjYW52YXMpO1xuICAgICAgICB9XG4gICAgICAgIGltZy5vbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9uIHRoZSBQUzQgcGxhdGZvcm0gc2V0dGluZyB0aGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgb24gaW1hZ2VzXG4gICAgICAgIC8vIGNhbiBjYXVzZSBDT1JTIGZhaWx1cmVzLlxuICAgICAgICBpZiAoIVV0aWxzLmlzUFM0KSB7XG4gICAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNsYXNzIFV0aWxzIHtcblxuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICh2YWx1ZSAlIDEpID09PSAwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzT2JqZWN0TGl0ZXJhbCh2YWx1ZSl7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3RcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QXJyYXlJbmRleChpbmRleCwgYXJyKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5nZXRNb2R1bG9JbmRleChpbmRleCwgYXJyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGVxdWFsVmFsdWVzKHYxLCB2Mikge1xuICAgICAgICBpZiAoKHR5cGVvZiB2MSkgIT09ICh0eXBlb2YgdjIpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2MSkpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5pc09iamVjdExpdGVyYWwodjIpICYmIFV0aWxzLmVxdWFsT2JqZWN0TGl0ZXJhbHModjEsIHYyKVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodjEpKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2MikgJiYgVXRpbHMuZXF1YWxBcnJheXModjEsIHYyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHYxID09PSB2MlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGVxdWFsT2JqZWN0TGl0ZXJhbHMob2JqMSwgb2JqMikge1xuICAgICAgICBsZXQga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcbiAgICAgICAgbGV0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gICAgICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMxLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgazEgPSBrZXlzMVtpXTtcbiAgICAgICAgICAgIGNvbnN0IGsyID0ga2V5czJbaV07XG4gICAgICAgICAgICBpZiAoazEgIT09IGsyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHYxID0gb2JqMVtrMV07XG4gICAgICAgICAgICBjb25zdCB2MiA9IG9iajJbazJdO1xuXG4gICAgICAgICAgICBpZiAoIVV0aWxzLmVxdWFsVmFsdWVzKHYxLCB2MikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBlcXVhbEFycmF5cyh2MSwgdjIpIHtcbiAgICAgICAgaWYgKHYxLmxlbmd0aCAhPT0gdjIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHYxLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVxdWFsVmFsdWVzKHYxW2ldLCB2MltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG59XG5cbi8qKlxuICogTWFpbnRhaW5zIHRoZSBzdGF0ZSBvZiBhIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqL1xuY2xhc3MgV2ViR0xTdGF0ZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihpZCwgZ2wpIHtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fYnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZnJhbWVidWZmZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJidWZmZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8vIENvbnRhaW5zIHZlcnRleCBhdHRyaWJ1dGUgZGVmaW5pdGlvbiBhcnJheXMgKGVuYWJsZWQsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KS5cbiAgICAgICAgdGhpcy5fdmVydGV4QXR0cmlicyA9IG5ldyBBcnJheSgxNik7XG4gICAgICAgIHRoaXMuX25vbkRlZmF1bHRGbGFncyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3RleHR1cmVzID0gbmV3IEFycmF5KDgpO1xuICAgICAgICB0aGlzLl9tYXhUZXh0dXJlID0gMDtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZSA9IGdsLlRFWFRVUkUwO1xuICAgICAgICB0aGlzLl9waXhlbFN0b3JlaSA9IG5ldyBBcnJheSg1KTtcbiAgICB9XG5cbiAgICBfZ2V0RGVmYXVsdEZsYWcoY2FwKSB7XG4gICAgICAgIHJldHVybiAoY2FwID09PSB0aGlzLl9nbC5ESVRIRVIpO1xuICAgIH1cblxuICAgIHNldEZsYWcoY2FwLCB2KSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2dldERlZmF1bHRGbGFnKGNhcCk7XG4gICAgICAgIGlmICh2ID09PSBkZWYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub25EZWZhdWx0RmxhZ3MuZGVsZXRlKGNhcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX25vbkRlZmF1bHRGbGFncy5oYXMoY2FwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25vbkRlZmF1bHRGbGFncy5hZGQoY2FwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0QnVmZmVyKHRhcmdldCwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMuX2J1ZmZlcnMuZ2V0KHRhcmdldCkgIT09IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5fYnVmZmVycy5zZXQodGFyZ2V0LCBidWZmZXIpO1xuXG4gICAgICAgIGlmIChjaGFuZ2UgJiYgKHRhcmdldCA9PT0gdGhpcy5fZ2wuQVJSQVlfQlVGRkVSKSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgYXJyYXkgYnVmZmVyIGlzIGNoYW5nZWQgYWxsIGF0dHJpYnV0ZXMgYXJlIGNsZWFyZWQuXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWJzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cblxuICAgIHNldEZyYW1lYnVmZmVyKHRhcmdldCwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMuX2ZyYW1lYnVmZmVycy5nZXQodGFyZ2V0KSAhPT0gYnVmZmVyO1xuICAgICAgICB0aGlzLl9mcmFtZWJ1ZmZlcnMuc2V0KHRhcmdldCwgYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICBzZXRSZW5kZXJidWZmZXIodGFyZ2V0LCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gdGhpcy5fcmVuZGVyYnVmZmVycy5nZXQodGFyZ2V0KSAhPT0gYnVmZmVyO1xuICAgICAgICB0aGlzLl9yZW5kZXJidWZmZXJzLnNldCh0YXJnZXQsIGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuXG4gICAgc2V0UHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMuX3Byb2dyYW0gIT09IHByb2dyYW07XG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICByZXR1cm4gY2hhbmdlXG4gICAgfVxuXG4gICAgc2V0U2V0dGluZyhmdW5jLCB2KSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLl9zZXR0aW5ncy5nZXQoZnVuYyk7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9ICFzIHx8ICFVdGlscy5lcXVhbFZhbHVlcyhzLCB2KTtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3Muc2V0KGZ1bmMsIHYpO1xuICAgICAgICByZXR1cm4gY2hhbmdlXG4gICAgfVxuXG4gICAgZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHZhID0gdGhpcy5fdmVydGV4QXR0cmlic1tpbmRleF07XG4gICAgICAgIGlmICh2YSAmJiB2YVs1XSkge1xuICAgICAgICAgICAgdmFbNV0gPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCkge1xuICAgICAgICBjb25zdCB2YSA9IHRoaXMuX3ZlcnRleEF0dHJpYnNbaW5kZXhdO1xuICAgICAgICBpZiAodmEpIHtcbiAgICAgICAgICAgIGlmICghdmFbMF0pIHtcbiAgICAgICAgICAgICAgICB2YVswXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWJzW2luZGV4XSA9IFswLCAwLCAwLCAwLCAwLCB0cnVlXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4LCBwcm9wcykge1xuICAgICAgICBsZXQgdmEgPSB0aGlzLl92ZXJ0ZXhBdHRyaWJzW2luZGV4XTtcbiAgICAgICAgbGV0IGVxdWFsID0gZmFsc2U7XG4gICAgICAgIGlmICh2YSkge1xuICAgICAgICAgICAgZXF1YWwgPSB2YVswXSA9PT0gcHJvcHNbMF0gJiZcbiAgICAgICAgICAgICAgICB2YVsxXSA9PT0gcHJvcHNbMV0gJiZcbiAgICAgICAgICAgICAgICB2YVsyXSA9PT0gcHJvcHNbMl0gJiZcbiAgICAgICAgICAgICAgICB2YVszXSA9PT0gcHJvcHNbM10gJiZcbiAgICAgICAgICAgICAgICB2YVs0XSA9PT0gcHJvcHNbNF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXF1YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3BzWzVdID0gdmEgPyB2YVs1XSA6IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRBY3RpdmVUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2FjdGl2ZVRleHR1cmUgIT09IHRleHR1cmU7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG5cbiAgICBiaW5kVGV4dHVyZSh0YXJnZXQsIHRleHR1cmUpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlSW5kZXggPSBXZWJHTFN0YXRlLl9nZXRUZXh0dXJlSW5kZXgodGhpcy5fYWN0aXZlVGV4dHVyZSk7XG4gICAgICAgIHRoaXMuX21heFRleHR1cmUgPSBNYXRoLm1heCh0aGlzLl9tYXhUZXh0dXJlLCBhY3RpdmVJbmRleCArIDEpO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fdGV4dHVyZXNbYWN0aXZlSW5kZXhdO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IFdlYkdMU3RhdGUuX2dldFRleHR1cmVUYXJnZXRJbmRleCh0YXJnZXQpO1xuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRbdGFyZ2V0SW5kZXhdID09PSB0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFt0YXJnZXRJbmRleF0gPSB0ZXh0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzW2FjdGl2ZUluZGV4XSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzW2FjdGl2ZUluZGV4XVt0YXJnZXRJbmRleF0gPSB0ZXh0dXJlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0UGl4ZWxTdG9yZWkocG5hbWUsIHBhcmFtKSB7XG4gICAgICAgIGNvbnN0IGkgPSBXZWJHTFN0YXRlLl9nZXRQaXhlbFN0b3JlaUluZGV4KHBuYW1lKTtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gIVV0aWxzLmVxdWFsVmFsdWVzKHRoaXMuX3BpeGVsU3RvcmVpW2ldLCBwYXJhbSk7XG4gICAgICAgIHRoaXMuX3BpeGVsU3RvcmVpW2ldID0gcGFyYW07XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuXG4gICAgbWlncmF0ZShzKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzO1xuXG4gICAgICAgIC8vIFdhcm5pbmc6IG1pZ3JhdGUgc2hvdWxkIGNhbGwgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBtZXRob2RzIGRpcmVjdGx5LlxuXG4gICAgICAgIHRoaXMuX21pZ3JhdGVGbGFncyh0LCBzKTtcblxuICAgICAgICAvLyB1c2VQcm9ncmFtXG4gICAgICAgIGlmIChzLl9wcm9ncmFtICE9PSB0Ll9wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5fdXNlUHJvZ3JhbShzLl9wcm9ncmFtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21pZ3JhdGVGcmFtZWJ1ZmZlcnModCwgcyk7XG4gICAgICAgIHRoaXMuX21pZ3JhdGVSZW5kZXJidWZmZXJzKHQsIHMpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZlcnNDaGFuZ2VkID0gdGhpcy5fbWlncmF0ZUJ1ZmZlcnModCwgcyk7XG4gICAgICAgIHRoaXMuX21pZ3JhdGVBdHRyaWJ1dGVzKHQsIHMsIGJ1ZmZlcnNDaGFuZ2VkKTtcblxuICAgICAgICB0aGlzLl9taWdyYXRlRmxhZ3ModCwgcyk7XG5cbiAgICAgICAgdGhpcy5fbWlncmF0ZVNldHRpbmdzKHQsIHMpO1xuXG4gICAgICAgIHRoaXMuX21pZ3JhdGVQaXhlbFN0b3JlaSh0LCBzKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX21pZ3JhdGVUZXh0dXJlcyh0LCBzKTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgX21pZ3JhdGVQaXhlbFN0b3JlaSh0LCBzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdC5fcGl4ZWxTdG9yZWkubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodC5fcGl4ZWxTdG9yZWlbaV0gIT09IHMuX3BpeGVsU3RvcmVpW2ldKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzLl9waXhlbFN0b3JlaVtpXSAhPT0gdW5kZWZpbmVkID8gcy5fcGl4ZWxTdG9yZWlbaV0gOiBXZWJHTFN0YXRlLl9nZXREZWZhdWx0UGl4ZWxTdG9yZWlCeUluZGV4KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9waXhlbFN0b3JlaShXZWJHTFN0YXRlLl9nZXRQaXhlbFN0b3JlaUJ5SW5kZXgoaSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9taWdyYXRlVGV4dHVyZXModCwgcykge1xuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heCh0Ll9tYXhUZXh0dXJlLCBzLl9tYXhUZXh0dXJlKTtcblxuICAgICAgICBsZXQgYWN0aXZlVGV4dHVyZSA9IHQuX2FjdGl2ZVRleHR1cmU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc1RhcmdldHMgPSBzLl90ZXh0dXJlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHRUYXJnZXRzID0gdC5fdGV4dHVyZXNbaV07XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlTnVtYiA9IFdlYkdMU3RhdGUuX2dldFRleHR1cmVCeUluZGV4KGkpO1xuXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRNYXggPSBNYXRoLm1heCh0VGFyZ2V0cyA/IHRUYXJnZXRzLmxlbmd0aCA6IDAsIHNUYXJnZXRzID8gc1RhcmdldHMubGVuZ3RoIDogMCk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbiA9IHRhcmdldE1heDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IFdlYkdMU3RhdGUuX2dldFRleHR1cmVUYXJnZXRCeUluZGV4KGopO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVUZXh0dXJlICE9PSB0ZXh0dXJlTnVtYikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5fYWN0aXZlVGV4dHVyZSh0ZXh0dXJlTnVtYik7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRleHR1cmUgPSB0ZXh0dXJlTnVtYjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gKHNUYXJnZXRzICYmIHNUYXJnZXRzW2pdKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9iaW5kVGV4dHVyZSh0YXJnZXQsIHRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHMuX2FjdGl2ZVRleHR1cmUgIT09IGFjdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLl9hY3RpdmVUZXh0dXJlKHMuX2FjdGl2ZVRleHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX21pZ3JhdGVCdWZmZXJzKHQsIHMpIHtcbiAgICAgICAgcy5fYnVmZmVycy5mb3JFYWNoKChmcmFtZWJ1ZmZlciwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAodC5fYnVmZmVycy5nZXQodGFyZ2V0KSAhPT0gZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5fYmluZEJ1ZmZlcih0YXJnZXQsIGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdC5fYnVmZmVycy5mb3JFYWNoKChidWZmZXIsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYiA9IHMuX2J1ZmZlcnMuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2JpbmRCdWZmZXIodGFyZ2V0LCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAocy5fYnVmZmVycy5nZXQodGhpcy5fZ2wuQVJSQVlfQlVGRkVSKSAhPT0gdC5fYnVmZmVycy5nZXQodGhpcy5fZ2wuQVJSQVlfQlVGRkVSKSlcbiAgICB9XG5cbiAgICBfbWlncmF0ZUZyYW1lYnVmZmVycyh0LCBzKSB7XG4gICAgICAgIHMuX2ZyYW1lYnVmZmVycy5mb3JFYWNoKChmcmFtZWJ1ZmZlciwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAodC5fZnJhbWVidWZmZXJzLmdldCh0YXJnZXQpICE9PSBmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHQuX2ZyYW1lYnVmZmVycy5mb3JFYWNoKChmcmFtZWJ1ZmZlciwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmYiA9IHMuX2ZyYW1lYnVmZmVycy5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChmYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2JpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfbWlncmF0ZVJlbmRlcmJ1ZmZlcnModCwgcykge1xuICAgICAgICBzLl9yZW5kZXJidWZmZXJzLmZvckVhY2goKHJlbmRlcmJ1ZmZlciwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAodC5fcmVuZGVyYnVmZmVycy5nZXQodGFyZ2V0KSAhPT0gcmVuZGVyYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2JpbmRSZW5kZXJidWZmZXIodGFyZ2V0LCByZW5kZXJidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0Ll9yZW5kZXJidWZmZXJzLmZvckVhY2goKHJlbmRlcmJ1ZmZlciwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmYiA9IHMuX3JlbmRlcmJ1ZmZlcnMuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoZmIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9iaW5kUmVuZGVyYnVmZmVyKHRhcmdldCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9taWdyYXRlQXR0cmlidXRlcyh0LCBzLCBidWZmZXJzQ2hhbmdlZCkge1xuXG4gICAgICAgIGlmICghYnVmZmVyc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHQuX3ZlcnRleEF0dHJpYnMuZm9yRWFjaCgoYXR0cmliLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcy5fdmVydGV4QXR0cmlic1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgJ2RlbGV0ZScgYSB2ZXJ0ZXggYXR0cmliIHNvIHdlJ2xsIGRpc2FibGUgaXQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzLl92ZXJ0ZXhBdHRyaWJzLmZvckVhY2goKGF0dHJpYiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5fdmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgYXR0cmliWzBdLCBhdHRyaWJbMV0sIGF0dHJpYlsyXSwgYXR0cmliWzRdKTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmliWzVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2Rpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIGJ1ZmZlcnMgYXJlIGNoYW5nZWQsIHByZXZpb3VzIGF0dHJpYnV0ZXMgd2VyZSByZXNldCBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgICAgcy5fdmVydGV4QXR0cmlicy5mb3JFYWNoKChhdHRyaWIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYlswXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qgc2V0IHZlcnRleCBhdHRyaWIgcG9pbnRlciB3aGVuIGl0IHdhcyBqdXN0IHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5fdmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgYXR0cmliWzBdLCBhdHRyaWJbMV0sIGF0dHJpYlsyXSwgYXR0cmliWzNdLCBhdHRyaWJbNF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXR0cmliWzVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbWlncmF0ZVNldHRpbmdzKHQsIHMpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdHMgPSB0aGlzLmNvbnN0cnVjdG9yLmdldERlZmF1bHRTZXR0aW5ncygpO1xuICAgICAgICB0Ll9zZXR0aW5ncy5mb3JFYWNoKCh2YWx1ZSwgZnVuYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGZ1bmMubmFtZSB8fCBmdW5jLnhuYW1lO1xuICAgICAgICAgICAgaWYgKCFzLl9zZXR0aW5ncy5oYXMoZnVuYykpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJncyA9IGRlZmF1bHRzLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNGdW5jdGlvbihhcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncyh0aGlzLl9nbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBhY3R1YWxseSBzZXR0aW5nIHRoZSBzZXR0aW5nIGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuXG4gICAgICAgICAgICAgICAgcy5fc2V0dGluZ3Muc2V0KGZ1bmMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fZ2wsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcy5fc2V0dGluZ3MuZm9yRWFjaCgodmFsdWUsIGZ1bmMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRWYWx1ZSA9IHQuX3NldHRpbmdzLmdldChmdW5jKTtcbiAgICAgICAgICAgIGlmICghdFZhbHVlIHx8ICFVdGlscy5lcXVhbFZhbHVlcyh0VmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fZ2wsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX21pZ3JhdGVGbGFncyh0LCBzKSB7XG4gICAgICAgIHQuX25vbkRlZmF1bHRGbGFncy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICAgICAgaWYgKCFzLl9ub25EZWZhdWx0RmxhZ3MuaGFzKHNldHRpbmcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dldERlZmF1bHRGbGFnKHNldHRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9lbmFibGUoc2V0dGluZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2Rpc2FibGUoc2V0dGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcy5fbm9uRGVmYXVsdEZsYWdzLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICAgICAgICBpZiAoIXQuX25vbkRlZmF1bHRGbGFncy5oYXMoc2V0dGluZykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ2V0RGVmYXVsdEZsYWcoc2V0dGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2Rpc2FibGUoc2V0dGluZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2VuYWJsZShzZXR0aW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXREZWZhdWx0U2V0dGluZ3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGVmYXVsdFNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0U2V0dGluZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBkID0gdGhpcy5fZGVmYXVsdFNldHRpbmdzO1xuICAgICAgICAgICAgY29uc3QgZyA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGU7XG4gICAgICAgICAgICBkLnNldChcInZpZXdwb3J0XCIsIGZ1bmN0aW9uKGdsKSB7cmV0dXJuIFswLDAsZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0XX0pO1xuICAgICAgICAgICAgZC5zZXQoXCJzY2lzc29yXCIsIGZ1bmN0aW9uKGdsKSB7cmV0dXJuIFswLDAsZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0XX0pO1xuICAgICAgICAgICAgZC5zZXQoXCJibGVuZENvbG9yXCIsIFswLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICBkLnNldChcImJsZW5kRXF1YXRpb25cIiwgW2cuRlVOQ19BRERdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiYmxlbmRFcXVhdGlvblNlcGFyYXRlXCIsIFtnLkZVTkNfQURELCBnLkZVTkNfQUREXSk7XG4gICAgICAgICAgICBkLnNldChcImJsZW5kRnVuY1wiLCBbZy5PTkUsIGcuWkVST10pO1xuICAgICAgICAgICAgZC5zZXQoXCJibGVuZEZ1bmNTZXBhcmF0ZVwiLCBbZy5PTkUsIGcuWkVSTywgZy5PTkUsIGcuWkVST10pO1xuICAgICAgICAgICAgZC5zZXQoXCJjbGVhckNvbG9yXCIsIFswLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICBkLnNldChcImNsZWFyRGVwdGhcIiwgWzFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiY2xlYXJTdGVuY2lsXCIsIFswXSk7XG4gICAgICAgICAgICBkLnNldChcImNvbG9yTWFza1wiLCBbdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJjdWxsRmFjZVwiLCBbZy5CQUNLXSk7XG4gICAgICAgICAgICBkLnNldChcImRlcHRoRnVuY1wiLCBbZy5MRVNTXSk7XG4gICAgICAgICAgICBkLnNldChcImRlcHRoTWFza1wiLCBbdHJ1ZV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJkZXB0aFJhbmdlXCIsIFswLCAxXSk7XG4gICAgICAgICAgICBkLnNldChcImZyb250RmFjZVwiLCBbZy5DQ1ddKTtcbiAgICAgICAgICAgIGQuc2V0KFwibGluZVdpZHRoXCIsIFsxXSk7XG4gICAgICAgICAgICBkLnNldChcInBvbHlnb25PZmZzZXRcIiwgWzAsIDBdKTtcbiAgICAgICAgICAgIGQuc2V0KFwic2FtcGxlQ292ZXJhZ2VcIiwgWzEsIGZhbHNlXSk7XG4gICAgICAgICAgICBkLnNldChcInN0ZW5jaWxGdW5jXCIsIFtnLkFMV0FZUywgMCwgMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJfc3RlbmNpbEZ1bmNTZXBhcmF0ZUZyb250XCIsIFtnLkFMV0FZUywgMCwgMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJfc3RlbmNpbEZ1bmNTZXBhcmF0ZUJhY2tcIiwgW2cuQUxXQVlTLCAwLCAxXSk7XG4gICAgICAgICAgICBkLnNldChcIl9zdGVuY2lsRnVuY1NlcGFyYXRlRnJvbnRBbmRCYWNrXCIsIFtnLkFMV0FZUywgMCwgMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJzdGVuY2lsTWFza1wiLCBbMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJfc3RlbmNpbE1hc2tTZXBhcmF0ZUZyb250XCIsIFsxXSk7XG4gICAgICAgICAgICBkLnNldChcIl9zdGVuY2lsTWFza1NlcGFyYXRlQmFja1wiLCBbMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJfc3RlbmNpbE1hc2tTZXBhcmF0ZUZyb250QW5kQmFja1wiLCBbMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJzdGVuY2lsT3BcIiwgW2cuS0VFUCwgZy5LRUVQLCBnLktFRVBdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiX3N0ZW5jaWxPcFNlcGFyYXRlRnJvbnRcIiwgW2cuS0VFUCwgZy5LRUVQLCBnLktFRVBdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiX3N0ZW5jaWxPcFNlcGFyYXRlQmFja1wiLCBbZy5LRUVQLCBnLktFRVAsIGcuS0VFUF0pO1xuICAgICAgICAgICAgZC5zZXQoXCJfc3RlbmNpbE9wU2VwYXJhdGVGcm9udEFuZEJhY2tcIiwgW2cuS0VFUCwgZy5LRUVQLCBnLktFRVBdKTtcbiAgICAgICAgICAgIGQuc2V0KFwidmVydGV4QXR0cmliMWZcIiwgW10pO1xuICAgICAgICAgICAgZC5zZXQoXCJ2ZXJ0ZXhBdHRyaWIxZnZcIiwgW10pO1xuICAgICAgICAgICAgZC5zZXQoXCJ2ZXJ0ZXhBdHRyaWIyZlwiLCBbXSk7XG4gICAgICAgICAgICBkLnNldChcInZlcnRleEF0dHJpYjJmdlwiLCBbXSk7XG4gICAgICAgICAgICBkLnNldChcInZlcnRleEF0dHJpYjNmXCIsIFtdKTtcbiAgICAgICAgICAgIGQuc2V0KFwidmVydGV4QXR0cmliM2Z2XCIsIFtdKTtcbiAgICAgICAgICAgIGQuc2V0KFwidmVydGV4QXR0cmliNGZcIiwgW10pO1xuICAgICAgICAgICAgZC5zZXQoXCJ2ZXJ0ZXhBdHRyaWI0ZnZcIiwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0U2V0dGluZ3NcbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFRleHR1cmVUYXJnZXRJbmRleCh0YXJnZXQpIHtcbiAgICAgICAgc3dpdGNoKHRhcmdldCkge1xuICAgICAgICAgICAgY2FzZSAweDBERTE6XG4gICAgICAgICAgICAgICAgLyogVEVYVFVSRV8yRCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgY2FzZSAweDg1MTM6XG4gICAgICAgICAgICAgICAgLyogVEVYVFVSRV9DVUJFX01BUCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBTaG91bGRuJ3QgaGFwcGVuLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0ZXh0dXJlIHRhcmdldDogJyArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFRleHR1cmVUYXJnZXRCeUluZGV4KGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dHVyZVRhcmdldEluZGljZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVUYXJnZXRJbmRpY2VzID0gWzB4MERFMSwgMHg4NTEzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVRhcmdldEluZGljZXNbaW5kZXhdXG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRUZXh0dXJlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4IC0gMHg4NEMwIC8qIEdMX1RFWFRVUkUwICovO1xuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0VGV4dHVyZUJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ICsgMHg4NEMwO1xuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0UGl4ZWxTdG9yZWlJbmRleChwbmFtZSkge1xuICAgICAgICBzd2l0Y2gocG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgMHgwRDA1OlxuICAgICAgICAgICAgICAgIC8qIFBBQ0tfQUxJR05NRU5UICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIDB4MENGNTpcbiAgICAgICAgICAgICAgICAvKiBVTlBBQ0tfQUxJR05NRU5UICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIDB4OTI0MDpcbiAgICAgICAgICAgICAgICAvKiBVTlBBQ0tfRkxJUF9ZX1dFQkdMICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlIDB4OTI0MTpcbiAgICAgICAgICAgICAgICAvKiBVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgIGNhc2UgMHg5MjQzOlxuICAgICAgICAgICAgICAgIC8qIFVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgICAgICAgICAvL0B0b2RvOiBzdXBwb3J0IFdlYkdMMiBwcm9wZXJ0aWVzLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMUmVuZGVyaW5nQ29udGV4dC9waXhlbFN0b3JlaVxuICAgICAgICAgICAgY2FzZSAweDkyNDU6XG4gICAgICAgICAgICAgICAgLyogVU5QQUNLX0ZMSVBfQkxVRV9SRUQgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkbid0IGhhcHBlbi5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcGl4ZWxzdG9yZWk6ICcgKyBwbmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFBpeGVsU3RvcmVpQnlJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BpeGVsU3RvcmVpSW5kaWNlcykge1xuICAgICAgICAgICAgdGhpcy5fcGl4ZWxTdG9yZWlJbmRpY2VzID0gWzB4MEQwNSwgMHgwQ0Y1LCAweDkyNDAsIDB4OTI0MSwgMHg5MjQzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGl4ZWxTdG9yZWlJbmRpY2VzW2luZGV4XVxuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0RGVmYXVsdFBpeGVsU3RvcmVpQnlJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BpeGVsU3RvcmVpRGVmYXVsdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsU3RvcmVpRGVmYXVsdHMgPSBbNCwgNCwgZmFsc2UsIGZhbHNlLCBXZWJHTFJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLkJST1dTRVJfREVGQVVMVF9XRUJHTF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpeGVsU3RvcmVpRGVmYXVsdHNbaW5kZXhdXG4gICAgfVxufVxuXG5jbGFzcyBXZWJHTFN0YXRlTWFuYWdlciB7XG5cbiAgICBfaW5pdFN0YXRlTWFuYWdlcihpZCA9IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IHt9O1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGlkKTtcbiAgICB9XG5cbiAgICBfZ2V0U3RhdGUoaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZXNbaWRdKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZXNbaWRdID0gbmV3IFdlYkdMU3RhdGUoaWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZXNbaWRdO1xuICAgIH1cblxuICAgIHN3aXRjaFN0YXRlKGlkID0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLl9pZCAhPT0gaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaWQpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUubWlncmF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJHVzZVByb2dyYW0ocHJvZ3JhbSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0UHJvZ3JhbShwcm9ncmFtKSlcbiAgICAgICAgICAgIHRoaXMuX3VzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgfVxuXG4gICAgJGJpbmRCdWZmZXIodGFyZ2V0LCBmYikge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0QnVmZmVyKHRhcmdldCwgZmIpKVxuICAgICAgICAgICAgdGhpcy5fYmluZEJ1ZmZlcih0YXJnZXQsIGZiKTtcbiAgICB9XG5cbiAgICAkYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgZmIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldEZyYW1lYnVmZmVyKHRhcmdldCwgZmIpKVxuICAgICAgICAgICAgdGhpcy5fYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgZmIpO1xuICAgIH1cblxuICAgICRiaW5kUmVuZGVyYnVmZmVyKHRhcmdldCwgZmIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFJlbmRlcmJ1ZmZlcih0YXJnZXQsIGZiKSlcbiAgICAgICAgICAgIHRoaXMuX2JpbmRSZW5kZXJidWZmZXIodGFyZ2V0LCBmYik7XG4gICAgfVxuXG4gICAgJGVuYWJsZShjYXApIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldEZsYWcoY2FwLCB0cnVlKSlcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZShjYXApO1xuICAgIH1cblxuICAgICRkaXNhYmxlKGNhcCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0RmxhZyhjYXAsIGZhbHNlKSlcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGUoY2FwKTtcbiAgICB9XG5cbiAgICAkdmlld3BvcnQoeCwgeSwgdywgaCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl92aWV3cG9ydCwgW3gsIHksIHcsIGhdKSlcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0KHgsIHksIHcsIGgpO1xuICAgIH1cblxuICAgICRzY2lzc29yKHgsIHksIHcsIGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fc2Npc3NvciwgW3gsIHksIHcsIGhdKSlcbiAgICAgICAgICAgIHRoaXMuX3NjaXNzb3IoeCwgeSwgdywgaCk7XG4gICAgfVxuXG4gICAgJGRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KSlcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgfVxuXG4gICAgJGVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCkpXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgfVxuXG4gICAgJHZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS52ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4LCBbc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXRdKSlcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICAkYWN0aXZlVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRBY3RpdmVUZXh0dXJlKHRleHR1cmUpKVxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICB9XG5cbiAgICAkYmluZFRleHR1cmUodGFyZ2V0LCB0ZXh0dXJlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleHR1cmUpKVxuICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmUodGFyZ2V0LCB0ZXh0dXJlKTtcbiAgICB9XG5cbiAgICAkcGl4ZWxTdG9yZWkocG5hbWUsIHBhcmFtKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRQaXhlbFN0b3JlaShwbmFtZSwgcGFyYW0pKSB7XG4gICAgICAgICAgICB0aGlzLl9waXhlbFN0b3JlaShwbmFtZSwgcGFyYW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJHN0ZW5jaWxGdW5jU2VwYXJhdGUoZmFjZSwgZnVuYywgcmVmLCBtYXNrKSB7XG4gICAgICAgIGxldCBmO1xuICAgICAgICBzd2l0Y2goZmFjZSkge1xuICAgICAgICAgICAgY2FzZSB0aGlzLkZST05UOlxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdGVuY2lsRnVuY1NlcGFyYXRlRnJvbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuQkFDSzpcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fc3RlbmNpbEZ1bmNTZXBhcmF0ZUJhY2s7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuRlJPTlRfQU5EX0JBQ0s6XG4gICAgICAgICAgICAgICAgZiA9IHRoaXMuX3N0ZW5jaWxGdW5jU2VwYXJhdGVGcm9udEFuZEJhY2s7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyhmLCBbZnVuYywgcmVmLCBtYXNrXSkpXG4gICAgICAgICAgICBmLmFwcGx5KHRoaXMsIFtmdW5jLCByZWYsIG1hc2tdKTtcbiAgICB9XG5cbiAgICBfc3RlbmNpbEZ1bmNTZXBhcmF0ZUZyb250KGZ1bmMsIHJlZiwgbWFzaykge1xuICAgICAgICB0aGlzLl9zdGVuY2lsRnVuY1NlcGFyYXRlKHRoaXMuRlJPTlQsIGZ1bmMsIHJlZiwgbWFzayk7XG4gICAgfVxuXG4gICAgX3N0ZW5jaWxGdW5jU2VwYXJhdGVCYWNrKGZ1bmMsIHJlZiwgbWFzaykge1xuICAgICAgICB0aGlzLl9zdGVuY2lsRnVuY1NlcGFyYXRlKHRoaXMuQkFDSywgZnVuYywgcmVmLCBtYXNrKTtcbiAgICB9XG5cbiAgICBfc3RlbmNpbEZ1bmNTZXBhcmF0ZUZyb250QW5kQmFjayhmdW5jLCByZWYsIG1hc2spIHtcbiAgICAgICAgdGhpcy5fc3RlbmNpbEZ1bmNTZXBhcmF0ZSh0aGlzLkZST05UX0FORF9CQUNLLCBmdW5jLCByZWYsIG1hc2spO1xuICAgIH1cblxuICAgICRzdGVuY2lsTWFza1NlcGFyYXRlKGZhY2UsIG1hc2spIHtcbiAgICAgICAgbGV0IGY7XG4gICAgICAgIHN3aXRjaChmYWNlKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMuRlJPTlQ6XG4gICAgICAgICAgICAgICAgZiA9IHRoaXMuX3N0ZW5jaWxNYXNrU2VwYXJhdGVGcm9udDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5CQUNLOlxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdGVuY2lsTWFza1NlcGFyYXRlQmFjaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5GUk9OVF9BTkRfQkFDSzpcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fc3RlbmNpbE1hc2tTZXBhcmF0ZUZyb250QW5kQmFjaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKGYsIFttYXNrXSkpXG4gICAgICAgICAgICBmLmFwcGx5KHRoaXMsIFttYXNrXSk7XG4gICAgfVxuXG4gICAgX3N0ZW5jaWxNYXNrU2VwYXJhdGVGcm9udChtYXNrKSB7XG4gICAgICAgIHRoaXMuX3N0ZW5jaWxNYXNrU2VwYXJhdGUodGhpcy5GUk9OVCwgbWFzayk7XG4gICAgfVxuXG4gICAgX3N0ZW5jaWxNYXNrU2VwYXJhdGVCYWNrKG1hc2spIHtcbiAgICAgICAgdGhpcy5fc3RlbmNpbE1hc2tTZXBhcmF0ZSh0aGlzLkJBQ0ssIG1hc2spO1xuICAgIH1cblxuICAgIF9zdGVuY2lsTWFza1NlcGFyYXRlRnJvbnRBbmRCYWNrKG1hc2spIHtcbiAgICAgICAgdGhpcy5fc3RlbmNpbE1hc2tTZXBhcmF0ZSh0aGlzLkZST05UX0FORF9CQUNLLCBtYXNrKTtcbiAgICB9XG5cbiAgICAkc3RlbmNpbE9wU2VwYXJhdGUoZmFjZSwgZmFpbCwgemZhaWwsIHpwYXNzKSB7XG4gICAgICAgIGxldCBmO1xuICAgICAgICBzd2l0Y2goZmFjZSkge1xuICAgICAgICAgICAgY2FzZSB0aGlzLkZST05UOlxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdGVuY2lsT3BTZXBhcmF0ZUZyb250O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLkJBQ0s6XG4gICAgICAgICAgICAgICAgZiA9IHRoaXMuX3N0ZW5jaWxPcFNlcGFyYXRlQmFjaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5GUk9OVF9BTkRfQkFDSzpcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fc3RlbmNpbE9wU2VwYXJhdGVGcm9udEFuZEJhY2s7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyhmLCBbZmFpbCwgemZhaWwsIHpwYXNzXSkpXG4gICAgICAgICAgICBmLmFwcGx5KHRoaXMsIFtmYWlsLCB6ZmFpbCwgenBhc3NdKTtcbiAgICB9XG5cbiAgICBfc3RlbmNpbE9wU2VwYXJhdGVGcm9udChmYWlsLCB6ZmFpbCwgenBhc3MpIHtcbiAgICAgICAgdGhpcy5fc3RlbmNpbE9wU2VwYXJhdGUodGhpcy5GUk9OVCwgZmFpbCwgemZhaWwsIHpwYXNzKTtcbiAgICB9XG5cbiAgICBfc3RlbmNpbE9wU2VwYXJhdGVCYWNrKGZhaWwsIHpmYWlsLCB6cGFzcykge1xuICAgICAgICB0aGlzLl9zdGVuY2lsT3BTZXBhcmF0ZSh0aGlzLkJBQ0ssIGZhaWwsIHpmYWlsLCB6cGFzcyk7XG4gICAgfVxuXG4gICAgX3N0ZW5jaWxPcFNlcGFyYXRlRnJvbnRBbmRCYWNrKGZhaWwsIHpmYWlsLCB6cGFzcykge1xuICAgICAgICB0aGlzLl9zdGVuY2lsT3BTZXBhcmF0ZSh0aGlzLkZST05UX0FORF9CQUNLLCBmYWlsLCB6ZmFpbCwgenBhc3MpO1xuICAgIH1cblxuICAgICRibGVuZENvbG9yKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2JsZW5kQ29sb3IsIFtyZWQsIGdyZWVuLCBibHVlLCBhbHBoYV0pKVxuICAgICAgICAgICAgdGhpcy5fYmxlbmRDb2xvcihyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSk7XG4gICAgfVxuXG4gICAgJGJsZW5kRXF1YXRpb24obW9kZSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9ibGVuZEVxdWF0aW9uLCBbbW9kZV0pKVxuICAgICAgICAgICAgdGhpcy5fYmxlbmRFcXVhdGlvbihtb2RlKTtcbiAgICB9XG5cbiAgICAkYmxlbmRFcXVhdGlvblNlcGFyYXRlKG1vZGVSR0IsIG1vZGVBbHBoYSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9ibGVuZEVxdWF0aW9uU2VwYXJhdGUsIFttb2RlUkdCLCBtb2RlQWxwaGFdKSlcbiAgICAgICAgICAgIHRoaXMuX2JsZW5kRXF1YXRpb25TZXBhcmF0ZShtb2RlUkdCLCBtb2RlQWxwaGEpO1xuICAgIH1cblxuICAgICRibGVuZEZ1bmMoc2ZhY3RvciwgZGZhY3Rvcikge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9ibGVuZEZ1bmMsIFtzZmFjdG9yLCBkZmFjdG9yXSkpXG4gICAgICAgICAgICB0aGlzLl9ibGVuZEZ1bmMoc2ZhY3RvciwgZGZhY3Rvcik7XG4gICAgfVxuXG4gICAgJGJsZW5kRnVuY1NlcGFyYXRlKHNyY1JHQiwgZHN0UkdCLCBzcmNBbHBoYSwgZHN0QWxwaGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fYmxlbmRGdW5jU2VwYXJhdGUsIFtzcmNSR0IsIGRzdFJHQiwgc3JjQWxwaGEsIGRzdEFscGhhXSkpXG4gICAgICAgICAgICB0aGlzLl9ibGVuZEZ1bmNTZXBhcmF0ZShzcmNSR0IsIGRzdFJHQiwgc3JjQWxwaGEsIGRzdEFscGhhKTtcbiAgICB9XG5cbiAgICAkY2xlYXJDb2xvcihyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9jbGVhckNvbG9yLCBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdKSlcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyQ29sb3IocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpO1xuICAgIH1cblxuICAgICRjbGVhckRlcHRoKGRlcHRoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2NsZWFyRGVwdGgsIFtkZXB0aF0pKVxuICAgICAgICAgICAgdGhpcy5fY2xlYXJEZXB0aChkZXB0aCk7XG4gICAgfVxuXG4gICAgJGNsZWFyU3RlbmNpbChzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2NsZWFyU3RlbmNpbCwgW3NdKSlcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU3RlbmNpbChzKTtcbiAgICB9XG5cbiAgICAkY29sb3JNYXNrKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2NvbG9yTWFzaywgW3JlZCwgZ3JlZW4sIGJsdWUsIGFscGhhXSkpXG4gICAgICAgICAgICB0aGlzLl9jb2xvck1hc2socmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpO1xuICAgIH1cblxuICAgICRjdWxsRmFjZShtb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2N1bGxGYWNlLCBbbW9kZV0pKVxuICAgICAgICAgICAgdGhpcy5fY3VsbEZhY2UobW9kZSk7XG4gICAgfVxuXG4gICAgJGRlcHRoRnVuYyhmdW5jKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2RlcHRoRnVuYywgW2Z1bmNdKSlcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoRnVuYyhmdW5jKTtcbiAgICB9XG5cbiAgICAkZGVwdGhNYXNrKGZsYWcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fZGVwdGhNYXNrLCBbZmxhZ10pKVxuICAgICAgICAgICAgdGhpcy5fZGVwdGhNYXNrKGZsYWcpO1xuICAgIH1cblxuICAgICRkZXB0aFJhbmdlKHpOZWFyLCB6RmFyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2RlcHRoUmFuZ2UsIFt6TmVhciwgekZhcl0pKVxuICAgICAgICAgICAgdGhpcy5fZGVwdGhSYW5nZSh6TmVhciwgekZhcik7XG4gICAgfVxuXG4gICAgJGZyb250RmFjZShtb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2Zyb250RmFjZSwgW21vZGVdKSlcbiAgICAgICAgICAgIHRoaXMuX2Zyb250RmFjZShtb2RlKTtcbiAgICB9XG5cbiAgICAkbGluZVdpZHRoKHdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2xpbmVXaWR0aCwgW3dpZHRoXSkpXG4gICAgICAgICAgICB0aGlzLl9saW5lV2lkdGgod2lkdGgpO1xuICAgIH1cblxuICAgICRwb2x5Z29uT2Zmc2V0KGZhY3RvciwgdW5pdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fcG9seWdvbk9mZnNldCwgW2ZhY3RvciwgdW5pdHNdKSlcbiAgICAgICAgICAgIHRoaXMuX3BvbHlnb25PZmZzZXQoZmFjdG9yLCB1bml0cyk7XG4gICAgfVxuXG4gICAgJHNhbXBsZUNvdmVyYWdlKHZhbHVlLCBpbnZlcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fc2FtcGxlQ292ZXJhZ2UsIFt2YWx1ZSwgaW52ZXJ0XSkpXG4gICAgICAgICAgICB0aGlzLl9zYW1wbGVDb3ZlcmFnZSh2YWx1ZSwgaW52ZXJ0KTtcbiAgICB9XG5cbiAgICAkc3RlbmNpbEZ1bmMoZnVuYywgcmVmLCBtYXNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3N0ZW5jaWxGdW5jLCBbZnVuYywgcmVmLCBtYXNrXSkpXG4gICAgICAgICAgICB0aGlzLl9zdGVuY2lsRnVuYyhmdW5jLCByZWYsIG1hc2spO1xuICAgIH1cblxuICAgICRzdGVuY2lsTWFzayhtYXNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3N0ZW5jaWxNYXNrLCBbbWFza10pKVxuICAgICAgICAgICAgdGhpcy5fc3RlbmNpbE1hc2sobWFzayk7XG4gICAgfVxuXG4gICAgJHN0ZW5jaWxPcChmYWlsLCB6ZmFpbCwgenBhc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fc3RlbmNpbE9wLCBbZmFpbCwgemZhaWwsIHpwYXNzXSkpXG4gICAgICAgICAgICB0aGlzLl9zdGVuY2lsT3AoZmFpbCwgemZhaWwsIHpwYXNzKTtcbiAgICB9XG5cbiAgICAkdmVydGV4QXR0cmliMWYoaW5keCwgeCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl92ZXJ0ZXhBdHRyaWIxZiwgW2luZHgsIHhdKSlcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYjFmKGluZHgsIHgpO1xuICAgIH1cblxuICAgICR2ZXJ0ZXhBdHRyaWIxZnYoaW5keCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3ZlcnRleEF0dHJpYjFmdiwgW2luZHgsIHZhbHVlc10pKVxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliMWZ2KGluZHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgJHZlcnRleEF0dHJpYjJmKGluZHgsIHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fdmVydGV4QXR0cmliMmYsIFtpbmR4LCB4LCB5XSkpXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWIyZihpbmR4LCB4LCB5KTtcbiAgICB9XG5cbiAgICAkdmVydGV4QXR0cmliMmZ2KGluZHgsIHZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl92ZXJ0ZXhBdHRyaWIyZnYsIFtpbmR4LCB2YWx1ZXNdKSlcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYjJmdihpbmR4LCB2YWx1ZXMpO1xuICAgIH1cblxuICAgICR2ZXJ0ZXhBdHRyaWIzZihpbmR4LCB4LCB5LCB6KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3ZlcnRleEF0dHJpYjNmLCBbaW5keCwgeCwgeSwgel0pKVxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliM2YoaW5keCwgeCwgeSwgeik7XG4gICAgfVxuXG4gICAgJHZlcnRleEF0dHJpYjNmdihpbmR4LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fdmVydGV4QXR0cmliM2Z2LCBbaW5keCwgdmFsdWVzXSkpXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWIzZnYoaW5keCwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAkdmVydGV4QXR0cmliNGYoaW5keCwgeCwgeSwgeiwgdykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl92ZXJ0ZXhBdHRyaWI0ZiwgW2luZHgsIHgsIHksIHosIHddKSlcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYjRmKGluZHgsIHgsIHksIHosIHcpO1xuICAgIH1cblxuICAgICR2ZXJ0ZXhBdHRyaWI0ZnYoaW5keCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3ZlcnRleEF0dHJpYjRmdiwgW2luZHgsIHZhbHVlc10pKVxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliNGZ2KGluZHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIGNvbnRleHQgc2hhcmluZy5cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5hYmxlKGdsLCBpZCA9IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoV2ViR0xTdGF0ZU1hbmFnZXIucHJvdG90eXBlKTtcbiAgICAgICAgY29uc3QgV2ViR0xSZW5kZXJpbmdDb250ZXh0UHJvdG8gPSBnbC5fX3Byb3RvX187XG4gICAgICAgIG5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gV2ViR0xTdGF0ZU1hbmFnZXIucHJvdG90eXBlW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCIkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2xbbmFtZV0gIT09IG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ2xbbmFtZV0ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgQ2hyb21lIFdlYkdMIEluc3BlY3RvciBwbHVnaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xbbmFtZV0ueG5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2xbJ18nICsgbmFtZV0gPSBnbFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnbFtuYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFdlYkdMU3RhdGVNYW5hZ2VyLnByb3RvdHlwZS5faW5pdFN0YXRlTWFuYWdlci5jYWxsKGdsLCBpZCk7XG5cbiAgICAgICAgcmV0dXJuIGdsO1xuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJHTFN0YXRlTWFuYWdlcjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2Uge1xuXG4gICAgc3RhdGljIGRlZmF1bHRTZXR0ZXIob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGF0Y2hPYmplY3Qob2JqLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoIVV0aWxzLmlzT2JqZWN0TGl0ZXJhbChzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbTGlnaHRuaW5nXSBTZXR0aW5ncyBtdXN0IGJlIG9iamVjdCBsaXRlcmFsXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5hbWVzID0gT2JqZWN0LmtleXMoc2V0dGluZ3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBuYW1lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IG5hbWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaE9iamVjdFByb3BlcnR5KG9iaiwgbmFtZSwgc2V0dGluZ3NbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHBhdGNoT2JqZWN0UHJvcGVydHkob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQgc2V0dGVyID0gb2JqLnNldFNldHRpbmcgfHwgQmFzZS5kZWZhdWx0U2V0dGVyO1xuXG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJfXCIpIHtcbiAgICAgICAgICAgIC8vIERpc2FsbG93IHBhdGNoaW5nIHByaXZhdGUgdmFyaWFibGVzLlxuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiX19jcmVhdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbTGlnaHRuaW5nXSBQYXRjaCBvZiBwcml2YXRlIHByb3BlcnR5ICdcIiArIG5hbWUgKyBcIicgaXMgbm90IGFsbG93ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSAhPT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICAgIC8vIFR5cGUgaXMgYSByZXNlcnZlZCBrZXl3b3JkIHRvIHNwZWNpZnkgdGhlIGNsYXNzIHR5cGUgb24gY3JlYXRpb24uXG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNGdW5jdGlvbih2YWx1ZSkgJiYgdmFsdWUuX19sb2NhbCkge1xuICAgICAgICAgICAgICAgIC8vIExvY2FsIGZ1bmN0aW9uIChCYXNlLmxvY2FsKHMgPT4gcy5zb21ldGhpbmcpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuX19sb2NhbChvYmopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXR0ZXIob2JqLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbG9jYWwoZnVuYykge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGFzIGFuIG9iamVjdCBzZXR0aW5nLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAgZnVuYy5fX2xvY2FsID0gdHJ1ZTtcbiAgICB9XG5cblxufVxuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4vVXRpbHMubWpzXCI7XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUmVuZGVyIHRyZWUgbm9kZS5cbiAqL1xuXG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IEVsZW1lbnRDb3JlIGZyb20gXCIuL2NvcmUvRWxlbWVudENvcmUubWpzXCI7XG5pbXBvcnQgQmFzZSBmcm9tIFwiLi9CYXNlLm1qc1wiO1xuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4vVXRpbHMubWpzXCI7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCIuLi9FdmVudEVtaXR0ZXIubWpzXCI7XG5pbXBvcnQgU2hhZGVyIGZyb20gXCIuL1NoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudCB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG5cbiAgICAgICAgdGhpcy5fX2lkID0gRWxlbWVudC5pZCsrO1xuXG4gICAgICAgIHRoaXMuX19zdGFydCgpO1xuXG4gICAgICAgIC8vIEV2ZW50RW1pdHRlciBjb25zdHJ1Y3Rvci5cbiAgICAgICAgdGhpcy5faGFzRXZlbnRMaXN0ZW5lcnMgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9fY29yZSA9IG5ldyBFbGVtZW50Q29yZSh0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdGhhdCBjYW4gYmUgdXNlZCB3aGlsZSBtZXJnaW5nIHRyZWVzLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX3JlZiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVsZW1lbnQgaXMgYXR0YWNoZWQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIHRoZSBzdGFnZSByb290LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX19hdHRhY2hlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBlbGVtZW50IGlzIGVuYWJsZWQgd2hlbiBpdCBpcyBhdHRhY2hlZCBhbmQgaXQgaXMgdmlzaWJsZSAod29ybGRBbHBoYSA+IDApLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX19lbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVsZW1lbnQgaXMgYWN0aXZlIHdoZW4gaXQgaXMgZW5hYmxlZCBhbmQgaXQgaXMgd2l0aGluIGJvdW5kcy5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX3BhcmVudCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0dXJlIHRoYXQgaXMgY3VycmVudGx5IHNldC5cbiAgICAgICAgICogQHR5cGUge1RleHR1cmV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fdGV4dHVyZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHRleHR1cmUuIFdoaWxlIHRoaXMudGV4dHVyZSBpcyBsb2FkaW5nLCB0aGlzIG9uZSBtYXkgYmUgZGlmZmVyZW50LlxuICAgICAgICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGFncyB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5L3NlYXJjaCBmb3IgYSBzcGVjaWZpYyBlbGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fdGFncyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0cmVlJ3MgdGFncyBtYXBwaW5nLlxuICAgICAgICAgKiBUaGlzIGNvbnRhaW5zIGFsbCBlbGVtZW50cyBmb3IgYWxsIGtub3duIHRhZ3MsIGF0IGFsbCB0aW1lcy5cbiAgICAgICAgICogQHR5cGUge01hcH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX190cmVlVGFncyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB0YWcgY29udGV4dDogdGFnZ2VkIGVsZW1lbnRzIGluIHRoaXMgYnJhbmNoIHdpbGwgbm90IGJlIHJlYWNoYWJsZSBmcm9tIGFuY2VzdG9ycyBvZiB0aGlzIGVsZW1lbnRzLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX190YWdSb290ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIChMYXp5LWluaXRpYWxpc2VkKSBsaXN0IG9mIGNoaWxkcmVuIG93bmVkIGJ5IHRoaXMgZWxlbWVudHMuXG4gICAgICAgICAqIEB0eXBlIHtFbGVtZW50Q2hpbGRMaXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX2NoaWxkTGlzdCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fdyA9IDA7XG5cbiAgICAgICAgdGhpcy5faCA9IDA7XG4gICAgfVxuXG4gICAgX19zdGFydCgpIHtcbiAgICB9XG5cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9faWQ7XG4gICAgfVxuXG4gICAgc2V0IHJlZihyZWYpIHtcbiAgICAgICAgaWYgKHRoaXMuX19yZWYgIT09IHJlZikge1xuICAgICAgICAgICAgY29uc3QgY2hhcmNvZGUgPSByZWYuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmICghVXRpbHMuaXNVY0NoYXIoY2hhcmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIlJlZiBtdXN0IHN0YXJ0IHdpdGggYW4gdXBwZXIgY2FzZSBjaGFyYWN0ZXI6IFwiICsgcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9fcmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUYWcodGhpcy5fX3JlZik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3BhcmVudC5fX2NoaWxkTGlzdC5jbGVhclJlZih0aGlzLl9fcmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX19yZWYgPSByZWY7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fcmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVGFnKHRoaXMuX19yZWYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19wYXJlbnQuX19jaGlsZExpc3Quc2V0UmVmKHRoaXMuX19yZWYsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCByZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fcmVmO1xuICAgIH1cblxuICAgIGdldCBjb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmU7XG4gICAgfVxuXG4gICAgc2V0QXNSb290KCkge1xuICAgICAgICB0aGlzLl9fY29yZS5zZXRBc1Jvb3QoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQXR0YWNoZWRGbGFnKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVuYWJsZWRGbGFnKCk7XG4gICAgfVxuXG4gICAgZ2V0IGlzUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmlzUm9vdDtcbiAgICB9XG5cbiAgICBfc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5fX3BhcmVudCA9PT0gcGFyZW50KSByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMuX19wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc2V0VGFnc1BhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3BhcmVudCA9IHBhcmVudDtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRUYWdzUGFyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVBdHRhY2hlZEZsYWcoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRW5hYmxlZEZsYWcoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29sbGlzaW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNSb290ICYmIHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIlJvb3Qgc2hvdWxkIG5vdCBiZSBhZGRlZCBhcyBhIGNoaWxkISBSZXN1bHRzIGFyZSB1bnNwZWNpZmllZCFcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0RGVwdGgoKSB7XG4gICAgICAgIGxldCBkZXB0aCA9IDA7XG5cbiAgICAgICAgbGV0IHAgPSB0aGlzLl9fcGFyZW50O1xuICAgICAgICB3aGlsZShwKSB7XG4gICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgcCA9IHAuX19wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgfTtcblxuICAgIGdldEFuY2VzdG9yKGwpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICB3aGlsZSAobCA+IDAgJiYgcC5fX3BhcmVudCkge1xuICAgICAgICAgICAgcCA9IHAuX19wYXJlbnQ7XG4gICAgICAgICAgICBsLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIGdldEFuY2VzdG9ycygpIHtcbiAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBhLnB1c2gocCk7XG4gICAgICAgICAgICBwID0gcC5fX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBnZXRBbmNlc3RvckF0RGVwdGgoZGVwdGgpIHtcbiAgICAgICAgbGV0IGxldmVscyA9IHRoaXMuZ2V0RGVwdGgoKSAtIGRlcHRoO1xuICAgICAgICBpZiAobGV2ZWxzIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5jZXN0b3IobGV2ZWxzKTtcbiAgICB9O1xuXG4gICAgaXNBbmNlc3Rvck9mKGMpIHtcbiAgICAgICAgbGV0IHAgPSBjO1xuICAgICAgICB3aGlsZShwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBnZXRTaGFyZWRBbmNlc3RvcihjKSB7XG4gICAgICAgIGxldCBvMSA9IHRoaXM7XG4gICAgICAgIGxldCBvMiA9IGM7XG4gICAgICAgIGxldCBsMSA9IG8xLmdldERlcHRoKCk7XG4gICAgICAgIGxldCBsMiA9IG8yLmdldERlcHRoKCk7XG4gICAgICAgIGlmIChsMSA+IGwyKSB7XG4gICAgICAgICAgICBvMSA9IG8xLmdldEFuY2VzdG9yKGwxIC0gbDIpO1xuICAgICAgICB9IGVsc2UgaWYgKGwyID4gbDEpIHtcbiAgICAgICAgICAgIG8yID0gbzIuZ2V0QW5jZXN0b3IobDIgLSBsMSk7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAobzEgPT09IG8yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvMSA9IG8xLl9fcGFyZW50O1xuICAgICAgICAgICAgbzIgPSBvMi5fX3BhcmVudDtcbiAgICAgICAgfSB3aGlsZSAobzEgJiYgbzIpO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBnZXQgYXR0YWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fYXR0YWNoZWQ7XG4gICAgfVxuXG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZW5hYmxlZDtcbiAgICB9XG5cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2FjdGl2ZTtcbiAgICB9XG5cbiAgICBfaXNBdHRhY2hlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9fcGFyZW50ID8gdGhpcy5fX3BhcmVudC5fX2F0dGFjaGVkIDogKHRoaXMuc3RhZ2Uucm9vdCA9PT0gdGhpcykpO1xuICAgIH07XG5cbiAgICBfaXNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUudmlzaWJsZSAmJiAodGhpcy5fX2NvcmUuYWxwaGEgPiAwKSAmJiAodGhpcy5fX3BhcmVudCA/IHRoaXMuX19wYXJlbnQuX19lbmFibGVkIDogKHRoaXMuc3RhZ2Uucm9vdCA9PT0gdGhpcykpO1xuICAgIH07XG5cbiAgICBfaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0VuYWJsZWQoKSAmJiB0aGlzLndpdGhpbkJvdW5kc01hcmdpbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgJ2F0dGFjaGVkJyBmbGFnIGZvciB0aGlzIGJyYW5jaC5cbiAgICAgKi9cbiAgICBfdXBkYXRlQXR0YWNoZWRGbGFnKCkge1xuICAgICAgICBsZXQgbmV3QXR0YWNoZWQgPSB0aGlzLl9pc0F0dGFjaGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9fYXR0YWNoZWQgIT09IG5ld0F0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9fYXR0YWNoZWQgPSBuZXdBdHRhY2hlZDtcblxuICAgICAgICAgICAgaWYgKG5ld0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TZXR1cCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5nZXQoKTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGxldCBtID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChtID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uX3VwZGF0ZUF0dGFjaGVkRmxhZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3QXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkF0dGFjaCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRldGFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlICdlbmFibGVkJyBmbGFnIGZvciB0aGlzIGJyYW5jaC5cbiAgICAgKi9cbiAgICBfdXBkYXRlRW5hYmxlZEZsYWcoKSB7XG4gICAgICAgIGxldCBuZXdFbmFibGVkID0gdGhpcy5faXNFbmFibGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9fZW5hYmxlZCAhPT0gbmV3RW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKG5ld0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkVuYWJsZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbmFibGVkRmxhZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5zZXRFbmFibGVkRmxhZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5nZXQoKTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGxldCBtID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChtID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uX3VwZGF0ZUVuYWJsZWRGbGFnKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX3NldEVuYWJsZWRGbGFnKCkge1xuICAgICAgICB0aGlzLl9fZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gRm9yY2UgcmUtY2hlY2sgb2YgdGV4dHVyZSBiZWNhdXNlIGRpbWVuc2lvbnMgbWlnaHQgaGF2ZSBjaGFuZ2VkIChjdXR0aW5nKS5cbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLl91cGRhdGVUZXh0dXJlQ29vcmRzKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGV4dHVyZS5hZGRFbGVtZW50KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMud2l0aGluQm91bmRzTWFyZ2luKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBY3RpdmVGbGFnKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX2NvcmUuc2hhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9fY29yZS5zaGFkZXIuYWRkRWxlbWVudCh0aGlzLl9fY29yZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIF91bnNldEVuYWJsZWRGbGFnKCkge1xuICAgICAgICBpZiAodGhpcy5fX2FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zZXRBY3RpdmVGbGFnKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX190ZXh0dXJlLnJlbW92ZUVsZW1lbnQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX2NvcmUuc2hhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9fY29yZS5zaGFkZXIucmVtb3ZlRWxlbWVudCh0aGlzLl9fY29yZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdGV4dHVyaXplcikge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJpemVyLmZpbHRlcnMuZm9yRWFjaChmaWx0ZXIgPT4gZmlsdGVyLnJlbW92ZUVsZW1lbnQodGhpcy5fX2NvcmUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3NldEFjdGl2ZUZsYWcoKSB7XG4gICAgICAgIHRoaXMuX19hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgbXVzdCBoYXBwZW4gYmVmb3JlIGVuYWJsaW5nIHRoZSB0ZXh0dXJlLCBiZWNhdXNlIGl0IG1heSBhbHJlYWR5IGJlIGxvYWRlZCBvciBsb2FkIGRpcmVjdGx5LlxuICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX190ZXh0dXJlLmluY0FjdGl2ZUNvdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZVRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbkFjdGl2ZSgpO1xuICAgIH1cblxuICAgIF91bnNldEFjdGl2ZUZsYWcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fX3RleHR1cmUuZGVjQWN0aXZlQ291bnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlVGV4dHVyZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc1RleHR1cml6ZXIoKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJpemVyLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29uSW5hY3RpdmUoKTtcbiAgICB9XG5cbiAgICBfb25TZXR1cCgpIHtcbiAgICB9XG5cbiAgICBfb25BdHRhY2goKSB7XG4gICAgfVxuXG4gICAgX29uRGV0YWNoKCkge1xuICAgIH1cblxuICAgIF9vbkVuYWJsZWQoKSB7XG4gICAgfVxuXG4gICAgX29uRGlzYWJsZWQoKSB7XG4gICAgfVxuXG4gICAgX29uQWN0aXZlKCkge1xuICAgIH1cblxuICAgIF9vbkluYWN0aXZlKCkge1xuICAgIH1cblxuICAgIF9vblJlc2l6ZSgpIHtcbiAgICB9XG5cbiAgICBfZ2V0UmVuZGVyV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLl93KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9fZGlzcGxheWVkVGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlLmdldFJlbmRlcldpZHRoKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgIC8vIFRleHR1cmUgYWxyZWFkeSBsb2FkZWQsIGJ1dCBub3QgeWV0IHVwZGF0ZWQgKHByb2JhYmx5IGJlY2F1c2UgdGhpcyBlbGVtZW50IGlzIG5vdCBhY3RpdmUpLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX190ZXh0dXJlLmdldFJlbmRlcldpZHRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfZ2V0UmVuZGVySGVpZ2h0KCkge1xuICAgICAgICBpZiAodGhpcy5faCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2g7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fX2Rpc3BsYXllZFRleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGlzcGxheWVkVGV4dHVyZS5nZXRSZW5kZXJIZWlnaHQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgLy8gVGV4dHVyZSBhbHJlYWR5IGxvYWRlZCwgYnV0IG5vdCB5ZXQgdXBkYXRlZCAocHJvYmFibHkgYmVjYXVzZSB0aGlzIGVsZW1lbnQgaXMgbm90IGFjdGl2ZSkuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX3RleHR1cmUuZ2V0UmVuZGVySGVpZ2h0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXQgcmVuZGVyV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fZW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHdpZHRoIGlzIG9ubHkgbWFpbnRhaW5lZCBpZiB0aGlzIGVsZW1lbnQgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5nZXRSZW5kZXJXaWR0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJlbmRlcldpZHRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcmVuZGVySGVpZ2h0KCkge1xuICAgICAgICBpZiAodGhpcy5fX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5nZXRSZW5kZXJIZWlnaHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRSZW5kZXJIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBmaW5hbFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS54O1xuICAgIH1cblxuICAgIGdldCBmaW5hbFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS55O1xuICAgIH1cblxuICAgIGdldCBmaW5hbFcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS53O1xuICAgIH1cblxuICAgIGdldCBmaW5hbEgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5oO1xuICAgIH1cblxuICAgIHRleHR1cmVJc0xvYWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX190ZXh0dXJlICYmIHRoaXMuX190ZXh0dXJlLmlzTG9hZGVkKCk7XG4gICAgfVxuXG4gICAgbG9hZFRleHR1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fX3RleHR1cmUubG9hZCgpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX190ZXh0dXJlLmlzVXNlZCgpIHx8ICF0aGlzLl9pc0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIExvYWRpbmcgdGhlIHRleHR1cmUgd2lsbCBoYXZlIG5vIGVmZmVjdCBvbiB0aGUgZGltZW5zaW9ucyBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgdXBkYXRlIHRoZW0sIHNvIHRoYXQgY2FsY3MgY2FuIGJlIHBlcmZvcm1lZCBpbW1lZGlhdGVseSBpbiB1c2VybGFuZC5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZW5hYmxlVGV4dHVyZUVycm9yKCkge1xuICAgICAgICAvLyB0eEVycm9yIGV2ZW50IHNob3VsZCBhdXRvbWF0aWNhbGx5IGJlIHJlLXRyaWdnZXJlZCB3aGVuIGEgZWxlbWVudCBiZWNvbWVzIGFjdGl2ZS5cbiAgICAgICAgY29uc3QgbG9hZEVycm9yID0gdGhpcy5fX3RleHR1cmUubG9hZEVycm9yO1xuICAgICAgICBpZiAobG9hZEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3R4RXJyb3InLCBsb2FkRXJyb3IsIHRoaXMuX190ZXh0dXJlLl9zb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2VuYWJsZVRleHR1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZS5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXREaXNwbGF5ZWRUZXh0dXJlKHRoaXMuX190ZXh0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmV0YWluIHRoZSBvbGQgJ2dob3N0JyBpbWFnZSBhcyBpdCB3YXNuJ3QgdmlzaWJsZSBhbnl3YXkuXG4gICAgICAgICAgICB0aGlzLl9zZXREaXNwbGF5ZWRUZXh0dXJlKG51bGwpO1xuXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVUZXh0dXJlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kaXNhYmxlVGV4dHVyZSgpIHtcbiAgICAgICAgLy8gV2UgZGlzYWJsZSB0aGUgZGlzcGxheWVkIHRleHR1cmUgYmVjYXVzZSwgd2hlbiB0aGUgdGV4dHVyZSBjaGFuZ2VzIHdoaWxlIGludmlzaWJsZSwgd2Ugc2hvdWxkIHVzZSB0aGF0IHcsIGgsXG4gICAgICAgIC8vIG13LCBtaCBmb3IgY2hlY2tpbmcgd2l0aGluIGJvdW5kcy5cbiAgICAgICAgdGhpcy5fc2V0RGlzcGxheWVkVGV4dHVyZShudWxsKTtcbiAgICB9XG5cbiAgICBnZXQgdGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX190ZXh0dXJlO1xuICAgIH1cblxuICAgIHNldCB0ZXh0dXJlKHYpIHtcbiAgICAgICAgbGV0IHRleHR1cmU7XG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodikpIHtcbiAgICAgICAgICAgIGlmICh2LnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlID0gbmV3IHYudHlwZSh0aGlzLnN0YWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRleHR1cmUsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCF2KSB7XG4gICAgICAgICAgICB0ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2LmlzVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHRleHR1cmUgPSB2O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2LmlzVGV4dHVyZVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgU291cmNlVGV4dHVyZSh0aGlzLnN0YWdlKTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnRleHR1cmVTb3VyY2UgPSB2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW0xpZ2h0bmluZ10gUGxlYXNlIHNwZWNpZnkgYSB0ZXh0dXJlIHR5cGUuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZXZUZXh0dXJlID0gdGhpcy5fX3RleHR1cmU7XG4gICAgICAgIGlmICh0ZXh0dXJlICE9PSBwcmV2VGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fX3RleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RleHR1cmUuYWRkRWxlbWVudCh0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53aXRoaW5Cb3VuZHNNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZS5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0RGlzcGxheWVkVGV4dHVyZSh0aGlzLl9fdGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZVRleHR1cmVFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBjdXJyZW50IHRleHR1cmUgaXMgY2xlYXJlZCB3aGVuIHRoZSB0ZXh0dXJlIGlzIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwuXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RGlzcGxheWVkVGV4dHVyZShudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZUZXh0dXJlICYmIHByZXZUZXh0dXJlICE9PSB0aGlzLl9fZGlzcGxheWVkVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHByZXZUZXh0dXJlLnJlbW92ZUVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBkaXNwbGF5ZWRUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2Rpc3BsYXllZFRleHR1cmU7XG4gICAgfVxuXG4gICAgX3NldERpc3BsYXllZFRleHR1cmUodikge1xuICAgICAgICBsZXQgcHJldlRleHR1cmUgPSB0aGlzLl9fZGlzcGxheWVkVGV4dHVyZTtcblxuICAgICAgICBpZiAocHJldlRleHR1cmUgJiYgKHYgIT09IHByZXZUZXh0dXJlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlICE9PSBwcmV2VGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvbGQgZGlzcGxheWVkIHRleHR1cmUgaXMgZGVwcmVjYXRlZC5cbiAgICAgICAgICAgICAgICBwcmV2VGV4dHVyZS5yZW1vdmVFbGVtZW50KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJldlNvdXJjZSA9IHRoaXMuX19jb3JlLmRpc3BsYXllZFRleHR1cmVTb3VyY2UgPyB0aGlzLl9fY29yZS5kaXNwbGF5ZWRUZXh0dXJlU291cmNlLl9zb3VyY2UgOiBudWxsO1xuICAgICAgICBjb25zdCBzb3VyY2VDaGFuZ2VkID0gKHYgPyB2Ll9zb3VyY2UgOiBudWxsKSAhPT0gcHJldlNvdXJjZTtcblxuICAgICAgICB0aGlzLl9fZGlzcGxheWVkVGV4dHVyZSA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcblxuICAgICAgICBpZiAodGhpcy5fX2Rpc3BsYXllZFRleHR1cmUpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZWZlcmVuY2UgdGhlIGRpc3BsYXllZCB0ZXh0dXJlIGJlY2F1c2UgaXQgd2FzIGFscmVhZHkgcmVmZXJlbmNlZCAodGhpcy50ZXh0dXJlID09PSB0aGlzLmRpc3BsYXllZFRleHR1cmUpLlxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRleHR1cmVDb29yZHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29yZS5zZXREaXNwbGF5ZWRUZXh0dXJlU291cmNlKHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlLl9zb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX2NvcmUuc2V0RGlzcGxheWVkVGV4dHVyZVNvdXJjZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3VyY2VDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fX2Rpc3BsYXllZFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3R4TG9hZGVkJywgdGhpcy5fX2Rpc3BsYXllZFRleHR1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3R4VW5sb2FkZWQnLCB0aGlzLl9fZGlzcGxheWVkVGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblRleHR1cmVTb3VyY2VMb2FkZWQoKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gZWxlbWVudCBpcyBlbmFibGVkLCBidXQgd2Ugb25seSB3YW50IHRvIHNldCBkaXNwbGF5ZWQgdGV4dHVyZSBmb3IgYWN0aXZlIGVsZW1lbnRzLlxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIFdlIG1heSBiZSBkZWFsaW5nIHdpdGggYSB0ZXh0dXJlIHJlbG9hZGluZywgc28gd2UgbXVzdCBmb3JjZSB1cGRhdGUuXG4gICAgICAgICAgICB0aGlzLl9zZXREaXNwbGF5ZWRUZXh0dXJlKHRoaXMuX190ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBvblRleHR1cmVTb3VyY2VMb2FkRXJyb3IoZSkge1xuICAgICAgICB0aGlzLmVtaXQoJ3R4RXJyb3InLCBlLCB0aGlzLl9fdGV4dHVyZS5fc291cmNlKTtcbiAgICB9O1xuXG4gICAgZm9yY2VSZW5kZXJVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnNldEhhc1JlbmRlclVwZGF0ZXMoMyk7XG4gICAgfVxuXG4gICAgb25EaXNwbGF5ZWRUZXh0dXJlQ2xpcHBpbmdDaGFuZ2VkKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRleHR1cmVDb29yZHMoKTtcbiAgICB9O1xuXG4gICAgb25QcmVjaXNpb25DaGFuZ2VkKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgfTtcblxuICAgIG9uRGltZW5zaW9uc0NoYW5nZWQodywgaCkge1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlIGluc3RhbmNlb2YgVGV4dFRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS53ID0gdztcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5oID0gaDtcbiAgICAgICAgICAgIHRoaXMudyA9IHc7XG4gICAgICAgICAgICB0aGlzLmggPSBoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZURpbWVuc2lvbnMoKSB7XG4gICAgICAgIGxldCB3ID0gdGhpcy5fZ2V0UmVuZGVyV2lkdGgoKTtcbiAgICAgICAgbGV0IGggPSB0aGlzLl9nZXRSZW5kZXJIZWlnaHQoKTtcblxuICAgICAgICBsZXQgdW5rbm93blNpemUgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF3IHx8ICFoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlICYmIHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgJ21heCB3aWR0aCcgcmVwbGFjZW1lbnQgaW5zdGVhZCBpbiB0aGUgRWxlbWVudENvcmUgY2FsY3MuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgaXQgaXMgYWJsZSB0byBkZXRlcm1pbmUgd2l0aGluQm91bmRzLlxuICAgICAgICAgICAgICAgIHcgPSB3IHx8IHRoaXMuX190ZXh0dXJlLm13O1xuICAgICAgICAgICAgICAgIGggPSBoIHx8IHRoaXMuX190ZXh0dXJlLm1oO1xuXG4gICAgICAgICAgICAgICAgaWYgKCghdyB8fCAhaCkgJiYgdGhpcy5fX3RleHR1cmUuaXNBdXRvc2l6ZVRleHR1cmUoKSkge1xuICAgICAgICAgICAgICAgICAgICB1bmtub3duU2l6ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX19jb3JlLnNldERpbWVuc2lvbnModywgaCwgdW5rbm93blNpemUpKSB7XG4gICAgICAgICAgICB0aGlzLl9vblJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZVRleHR1cmVDb29yZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXllZFRleHR1cmUgJiYgdGhpcy5kaXNwbGF5ZWRUZXh0dXJlLl9zb3VyY2UpIHtcbiAgICAgICAgICAgIGxldCBkaXNwbGF5ZWRUZXh0dXJlID0gdGhpcy5kaXNwbGF5ZWRUZXh0dXJlO1xuICAgICAgICAgICAgbGV0IGRpc3BsYXllZFRleHR1cmVTb3VyY2UgPSB0aGlzLmRpc3BsYXllZFRleHR1cmUuX3NvdXJjZTtcblxuICAgICAgICAgICAgbGV0IHR4MSA9IDAsIHR5MSA9IDAsIHR4MiA9IDEuMCwgdHkyID0gMS4wO1xuICAgICAgICAgICAgaWYgKGRpc3BsYXllZFRleHR1cmUuY2xpcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0ZXh0dXJlIGNsaXBwaW5nLlxuICAgICAgICAgICAgICAgIGxldCB3ID0gZGlzcGxheWVkVGV4dHVyZVNvdXJjZS5nZXRSZW5kZXJXaWR0aCgpO1xuICAgICAgICAgICAgICAgIGxldCBoID0gZGlzcGxheWVkVGV4dHVyZVNvdXJjZS5nZXRSZW5kZXJIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgaXcsIGloLCBydywgcmg7XG4gICAgICAgICAgICAgICAgaXcgPSAxIC8gdztcbiAgICAgICAgICAgICAgICBpaCA9IDEgLyBoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3BsYXllZFRleHR1cmUucHcpIHtcbiAgICAgICAgICAgICAgICAgICAgcncgPSAoZGlzcGxheWVkVGV4dHVyZS5wdykgKiBpdztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBydyA9ICh3IC0gZGlzcGxheWVkVGV4dHVyZS5weCkgKiBpdztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheWVkVGV4dHVyZS5waCkge1xuICAgICAgICAgICAgICAgICAgICByaCA9IGRpc3BsYXllZFRleHR1cmUucGggKiBpaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByaCA9IChoIC0gZGlzcGxheWVkVGV4dHVyZS5weSkgKiBpaDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdyAqPSAoZGlzcGxheWVkVGV4dHVyZS5weCk7XG4gICAgICAgICAgICAgICAgaWggKj0gKGRpc3BsYXllZFRleHR1cmUucHkpO1xuXG4gICAgICAgICAgICAgICAgdHgxID0gaXc7XG4gICAgICAgICAgICAgICAgdHkxID0gaWg7XG4gICAgICAgICAgICAgICAgdHgyID0gdHgyICogcncgKyBpdztcbiAgICAgICAgICAgICAgICB0eTIgPSB0eTIgKiByaCArIGloO1xuXG4gICAgICAgICAgICAgICAgdHgxID0gTWF0aC5tYXgoMCwgdHgxKTtcbiAgICAgICAgICAgICAgICB0eTEgPSBNYXRoLm1heCgwLCB0eTEpO1xuICAgICAgICAgICAgICAgIHR4MiA9IE1hdGgubWluKDEsIHR4Mik7XG4gICAgICAgICAgICAgICAgdHkyID0gTWF0aC5taW4oMSwgdHkyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpc3BsYXllZFRleHR1cmVTb3VyY2UuX2ZsaXBUZXh0dXJlWSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wdHkgPSB0eTI7XG4gICAgICAgICAgICAgICAgdHkyID0gdHkxO1xuICAgICAgICAgICAgICAgIHR5MSA9IHRlbXB0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX19jb3JlLnNldFRleHR1cmVDb29yZHModHgxLCB0eTEsIHR4MiwgdHkyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENvcm5lclBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmdldENvcm5lclBvaW50cygpO1xuICAgIH1cblxuICAgIF91bnNldFRhZ3NQYXJlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fdGFncykge1xuICAgICAgICAgICAgdGhpcy5fX3RhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdHJlZVRhZ3MuXG4gICAgICAgICAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwID0gcC5fX3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50VHJlZVRhZ3MgPSBwLl9fdHJlZVRhZ3MuZ2V0KHRhZyk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFRyZWVUYWdzLmRlbGV0ZSh0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocC5fX3RhZ1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGFncyA9IG51bGw7XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX190cmVlVGFncykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9fdGFnUm9vdCkge1xuICAgICAgICAgICAgICAgIHRhZ3MgPSBVdGlscy5pdGVyYXRvclRvQXJyYXkodGhpcy5fX3RyZWVUYWdzLmtleXMoKSk7XG4gICAgICAgICAgICAgICAgbiA9IHRhZ3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFnU2V0ID0gdGhpcy5fX3RyZWVUYWdzLmdldCh0YWdzW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdHJlZVRhZ3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHAgPSBwLl9fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnRUcmVlVGFncyA9IHAuX190cmVlVGFncy5nZXQodGFnc1tpXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdTZXQuZm9yRWFjaChmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmVlVGFncy5kZWxldGUoY29tcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5fX3RhZ1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIF9zZXRUYWdzUGFyZW50KCkge1xuICAgICAgICAvLyBKdXN0IGNvcHkgb3ZlciB0aGUgJ2xvY2FsJyB0YWdzLlxuICAgICAgICBpZiAodGhpcy5fX3RhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX190YWdzLmZvckVhY2goKHRhZykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgICAgICAgICB3aGlsZSAocCA9IHAuX19wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwLl9fdHJlZVRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuX190cmVlVGFncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gcC5fX3RyZWVUYWdzLmdldCh0YWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLl9fdHJlZVRhZ3Muc2V0KHRhZywgcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzLmFkZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocC5fX3RhZ1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX3RyZWVUYWdzICYmIHRoaXMuX190cmVlVGFncy5zaXplKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX190YWdSb290KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3RyZWVUYWdzLmZvckVhY2goKHRhZ1NldCwgdGFnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwLl9fdGFnUm9vdCAmJiAocCA9IHAuX19wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5fX3RhZ1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgY29weSBhbGwgc3Vicy5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcC5fX3RyZWVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5fX3RyZWVUYWdzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IHAuX190cmVlVGFncy5nZXQodGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5fX3RyZWVUYWdzLnNldCh0YWcsIHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdTZXQuZm9yRWFjaChmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuYWRkKGNvbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIF9nZXRCeVRhZyh0YWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fdHJlZVRhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdCA9IHRoaXMuX190cmVlVGFncy5nZXQodGFnKTtcbiAgICAgICAgcmV0dXJuIHQgPyBVdGlscy5zZXRUb0FycmF5KHQpIDogW107XG4gICAgfTtcblxuICAgIGdldFRhZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fdGFncyA/IHRoaXMuX190YWdzIDogW107XG4gICAgfTtcblxuICAgIHNldFRhZ3ModGFncykge1xuICAgICAgICB0YWdzID0gdGFncy5yZWR1Y2UoKGFjYywgdGFnKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjLmNvbmNhdCh0YWcuc3BsaXQoJyAnKSk7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBpZiAodGhpcy5fX3JlZikge1xuICAgICAgICAgICAgdGFncy5wdXNoKHRoaXMuX19yZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGksIG4gPSB0YWdzLmxlbmd0aDtcbiAgICAgICAgbGV0IHJlbW92ZXMgPSBbXTtcbiAgICAgICAgbGV0IGFkZHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1RhZyh0YWdzW2ldKSkge1xuICAgICAgICAgICAgICAgIGFkZHMucHVzaCh0YWdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXJyZW50VGFncyA9IHRoaXMudGFncyB8fCBbXTtcbiAgICAgICAgbiA9IGN1cnJlbnRUYWdzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRhZ3MuaW5kZXhPZihjdXJyZW50VGFnc1tpXSkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVzLnB1c2goY3VycmVudFRhZ3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGFnKHJlbW92ZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFkZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVGFnKGFkZHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkVGFnKHRhZykge1xuICAgICAgICBpZiAodGFnLmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc1VjQ2hhcih0YWcuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiVGFnIG1heSBub3Qgc3RhcnQgd2l0aCBhbiB1cHBlciBjYXNlIGNoYXJhY3Rlci5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2FkZFRhZyh0YWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGFncyA9IHRhZy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG0gPSB0YWdzLmxlbmd0aDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRhZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNVY0NoYXIodGFnLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJUYWcgbWF5IG5vdCBzdGFydCB3aXRoIGFuIHVwcGVyIGNhc2UgY2hhcmFjdGVyLlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUYWcodGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hZGRUYWcodGFnKSB7XG4gICAgICAgIGlmICghdGhpcy5fX3RhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX190YWdzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX190YWdzLmluZGV4T2YodGFnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX190YWdzLnB1c2godGFnKTtcblxuICAgICAgICAgICAgLy8gQWRkIHRvIHRyZWVUYWdzIGhpZXJhcmNoeS5cbiAgICAgICAgICAgIGxldCBwID0gdGhpcy5fX3BhcmVudDtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXAuX190cmVlVGFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5fX3RyZWVUYWdzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBwLl9fdHJlZVRhZ3MuZ2V0KHRhZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuX190cmVlVGFncy5zZXQodGFnLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHMuYWRkKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoIXAuX190YWdSb290ICYmIChwID0gcC5fX3BhcmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlVGFnKHRhZykge1xuICAgICAgICBsZXQgaSA9IHRoaXMuX190YWdzLmluZGV4T2YodGFnKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGFncy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRyZWVUYWdzIGhpZXJhcmNoeS5cbiAgICAgICAgICAgIGxldCBwID0gdGhpcy5fX3BhcmVudDtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IHAuX190cmVlVGFncy5nZXQodGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoIXAuX190YWdSb290ICYmIChwID0gcC5fX3BhcmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzVGFnKHRhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX190YWdzICYmICh0aGlzLl9fdGFncy5pbmRleE9mKHRhZykgIT09IC0xKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvbmUgb2YgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHN1YnRyZWUgdGhhdCBoYXZlIHRoaXMgdGFnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBfdGFnKHRhZykge1xuICAgICAgICBpZiAodGFnLmluZGV4T2YoXCIuXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXRhZyh0YWcpWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX190cmVlVGFncykge1xuICAgICAgICAgICAgICAgIGxldCB0ID0gdGhpcy5fX3RyZWVUYWdzLmdldCh0YWcpO1xuICAgICAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0LnZhbHVlcygpLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXQgdGFnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFnO1xuICAgIH1cblxuICAgIHNldCB0YWcodCkge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHN1YnRyZWUgdGhhdCBoYXZlIHRoaXMgdGFnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudFtdfVxuICAgICAqL1xuICAgIG10YWcodGFnKSB7XG4gICAgICAgIGxldCBpZHggPSB0YWcuaW5kZXhPZihcIi5cIik7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgbGV0IHBhcnRzID0gdGFnLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBsZXQgcmVzID0gdGhpcy5fZ2V0QnlUYWcocGFydHNbMF0pO1xuICAgICAgICAgICAgbGV0IGxldmVsID0gMTtcbiAgICAgICAgICAgIGxldCBjID0gcGFydHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHJlcy5sZW5ndGggJiYgbGV2ZWwgPCBjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc24gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbiA9IHJlcy5sZW5ndGg7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzbiA9IHJlc24uY29uY2F0KHJlc1tqXS5fZ2V0QnlUYWcocGFydHNbbGV2ZWxdKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzID0gcmVzbjtcbiAgICAgICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeVRhZyh0YWcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN0YWcodGFnLCBzZXR0aW5ncykge1xuICAgICAgICBsZXQgdCA9IHRoaXMubXRhZyh0YWcpO1xuICAgICAgICBsZXQgbiA9IHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0W2ldLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdGFnUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX190YWdSb290O1xuICAgIH1cblxuICAgIHNldCB0YWdSb290KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX190YWdSb290ICE9PSB2KSB7XG4gICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRUYWdzUGFyZW50KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vuc2V0VGFnc1BhcmVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9fdGFnUm9vdCA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWwocGF0aCkge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5zZWxlY3QocGF0aCk7XG4gICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0KHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguaW5kZXhPZihcIixcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0b3JzID0gcGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KHRoaXMuX3NlbGVjdChzZWxlY3RvcnNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0KHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NlbGVjdChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoID09PSBcIlwiKSByZXR1cm4gW3RoaXNdO1xuXG5cbiAgICAgICAgbGV0IHBvaW50SWR4ID0gcGF0aC5pbmRleE9mKFwiLlwiKTtcbiAgICAgICAgbGV0IGFycm93SWR4ID0gcGF0aC5pbmRleE9mKFwiPlwiKTtcbiAgICAgICAgaWYgKHBvaW50SWR4ID09PSAtMSAmJiBhcnJvd0lkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFF1aWNrIGNhc2UuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdGFnKHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZWN0IGJ5IGZpcnN0IGNoYXIuXG4gICAgICAgIGxldCBpc1JlZjtcbiAgICAgICAgaWYgKGFycm93SWR4ID09PSAwKSB7XG4gICAgICAgICAgICBpc1JlZiA9IHRydWU7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMSk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRJZHggPT09IDApIHtcbiAgICAgICAgICAgIGlzUmVmID0gZmFsc2U7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc1JlZiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdENoaWxkcyhwYXRoLCBpc1JlZik7XG4gICAgfVxuXG4gICAgX3NlbGVjdENoaWxkcyhwYXRoLCBpc1JlZikge1xuICAgICAgICBjb25zdCBwb2ludElkeCA9IHBhdGguaW5kZXhPZihcIi5cIik7XG4gICAgICAgIGNvbnN0IGFycm93SWR4ID0gcGF0aC5pbmRleE9mKFwiPlwiKTtcblxuICAgICAgICBpZiAocG9pbnRJZHggPT09IC0xICYmIGFycm93SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5nZXRCeVJlZihwYXRoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmID8gW3JlZl0gOiBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXRhZyhwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoYXJyb3dJZHggPT09IC0xKSB8fCAocG9pbnRJZHggIT09IC0xICYmIHBvaW50SWR4IDwgYXJyb3dJZHgpKSB7XG4gICAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IHBhdGguc3Vic3RyKDAsIHBvaW50SWR4KTtcbiAgICAgICAgICAgIGlmIChpc1JlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuZ2V0QnlSZWYoc3RyKTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gcmVmID8gW3JlZl0gOiBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMubXRhZyhzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvdGFsID0gW107XG4gICAgICAgICAgICBjb25zdCBzdWJQYXRoID0gcGF0aC5zdWJzdHIocG9pbnRJZHggKyAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmV4dC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHRvdGFsLmNvbmNhdChuZXh0W2ldLl9zZWxlY3RDaGlsZHMoc3ViUGF0aCwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgY29uc3Qgc3RyID0gcGF0aC5zdWJzdHIoMCwgYXJyb3dJZHgpO1xuICAgICAgICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5nZXRCeVJlZihzdHIpO1xuICAgICAgICAgICAgICAgIG5leHQgPSByZWYgPyBbcmVmXSA6IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5tdGFnKHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHN1YlBhdGggPSBwYXRoLnN1YnN0cihhcnJvd0lkeCArIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBuZXh0Lmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWwuY29uY2F0KG5leHRbaV0uX3NlbGVjdENoaWxkcyhzdWJQYXRoLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRCeVJlZihyZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRMaXN0LmdldEJ5UmVmKHJlZik7XG4gICAgfVxuXG4gICAgZ2V0TG9jYXRpb25TdHJpbmcoKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpID0gdGhpcy5fX3BhcmVudCA/IHRoaXMuX19wYXJlbnQuX2NoaWxkcmVuLmdldEluZGV4KHRoaXMpIDogXCJSXCI7XG4gICAgICAgIGxldCBsb2NhbFRhZ3MgPSB0aGlzLmdldFRhZ3MoKTtcbiAgICAgICAgbGV0IHN0ciA9IHRoaXMuX19wYXJlbnQgPyB0aGlzLl9fcGFyZW50LmdldExvY2F0aW9uU3RyaW5nKCk6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgc3RyICs9IFwiOltcIiArIGkgKyBcIl1cIiArIHRoaXMucmVmO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsVGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0ciArPSBcIjpbXCIgKyBpICsgXCJdXCIgKyBsb2NhbFRhZ3Muam9pbihcIixcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgKz0gXCI6W1wiICsgaSArIFwiXSNcIiArIHRoaXMuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuZ2V0UHJldHR5U3RyaW5nKG9iaiwgXCJcIik7XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRQcmV0dHlTdHJpbmcob2JqLCBpbmRlbnQpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gb2JqLmNoaWxkcmVuO1xuICAgICAgICBkZWxldGUgb2JqLmNoaWxkcmVuO1xuXG5cbiAgICAgICAgLy8gQ29udmVydCBzaW5ndWxhciBqc29uIHNldHRpbmdzIG9iamVjdC5cbiAgICAgICAgbGV0IGNvbG9yS2V5cyA9IFtcImNvbG9yXCIsIFwiY29sb3JVbFwiLCBcImNvbG9yVXJcIiwgXCJjb2xvckJsXCIsIFwiY29sb3JCclwiXTtcbiAgICAgICAgbGV0IHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaiwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgIGlmIChjb2xvcktleXMuaW5kZXhPZihrKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJDT0xPUltcIiArIHYudG9TdHJpbmcoMTYpICsgXCJdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cIkNPTE9SXFxbKFthLWYwLTldezEsOH0pXFxdXCIvZywgXCIweCQxXCIpO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGNoaWxkU3RyID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlZnMgPSBPYmplY3Qua2V5cyhjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgY2hpbGRTdHIgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gcmVmcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRTdHIgKz0gYFxcbiR7aW5kZW50fSAgXCIke3JlZnNbaV19XCI6YFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2hpbGRyZW5bcmVmc1tpXV0ucmVmO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFN0ciArPSBFbGVtZW50LmdldFByZXR0eVN0cmluZyhjaGlsZHJlbltyZWZzW2ldXSwgaW5kZW50ICsgXCIgIFwiKSArIChpIDwgbiAtIDEgPyBcIixcIiA6IFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaXNFbXB0eSA9IChzdHIgPT09IFwie31cIik7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCBzdHIubGVuZ3RoIC0gMSkgKyAoaXNFbXB0eSA/IFwiXCIgOiBcIixcIikgKyBjaGlsZFN0ciArIFwiXFxuXCIgKyBpbmRlbnQgKyBcIn1cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY2hpbGRTdHIgPSBcIltcIjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFN0ciArPSBFbGVtZW50LmdldFByZXR0eVN0cmluZyhjaGlsZHJlbltpXSwgaW5kZW50ICsgXCIgIFwiKSArIChpIDwgbiAtIDEgPyBcIixcIiA6IFwiXCIpICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGRTdHIgKz0gaW5kZW50ICsgXCJdfVwiO1xuICAgICAgICAgICAgICAgIGxldCBpc0VtcHR5ID0gKHN0ciA9PT0gXCJ7fVwiKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIHN0ci5sZW5ndGggLSAxKSArIChpc0VtcHR5ID8gXCJcIiA6IFwiLFwiKSArIFwiXFxcImNoaWxkcmVuXFxcIjpcXG5cIiArIGluZGVudCArIGNoaWxkU3RyICsgXCJ9XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIGxldCBzZXR0aW5ncyA9IHRoaXMuZ2V0Tm9uRGVmYXVsdHMoKTtcblxuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5nZXQoKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBtaXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRBcnJheS5wdXNoKGNoaWxkcmVuW2ldLmdldFNldHRpbmdzKCkpO1xuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nID0gbWlzc2luZyB8fCAhY2hpbGRyZW5baV0ucmVmO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5jaGlsZHJlbiA9IHt9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQXJyYXkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5jaGlsZHJlbltjaGlsZC5yZWZdID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5pZCA9IHRoaXMuaWQ7XG5cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH1cblxuICAgIGdldE5vbkRlZmF1bHRzKCkge1xuICAgICAgICBsZXQgc2V0dGluZ3MgPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gRWxlbWVudCkge1xuICAgICAgICAgICAgc2V0dGluZ3MudHlwZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9fcmVmKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5yZWYgPSB0aGlzLl9fcmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX190YWdzICYmIHRoaXMuX190YWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2V0dGluZ3MudGFncyA9IHRoaXMuX190YWdzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMueCAhPT0gMCkgc2V0dGluZ3MueCA9IHRoaXMueDtcbiAgICAgICAgaWYgKHRoaXMueSAhPT0gMCkgc2V0dGluZ3MueSA9IHRoaXMueTtcbiAgICAgICAgaWYgKHRoaXMudyAhPT0gMCkgc2V0dGluZ3MudyA9IHRoaXMudztcbiAgICAgICAgaWYgKHRoaXMuaCAhPT0gMCkgc2V0dGluZ3MuaCA9IHRoaXMuaDtcblxuICAgICAgICBpZiAodGhpcy5zY2FsZVggPT09IHRoaXMuc2NhbGVZKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2FsZVggIT09IDEpIHNldHRpbmdzLnNjYWxlID0gdGhpcy5zY2FsZVg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2FsZVggIT09IDEpIHNldHRpbmdzLnNjYWxlWCA9IHRoaXMuc2NhbGVYO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NhbGVZICE9PSAxKSBzZXR0aW5ncy5zY2FsZVkgPSB0aGlzLnNjYWxlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBpdm90WCA9PT0gdGhpcy5waXZvdFkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpdm90WCAhPT0gMC41KSBzZXR0aW5ncy5waXZvdCA9IHRoaXMucGl2b3RYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucGl2b3RYICE9PSAwLjUpIHNldHRpbmdzLnBpdm90WCA9IHRoaXMucGl2b3RYO1xuICAgICAgICAgICAgaWYgKHRoaXMucGl2b3RZICE9PSAwLjUpIHNldHRpbmdzLnBpdm90WSA9IHRoaXMucGl2b3RZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubW91bnRYID09PSB0aGlzLm1vdW50WSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubW91bnRYICE9PSAwKSBzZXR0aW5ncy5tb3VudCA9IHRoaXMubW91bnRYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubW91bnRYICE9PSAwKSBzZXR0aW5ncy5tb3VudFggPSB0aGlzLm1vdW50WDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vdW50WSAhPT0gMCkgc2V0dGluZ3MubW91bnRZID0gdGhpcy5tb3VudFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbHBoYSAhPT0gMSkgc2V0dGluZ3MuYWxwaGEgPSB0aGlzLmFscGhhO1xuXG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlKSBzZXR0aW5ncy52aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMucm90YXRpb24gIT09IDApIHNldHRpbmdzLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5jb2xvclVsID09PSB0aGlzLmNvbG9yVXIgJiYgdGhpcy5jb2xvckJsID09PSB0aGlzLmNvbG9yQnIgJiYgdGhpcy5jb2xvclVsID09PSB0aGlzLmNvbG9yQmwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yVWwgIT09IDB4RkZGRkZGRkYpIHNldHRpbmdzLmNvbG9yID0gdGhpcy5jb2xvclVsLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yVWwgIT09IDB4RkZGRkZGRkYpIHNldHRpbmdzLmNvbG9yVWwgPSB0aGlzLmNvbG9yVWwudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JVciAhPT0gMHhGRkZGRkZGRikgc2V0dGluZ3MuY29sb3JVciA9IHRoaXMuY29sb3JVci50b1N0cmluZygxNik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvckJsICE9PSAweEZGRkZGRkZGKSBzZXR0aW5ncy5jb2xvckJsID0gdGhpcy5jb2xvckJsLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yQnIgIT09IDB4RkZGRkZGRkYpIHNldHRpbmdzLmNvbG9yQnIgPSB0aGlzLmNvbG9yQnIudG9TdHJpbmcoMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuekluZGV4KSBzZXR0aW5ncy56SW5kZXggPSB0aGlzLnpJbmRleDtcblxuICAgICAgICBpZiAodGhpcy5mb3JjZVpJbmRleENvbnRleHQpIHNldHRpbmdzLmZvcmNlWkluZGV4Q29udGV4dCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuY2xpcHBpbmcpIHNldHRpbmdzLmNsaXBwaW5nID0gdGhpcy5jbGlwcGluZztcblxuICAgICAgICBpZiAoIXRoaXMuY2xpcGJveCkgc2V0dGluZ3MuY2xpcGJveCA9IHRoaXMuY2xpcGJveDtcblxuICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgIGxldCB0bmQgPSB0aGlzLl9fdGV4dHVyZS5nZXROb25EZWZhdWx0cygpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRuZCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MudGV4dHVyZSA9IHRuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNoYWRlciAmJiBVdGlscy5pc0Z1bmN0aW9uKHRoaXMuc2hhZGVyLmdldE5vbkRlZmF1bHRzKSkge1xuICAgICAgICAgICAgbGV0IHRuZCA9IHRoaXMuc2hhZGVyLmdldE5vbkRlZmF1bHRzKCk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModG5kKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zaGFkZXIgPSB0bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGFzVGV4dHVyaXplcigpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0dXJpemVyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5yZW5kZXJUb1RleHR1cmUgPSB0aGlzLnRleHR1cml6ZXIuZW5hYmxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRleHR1cml6ZXIubGF6eSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnJlbmRlclRvVGV4dHVyZUxhenkgPSB0aGlzLnRleHR1cml6ZXIubGF6eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRleHR1cml6ZXIuY29sb3JpemUpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5jb2xvcml6ZVJlc3VsdFRleHR1cmUgPSB0aGlzLnRleHR1cml6ZXIuY29sb3JpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0dXJpemVyLnJlbmRlck9mZnNjcmVlbikge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnJlbmRlck9mZnNjcmVlbiA9IHRoaXMudGV4dHVyaXplci5yZW5kZXJPZmZzY3JlZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRHZXR0ZXIocHJvcGVydHlQYXRoKSB7XG4gICAgICAgIGxldCBnZXR0ZXIgPSBFbGVtZW50LlBST1BfR0VUVEVSUy5nZXQocHJvcGVydHlQYXRoKTtcbiAgICAgICAgaWYgKCFnZXR0ZXIpIHtcbiAgICAgICAgICAgIGdldHRlciA9IG5ldyBGdW5jdGlvbignb2JqJywgJ3JldHVybiBvYmouJyArIHByb3BlcnR5UGF0aCk7XG4gICAgICAgICAgICBFbGVtZW50LlBST1BfR0VUVEVSUy5zZXQocHJvcGVydHlQYXRoLCBnZXR0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXR0ZXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFNldHRlcihwcm9wZXJ0eVBhdGgpIHtcbiAgICAgICAgbGV0IHNldHRlciA9IEVsZW1lbnQuUFJPUF9TRVRURVJTLmdldChwcm9wZXJ0eVBhdGgpO1xuICAgICAgICBpZiAoIXNldHRlcikge1xuICAgICAgICAgICAgc2V0dGVyID0gbmV3IEZ1bmN0aW9uKCdvYmonLCAndicsICdvYmouJyArIHByb3BlcnR5UGF0aCArICcgPSB2Jyk7XG4gICAgICAgICAgICBFbGVtZW50LlBST1BfU0VUVEVSUy5zZXQocHJvcGVydHlQYXRoLCBzZXR0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXR0ZXI7XG4gICAgfVxuXG4gICAgZ2V0IHdpdGhpbkJvdW5kc01hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLl93aXRoaW5Cb3VuZHNNYXJnaW47XG4gICAgfVxuXG4gICAgX2VuYWJsZVdpdGhpbkJvdW5kc01hcmdpbigpIHtcbiAgICAgICAgLy8gSWZmIGVuYWJsZWQsIHRoaXMgdG9nZ2xlcyB0aGUgYWN0aXZlIGZsYWcuXG4gICAgICAgIGlmICh0aGlzLl9fZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0QWN0aXZlRmxhZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Rpc2FibGVXaXRoaW5Cb3VuZHNNYXJnaW4oKSB7XG4gICAgICAgIC8vIElmZiBhY3RpdmUsIHRoaXMgdG9nZ2xlcyB0aGUgYWN0aXZlIGZsYWcuXG4gICAgICAgIGlmICh0aGlzLl9fYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl91bnNldEFjdGl2ZUZsYWcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBib3VuZHNNYXJnaW4odikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodikgJiYgdiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm91bmRzTWFyZ2luIHNob3VsZCBiZSBhbiBhcnJheSBvZiBsZWZ0LXRvcC1yaWdodC1ib3R0b20gdmFsdWVzIG9yIG51bGwgKGluaGVyaXQgbWFyZ2luKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fY29yZS5ib3VuZHNNYXJnaW4gPSB2O1xuICAgIH1cblxuICAgIGdldCBib3VuZHNNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5ib3VuZHNNYXJnaW47XG4gICAgfVxuXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5vZmZzZXRYO1xuICAgIH1cblxuICAgIHNldCB4KHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUub2Zmc2V0WCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5vZmZzZXRZO1xuICAgIH1cblxuICAgIHNldCB5KHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUub2Zmc2V0WSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93O1xuICAgIH1cblxuICAgIHNldCB3KHYpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzRnVuY3Rpb24odikpIHtcbiAgICAgICAgICAgIHRoaXMuX3cgPSAwO1xuICAgICAgICAgICAgdGhpcy5fX2NvcmUuZnVuY1cgPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IE1hdGgubWF4KHYsIDApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3cgIT09IHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29yZS5kaXNhYmxlRnVuY1coKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ID0gdjtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2g7XG4gICAgfVxuXG4gICAgc2V0IGgodikge1xuICAgICAgICBpZiAoVXRpbHMuaXNGdW5jdGlvbih2KSkge1xuICAgICAgICAgICAgdGhpcy5faCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9fY29yZS5mdW5jSCA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gTWF0aC5tYXgodiwgMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faCAhPT0gdikge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jb3JlLmRpc2FibGVGdW5jSCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ggPSB2O1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjb2xsaXNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsaXNpb247XG4gICAgfVxuXG4gICAgc2V0IGNvbGxpc2lvbih2KSB7XG4gICAgICAgIHRoaXMuX2NvbGxpc2lvbiA9IHY7XG4gICAgfVxuXG4gICAgX3VwZGF0ZUNvbGxpc2lvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uICYmIHRoaXMuX19wYXJlbnQgJiYgdGhpcy5fX3BhcmVudC5jb2xsaXNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXJrIGNvbGxpc2lvbiBhcyAyIHRvIGluZGljYXRlIGF0bGVhc3Qgb25lIGRlc2NlbmRhbnQgaGFzIGNvbGxpc2lvbiBlbmFibGVkLlxuICAgICAgICAgICAgICogVGhpcyBuYXJyb3dzIGRvd24gdGhlIHNlYXJjaCBmb3IgZWxlbWVudHMgd2l0aCBhY3RpdmUgY29sbGlzaW9uLlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX19wYXJlbnQuY29sbGlzaW9uID0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzY2FsZVgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5zY2FsZVg7XG4gICAgfVxuXG4gICAgc2V0IHNjYWxlWCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnNjYWxlWCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHNjYWxlWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnNjYWxlWTtcbiAgICB9XG5cbiAgICBzZXQgc2NhbGVZKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuc2NhbGVZID0gdjtcbiAgICB9XG5cbiAgICBnZXQgc2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5zY2FsZTtcbiAgICB9XG5cbiAgICBzZXQgc2NhbGUodikge1xuICAgICAgICB0aGlzLl9fY29yZS5zY2FsZSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnBpdm90WDtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RYKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUucGl2b3RYID0gdjtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3RZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUucGl2b3RZO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFkodikge1xuICAgICAgICB0aGlzLl9fY29yZS5waXZvdFkgPSB2O1xuICAgIH1cblxuICAgIGdldCBwaXZvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnBpdm90O1xuICAgIH1cblxuICAgIHNldCBwaXZvdCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnBpdm90ID0gdjtcbiAgICB9XG5cbiAgICBnZXQgbW91bnRYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUubW91bnRYO1xuICAgIH1cblxuICAgIHNldCBtb3VudFgodikge1xuICAgICAgICB0aGlzLl9fY29yZS5tb3VudFggPSB2O1xuICAgIH1cblxuICAgIGdldCBtb3VudFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5tb3VudFk7XG4gICAgfVxuXG4gICAgc2V0IG1vdW50WSh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLm1vdW50WSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IG1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUubW91bnQ7XG4gICAgfVxuXG4gICAgc2V0IG1vdW50KHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUubW91bnQgPSB2O1xuICAgIH1cblxuICAgIGdldCByb3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnJvdGF0aW9uO1xuICAgIH1cblxuICAgIHNldCByb3RhdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnJvdGF0aW9uID0gdjtcbiAgICB9XG5cbiAgICBnZXQgYWxwaGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5hbHBoYTtcbiAgICB9XG5cbiAgICBzZXQgYWxwaGEodikge1xuICAgICAgICB0aGlzLl9fY29yZS5hbHBoYSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS52aXNpYmxlO1xuICAgIH1cblxuICAgIHNldCB2aXNpYmxlKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUudmlzaWJsZSA9IHY7XG4gICAgfVxuICAgIFxuICAgIGdldCBjb2xvclVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuY29sb3JVbDtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JVbCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLmNvbG9yVWwgPSB2O1xuICAgIH1cblxuICAgIGdldCBjb2xvclVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuY29sb3JVcjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JVcih2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLmNvbG9yVXIgPSB2O1xuICAgIH1cblxuICAgIGdldCBjb2xvckJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuY29sb3JCbDtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCbCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLmNvbG9yQmwgPSB2O1xuICAgIH1cblxuICAgIGdldCBjb2xvckJyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuY29sb3JCcjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCcih2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLmNvbG9yQnIgPSB2O1xuICAgIH1cblxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmNvbG9yVWw7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JVbCAhPT0gdiB8fCB0aGlzLmNvbG9yVXIgIT09IHYgfHwgdGhpcy5jb2xvckJsICE9PSB2IHx8IHRoaXMuY29sb3JCciAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5jb2xvclVsID0gdjtcbiAgICAgICAgICAgIHRoaXMuY29sb3JVciA9IHY7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQmwgPSB2O1xuICAgICAgICAgICAgdGhpcy5jb2xvckJyID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjb2xvclRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JVbDtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JUb3Aodikge1xuICAgICAgICBpZiAodGhpcy5jb2xvclVsICE9PSB2IHx8IHRoaXMuY29sb3JVciAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5jb2xvclVsID0gdjtcbiAgICAgICAgICAgIHRoaXMuY29sb3JVciA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY29sb3JCb3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yQmw7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQm90dG9tKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JCbCAhPT0gdiB8fCB0aGlzLmNvbG9yQnIgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCbCA9IHY7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQnIgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JVbDtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JMZWZ0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JVbCAhPT0gdiB8fCB0aGlzLmNvbG9yQmwgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JVbCA9IHY7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQmwgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yVXI7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yUmlnaHQodikge1xuICAgICAgICBpZiAodGhpcy5jb2xvclVyICE9PSB2IHx8IHRoaXMuY29sb3JCciAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5jb2xvclVyID0gdjtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCciA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgekluZGV4KCkge3JldHVybiB0aGlzLl9fY29yZS56SW5kZXh9XG4gICAgc2V0IHpJbmRleCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnpJbmRleCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGZvcmNlWkluZGV4Q29udGV4dCgpIHtyZXR1cm4gdGhpcy5fX2NvcmUuZm9yY2VaSW5kZXhDb250ZXh0fVxuICAgIHNldCBmb3JjZVpJbmRleENvbnRleHQodikge1xuICAgICAgICB0aGlzLl9fY29yZS5mb3JjZVpJbmRleENvbnRleHQgPSB2O1xuICAgIH1cblxuICAgIGdldCBjbGlwcGluZygpIHtyZXR1cm4gdGhpcy5fX2NvcmUuY2xpcHBpbmd9XG4gICAgc2V0IGNsaXBwaW5nKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuY2xpcHBpbmcgPSB2O1xuICAgIH1cblxuICAgIGdldCBjbGlwYm94KCkge3JldHVybiB0aGlzLl9fY29yZS5jbGlwYm94fVxuICAgIHNldCBjbGlwYm94KHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuY2xpcGJveCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHRhZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRhZ3MoKTtcbiAgICB9XG5cbiAgICBzZXQgdGFncyh2KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2KSkgdiA9IFt2XTtcbiAgICAgICAgdGhpcy5zZXRUYWdzKHYpO1xuICAgIH1cblxuICAgIHNldCB0KHYpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdjtcbiAgICB9XG5cbiAgICBnZXQgX2NoaWxkcmVuKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19jaGlsZExpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuX19jaGlsZExpc3QgPSBuZXcgRWxlbWVudENoaWxkTGlzdCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX19jaGlsZExpc3Q7XG4gICAgfVxuXG4gICAgZ2V0IGNoaWxkTGlzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hbGxvd0NoaWxkcmVuQWNjZXNzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJEaXJlY3QgYWNjZXNzIHRvIGNoaWxkcmVuIGlzIG5vdCBhbGxvd2VkIGluIFwiICsgdGhpcy5nZXRMb2NhdGlvblN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgfVxuXG4gICAgaGFzQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxvd0NoaWxkcmVuQWNjZXNzKCkgJiYgdGhpcy5fX2NoaWxkTGlzdCAmJiAodGhpcy5fX2NoaWxkTGlzdC5sZW5ndGggPiAwKTtcbiAgICB9XG5cbiAgICBfYWxsb3dDaGlsZHJlbkFjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZExpc3QuZ2V0KCk7XG4gICAgfVxuXG4gICAgc2V0IGNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMaXN0LnBhdGNoKGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBhZGQobykge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZExpc3QuYShvKTtcbiAgICB9XG5cbiAgICBnZXQgcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19wYXJlbnQ7XG4gICAgfVxuXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19wYXJlbnQ7XG4gICAgfVxuXG4gICAgZ2V0IHNyYygpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSAmJiB0aGlzLnRleHR1cmUgaW5zdGFuY2VvZiBJbWFnZVRleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUuX3NyYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc3JjKHYpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBJbWFnZVRleHR1cmUodGhpcy5zdGFnZSk7XG4gICAgICAgIHRleHR1cmUuc3JjID0gdjtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB9XG5cbiAgICBzZXQgbXcodikge1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUubXcgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcignUGxlYXNlIHNldCBtdyBhZnRlciBzZXR0aW5nIGEgdGV4dHVyZS4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBtaCh2KSB7XG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5taCA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKCdQbGVhc2Ugc2V0IG1oIGFmdGVyIHNldHRpbmcgYSB0ZXh0dXJlLicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHJlY3QoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50ZXh0dXJlID09PSB0aGlzLnN0YWdlLnJlY3RhbmdsZVRleHR1cmUpO1xuICAgIH1cblxuICAgIHNldCByZWN0KHYpIHtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IHRoaXMuc3RhZ2UucmVjdGFuZ2xlVGV4dHVyZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbmFibGVUZXh0VGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUgfHwgISh0aGlzLnRleHR1cmUgaW5zdGFuY2VvZiBUZXh0VGV4dHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0VGV4dHVyZSh0aGlzLnN0YWdlKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUudyAmJiAhdGhpcy50ZXh0dXJlLmgpIHtcbiAgICAgICAgICAgICAgICAvLyBJbmhlcml0IGRpbWVuc2lvbnMgZnJvbSBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHVzZXJsYW5kIHRvIHNldCBkaW1lbnNpb25zIG9mIHRoZSBFbGVtZW50IGFuZCB0aGVuIGxhdGVyIHNwZWNpZnkgdGhlIHRleHQuXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLncgPSB0aGlzLnc7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmggPSB0aGlzLmg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgICB9XG5cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSAmJiAodGhpcy50ZXh0dXJlIGluc3RhbmNlb2YgVGV4dFRleHR1cmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgdGV4dCh2KSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0dXJlIHx8ICEodGhpcy50ZXh0dXJlIGluc3RhbmNlb2YgVGV4dFRleHR1cmUpKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVRleHRUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLmlzU3RyaW5nKHYpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUudGV4dCA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUucGF0Y2godik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgb25VcGRhdGUoZikge1xuICAgICAgICB0aGlzLl9fY29yZS5vblVwZGF0ZSA9IGY7XG4gICAgfVxuXG4gICAgc2V0IG9uQWZ0ZXJDYWxjcyhmKSB7XG4gICAgICAgIHRoaXMuX19jb3JlLm9uQWZ0ZXJDYWxjcyA9IGY7XG4gICAgfVxuXG4gICAgc2V0IG9uQWZ0ZXJVcGRhdGUoZikge1xuICAgICAgICB0aGlzLl9fY29yZS5vbkFmdGVyVXBkYXRlID0gZjtcbiAgICB9XG5cbiAgICBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHVwZGF0ZSBsb29wIGlzIHJ1bi5cbiAgICAgICAgdGhpcy5fX2NvcmUuX3NldEhhc1VwZGF0ZXMoKTtcbiAgICB9XG5cbiAgICBnZXQgc2hhZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuc2hhZGVyO1xuICAgIH1cblxuICAgIHNldCBzaGFkZXIodikge1xuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYpICYmICF2LnR5cGUpIHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgcHJvcGVydGllcyBvbiBhbiBleGlzdGluZyBzaGFkZXIuXG4gICAgICAgICAgICBpZiAodGhpcy5zaGFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlci5wYXRjaCh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IFNoYWRlci5jcmVhdGUodGhpcy5zdGFnZSwgdik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fZW5hYmxlZCAmJiB0aGlzLl9fY29yZS5zaGFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29yZS5zaGFkZXIucmVtb3ZlRWxlbWVudCh0aGlzLl9fY29yZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX19jb3JlLnNoYWRlciA9IHNoYWRlcjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX19lbmFibGVkICYmIHRoaXMuX19jb3JlLnNoYWRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jb3JlLnNoYWRlci5hZGRFbGVtZW50KHRoaXMuX19jb3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9oYXNUZXh0dXJpemVyKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9fY29yZS5fdGV4dHVyaXplcjtcbiAgICB9XG5cbiAgICBnZXQgcmVuZGVyVG9UZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydHRcbiAgICB9XG5cbiAgICBzZXQgcmVuZGVyVG9UZXh0dXJlKHYpIHtcbiAgICAgICAgdGhpcy5ydHQgPSB2XG4gICAgfVxuXG4gICAgZ2V0IHJ0dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1RleHR1cml6ZXIoKSAmJiB0aGlzLnRleHR1cml6ZXIuZW5hYmxlZDtcbiAgICB9XG5cbiAgICBzZXQgcnR0KHYpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJpemVyLmVuYWJsZWQgPSB2O1xuICAgIH1cblxuICAgIGdldCBydHRMYXp5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzVGV4dHVyaXplcigpICYmIHRoaXMudGV4dHVyaXplci5sYXp5O1xuICAgIH1cblxuICAgIHNldCBydHRMYXp5KHYpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJpemVyLmxhenkgPSB2O1xuICAgIH1cblxuICAgIGdldCByZW5kZXJPZmZzY3JlZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNUZXh0dXJpemVyKCkgJiYgdGhpcy50ZXh0dXJpemVyLnJlbmRlck9mZnNjcmVlbjtcbiAgICB9XG5cbiAgICBzZXQgcmVuZGVyT2Zmc2NyZWVuKHYpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJpemVyLnJlbmRlck9mZnNjcmVlbiA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yaXplUmVzdWx0VGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1RleHR1cml6ZXIoKSAmJiB0aGlzLnRleHR1cml6ZXIuY29sb3JpemU7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yaXplUmVzdWx0VGV4dHVyZSh2KSB7XG4gICAgICAgIHRoaXMudGV4dHVyaXplci5jb2xvcml6ZSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0VGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyaXplci5fZ2V0VGV4dHVyZVNvdXJjZSgpO1xuICAgIH1cblxuICAgIGdldCB0ZXh0dXJpemVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUudGV4dHVyaXplcjtcbiAgICB9XG5cbiAgICBwYXRjaChzZXR0aW5ncykge1xuICAgICAgICBsZXQgcGF0aHMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncyk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBwYXRocy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXRoID0gcGF0aHNbaV07XG4gICAgICAgICAgICBjb25zdCB2ID0gc2V0dGluZ3NbcGF0aF07XG5cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2hhckNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNVY0NoYXIoZmlyc3RDaGFyQ29kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWYuXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmdldEJ5UmVmKHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIGxpc3QgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXRjaCB0aGlzIGNhc2UgdG8gY2FwdHVyZSBjcmVhdGVNb2RlIGZsYWcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuY2hpbGRMaXN0LmNyZWF0ZUl0ZW0odik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXRjaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLmlzRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMucmVmID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZExpc3QuYShjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQuY2hpbGRMaXN0LnJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5wYXRjaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LmlzRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBlbGVtZW50IGJ5IG5ldyBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdi5yZWYgPSBwYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZExpc3QucmVwbGFjZSh2LCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSBmb3IgcGF0aDogXCIgKyBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydHkuXG4gICAgICAgICAgICAgICAgQmFzZS5wYXRjaE9iamVjdFByb3BlcnR5KHRoaXMsIHBhdGgsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgXCIgKFwiICsgdGhpcy5nZXRMb2NhdGlvblN0cmluZygpICsgXCIpOiBcIiArIG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGFuaW1hdGlvbihzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFnZS5hbmltYXRpb25zLmNyZWF0ZUFuaW1hdGlvbih0aGlzLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgdHJhbnNpdGlvbihwcm9wZXJ0eSwgc2V0dGluZ3MgPSBudWxsKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zaXRpb24ocHJvcGVydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0VHJhbnNpdGlvbihwcm9wZXJ0eSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgLy8gV2UgZG8gbm90IGNyZWF0ZS9yZXR1cm4gdGhlIHRyYW5zaXRpb24sIGJlY2F1c2UgaXQgd291bGQgdW5kbyB0aGUgJ2xhenkgdHJhbnNpdGlvbiBjcmVhdGlvbicgb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgdHJhbnNpdGlvbnMob2JqZWN0KSB7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgICAga2V5cy5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbihwcm9wZXJ0eSwgb2JqZWN0W3Byb3BlcnR5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldCBzbW9vdGgob2JqZWN0KSB7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgICAga2V5cy5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNtb290aChwcm9wZXJ0eSwgdmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTbW9vdGgocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmFzdEZvcndhcmQocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICBsZXQgdCA9IHRoaXMuX3RyYW5zaXRpb25zW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGlmICh0ICYmIHQuaXNUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdC5maW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRUcmFuc2l0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQgPSB0aGlzLl90cmFuc2l0aW9uc1twcm9wZXJ0eV07XG4gICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgdHJhbnNpdGlvbi5cbiAgICAgICAgICAgIHQgPSBuZXcgVHJhbnNpdGlvbih0aGlzLnN0YWdlLnRyYW5zaXRpb25zLCB0aGlzLnN0YWdlLnRyYW5zaXRpb25zLmRlZmF1bHRUcmFuc2l0aW9uU2V0dGluZ3MsIHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfSBlbHNlIGlmICh0LmlzVHJhbnNpdGlvblNldHRpbmdzKSB7XG4gICAgICAgICAgICAvLyBVcGdyYWRlIHRvICdyZWFsJyB0cmFuc2l0aW9uLlxuICAgICAgICAgICAgdCA9IG5ldyBUcmFuc2l0aW9uKFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UudHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25zW3Byb3BlcnR5XSA9IHQ7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIF9zZXRUcmFuc2l0aW9uKHByb3BlcnR5LCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVUcmFuc2l0aW9uKHByb3BlcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwoc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBwbGFpbiBvYmplY3QgdG8gcHJvcGVyIHNldHRpbmdzIG9iamVjdC5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9IHRoaXMuc3RhZ2UudHJhbnNpdGlvbnMuY3JlYXRlU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl90cmFuc2l0aW9uc1twcm9wZXJ0eV07XG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmlzVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFJ1bnRpbWUgc2V0dGluZ3MgY2hhbmdlLlxuICAgICAgICAgICAgICAgIGN1cnJlbnQuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGx5LCBvbmx5IHNldCB0aGUgc2V0dGluZ3MgYW5kIHVwZ3JhZGUgdG8gYSAncmVhbCcgdHJhbnNpdGlvbiB3aGVuIGl0IGlzIHVzZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbnNbcHJvcGVydHldID0gc2V0dGluZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVtb3ZlVHJhbnNpdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90cmFuc2l0aW9uc1twcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTbW9vdGgocHJvcGVydHksIHYpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzLl9nZXRUcmFuc2l0aW9uKHByb3BlcnR5KTtcbiAgICAgICAgaWYgKHQgJiYgdC5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnRhcmdldFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRTbW9vdGgocHJvcGVydHksIHYsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5fc2V0VHJhbnNpdGlvbihwcm9wZXJ0eSwgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ID0gdGhpcy5fZ2V0VHJhbnNpdGlvbihwcm9wZXJ0eSk7XG4gICAgICAgIHQuc3RhcnQodik7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIGdldCBmbGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuZmxleDtcbiAgICB9XG5cbiAgICBzZXQgZmxleCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLmZsZXggPSB2O1xuICAgIH1cblxuICAgIGdldCBmbGV4SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmZsZXhJdGVtO1xuICAgIH1cblxuICAgIHNldCBmbGV4SXRlbSh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLmZsZXhJdGVtID0gdjtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNDb2xvclByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJjb2xvclwiKSA+PSAwO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRNZXJnZXIocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKEVsZW1lbnQuaXNDb2xvclByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0YWdlVXRpbHMubWVyZ2VDb2xvcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU3RhZ2VVdGlscy5tZXJnZU51bWJlcnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IFtgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YF07XG4gICAgICAgIGNvbnN0IHRyZWUgPSB7fTtcbiAgICAgICAgdHJlZVtyZWZdID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgRWxlbWVudC5jb2xsZWN0Q2hpbGRyZW4odHJlZVtyZWZdLCB0aGlzLl9fY2hpbGRMaXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyZWVbcmVmXSA9IHsuLi5FbGVtZW50LmdldFByb3BlcnRpZXModGhpcyl9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb2xsZWN0Q2hpbGRyZW4odHJlZSwgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgY2hpbGRMaXN0ID0gY2hpbGRyZW47XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gY2hpbGRMaXN0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGNoaWxkTGlzdC5nZXRBdChpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IGAke2VsZW1lbnQuX19yZWYgfHwgYEVsZW1lbnQtJHtlbGVtZW50LmlkfWB9YDtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLmdldFByb3BlcnRpZXMoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIHRyZWVbcmVmXSA9IHsuLi5wcm9wZXJ0aWVzfTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgIHRyZWVbcmVmXS5jaGlsZHJlbiA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGVjdENoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICB0cmVlW3JlZl0uY2hpbGRyZW4sIGVsZW1lbnQuX19jaGlsZExpc3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFByb3BlcnRpZXMoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgICAgICBjb25zdCBsaXN0ID0gW1xuICAgICAgICAgICAgXCJhbHBoYVwiLCBcImFjdGl2ZVwiLCBcImF0dGFjaGVkXCIsIFwiYm91bmRzTWFyZ2luXCIsIFwiY29sb3JcIiwgXCJjbGlwcGluZ1wiLCBcImVuYWJsZWRcIiwgXCJoXCIsIFwiaWRcIiwgXCJpc0NvbXBvbmVudFwiLFxuICAgICAgICAgICAgXCJtb3VudFwiLCBcIm1vdW50WVwiLCBcIm1vdW50WFwiLCBcInBpdm90XCIsIFwicGl2b3RYXCIsIFwicGl2b3RZXCIsIFwicmVmXCIsIFwicmVuZGVyT2ZTY3JlZW5cIiwgXCJyZW5kZXJUb1RleHR1cmVcIiwgXCJzY2FsZVwiLFxuICAgICAgICAgICAgXCJzY2FsZVhcIiwgXCJzY2FsZVlcIiwgXCJzdGF0ZVwiLCBcInRhZ1wiLCBcInZpc2libGVcIiwgXCJ3XCIsIFwieFwiLCBcInlcIiwgXCJ6SW5kZXhcIixcbiAgICAgICAgICAgIFwiISFmbGV4XCIsIFwiISFmbGV4SXRlbVwiLCBcImhhc0ZvY3VzKClcIiwgXCJoYXNGaW5hbEZvY3VzKClcIlxuICAgICAgICBdO1xuICAgICAgICBsZXQgbiA9IGxpc3QubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgIGxldCBrZXkgPSBsaXN0W25dO1xuICAgICAgICAgICAgY29uc3QgZ2V0Qm9vbGVhbiA9IC9eIXsyfS87XG4gICAgICAgICAgICBjb25zdCBpc0Z1bmN0aW9uID0gL1xcKFxcKSQvO1xuXG4gICAgICAgICAgICBpZiAoZ2V0Qm9vbGVhbi50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDIsIGtleS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSAhIWVsZW1lbnRba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbi50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDAsIGtleS5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRba2V5XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSBlbGVtZW50W2tleV0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSBlbGVtZW50W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsuLi5wcm9wcywgLi4uZWxlbWVudC5nZXROb25EZWZhdWx0cygpfTtcbiAgICB9XG59XG5cbi8vIFRoaXMgZ2l2ZXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgYmVuZWZpdCBjb21wYXJlZCB0byBleHRlbmRpbmcgRXZlbnRFbWl0dGVyLlxuRXZlbnRFbWl0dGVyLmFkZEFzTWl4aW4oRWxlbWVudCk7XG5cbkVsZW1lbnQucHJvdG90eXBlLmlzRWxlbWVudCA9IDE7XG5cbkVsZW1lbnQuaWQgPSAxO1xuXG4vLyBHZXR0ZXJzIHJldXNlZCB3aGVuIHJlZmVyZW5jaW5nIGVsZW1lbnQgKHN1Ym9iamVjdCkgcHJvcGVydGllcyBieSBhIHByb3BlcnR5IHBhdGgsIGFzIHVzZWQgaW4gYSB0cmFuc2l0aW9uIG9yIGFuaW1hdGlvbiAoJ3gnLCAndGV4dHVyZS54JywgZXRjKS5cbkVsZW1lbnQuUFJPUF9HRVRURVJTID0gbmV3IE1hcCgpO1xuXG4vLyBTZXR0ZXJzIHJldXNlZCB3aGVuIHJlZmVyZW5jaW5nIGVsZW1lbnQgKHN1Ym9iamVjdCkgcHJvcGVydGllcyBieSBhIHByb3BlcnR5IHBhdGgsIGFzIHVzZWQgaW4gYSB0cmFuc2l0aW9uIG9yIGFuaW1hdGlvbiAoJ3gnLCAndGV4dHVyZS54JywgZXRjKS5cbkVsZW1lbnQuUFJPUF9TRVRURVJTID0gbmV3IE1hcCgpO1xuXG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi9UZXh0dXJlLm1qc1wiO1xuaW1wb3J0IEltYWdlVGV4dHVyZSBmcm9tIFwiLi4vdGV4dHVyZXMvSW1hZ2VUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IFRleHRUZXh0dXJlIGZyb20gXCIuLi90ZXh0dXJlcy9UZXh0VGV4dHVyZS5tanNcIjtcbmltcG9ydCBTb3VyY2VUZXh0dXJlIGZyb20gXCIuLi90ZXh0dXJlcy9Tb3VyY2VUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IFRyYW5zaXRpb24gZnJvbSBcIi4uL2FuaW1hdGlvbi9UcmFuc2l0aW9uLm1qc1wiO1xuaW1wb3J0IEVsZW1lbnRDaGlsZExpc3QgZnJvbSBcIi4vRWxlbWVudENoaWxkTGlzdC5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogTWFuYWdlcyB0aGUgbGlzdCBvZiBjaGlsZHJlbiBmb3IgYW4gZWxlbWVudC5cbiAqL1xuXG5pbXBvcnQgT2JqZWN0TGlzdCBmcm9tIFwiLi9PYmplY3RMaXN0Lm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50Q2hpbGRMaXN0IGV4dGVuZHMgT2JqZWN0TGlzdCB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cblxuICAgIF9jb25uZWN0UGFyZW50KGl0ZW0pIHtcbiAgICAgICAgY29uc3QgcHJldlBhcmVudCA9IGl0ZW0ucGFyZW50O1xuICAgICAgICBpZiAocHJldlBhcmVudCAmJiBwcmV2UGFyZW50ICE9PSB0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBDbGVhbnVwIGluIHByZXZpb3VzIGNoaWxkIGxpc3QsIHdpdGhvdXRcbiAgICAgICAgICAgIGNvbnN0IHByZXZDaGlsZExpc3QgPSBpdGVtLnBhcmVudC5jaGlsZExpc3Q7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDaGlsZExpc3QuZ2V0SW5kZXgoaXRlbSk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnJlZikge1xuICAgICAgICAgICAgICAgIHByZXZDaGlsZExpc3QuX3JlZnNbaXRlbS5yZWZdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkNoaWxkTGlzdC5faXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgLy8gQWxzbyBjbGVhbiB1cCBlbGVtZW50IGNvcmUuXG4gICAgICAgICAgICBwcmV2UGFyZW50LmNvcmUucmVtb3ZlQ2hpbGRBdChpbmRleCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0uX3NldFBhcmVudCh0aGlzLl9lbGVtZW50KTtcblxuICAgICAgICAvLyBXZSBhcmUgZXhwZWN0aW5nIHRoZSBjYWxsZXIgdG8gc3luYyBpdCB0byB0aGUgY29yZS5cbiAgICB9XG5cbiAgICBvbkFkZChpdGVtLCBpbmRleCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0UGFyZW50KGl0ZW0pO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNvcmUuYWRkQ2hpbGRBdChpbmRleCwgaXRlbS5jb3JlKTtcbiAgICB9XG5cbiAgICBvblJlbW92ZShpdGVtLCBpbmRleCkge1xuICAgICAgICBpdGVtLl9zZXRQYXJlbnQobnVsbCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY29yZS5yZW1vdmVDaGlsZEF0KGluZGV4KTtcbiAgICB9XG5cbiAgICBvblN5bmMocmVtb3ZlZCwgYWRkZWQsIG9yZGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gcmVtb3ZlZC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHJlbW92ZWRbaV0uX3NldFBhcmVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGFkZGVkLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdFBhcmVudChhZGRlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdjID0gaSA9PiBpLmNvcmU7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY29yZS5zeW5jQ2hpbGRyZW4ocmVtb3ZlZC5tYXAoZ2MpLCBhZGRlZC5tYXAoZ2MpLCBvcmRlci5tYXAoZ2MpKTtcbiAgICB9XG5cbiAgICBvblNldChpdGVtLCBpbmRleCwgcHJldkl0ZW0pIHtcbiAgICAgICAgcHJldkl0ZW0uX3NldFBhcmVudChudWxsKTtcblxuICAgICAgICB0aGlzLl9jb25uZWN0UGFyZW50KGl0ZW0pO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNvcmUuc2V0Q2hpbGRBdChpbmRleCwgaXRlbS5jb3JlKTtcbiAgICB9XG5cbiAgICBvbk1vdmUoaXRlbSwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY29yZS5tb3ZlQ2hpbGQoZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVJdGVtKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgb2JqZWN0LnR5cGUodGhpcy5fZWxlbWVudC5zdGFnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5zdGFnZS5jcmVhdGVFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0l0ZW0ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QuaXNFbGVtZW50O1xuICAgIH1cblxufVxuXG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogTWFuYWdlcyBhIGxpc3Qgb2Ygb2JqZWN0cy5cbiAqIE9iamVjdHMgbWF5IGJlIHBhdGNoZWQuIFRoZW4sIHRoZXkgY2FuIGJlIHJlZmVyZW5jZWQgdXNpbmcgdGhlICdyZWYnIChzdHJpbmcpIHByb3BlcnR5LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPYmplY3RMaXN0IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLl9yZWZzID0ge31cbiAgICB9XG5cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcztcbiAgICB9XG5cbiAgICBnZXQgZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1swXTtcbiAgICB9XG5cbiAgICBnZXQgbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aCA/IHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGFkZChpdGVtKSB7XG4gICAgICAgIHRoaXMuYWRkQXQoaXRlbSwgdGhpcy5faXRlbXMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBhZGRBdChpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbChpdGVtKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBpdGVtO1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmNyZWF0ZUl0ZW0obyk7XG4gICAgICAgICAgICAgICAgaXRlbS5wYXRjaChvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXQoaXRlbSwgaW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmc1tpdGVtLnJlZl0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMub25BZGQoaXRlbSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRBdDogVGhlIGluZGV4ICcgKyBpbmRleCArICcgaXMgb3V0IG9mIGJvdW5kcyAnICsgdGhpcy5faXRlbXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlcGxhY2VCeVJlZihpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnJlZikge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy5nZXRCeVJlZihpdGVtLnJlZik7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nSXRlbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVwbGFjZUJ5UmVmOiBubyBpdGVtIGZvdW5kIHdpdGggcmVmZXJlbmNlOiAnICsgaXRlbS5yZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKGl0ZW0sIGV4aXN0aW5nSXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcGxhY2VCeVJlZjogbm8gcmVmIHNwZWNpZmllZCBpbiBpdGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRBdChpdGVtLCB0aGlzLl9pdGVtcy5sZW5ndGgpO1xuXG4gICAgfVxuXG4gICAgcmVwbGFjZShpdGVtLCBwcmV2SXRlbSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXgocHJldkl0ZW0pO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcGxhY2U6IFRoZSBwcmV2aW91cyBpdGVtIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdChpdGVtLCBpbmRleCk7XG4gICAgfVxuXG4gICAgc2V0QXQoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbChpdGVtKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBpdGVtO1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmNyZWF0ZUl0ZW0obyk7XG4gICAgICAgICAgICAgICAgaXRlbS5wYXRjaChvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJvbUluZGV4ID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbUluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1vdmUoaXRlbSwgZnJvbUluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXRlbXNbaW5kZXhdLnJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmc1t0aGlzLl9pdGVtc1tpbmRleF0ucmVmXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZJdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXQ6IG92ZXJ3cml0ZSBjdXJyZW50LlxuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4XSA9IGl0ZW07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmc1tpdGVtLnJlZl0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMub25TZXQoaXRlbSwgaW5kZXgsIHByZXZJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0QXQ6IFRoZSBpbmRleCAnICsgaW5kZXggKyAnIGlzIG91dCBvZiBib3VuZHMgJyArIHRoaXMuX2l0ZW1zLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRBdChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIH1cblxuICAgIGdldEluZGV4KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGl0ZW0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZW1vdmVBdChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0ucmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmc1tpdGVtLnJlZl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIHRoaXMub25SZW1vdmUoaXRlbSwgaW5kZXgpO1xuXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVtb3ZlQXQ6IFRoZSBpbmRleCAke2luZGV4fSBpcyBvdXQgb2YgYm91bmRzICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuX2l0ZW1zO1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3JlZnMgPSB7fVxuICAgICAgICAgICAgdGhpcy5vblN5bmMocHJldiwgW10sIFtdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhKG8pIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbChvKSkge1xuICAgICAgICAgICAgbGV0IGMgPSB0aGlzLmNyZWF0ZUl0ZW0obyk7XG4gICAgICAgICAgICBjLnBhdGNoKG8pO1xuICAgICAgICAgICAgdGhpcy5hZGQoYyk7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IG8ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hKG9baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0l0ZW0obykpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKG8pO1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgICB9XG5cbiAgICBfZ2V0UmVmcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZnM7XG4gICAgfVxuXG4gICAgZ2V0QnlSZWYocmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZzW3JlZl07XG4gICAgfVxuXG4gICAgY2xlYXJSZWYocmVmKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZWZzW3JlZl07XG4gICAgfVxuXG4gICAgc2V0UmVmKHJlZiwgY2hpbGQpIHtcbiAgICAgICAgdGhpcy5fcmVmc1tyZWZdID0gY2hpbGQ7XG4gICAgfVxuXG4gICAgcGF0Y2goc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbChzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEJ5T2JqZWN0KHNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNldHRpbmdzKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0QnlBcnJheShzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0QnlPYmplY3Qoc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gT3ZlcnJ1bGUgc2V0dGluZ3Mgb2Yga25vd24gcmVmZXJlbmNlZCBpdGVtcy5cbiAgICAgICAgbGV0IHJlZnMgPSB0aGlzLl9nZXRSZWZzKCk7XG4gICAgICAgIGxldCBjcmVmcyA9IE9iamVjdC5rZXlzKHNldHRpbmdzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjcmVmcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjcmVmID0gY3JlZnNbaV07XG4gICAgICAgICAgICBsZXQgcyA9IHNldHRpbmdzW2NyZWZdO1xuXG4gICAgICAgICAgICBsZXQgYyA9IHJlZnNbY3JlZl07XG4gICAgICAgICAgICBpZiAoIWMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0l0ZW0ocykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBwcmV2aW91cyBpdGVtO1xuICAgICAgICAgICAgICAgICAgICBzLnJlZiA9IGNyZWY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuY3JlYXRlSXRlbShzKTtcbiAgICAgICAgICAgICAgICAgICAgYy5yZWYgPSBjcmVmO1xuICAgICAgICAgICAgICAgICAgICBjLnBhdGNoKHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSXRlbShzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyAhPT0gcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBwcmV2aW91cyBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkeCA9IHRoaXMuZ2V0SW5kZXgoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnJlZiA9IGNyZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0KHMsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjLnBhdGNoKHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9lcXVhbHNBcnJheShhcnJheSkge1xuICAgICAgICBsZXQgc2FtZSA9IHRydWU7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9pdGVtcy5sZW5ndGg7IChpIDwgbikgJiYgc2FtZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2FtZSA9IHNhbWUgJiYgKHRoaXMuX2l0ZW1zW2ldID09PSBhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYW1lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhbWU7XG4gICAgfVxuXG4gICAgX3NldEJ5QXJyYXkoYXJyYXkpIHtcbiAgICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGZpcnN0IGNoZWNrIGlmIHRoZSBhcnJheXMgbWF0Y2ggZXhhY3RseSBhbmQgYmFpbCBvdXQgaWYgdGhleSBkby5cbiAgICAgICAgaWYgKHRoaXMuX2VxdWFsc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9pdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zW2ldLm1hcmtlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVmcztcbiAgICAgICAgbGV0IG5ld0l0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcyA9IGFycmF5W2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJdGVtKHMpKSB7XG4gICAgICAgICAgICAgICAgcy5tYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXdJdGVtcy5wdXNoKHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY3JlZiA9IHMucmVmO1xuICAgICAgICAgICAgICAgIGxldCBjO1xuICAgICAgICAgICAgICAgIGlmIChjcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVmcykgcmVmcyA9IHRoaXMuX2dldFJlZnMoKTtcbiAgICAgICAgICAgICAgICAgICAgYyA9IHJlZnNbY3JlZl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuY3JlYXRlSXRlbShzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjLm1hcmtlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwocykpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5wYXRjaChzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0SXRlbXMobmV3SXRlbXMpO1xuICAgIH1cblxuICAgIF9zZXRJdGVtcyhuZXdJdGVtcykge1xuICAgICAgICBsZXQgcHJldkl0ZW1zID0gdGhpcy5faXRlbXM7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gbmV3SXRlbXM7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBpdGVtcy5cbiAgICAgICAgbGV0IHJlbW92ZWQgPSBwcmV2SXRlbXMuZmlsdGVyKGl0ZW0gPT4ge2xldCBtID0gaXRlbS5tYXJrZXI7IGRlbGV0ZSBpdGVtLm1hcmtlcjsgcmV0dXJuIG19KTtcbiAgICAgICAgbGV0IGFkZGVkID0gbmV3SXRlbXMuZmlsdGVyKGl0ZW0gPT4gKHByZXZJdGVtcy5pbmRleE9mKGl0ZW0pID09PSAtMSkpO1xuXG4gICAgICAgIGlmIChyZW1vdmVkLmxlbmd0aCB8fCBhZGRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIHJlZnMuXG4gICAgICAgICAgICB0aGlzLl9yZWZzID0ge31cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5faXRlbXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlZiA9IHRoaXMuX2l0ZW1zW2ldLnJlZjtcbiAgICAgICAgICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnNbcmVmXSA9IHRoaXMuX2l0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25TeW5jKHJlbW92ZWQsIGFkZGVkLCBuZXdJdGVtcyk7XG4gICAgfVxuXG4gICAgc29ydChmKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5faXRlbXMuc2xpY2UoKTtcbiAgICAgICAgaXRlbXMuc29ydChmKTtcbiAgICAgICAgdGhpcy5fc2V0QnlBcnJheShpdGVtcyk7XG4gICAgfVxuXG4gICAgb25BZGQoaXRlbSwgaW5kZXgpIHtcbiAgICB9XG5cbiAgICBvblJlbW92ZShpdGVtLCBpbmRleCkge1xuICAgIH1cblxuICAgIG9uU3luYyhyZW1vdmVkLCBhZGRlZCwgb3JkZXIpIHtcbiAgICB9XG5cbiAgICBvblNldChpdGVtLCBpbmRleCwgcHJldkl0ZW0pIHtcbiAgICB9XG5cbiAgICBvbk1vdmUoaXRlbSwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgfVxuXG4gICAgY3JlYXRlSXRlbShvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0TGlzdC5jcmVhdGVJdGVtIG11c3QgY3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgb2JqZWN0XCIpO1xuICAgIH1cblxuICAgIGlzSXRlbShvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvckVhY2goZikge1xuICAgICAgICB0aGlzLmdldCgpLmZvckVhY2goZik7XG4gICAgfVxuXG59XG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi9VdGlscy5tanNcIjtcblxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4vVXRpbHMubWpzXCI7XG5pbXBvcnQgQmFzZSBmcm9tIFwiLi9CYXNlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY29yZUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmN0eCA9IGNvcmVDb250ZXh0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgKGVuYWJsZWQpIGVsZW1lbnRzIHRoYXQgdXNlIHRoaXMgc2hhZGVyLlxuICAgICAgICAgKiBAdHlwZSB7U2V0PEVsZW1lbnRDb3JlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0gbmV3IFNldCgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGUoc3RhZ2UsIHYpIHtcbiAgICAgICAgbGV0IHNoYWRlcjtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2KSkge1xuICAgICAgICAgICAgaWYgKHYudHlwZSkge1xuICAgICAgICAgICAgICAgIHNoYWRlciA9IHN0YWdlLnJlbmRlcmVyLmNyZWF0ZVNoYWRlcihzdGFnZS5jdHgsIHYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNoYWRlcikge1xuICAgICAgICAgICAgICAgIEJhc2UucGF0Y2hPYmplY3Qoc2hhZGVyLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzaGFkZXIgPSBzdGFnZS5jdHgucmVuZGVyU3RhdGUuZGVmYXVsdFNoYWRlcjtcbiAgICAgICAgfSBlbHNlIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNoYWRlciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodi5pc1NoYWRlcikge1xuICAgICAgICAgICAgICAgIGlmICghc3RhZ2UucmVuZGVyZXIuaXNWYWxpZFNoYWRlclR5cGUodi5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltMaWdodG5pbmddIEludmFsaWQgc2hhZGVyIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaGFkZXIgPSB2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW0xpZ2h0bmluZ10gUGxlYXNlIHNwZWNpZnkgYSBzaGFkZXIgdHlwZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0V2ViR0woKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEMyZCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBhZGRFbGVtZW50KGVsZW1lbnRDb3JlKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzLmFkZChlbGVtZW50Q29yZSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlRWxlbWVudChlbGVtZW50Q29yZSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50cy5kZWxldGUoZWxlbWVudENvcmUpO1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZHJhdygpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMuZm9yRWFjaChlbGVtZW50Q29yZSA9PiB7XG4gICAgICAgICAgICBlbGVtZW50Q29yZS5zZXRIYXNSZW5kZXJVcGRhdGVzKDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwYXRjaChzZXR0aW5ncykge1xuICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRoaXMsIHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICAvLyBTaG91bGQgcmV0dXJuIHRydWUgaWYgdGhpcyBzaGFkZXIgaXMgY29uZmlndXJlZCAodXNpbmcgaXQncyBwcm9wZXJ0aWVzKSB0byBub3QgaGF2ZSBhbnkgZWZmZWN0LlxuICAgICAgICAvLyBUaGlzIG1heSBhbGxvdyB0aGUgcmVuZGVyIGVuZ2luZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBzaGFkZXIgcHJvZ3JhbSBzd2l0Y2hlcyBvciBldmVuIHRleHR1cmUgY29waWVzLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkRW1wdHkoKSB7XG4gICAgICAgIC8vIERyYXdzIHRoaXMgc2hhZGVyIGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHF1YWRzIHRvIGJlIGFkZGVkLlxuICAgICAgICAvLyBUaGlzIGlzIGhhbmR5IGZvciBjdXN0b20gc2hhZGVycy5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIC8vIENhbGxlZCB3aGVuIG5vIG1vcmUgZW5hYmxlZCBlbGVtZW50cyBoYXZlIHRoaXMgc2hhZGVyLlxuICAgIH1cblxuICAgIGdldCBpc1NoYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEFwcGxpY2F0aW9uIHJlbmRlciB0cmVlLlxuICovXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50RW1pdHRlci5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi9VdGlscy5tanNcIjtcbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gXCIuLi9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyLm1qc1wiO1xuaW1wb3J0IEMyZFJlbmRlcmVyIGZyb20gXCIuLi9yZW5kZXJlci9jMmQvQzJkUmVuZGVyZXIubWpzXCI7XG5pbXBvcnQgU3BhcmtSZW5kZXJlciBmcm9tIFwiLi4vcmVuZGVyZXIvc3BhcmsvU3BhcmtSZW5kZXJlci5tanNcIjtcbmltcG9ydCBQbGF0Zm9ybUxvYWRlciBmcm9tIFwiLi4vcGxhdGZvcm1zL1BsYXRmb3JtTG9hZGVyLm1qc1wiO1xuaW1wb3J0IFdlYkdMU3RhdGVNYW5hZ2VyIGZyb20gXCIuLi90b29scy9XZWJHTFN0YXRlTWFuYWdlci5tanNcIjtcbmltcG9ydCBTaGFkZXIgZnJvbSBcIi4vU2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFnZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl91c2VkTWVtb3J5ID0gMDtcbiAgICAgICAgdGhpcy5fbGFzdEdjRnJhbWUgPSAwO1xuXG4gICAgICAgIGNvbnN0IHBsYXRmb3JtVHlwZSA9IFN0YWdlLnBsYXRmb3JtID8gU3RhZ2UucGxhdGZvcm0gOiBQbGF0Zm9ybUxvYWRlci5sb2FkKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gbmV3IHBsYXRmb3JtVHlwZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLnBsYXRmb3JtLmluaXQpIHtcbiAgICAgICAgICAgIHRoaXMucGxhdGZvcm0uaW5pdCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgICB0aGlzLmMyZCA9IG51bGw7XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0T3B0aW9uKCdjb250ZXh0Jyk7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC51c2VQcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYzJkID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc1dlYiAmJiAoIVN0YWdlLmlzV2ViZ2xTdXBwb3J0ZWQoKSB8fCB0aGlzLmdldE9wdGlvbignY2FudmFzMmQnKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmMyZCA9IHRoaXMucGxhdGZvcm0uY3JlYXRlQ2FudmFzQ29udGV4dCh0aGlzLmdldE9wdGlvbigndycpLCB0aGlzLmdldE9wdGlvbignaCcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbCA9IHRoaXMucGxhdGZvcm0uY3JlYXRlV2ViR0xDb250ZXh0KHRoaXMuZ2V0T3B0aW9uKCd3JyksIHRoaXMuZ2V0T3B0aW9uKCdoJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2wpIHtcbiAgICAgICAgICAgIC8vIFdyYXAgaW4gV2ViR0xTdGF0ZU1hbmFnZXIuXG4gICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHVubmVjZXNzYXJ5IGRvdWJsZSBXZWJHTCBjb21tYW5kcyBmcm9tIGJlaW5nIGV4ZWN1dGVkLCBhbmQgYWxsb3dzIGNvbnRleHQgc3dpdGNoaW5nLlxuICAgICAgICAgICAgLy8gQ29udGV4dCBzd2l0Y2hpbmcgaXMgbmVjZXNzYXJ5IHdoZW4gcmV1c2luZyB0aGUgc2FtZSBjb250ZXh0IGZvciBUaHJlZS5qcy5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgdXNlciBtdXN0IG1ha2Ugc3VyZSB0aGF0IHRoZSBXZWJHTCBjb250ZXh0IGlzIHVudG91Y2hlZCBiZWZvcmUgY3JlYXRpbmcgdGhlIGFwcGxpY2F0aW9uLFxuICAgICAgICAgICAgLy8gIHdoZW4gbWFudWFsbHkgcGFzc2luZyBvdmVyIGEgY2FudmFzIG9yIGNvbnRleHQgaW4gdGhlIG9wdGlvbnMuXG4gICAgICAgICAgICBXZWJHTFN0YXRlTWFuYWdlci5lbmFibGUodGhpcy5nbCwgXCJsaWdodG5pbmdcIilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vZGUgPSB0aGlzLmdsID8gMCA6IDE7XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgICAgaWYgKHRoaXMuZ2V0Q2FudmFzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMudyA9IHRoaXMuZ2V0Q2FudmFzKCkud2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmggPSB0aGlzLmdldENhbnZhcygpLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNTcGFyaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gbmV3IFNwYXJrUmVuZGVyZXIodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBDMmRSZW5kZXJlcih0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0Q2xlYXJDb2xvcih0aGlzLmdldE9wdGlvbignY2xlYXJDb2xvcicpKTtcblxuICAgICAgICB0aGlzLmZyYW1lQ291bnRlciA9IDA7XG5cbiAgICAgICAgdGhpcy50cmFuc2l0aW9ucyA9IG5ldyBUcmFuc2l0aW9uTWFuYWdlcih0aGlzKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIodGhpcyk7XG5cbiAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlciA9IG5ldyBUZXh0dXJlTWFuYWdlcih0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlVGhyb3R0bGVyID0gbmV3IFRleHR1cmVUaHJvdHRsZXIodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5kdCA9IDA7XG5cbiAgICAgICAgLy8gUHJlbG9hZCByZWN0YW5nbGUgdGV4dHVyZSwgc28gdGhhdCB3ZSBjYW4gc2tpcCBzb21lIGJvcmRlciBjaGVja3MgZm9yIGxvYWRpbmcgdGV4dHVyZXMuXG4gICAgICAgIHRoaXMucmVjdGFuZ2xlVGV4dHVyZSA9IG5ldyBSZWN0YW5nbGVUZXh0dXJlKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY3RhbmdsZVRleHR1cmUubG9hZCgpO1xuXG4gICAgICAgIC8vIE5ldmVyIGNsZWFuIHVwIGJlY2F1c2Ugd2UgdXNlIGl0IGFsbCB0aGUgdGltZS5cbiAgICAgICAgdGhpcy5yZWN0YW5nbGVUZXh0dXJlLnNvdXJjZS5wZXJtYW5lbnQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY3R4ID0gbmV3IENvcmVDb250ZXh0KHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNvdXJjZVRleHR1cmVzID0gbmV3IFNldCgpO1xuICAgIH1cblxuICAgIGdldCByZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc1dlYmdsU3VwcG9ydGVkKCkge1xuICAgICAgICBpZiAoVXRpbHMuaXNOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gISF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlbmRlcmluZyBtb2RlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogIDA6IFdlYkdMXG4gICAgICogIDE6IENhbnZhczJkXG4gICAgICovXG4gICAgZ2V0IG1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICAgIH1cblxuICAgIGlzV2ViZ2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IDA7XG4gICAgfVxuXG4gICAgaXNDMmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IDE7XG4gICAgfVxuXG4gICAgZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnNbbmFtZV07XG4gICAgfVxuXG4gICAgX3NldE9wdGlvbnMobykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0ge307XG5cbiAgICAgICAgbGV0IG9wdCA9IChuYW1lLCBkZWYpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9bbmFtZV07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1tuYW1lXSA9IGRlZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0KCdjYW52YXMnLCBudWxsKTtcbiAgICAgICAgb3B0KCdjb250ZXh0JywgbnVsbCk7XG4gICAgICAgIG9wdCgndycsIDE5MjApO1xuICAgICAgICBvcHQoJ2gnLCAxMDgwKTtcbiAgICAgICAgb3B0KCdzcmNCYXNlUGF0aCcsIG51bGwpO1xuICAgICAgICBvcHQoJ21lbW9yeVByZXNzdXJlJywgMjRlNik7XG4gICAgICAgIG9wdCgnYnVmZmVyTWVtb3J5JywgMmU2KTtcbiAgICAgICAgb3B0KCd0ZXh0UmVuZGVySXNzdWVNYXJnaW4nLCAwKTtcbiAgICAgICAgb3B0KCdmb250U2hhcnAnLHtwcmVjaXNpb246MC42NjY2NjY2NjY3LCBmb250U2l6ZTogMjR9KVxuICAgICAgICBvcHQoJ2NsZWFyQ29sb3InLCBbMCwgMCwgMCwgMF0pO1xuICAgICAgICBvcHQoJ2RlZmF1bHRGb250RmFjZScsICdzYW5zLXNlcmlmJyk7XG4gICAgICAgIG9wdCgnZml4ZWREdCcsIDApO1xuICAgICAgICBvcHQoJ3VzZUltYWdlV29ya2VyJywgdHJ1ZSk7XG4gICAgICAgIG9wdCgnYXV0b3N0YXJ0JywgdHJ1ZSk7XG4gICAgICAgIG9wdCgncHJlY2lzaW9uJywgMSk7XG4gICAgICAgIG9wdCgnY2FudmFzMmQnLCBmYWxzZSk7XG4gICAgICAgIG9wdCgncGxhdGZvcm0nLCBudWxsKTtcbiAgICAgICAgb3B0KCdyZWFkUGl4ZWxzQmVmb3JlRHJhdycsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBzZXRBcHBsaWNhdGlvbihhcHApIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IGFwcDtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuXG4gICAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uLmdldE9wdGlvbignZGVidWcnKSAmJiB0aGlzLnBsYXRmb3JtLl9pbWFnZVdvcmtlcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tMaWdodG5pbmddIFVzaW5nIGltYWdlIHdvcmtlciEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uLmdldE9wdGlvbignZGVidWcnKSAmJiB0aGlzLmMyZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tMaWdodG5pbmddIFVzaW5nIGNhbnZhczJkIHJlbmRlcmVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLnNldEFzUm9vdCgpO1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb24oJ2F1dG9zdGFydCcpKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXRmb3JtLnN0YXJ0TG9vcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5zdG9wTG9vcCgpO1xuICAgICAgICB0aGlzLnBsYXRmb3JtLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jdHguZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0uc3RvcExvb3AoKTtcbiAgICB9XG5cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0uc3RhcnRMb29wKCk7XG4gICAgfVxuXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGxpY2F0aW9uO1xuICAgIH1cblxuICAgIGdldENhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGUgPyB0aGlzLmMyZC5jYW52YXMgOiB0aGlzLmdsLmNhbnZhcztcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJQcmVjaXNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnByZWNpc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyBhIHRleHR1cmUgZm9yIHVwZGF0aW5nIGl0J3Mgc291cmNlIHVwb24gdGhlIG5leHQgZHJhd0ZyYW1lLlxuICAgICAqIEBwYXJhbSB0ZXh0dXJlXG4gICAgICovXG4gICAgYWRkVXBkYXRlU291cmNlVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgICAgIGlmICh0aGlzLl91cGRhdGluZ0ZyYW1lKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGNhbGxlZCBmcm9tIHRoZSB1cGxvYWQgbG9vcCwgd2UgbXVzdCBpbW1lZGlhdGVseSBsb2FkIHRoZSB0ZXh0dXJlIGluIG9yZGVyIHRvIGF2b2lkIGEgJ2ZsYXNoJy5cbiAgICAgICAgICAgIHRleHR1cmUuX3BlcmZvcm1VcGRhdGVTb3VyY2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNvdXJjZVRleHR1cmVzLmFkZCh0ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZVVwZGF0ZVNvdXJjZVRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICBpZiAodGhpcy5fdXBkYXRlU291cmNlVGV4dHVyZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNvdXJjZVRleHR1cmVzLmRlbGV0ZSh0ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhc1VwZGF0ZVNvdXJjZVRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3VwZGF0ZVNvdXJjZVRleHR1cmVzICYmIHRoaXMuX3VwZGF0ZVNvdXJjZVRleHR1cmVzLmhhcyh0ZXh0dXJlKSk7XG4gICAgfVxuXG4gICAgZHJhd0ZyYW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuY3VycmVudFRpbWU7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0aGlzLnBsYXRmb3JtLmdldEhyVGltZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZpeGVkRHQpIHtcbiAgICAgICAgICAgIHRoaXMuZHQgPSB0aGlzLl9vcHRpb25zLmZpeGVkRHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmR0ID0gKCF0aGlzLnN0YXJ0VGltZSkgPyAuMDIgOiAuMDAxICogKHRoaXMuY3VycmVudFRpbWUgLSB0aGlzLnN0YXJ0VGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ2ZyYW1lU3RhcnQnKTtcblxuICAgICAgICBpZiAodGhpcy5fdXBkYXRlU291cmNlVGV4dHVyZXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU291cmNlVGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLl9wZXJmb3JtVXBkYXRlU291cmNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNvdXJjZVRleHR1cmVzID0gbmV3IFNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnKTtcblxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5jdHguaGFzUmVuZGVyVXBkYXRlcygpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBtYXkgY2F1c2UgdGV4dHVyZXMgdG8gYmUgbG9hZGVkIGluIHN5bmMsIHNvIGJ5IHByb2Nlc3NpbmcgdGhlbSBoZXJlIHdlIG1heSBiZSBhYmxlIHRvIHNob3cgdGhlbVxuICAgICAgICAvLyBkdXJpbmcgdGhlIGN1cnJlbnQgZnJhbWUgYWxyZWFkeS5cbiAgICAgICAgdGhpcy50ZXh0dXJlVGhyb3R0bGVyLnByb2Nlc3NTb21lKCk7XG5cbiAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nRnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jdHgudXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5yZW5kZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nRnJhbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGxhdGZvcm0ubmV4dEZyYW1lKGNoYW5nZXMpO1xuXG4gICAgICAgIHRoaXMuZW1pdCgnZnJhbWVFbmQnKTtcblxuICAgICAgICB0aGlzLmZyYW1lQ291bnRlcisrO1xuICAgIH1cblxuICAgIGlzVXBkYXRpbmdGcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0aW5nRnJhbWU7XG4gICAgfVxuXG4gICAgcmVuZGVyRnJhbWUoKSB7XG4gICAgICAgIHRoaXMuY3R4LmZyYW1lKCk7XG4gICAgfVxuXG4gICAgZm9yY2VSZW5kZXJVcGRhdGUoKSB7XG4gICAgICAgIC8vIEVuZm9yY2UgcmUtcmVuZGVyaW5nLlxuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuY29yZS5fcGFyZW50LnNldEhhc1JlbmRlclVwZGF0ZXMoMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDbGVhckNvbG9yKGNsZWFyQ29sb3IpIHtcbiAgICAgICAgdGhpcy5mb3JjZVJlbmRlclVwZGF0ZSgpO1xuICAgICAgICBpZiAoY2xlYXJDb2xvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGNsZWFyLlxuICAgICAgICAgICAgdGhpcy5fY2xlYXJDb2xvciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjbGVhckNvbG9yKSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJDb2xvciA9IGNsZWFyQ29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhckNvbG9yID0gU3RhZ2VVdGlscy5nZXRSZ2JhQ29tcG9uZW50c05vcm1hbGl6ZWQoY2xlYXJDb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDbGVhckNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xlYXJDb2xvcjtcbiAgICB9XG5cbiAgICBjcmVhdGVFbGVtZW50KHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChzZXR0aW5ncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVTaGFkZXIoc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIFNoYWRlci5jcmVhdGUodGhpcywgc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGVsZW1lbnQoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmlzRWxlbWVudCkgcmV0dXJuIHNldHRpbmdzO1xuXG4gICAgICAgIGxldCBlbGVtZW50O1xuICAgICAgICBpZiAoc2V0dGluZ3MudHlwZSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBzZXR0aW5ncy50eXBlKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5wYXRjaChzZXR0aW5ncyk7XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgYyhzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50KHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMudztcbiAgICB9XG5cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuaDtcbiAgICB9XG5cbiAgICBnZXQgY29vcmRzV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLncgLyB0aGlzLl9vcHRpb25zLnByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBnZXQgY29vcmRzSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oIC8gdGhpcy5fb3B0aW9ucy5wcmVjaXNpb247XG4gICAgfVxuXG4gICAgYWRkTWVtb3J5VXNhZ2UoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5fdXNlZE1lbW9yeSArPSBkZWx0YTtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RHY0ZyYW1lICE9PSB0aGlzLmZyYW1lQ291bnRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZWRNZW1vcnkgPiB0aGlzLmdldE9wdGlvbignbWVtb3J5UHJlc3N1cmUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2MoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91c2VkTWVtb3J5ID4gdGhpcy5nZXRPcHRpb24oJ21lbW9yeVByZXNzdXJlJykgLSAyZTYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9vIGZldyByZWxlYXNlZC4gQWdncmVzc2l2ZSBjbGVhbnVwLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdjKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB1c2VkTWVtb3J5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlZE1lbW9yeTtcbiAgICB9XG5cbiAgICBnYyhhZ2dyZXNzaXZlKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0R2NGcmFtZSAhPT0gdGhpcy5mcmFtZUNvdW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RHY0ZyYW1lID0gdGhpcy5mcmFtZUNvdW50ZXI7XG4gICAgICAgICAgICBjb25zdCBtZW1vcnlVc2FnZUJlZm9yZSA9IHRoaXMuX3VzZWRNZW1vcnk7XG4gICAgICAgICAgICB0aGlzLmdjVGV4dHVyZU1lbW9yeShhZ2dyZXNzaXZlKTtcbiAgICAgICAgICAgIHRoaXMuZ2NSZW5kZXJUZXh0dXJlTWVtb3J5KGFnZ3Jlc3NpdmUpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5nYyhhZ2dyZXNzaXZlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb24uZ2V0T3B0aW9uKCdkZWJ1ZycpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtMaWdodG5pbmddIEdDJHthZ2dyZXNzaXZlID8gXCJbYWdncmVzc2l2ZV1cIiA6IFwiXCJ9ISBGcmFtZSAke3RoaXMuX2xhc3RHY0ZyYW1lfSBGcmVlZCAkeygobWVtb3J5VXNhZ2VCZWZvcmUgLSB0aGlzLl91c2VkTWVtb3J5KSAvIDFlNikudG9GaXhlZCgyKX1NUCBmcm9tIEdQVSBtZW1vcnkuIFJlbWFpbmluZzogJHsodGhpcy5fdXNlZE1lbW9yeSAvIDFlNikudG9GaXhlZCgyKX1NUGApO1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyID0gdGhpcy5fdXNlZE1lbW9yeSAtIHRoaXMudGV4dHVyZU1hbmFnZXIudXNlZE1lbW9yeSAtIHRoaXMuY3R4LnVzZWRNZW1vcnk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtMaWdodG5pbmddIFRleHR1cmVzOiAkeyh0aGlzLnRleHR1cmVNYW5hZ2VyLnVzZWRNZW1vcnkgLyAxZTYpLnRvRml4ZWQoMil9TVAsIFJlbmRlciBUZXh0dXJlczogJHsodGhpcy5jdHgudXNlZE1lbW9yeSAvIDFlNikudG9GaXhlZCgyKX1NUCwgUmVuZGVyZXIgY2FjaGVzOiAkeyhvdGhlciAvIDFlNikudG9GaXhlZCgyKX1NUGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2NUZXh0dXJlTWVtb3J5KGFnZ3Jlc3NpdmUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoYWdncmVzc2l2ZSAmJiB0aGlzLmN0eC5yb290LnZpc2libGUpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IEFMTCB0ZXh0dXJlcyBhcmUgY2xlYW5lZDtcbiAgICAgICAgICAgIHRoaXMuY3R4LnJvb3QudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5nYygpO1xuICAgICAgICAgICAgdGhpcy5jdHgucm9vdC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuZ2MoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdjUmVuZGVyVGV4dHVyZU1lbW9yeShhZ2dyZXNzaXZlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGFnZ3Jlc3NpdmUgJiYgdGhpcy5yb290LnZpc2libGUpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IEFMTCByZW5kZXIgdGV4dHVyZXMgYXJlIGNsZWFuZWQ7XG4gICAgICAgICAgICB0aGlzLnJvb3QudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jdHguZnJlZVVudXNlZFJlbmRlclRleHR1cmVzKDApO1xuICAgICAgICAgICAgdGhpcy5yb290LnZpc2libGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdHguZnJlZVVudXNlZFJlbmRlclRleHR1cmVzKDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0RHJhd2luZ0NhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxhdGZvcm0uZ2V0RHJhd2luZ0NhbnZhcygpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5jdHgudXBkYXRlKClcbiAgICB9XG5cbiAgICBhZGRTZXJ2aWNlUHJvdmlkZXIoc2VydmljZXByb3ZpZGVyKSB7XG4gICAgICAgIGlmIChVdGlscy5pc1NwYXJrKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXRmb3JtLmFkZFNlcnZpY2VQcm92aWRlcihzZXJ2aWNlcHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGRyZW5CeVBvc2l0aW9uKHgsIHkpe1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnJvb3QuY29yZS51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5yb290LmNvcmUuY29sbGVjdEF0Q29vcmQoeCx5LGNoaWxkcmVuKTtcblxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxufVxuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi9FbGVtZW50Lm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4vU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBUZXh0dXJlTWFuYWdlciBmcm9tIFwiLi9UZXh0dXJlTWFuYWdlci5tanNcIjtcbmltcG9ydCBUZXh0dXJlVGhyb3R0bGVyIGZyb20gXCIuL1RleHR1cmVUaHJvdHRsZXIubWpzXCI7XG5pbXBvcnQgQ29yZUNvbnRleHQgZnJvbSBcIi4vY29yZS9Db3JlQ29udGV4dC5tanNcIjtcbmltcG9ydCBUcmFuc2l0aW9uTWFuYWdlciBmcm9tIFwiLi4vYW5pbWF0aW9uL1RyYW5zaXRpb25NYW5hZ2VyLm1qc1wiO1xuaW1wb3J0IEFuaW1hdGlvbk1hbmFnZXIgZnJvbSBcIi4uL2FuaW1hdGlvbi9BbmltYXRpb25NYW5hZ2VyLm1qc1wiO1xuaW1wb3J0IFJlY3RhbmdsZVRleHR1cmUgZnJvbSBcIi4uL3RleHR1cmVzL1JlY3RhbmdsZVRleHR1cmUubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFnZVV0aWxzIHtcblxuICAgIHN0YXRpYyBtZXJnZU51bWJlcnModjEsIHYyLCBwKSB7XG4gICAgICAgIHJldHVybiB2MSAqIHAgKyB2MiAqICgxIC0gcCk7XG4gICAgfTtcblxuICAgIHN0YXRpYyByZ2IociwgZywgYikge1xuICAgICAgICByZXR1cm4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiICsgKDI1NSAqIDE2Nzc3MjE2KTtcbiAgICB9O1xuXG4gICAgc3RhdGljIHJnYmEociwgZywgYiwgYSkge1xuICAgICAgICByZXR1cm4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiICsgKCgoYSAqIDI1NSkgfCAwKSAqIDE2Nzc3MjE2KTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFJnYlN0cmluZyhjb2xvcikge1xuICAgICAgICBsZXQgciA9ICgoY29sb3IgLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGcgPSAoKGNvbG9yIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgYiA9IGNvbG9yICUgMjU2O1xuICAgICAgICByZXR1cm4gJ3JnYignICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJyknO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0UmdiYVN0cmluZyhjb2xvcikge1xuICAgICAgICBsZXQgciA9ICgoY29sb3IgLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGcgPSAoKGNvbG9yIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgYiA9IGNvbG9yICUgMjU2O1xuICAgICAgICBsZXQgYSA9ICgoY29sb3IgLyAxNjc3NzIxNikgfCAwKSAvIDI1NTtcbiAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhLnRvRml4ZWQoNCkgKyAnKSc7XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRSZ2JhU3RyaW5nRnJvbUFycmF5KGNvbG9yKSB7XG4gICAgICAgIGxldCByID0gTWF0aC5mbG9vcihjb2xvclswXSAqIDI1NSk7XG4gICAgICAgIGxldCBnID0gTWF0aC5mbG9vcihjb2xvclsxXSAqIDI1NSk7XG4gICAgICAgIGxldCBiID0gTWF0aC5mbG9vcihjb2xvclsyXSAqIDI1NSk7XG4gICAgICAgIGxldCBhID0gTWF0aC5mbG9vcihjb2xvclszXSAqIDI1NSkgLyAyNTU7XG4gICAgICAgIHJldHVybiAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYS50b0ZpeGVkKDQpICsgJyknO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0UmdiYUNvbXBvbmVudHNOb3JtYWxpemVkKGFyZ2IpIHtcbiAgICAgICAgbGV0IHIgPSAoKGFyZ2IgLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGcgPSAoKGFyZ2IgLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBiID0gYXJnYiAlIDI1NjtcbiAgICAgICAgbGV0IGEgPSAoKGFyZ2IgLyAxNjc3NzIxNikgfCAwKTtcbiAgICAgICAgcmV0dXJuIFtyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1LCBhIC8gMjU1XTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFJnYkNvbXBvbmVudHNOb3JtYWxpemVkKGFyZ2IpIHtcbiAgICAgICAgbGV0IHIgPSAoKGFyZ2IgLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGcgPSAoKGFyZ2IgLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBiID0gYXJnYiAlIDI1NjtcbiAgICAgICAgcmV0dXJuIFtyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1XTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFJnYmFDb21wb25lbnRzKGFyZ2IpIHtcbiAgICAgICAgbGV0IHIgPSAoKGFyZ2IgLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGcgPSAoKGFyZ2IgLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBiID0gYXJnYiAlIDI1NjtcbiAgICAgICAgbGV0IGEgPSAoKGFyZ2IgLyAxNjc3NzIxNikgfCAwKTtcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCBhXTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldEFyZ2JOdW1iZXIocmdiYSkge1xuICAgICAgICByZ2JhWzBdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzBdKSk7XG4gICAgICAgIHJnYmFbMV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbMV0pKTtcbiAgICAgICAgcmdiYVsyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVsyXSkpO1xuICAgICAgICByZ2JhWzNdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzNdKSk7XG4gICAgICAgIGxldCB2ID0gKChyZ2JhWzNdIHwgMCkgPDwgMjQpICsgKChyZ2JhWzBdIHwgMCkgPDwgMTYpICsgKChyZ2JhWzFdIHwgMCkgPDwgOCkgKyAocmdiYVsyXSB8IDApO1xuICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgIHYgPSAweEZGRkZGRkZGICsgdiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfTtcblxuICAgIHN0YXRpYyBtZXJnZUNvbG9ycyhjMSwgYzIsIHApIHtcbiAgICAgICAgbGV0IHIxID0gKChjMSAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgZzEgPSAoKGMxIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgYjEgPSBjMSAlIDI1NjtcbiAgICAgICAgbGV0IGExID0gKChjMSAvIDE2Nzc3MjE2KSB8IDApO1xuXG4gICAgICAgIGxldCByMiA9ICgoYzIgLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGcyID0gKChjMiAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGIyID0gYzIgJSAyNTY7XG4gICAgICAgIGxldCBhMiA9ICgoYzIgLyAxNjc3NzIxNikgfCAwKTtcblxuICAgICAgICBsZXQgciA9IHIxICogcCArIHIyICogKDEgLSBwKTtcbiAgICAgICAgbGV0IGcgPSBnMSAqIHAgKyBnMiAqICgxIC0gcCk7XG4gICAgICAgIGxldCBiID0gYjEgKiBwICsgYjIgKiAoMSAtIHApO1xuICAgICAgICBsZXQgYSA9IGExICogcCArIGEyICogKDEgLSBwKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhKSAqIDE2Nzc3MjE2ICsgTWF0aC5yb3VuZChyKSAqIDY1NTM2ICsgTWF0aC5yb3VuZChnKSAqIDI1NiArIE1hdGgucm91bmQoYik7XG4gICAgfTtcblxuICAgIHN0YXRpYyBtZXJnZU11bHRpQ29sb3JzKGMsIHApIHtcbiAgICAgICAgbGV0IHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwLCB0ID0gMDtcbiAgICAgICAgbGV0IG4gPSBjLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByMSA9ICgoY1tpXSAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICAgICAgbGV0IGcxID0gKChjW2ldIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICAgICAgbGV0IGIxID0gY1tpXSAlIDI1NjtcbiAgICAgICAgICAgIGxldCBhMSA9ICgoY1tpXSAvIDE2Nzc3MjE2KSB8IDApO1xuICAgICAgICAgICAgciArPSByMSAqIHBbaV07XG4gICAgICAgICAgICBnICs9IGcxICogcFtpXTtcbiAgICAgICAgICAgIGIgKz0gYjEgKiBwW2ldO1xuICAgICAgICAgICAgYSArPSBhMSAqIHBbaV07XG4gICAgICAgICAgICB0ICs9IHBbaV07XG4gICAgICAgIH1cblxuICAgICAgICB0ID0gMSAvIHQ7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKiB0KSAqIDE2Nzc3MjE2ICsgTWF0aC5yb3VuZChyICogdCkgKiA2NTUzNiArIE1hdGgucm91bmQoZyAqIHQpICogMjU2ICsgTWF0aC5yb3VuZChiICogdCk7XG4gICAgfTtcblxuICAgIHN0YXRpYyBtZXJnZU11bHRpQ29sb3JzRXF1YWwoYykge1xuICAgICAgICBsZXQgciA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDAsIHQgPSAwO1xuICAgICAgICBsZXQgbiA9IGMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGV0IHIxID0gKChjW2ldIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgICAgICBsZXQgZzEgPSAoKGNbaV0gLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgICAgICBsZXQgYjEgPSBjW2ldICUgMjU2O1xuICAgICAgICAgICAgbGV0IGExID0gKChjW2ldIC8gMTY3NzcyMTYpIHwgMCk7XG4gICAgICAgICAgICByICs9IHIxO1xuICAgICAgICAgICAgZyArPSBnMTtcbiAgICAgICAgICAgIGIgKz0gYjE7XG4gICAgICAgICAgICBhICs9IGExO1xuICAgICAgICAgICAgdCArPSAxLjA7XG4gICAgICAgIH1cblxuICAgICAgICB0ID0gMSAvIHQ7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKiB0KSAqIDE2Nzc3MjE2ICsgTWF0aC5yb3VuZChyICogdCkgKiA2NTUzNiArIE1hdGgucm91bmQoZyAqIHQpICogMjU2ICsgTWF0aC5yb3VuZChiICogdCk7XG4gICAgfTtcblxuICAgIHN0YXRpYyBtZXJnZUNvbG9yQWxwaGEoYywgYWxwaGEpIHtcbiAgICAgICAgbGV0IGEgPSAoKGMgLyAxNjc3NzIxNiB8IDApICogYWxwaGEpIHwgMDtcbiAgICAgICAgcmV0dXJuICgoKCgoYyA+PiAxNikgJiAweGZmKSAqIGEpIC8gMjU1KSAmIDB4ZmYpICtcbiAgICAgICAgICAgICgoKChjICYgMHhmZjAwKSAqIGEpIC8gMjU1KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICAgKCgoKChjICYgMHhmZikgPDwgMTYpICogYSkgLyAyNTUpICYgMHhmZjAwMDApICtcbiAgICAgICAgICAgIChhIDw8IDI0KTtcbiAgICB9O1xuXG4gICAgc3RhdGljIHJhZChkZWcpIHtcbiAgICAgICAgcmV0dXJuIGRlZyAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFRpbWluZ0JlemllcihhLCBiLCBjLCBkKSB7XG4gICAgICAgIGxldCB4YyA9IDMuMCAqIGE7XG4gICAgICAgIGxldCB4YiA9IDMuMCAqIChjIC0gYSkgLSB4YztcbiAgICAgICAgbGV0IHhhID0gMS4wIC0geGMgLSB4YjtcbiAgICAgICAgbGV0IHljID0gMy4wICogYjtcbiAgICAgICAgbGV0IHliID0gMy4wICogKGQgLSBiKSAtIHljO1xuICAgICAgICBsZXQgeWEgPSAxLjAgLSB5YyAtIHliO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgaWYgKHRpbWUgPj0gMS4wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB0ID0gMC41LCBjYngsIGNieGQsIGR4O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpdCA9IDA7IGl0IDwgMjA7IGl0KyspIHtcbiAgICAgICAgICAgICAgICBjYnggPSB0ICogKHQgKiAodCAqIHhhICsgeGIpICsgeGMpO1xuICAgICAgICAgICAgICAgIGR4ID0gdGltZSAtIGNieDtcbiAgICAgICAgICAgICAgICBpZiAoZHggPiAtMWUtOCAmJiBkeCA8IDFlLTgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgKiAodCAqICh0ICogeWEgKyB5YikgKyB5Yyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ3ViaWMgYmV6aWVyIGRlcml2YXRpdmUuXG4gICAgICAgICAgICAgICAgY2J4ZCA9IHQgKiAodCAqICgzICogeGEpICsgMiAqIHhiKSArIHhjO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNieGQgPiAxZS0xMCAmJiBjYnhkIDwgMWUtMTApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvYmxlbWF0aWMuIEZhbGwgYmFjayB0byBiaW5hcnkgc2VhcmNoIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdCArPSBkeCAvIGNieGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBiaW5hcnkgc2VhcmNoIG1ldGhvZC4gVGhpcyBpcyBtb3JlIHJlbGlhYmxlIHdoZW4gdGhlcmUgYXJlIG5lYXItMCBzbG9wZXMuXG4gICAgICAgICAgICBsZXQgbWluVCA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4VCA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCBpdCA9IDA7IGl0IDwgMjA7IGl0KyspIHtcbiAgICAgICAgICAgICAgICB0ID0gMC41ICogKG1pblQgKyBtYXhUKTtcblxuICAgICAgICAgICAgICAgIGNieCA9IHQgKiAodCAqICh0ICogeGEgKyB4YikgKyB4Yyk7XG5cbiAgICAgICAgICAgICAgICBkeCA9IHRpbWUgLSBjYng7XG4gICAgICAgICAgICAgICAgaWYgKGR4ID4gLTFlLTggJiYgZHggPCAxZS04KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbHV0aW9uIGZvdW5kIVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAqICh0ICogKHQgKiB5YSArIHliKSArIHljKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFQgPSB0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblQgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0VGltaW5nRnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHN3aXRjaCAoc3RyKSB7XG4gICAgICAgICAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJlYXNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0YWdlVXRpbHMuZ2V0VGltaW5nQmV6aWVyKDAuMjUsIDAuMSwgMC4yNSwgMS4wKTtcbiAgICAgICAgICAgIGNhc2UgXCJlYXNlLWluXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0YWdlVXRpbHMuZ2V0VGltaW5nQmV6aWVyKDAuNDIsIDAsIDEuMCwgMS4wKTtcbiAgICAgICAgICAgIGNhc2UgXCJlYXNlLW91dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdGFnZVV0aWxzLmdldFRpbWluZ0JlemllcigwLCAwLCAwLjU4LCAxLjApO1xuICAgICAgICAgICAgY2FzZSBcImVhc2UtaW4tb3V0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0YWdlVXRpbHMuZ2V0VGltaW5nQmV6aWVyKDAuNDIsIDAsIDAuNTgsIDEuMCk7XG4gICAgICAgICAgICBjYXNlIFwic3RlcC1zdGFydFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJzdGVwLWVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZSA9PT0gMSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxldCBzID0gXCJjdWJpYy1iZXppZXIoXCI7XG4gICAgICAgICAgICAgICAgaWYgKHN0ciAmJiBzdHIuaW5kZXhPZihzKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydHMgPSBzdHIuc3Vic3RyKHMubGVuZ3RoLCBzdHIubGVuZ3RoIC0gcy5sZW5ndGggLSAxKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIFVua25vd24gdGltaW5nIGZ1bmN0aW9uOiBcIiArIHN0cik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiB1c2UgbGluZWFyLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGEgPSBwYXJzZUZsb2F0KHBhcnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGIgPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGMgPSBwYXJzZUZsb2F0KHBhcnRzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSBwYXJzZUZsb2F0KHBhcnRzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGEpIHx8IGlzTmFOKGIpIHx8IGlzTmFOKGMpIHx8IGlzTmFOKGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBVbmtub3duIHRpbWluZyBmdW5jdGlvbjogXCIgKyBzdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IHVzZSBsaW5lYXIuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdGFnZVV0aWxzLmdldFRpbWluZ0JlemllcihhLCBiLCBjLCBkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBVbmtub3duIHRpbWluZyBmdW5jdGlvbjogXCIgKyBzdHIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjazogdXNlIGxpbmVhci5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmUge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdGFnZX0gc3RhZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gdGhpcy5zdGFnZS50ZXh0dXJlTWFuYWdlcjtcblxuICAgICAgICB0aGlzLmlkID0gVGV4dHVyZS5pZCsrO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgZW5hYmxlZCBlbGVtZW50cyB0aGF0IHVzZSB0aGlzIHRleHR1cmUgb2JqZWN0IChlaXRoZXIgYXMgdGV4dHVyZSBvciBkaXNwbGF5ZWRUZXh0dXJlKS5cbiAgICAgICAgICogQHR5cGUge1NldDxFbGVtZW50Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZW5hYmxlZCBlbGVtZW50cyB0aGF0IGFyZSBhY3RpdmUuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hY3RpdmVDb3VudCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhc3NvY2lhdGVkIHRleHR1cmUgc291cmNlLlxuICAgICAgICAgKiBTaG91bGQgbm90IGJlIGNoYW5nZWQuXG4gICAgICAgICAqIEB0eXBlIHtUZXh0dXJlU291cmNlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZXNpemUgbW9kZSBjYW4gYmUgc2V0IHRvIGNvdmVyIG9yIGNvbnRhaW4gYSBjZXJ0YWluIGFyZWEuXG4gICAgICAgICAqIEl0IHdpbGwgcmVzZXQgdGhlIHRleHR1cmUgY2xpcHBpbmcgc2V0dGluZ3MuXG4gICAgICAgICAqIFdoZW4gbWFudWFsIHRleHR1cmUgY2xpcHBpbmcgaXMgcGVyZm9ybWVkLCB0aGUgcmVzaXplTW9kZSBpcyByZXNldC5cbiAgICAgICAgICogQHR5cGUge3t0eXBlOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc2l6ZU1vZGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSBjbGlwcGluZyB4LW9mZnNldC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSBjbGlwcGluZyB5LW9mZnNldC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3kgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSBjbGlwcGluZyB3aWR0aC4gSWYgMCB0aGVuIGZ1bGwgd2lkdGguXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl93ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgY2xpcHBpbmcgaGVpZ2h0LiBJZiAwIHRoZW4gZnVsbCBoZWlnaHQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHByZWNpc2lvbiAoMC41ID0gZnV6enksIDEgPSBub3JtYWwsIDIgPSBzaGFycCBldmVuIHdoZW4gc2NhbGVkIHR3aWNlLCBldGMuKS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAobWF4aW11bSkgZXhwZWN0ZWQgdGV4dHVyZSBzb3VyY2Ugd2lkdGguIFVzZWQgZm9yIHdpdGhpbiBib3VuZHMgZGV0ZXJtaW5hdGlvbiB3aGlsZSB0ZXh0dXJlIGlzIG5vdCB5ZXQgbG9hZGVkLlxuICAgICAgICAgKiBJZiBub3Qgc2V0LCAyMDQ4IGlzIHVzZWQgYnkgRWxlbWVudENvcmUudXBkYXRlLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdyA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAobWF4aW11bSkgZXhwZWN0ZWQgdGV4dHVyZSBzb3VyY2UgaGVpZ2h0LiBVc2VkIGZvciB3aXRoaW4gYm91bmRzIGRldGVybWluYXRpb24gd2hpbGUgdGV4dHVyZSBpcyBub3QgeWV0IGxvYWRlZC5cbiAgICAgICAgICogSWYgbm90IHNldCwgMjA0OCBpcyB1c2VkIGJ5IEVsZW1lbnRDb3JlLnVwZGF0ZS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgVGV4dHVyZS5wcm90b3R5cGUudGV4dHVyZSB1c2VzIGNsaXBwaW5nLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xpcHBpbmcgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0ZXh0dXJlIG11c3QgdXBkYXRlICh3aGVuIGl0IGJlY29tZXMgdXNlZCBhZ2FpbikuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbXVzdFVwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgICBpZiAodGhpcy5fbXVzdFVwZGF0ZSB8fCB0aGlzLnN0YWdlLmhhc1VwZGF0ZVNvdXJjZVRleHR1cmUodGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTb3VyY2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLnJlbW92ZVVwZGF0ZVNvdXJjZVRleHR1cmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgICB9XG5cbiAgICBhZGRFbGVtZW50KHYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnRzLmhhcyh2KSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5hZGQodik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5hZGRUZXh0dXJlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHYuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNBY3RpdmVDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlRWxlbWVudCh2KSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLmRlbGV0ZSh2KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLnJlbW92ZVRleHR1cmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodi5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY0FjdGl2ZUNvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbmNBY3RpdmVDb3VudCgpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGV4dHVyZSBzb3VyY2UncyBhY3RpdmVDb3VudCBoYXMgdHJhbnNmZXJyZWQgb3duZXJzaGlwLlxuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcblxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0Zvck5ld2VyUmV1c2FibGVUZXh0dXJlU291cmNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmVDb3VudCsrO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuYmVjb21lc1VzZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlY0FjdGl2ZUNvdW50KCkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTsgLy8gRm9yY2UgdXBkYXRpbmcgdGhlIHNvdXJjZS5cbiAgICAgICAgdGhpcy5fYWN0aXZlQ291bnQtLTtcbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmVDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5iZWNvbWVzVW51c2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiZWNvbWVzVXNlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5pbmNBY3RpdmVUZXh0dXJlQ291bnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTG9hZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZU1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UmVzaXplTW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5vblRleHR1cmVTb3VyY2VMb2FkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NoZWNrRm9yTmV3ZXJSZXVzYWJsZVRleHR1cmVTb3VyY2UoKSB7XG4gICAgICAgIC8vIFdoZW4gdGhpcyBzb3VyY2UgYmVjYW1lIHVudXNlZCBhbmQgY2xlYW5lZCB1cCwgaXQgbWF5IGhhdmUgZGlzYXBwZWFyZWQgZnJvbSB0aGUgcmV1c2FibGUgdGV4dHVyZSBtYXAuXG4gICAgICAgIC8vIEluIHRoZSBtZWFudGltZSBhbm90aGVyIHRleHR1cmUgbWF5IGhhdmUgYmVlbiBnZW5lcmF0ZWQgbG9hZGVkIHdpdGggdGhlIHNhbWUgbG9va3VwIGlkLlxuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBjYXNlLCB1c2UgdGhhdCBvbmUgaW5zdGVhZCB0byBtYWtlIHN1cmUgb25seSBvbmUgYWN0aXZlIHRleHR1cmUgc291cmNlIHBlciBsb29rdXAgaWQgZXhpc3RzLlxuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKCFzb3VyY2UuaXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgcmV1c2FibGUgPSB0aGlzLl9nZXRSZXVzYWJsZVRleHR1cmVTb3VyY2UoKTtcbiAgICAgICAgICAgIGlmIChyZXVzYWJsZSAmJiByZXVzYWJsZS5pc0xvYWRlZCgpICYmIChyZXVzYWJsZSAhPT0gc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VUZXh0dXJlU291cmNlKHJldXNhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXNpemVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlSZXNpemVNb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiZWNvbWVzVW51c2VkKCkge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLmRlY0FjdGl2ZVRleHR1cmVDb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNVc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlQ291bnQgPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvb2t1cCBpZCBmb3IgdGhlIGN1cnJlbnQgdGV4dHVyZSBzZXR0aW5ncywgdG8gYmUgYWJsZSB0byByZXVzZSBpdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgX2dldExvb2t1cElkKCkge1xuICAgICAgICAvLyBEZWZhdWx0OiBkbyBub3QgcmV1c2UgdGV4dHVyZS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbG9hZGVyIGZ1bmN0aW9uIHRoYXQgaXMgYWJsZSB0byBnZW5lcmF0ZSB0aGUgdGV4dHVyZSBmb3IgdGhlIGN1cnJlbnQgc2V0dGluZ3Mgb2YgdGhpcyB0ZXh0dXJlLlxuICAgICAqIEl0IHNob3VsZCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgc2luZ2xlIGNhbGxiYWNrIGFyZ3VtZW50LlxuICAgICAqIFRoYXQgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxuICAgICAqICAgLSBlcnJcbiAgICAgKiAgIC0gb3B0aW9uczogb2JqZWN0XG4gICAgICogICAgIC0gc291cmNlOiBBcnJheUJ1ZmZlcnxXZWJHbFRleHR1cmV8SW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxJbWFnZUJpdG1hcFxuICAgICAqICAgICAtIHc6IE51bWJlclxuICAgICAqICAgICAtIGg6IE51bWJlclxuICAgICAqICAgICAtIHBlcm1hbmVudDogQm9vbGVhblxuICAgICAqICAgICAtIGhhc0FscGhhOiBib29sZWFuXG4gICAgICogICAgIC0gcGVybXVsdGlwbHlBbHBoYTogYm9vbGVhblxuICAgICAqICAgICAtIGZsaXBCbHVlUmVkOiBib29sZWFuXG4gICAgICogICAgIC0gcmVuZGVySW5mbzogb2JqZWN0XG4gICAgICogVGhlIGxvYWRlciBpdHNlbGYgbWF5IHJldHVybiBhIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gbG9hZGluZyBvZiB0aGUgdGV4dHVyZSBpcyBjYW5jZWxsZWQuIFRoaXMgY2FuIGJlIHVzZWRcbiAgICAgKiB0byBzdG9wIGZldGNoaW5nIGFuIGltYWdlIHdoZW4gaXQgaXMgbm8gbG9uZ2VyIGluIGVsZW1lbnQsIGZvciBleGFtcGxlLlxuICAgICAqL1xuICAgIF9nZXRTb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRleHR1cmUuZ2VuZXJhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuXG4gICAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRJc1ZhbGlkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGV4dHVyZSBpcyBub3QgJ3ZhbGlkJywgbm8gc291cmNlIGNhbiBiZSBjcmVhdGVkIGZvciBpdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfZ2V0SXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0ZXh0dXJlIHNvdXJjZSBtdXN0IGJlIHJlLWdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICBfY2hhbmdlZCgpIHtcbiAgICAgICAgLy8gSWYgbm8gZWxlbWVudCBpcyBhY3RpdmVseSB1c2luZyB0aGlzIHRleHR1cmUsIGlnbm9yZSBpdCBhbHRvZ2V0aGVyLlxuICAgICAgICBpZiAodGhpcy5pc1VzZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tdXN0VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVTb3VyY2UoKSB7XG4gICAgICAgIC8vIFdlIGRlbGF5IGFsbCB1cGRhdGVTb3VyY2UgY2FsbHMgdG8gdGhlIG5leHQgZHJhd0ZyYW1lLCBzbyB0aGF0IHdlIGNhbiBidW5kbGUgdGhlbS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG1heSByZWxvYWQgYSB0ZXh0dXJlIG1vcmUgb2Z0ZW4gdGhhbiBuZWNlc3NhcnksIHdoZW4sIGZvciBleGFtcGxlLCBwYXRjaGluZyBtdWx0aXBsZSB0ZXh0XG4gICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkVXBkYXRlU291cmNlVGV4dHVyZSh0aGlzKTtcbiAgICB9XG5cbiAgICBfcGVyZm9ybVVwZGF0ZVNvdXJjZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIElmLCBpbiB0aGUgbWVhbnRpbWUsIHRoZSB0ZXh0dXJlIHdhcyBubyBsb25nZXIgdXNlZCwganVzdCByZW1lbWJlciB0aGF0IGl0IG11c3QgdXBkYXRlIHVudGlsIGl0IGJlY29tZXMgdXNlZFxuICAgICAgICAvLyBhZ2Fpbi5cbiAgICAgICAgaWYgKGZvcmNlIHx8IHRoaXMuaXNVc2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX211c3RVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSB0aGlzLl9nZXRUZXh0dXJlU291cmNlKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlVGV4dHVyZVNvdXJjZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFRleHR1cmVTb3VyY2UoKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fZ2V0SXNWYWxpZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBsb29rdXBJZCA9IHRoaXMuX2dldExvb2t1cElkKCk7XG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9nZXRSZXVzYWJsZVRleHR1cmVTb3VyY2UobG9va3VwSWQpO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGlzLm1hbmFnZXIuZ2V0VGV4dHVyZVNvdXJjZSh0aGlzLl9nZXRTb3VyY2VMb2FkZXIoKSwgbG9va3VwSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgX2dldFJldXNhYmxlVGV4dHVyZVNvdXJjZShsb29rdXBJZCA9IHRoaXMuX2dldExvb2t1cElkKCkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dldElzVmFsaWQoKSkge1xuICAgICAgICAgICAgaWYgKGxvb2t1cElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRSZXVzYWJsZVRleHR1cmVTb3VyY2UobG9va3VwSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9yZXBsYWNlVGV4dHVyZVNvdXJjZShuZXdTb3VyY2UgPSBudWxsKSB7XG4gICAgICAgIGxldCBvbGRTb3VyY2UgPSB0aGlzLl9zb3VyY2U7XG5cbiAgICAgICAgdGhpcy5fc291cmNlID0gbmV3U291cmNlO1xuXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLnNpemUpIHtcbiAgICAgICAgICAgIGlmIChvbGRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkU291cmNlLmRlY0FjdGl2ZVRleHR1cmVDb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9sZFNvdXJjZS5yZW1vdmVUZXh0dXJlKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3U291cmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gTXVzdCBoYXBwZW4gYmVmb3JlIHNldERpc3BsYXllZFRleHR1cmUgdG8gZW5zdXJlIHNwcml0ZSBtYXAgdGV4Y29vcmRzIGFyZSB1c2VkLlxuICAgICAgICAgICAgICAgIG5ld1NvdXJjZS5hZGRUZXh0dXJlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTb3VyY2UuaW5jQWN0aXZlVGV4dHVyZUNvdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNVc2VkKCkpIHtcbiAgICAgICAgICAgIGlmIChuZXdTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3U291cmNlLmlzTG9hZGVkKCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSByZXNpemVNb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZXNpemVNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVJlc2l6ZU1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuX3NldERpc3BsYXllZFRleHR1cmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRFcnJvciA9IG5ld1NvdXJjZS5sb2FkRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vblRleHR1cmVTb3VyY2VMb2FkRXJyb3IobG9hZEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuX3NldERpc3BsYXllZFRleHR1cmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWQoKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHNvdXJjZSBpcyB1cCB0byBkYXRlLlxuICAgICAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2UubG9hZCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzTG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5pc0xvYWRlZCgpO1xuICAgIH1cblxuICAgIGdldCBsb2FkRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLmxvYWRFcnJvcjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2UuZnJlZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IHJlc2l6ZU1vZGUoe3R5cGUgPSBcImNvdmVyXCIsIHcgPSAwLCBoID0gMCwgY2xpcFggPSAwLjUsIGNsaXBZID0gMC41fSkge1xuICAgICAgICB0aGlzLl9yZXNpemVNb2RlID0ge3R5cGUsIHcsIGgsIGNsaXBYLCBjbGlwWX07XG4gICAgICAgIGlmICh0aGlzLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UmVzaXplTW9kZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHJlc2l6ZU1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNpemVNb2RlO1xuICAgIH1cblxuICAgIF9jbGVhclJlc2l6ZU1vZGUoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZU1vZGUgPSBudWxsO1xuICAgIH1cblxuICAgIF9hcHBseVJlc2l6ZU1vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXNpemVNb2RlLnR5cGUgPT09IFwiY292ZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlSZXNpemVDb3ZlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3Jlc2l6ZU1vZGUudHlwZSA9PT0gXCJjb250YWluXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UmVzaXplQ29udGFpbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByZWNpc2lvbigpO1xuICAgICAgICB0aGlzLl91cGRhdGVDbGlwcGluZygpO1xuICAgIH1cblxuICAgIF9hcHBseVJlc2l6ZUNvdmVyKCkge1xuICAgICAgICBjb25zdCBzY2FsZVggPSB0aGlzLl9yZXNpemVNb2RlLncgLyB0aGlzLl9zb3VyY2UudztcbiAgICAgICAgY29uc3Qgc2NhbGVZID0gdGhpcy5fcmVzaXplTW9kZS5oIC8gdGhpcy5fc291cmNlLmg7XG4gICAgICAgIGxldCBzY2FsZSA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgaWYgKCFzY2FsZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSAxL3NjYWxlO1xuICAgICAgICBpZiAoc2NhbGVYICYmIHNjYWxlWCA8IHNjYWxlKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNpcmVkU2l6ZSA9IHRoaXMuX3ByZWNpc2lvbiAqIHRoaXMuX3Jlc2l6ZU1vZGUudztcbiAgICAgICAgICAgIGNvbnN0IGNob3BwZWRPZmZQaXhlbHMgPSB0aGlzLl9zb3VyY2UudyAtIGRlc2lyZWRTaXplO1xuICAgICAgICAgICAgdGhpcy5feCA9IGNob3BwZWRPZmZQaXhlbHMgKiB0aGlzLl9yZXNpemVNb2RlLmNsaXBYO1xuICAgICAgICAgICAgdGhpcy5fdyA9IHRoaXMuX3NvdXJjZS53IC0gY2hvcHBlZE9mZlBpeGVscztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NhbGVZICYmIHNjYWxlWSA8IHNjYWxlKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNpcmVkU2l6ZSA9IHRoaXMuX3ByZWNpc2lvbiAqIHRoaXMuX3Jlc2l6ZU1vZGUuaDtcbiAgICAgICAgICAgIGNvbnN0IGNob3BwZWRPZmZQaXhlbHMgPSB0aGlzLl9zb3VyY2UuaCAtIGRlc2lyZWRTaXplO1xuICAgICAgICAgICAgdGhpcy5feSA9IGNob3BwZWRPZmZQaXhlbHMgKiB0aGlzLl9yZXNpemVNb2RlLmNsaXBZO1xuICAgICAgICAgICAgdGhpcy5faCA9IHRoaXMuX3NvdXJjZS5oIC0gY2hvcHBlZE9mZlBpeGVscztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hcHBseVJlc2l6ZUNvbnRhaW4oKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlWCA9IHRoaXMuX3Jlc2l6ZU1vZGUudyAvIHRoaXMuX3NvdXJjZS53O1xuICAgICAgICBjb25zdCBzY2FsZVkgPSB0aGlzLl9yZXNpemVNb2RlLmggLyB0aGlzLl9zb3VyY2UuaDtcbiAgICAgICAgbGV0IHNjYWxlID0gc2NhbGVYO1xuICAgICAgICBpZiAoIXNjYWxlIHx8IHNjYWxlWSA8IHNjYWxlKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNjYWxlKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IDEvc2NhbGU7XG4gICAgfVxuXG4gICAgZW5hYmxlQ2xpcHBpbmcoeCwgeSwgdywgaCkge1xuICAgICAgICB0aGlzLl9jbGVhclJlc2l6ZU1vZGUoKTtcblxuICAgICAgICB4ICo9IHRoaXMuX3ByZWNpc2lvbjtcbiAgICAgICAgeSAqPSB0aGlzLl9wcmVjaXNpb247XG4gICAgICAgIHcgKj0gdGhpcy5fcHJlY2lzaW9uO1xuICAgICAgICBoICo9IHRoaXMuX3ByZWNpc2lvbjtcbiAgICAgICAgaWYgKHRoaXMuX3ggIT09IHggfHwgdGhpcy5feSAhPT0geSB8fCB0aGlzLl93ICE9PSB3IHx8IHRoaXMuX2ggIT09IGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgICAgICB0aGlzLl93ID0gdztcbiAgICAgICAgICAgIHRoaXMuX2ggPSBoO1xuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDbGlwcGluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2FibGVDbGlwcGluZygpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJSZXNpemVNb2RlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3ggfHwgdGhpcy5feSB8fCB0aGlzLl93IHx8IHRoaXMuX2gpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICAgICAgICB0aGlzLl93ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2ggPSAwO1xuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDbGlwcGluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZUNsaXBwaW5nKCkge1xuICAgICAgICB0aGlzLmNsaXBwaW5nID0gISEodGhpcy5feCB8fCB0aGlzLl95IHx8IHRoaXMuX3cgfHwgdGhpcy5faCk7XG5cbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGlmIG5vdCB0aGUgY3VycmVudGx5IGRpc3BsYXllZCB0ZXh0dXJlLlxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuZGlzcGxheWVkVGV4dHVyZSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQub25EaXNwbGF5ZWRUZXh0dXJlQ2xpcHBpbmdDaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF91cGRhdGVQcmVjaXNpb24oKSB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBpZiBub3QgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgdGV4dHVyZS5cbiAgICAgICAgICAgIGlmIChlbGVtZW50LmRpc3BsYXllZFRleHR1cmUgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9uUHJlY2lzaW9uQ2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXROb25EZWZhdWx0cygpIHtcbiAgICAgICAgbGV0IG5vbkRlZmF1bHRzID0ge307XG4gICAgICAgIG5vbkRlZmF1bHRzWyd0eXBlJ10gPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLnggIT09IDApIG5vbkRlZmF1bHRzWyd4J10gPSB0aGlzLng7XG4gICAgICAgIGlmICh0aGlzLnkgIT09IDApIG5vbkRlZmF1bHRzWyd5J10gPSB0aGlzLnk7XG4gICAgICAgIGlmICh0aGlzLncgIT09IDApIG5vbkRlZmF1bHRzWyd3J10gPSB0aGlzLnc7XG4gICAgICAgIGlmICh0aGlzLmggIT09IDApIG5vbkRlZmF1bHRzWydoJ10gPSB0aGlzLmg7XG4gICAgICAgIGlmICh0aGlzLnByZWNpc2lvbiAhPT0gMSkgbm9uRGVmYXVsdHNbJ3ByZWNpc2lvbiddID0gdGhpcy5wcmVjaXNpb247XG4gICAgICAgIHJldHVybiBub25EZWZhdWx0cztcbiAgICB9XG5cbiAgICBnZXQgcHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH1cblxuICAgIGdldCBweSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfVxuXG4gICAgZ2V0IHB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdztcbiAgICB9XG5cbiAgICBnZXQgcGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oO1xuICAgIH1cblxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feCAvIHRoaXMuX3ByZWNpc2lvbjtcbiAgICB9XG4gICAgc2V0IHgodikge1xuICAgICAgICB0aGlzLl9jbGVhclJlc2l6ZU1vZGUoKTtcbiAgICAgICAgdiA9IHYgKiB0aGlzLl9wcmVjaXNpb247XG4gICAgICAgIGlmICh0aGlzLl94ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsaXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3kgLyB0aGlzLl9wcmVjaXNpb247XG4gICAgfVxuICAgIHNldCB5KHYpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJSZXNpemVNb2RlKCk7XG4gICAgICAgIHYgPSB2ICogdGhpcy5fcHJlY2lzaW9uO1xuICAgICAgICBpZiAodGhpcy5feSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5feSA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDbGlwcGluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93IC8gdGhpcy5fcHJlY2lzaW9uO1xuICAgIH1cblxuICAgIHNldCB3KHYpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJSZXNpemVNb2RlKCk7XG4gICAgICAgIHYgPSB2ICogdGhpcy5fcHJlY2lzaW9uO1xuICAgICAgICBpZiAodGhpcy5fdyAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fdyA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDbGlwcGluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oIC8gdGhpcy5fcHJlY2lzaW9uO1xuICAgIH1cblxuICAgIHNldCBoKHYpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJSZXNpemVNb2RlKCk7XG4gICAgICAgIHYgPSB2ICogdGhpcy5fcHJlY2lzaW9uO1xuICAgICAgICBpZiAodGhpcy5faCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5faCA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDbGlwcGluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHByZWNpc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBzZXQgcHJlY2lzaW9uKHYpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJSZXNpemVNb2RlKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcmVjaXNpb24gIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQcmVjaXNpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzQXV0b3NpemVUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXV0b3NpemVUZXh0dXJlKCkpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgdGhlIHJlY3RhbmdsZSB0ZXh0dXJlLCB3ZSdkIHByZWZlciB0byBub3QgY2F1c2UgYSAxeDEgdyxoIGFzIGl0IHdvdWxkIGludGVyZmVyZSB3aXRoIGZsZXggbGF5b3V0IGZpdC10by1jb250ZW50cy5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgZGltZW5zaW9ucyBhcmUgdW5rbm93biAodGV4dHVyZSBub3QgeWV0IGxvYWRlZCksIHVzZSBtYXhpbXVtIHdpZHRoIGFzIGEgZmFsbGJhY2sgYXMgcmVuZGVyIHdpZHRoIHRvIGFsbG93IHByb3BlciBib3VuZHMgY2hlY2tpbmcuXG4gICAgICAgIHJldHVybiAodGhpcy5fdyB8fCAodGhpcy5fc291cmNlID8gdGhpcy5fc291cmNlLmdldFJlbmRlcldpZHRoKCkgLSB0aGlzLl94IDogMCkpIC8gdGhpcy5fcHJlY2lzaW9uO1xuICAgIH1cblxuICAgIGdldFJlbmRlckhlaWdodCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXV0b3NpemVUZXh0dXJlKCkpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgdGhlIHJlY3RhbmdsZSB0ZXh0dXJlLCB3ZSdkIHByZWZlciB0byBub3QgY2F1c2UgYSAxeDEgdyxoIGFzIGl0IHdvdWxkIGludGVyZmVyZSB3aXRoIGZsZXggbGF5b3V0IGZpdC10by1jb250ZW50cy5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLl9oIHx8ICh0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2UuZ2V0UmVuZGVySGVpZ2h0KCkgLSB0aGlzLl95IDogMCkpIC8gdGhpcy5fcHJlY2lzaW9uO1xuICAgIH1cblxuICAgIHBhdGNoKHNldHRpbmdzKSB7XG4gICAgICAgIEJhc2UucGF0Y2hPYmplY3QodGhpcywgc2V0dGluZ3MpO1xuICAgIH1cblxufVxuXG5UZXh0dXJlLnByb3RvdHlwZS5pc1RleHR1cmUgPSB0cnVlO1xuXG5UZXh0dXJlLmlkID0gMDtcblxuaW1wb3J0IEJhc2UgZnJvbSBcIi4vQmFzZS5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBUZXh0dXJlU291cmNlIGZyb20gXCIuL1RleHR1cmVTb3VyY2UubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVNYW5hZ2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSB1c2VkIGFtb3VudCBvZiB0ZXh0dXJlIG1lbW9yeS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3VzZWRNZW1vcnkgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgdXBsb2FkZWQgdGV4dHVyZSBzb3VyY2VzLlxuICAgICAgICAgKiBAdHlwZSB7VGV4dHVyZVNvdXJjZVtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdXBsb2FkZWRUZXh0dXJlU291cmNlcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSBzb3VyY2UgbG9va3VwIGlkIHRvIHRleHR1cmUgc291cmNlIGhhc2htYXAuXG4gICAgICAgICAqIEB0eXBlIHtNYXA8U3RyaW5nLCBUZXh0dXJlU291cmNlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGV4dHVyZVNvdXJjZUhhc2htYXAgPSBuZXcgTWFwKCk7XG5cbiAgICB9XG5cbiAgICBnZXQgdXNlZE1lbW9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZWRNZW1vcnk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl91cGxvYWRlZFRleHR1cmVTb3VyY2VzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRnJlZVRleHR1cmVTb3VyY2UodGhpcy5fdXBsb2FkZWRUZXh0dXJlU291cmNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMudGV4dHVyZVNvdXJjZUhhc2htYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fdXNlZE1lbW9yeSA9IDA7XG4gICAgfVxuXG4gICAgZ2V0UmV1c2FibGVUZXh0dXJlU291cmNlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVTb3VyY2VIYXNobWFwLmdldChpZCk7XG4gICAgfVxuXG4gICAgZ2V0VGV4dHVyZVNvdXJjZShmdW5jLCBpZCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0ZXh0dXJlIHNvdXJjZSBpcyBhbHJlYWR5IGtub3duLlxuICAgICAgICBsZXQgdGV4dHVyZVNvdXJjZSA9IGlkID8gdGhpcy50ZXh0dXJlU291cmNlSGFzaG1hcC5nZXQoaWQpIDogbnVsbDtcbiAgICAgICAgaWYgKCF0ZXh0dXJlU291cmNlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRleHR1cmUgc291cmNlLlxuICAgICAgICAgICAgdGV4dHVyZVNvdXJjZSA9IG5ldyBUZXh0dXJlU291cmNlKHRoaXMsIGZ1bmMpO1xuXG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlU291cmNlLmxvb2t1cElkID0gaWQ7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlU291cmNlSGFzaG1hcC5zZXQoaWQsIHRleHR1cmVTb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmVTb3VyY2U7XG4gICAgfVxuXG4gICAgdXBsb2FkVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0ZXh0dXJlU291cmNlLmlzTG9hZGVkKCkpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9hZGRNZW1vcnlVc2FnZSh0ZXh0dXJlU291cmNlLncgKiB0ZXh0dXJlU291cmNlLmgpO1xuXG4gICAgICAgIC8vIExvYWQgdGV4dHVyZS5cbiAgICAgICAgY29uc3QgbmF0aXZlVGV4dHVyZSA9IHRoaXMuX25hdGl2ZVVwbG9hZFRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGV4dHVyZVNvdXJjZS5fbmF0aXZlVGV4dHVyZSA9IG5hdGl2ZVRleHR1cmU7XG5cbiAgICAgICAgLy8gV2UgYXR0YWNoIHcgYW5kIGggdG8gbmF0aXZlIHRleHR1cmUgKHdlIG5lZWQgaXQgaW4gQ29yZVJlbmRlclN0YXRlLl9pc1JlbmRlclRleHR1cmVSZXVzYWJsZSkuXG4gICAgICAgIG5hdGl2ZVRleHR1cmUudyA9IHRleHR1cmVTb3VyY2UudztcbiAgICAgICAgbmF0aXZlVGV4dHVyZS5oID0gdGV4dHVyZVNvdXJjZS5oO1xuXG4gICAgICAgIG5hdGl2ZVRleHR1cmUudXBkYXRlID0gdGhpcy5zdGFnZS5mcmFtZUNvdW50ZXI7XG5cbiAgICAgICAgdGhpcy5fdXBsb2FkZWRUZXh0dXJlU291cmNlcy5wdXNoKHRleHR1cmVTb3VyY2UpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5hZGRUb0xvb2t1cE1hcCh0ZXh0dXJlU291cmNlKTtcbiAgICB9XG5cbiAgICBfYWRkTWVtb3J5VXNhZ2UoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5fdXNlZE1lbW9yeSArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRNZW1vcnlVc2FnZShkZWx0YSk7XG4gICAgfVxuICAgIFxuICAgIGFkZFRvTG9va3VwTWFwKHRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgY29uc3QgbG9va3VwSWQgPSB0ZXh0dXJlU291cmNlLmxvb2t1cElkO1xuICAgICAgICBpZiAobG9va3VwSWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0dXJlU291cmNlSGFzaG1hcC5oYXMobG9va3VwSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlU291cmNlSGFzaG1hcC5zZXQobG9va3VwSWQsIHRleHR1cmVTb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2MoKSB7XG4gICAgICAgIHRoaXMuZnJlZVVudXNlZFRleHR1cmVTb3VyY2VzKCk7XG4gICAgICAgIHRoaXMuX2NsZWFudXBMb29rdXBNYXAoKTtcbiAgICB9XG4gICAgXG4gICAgZnJlZVVudXNlZFRleHR1cmVTb3VyY2VzKCkge1xuICAgICAgICBsZXQgcmVtYWluaW5nVGV4dHVyZVNvdXJjZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl91cGxvYWRlZFRleHR1cmVTb3VyY2VzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGV0IHRzID0gdGhpcy5fdXBsb2FkZWRUZXh0dXJlU291cmNlc1tpXTtcbiAgICAgICAgICAgIGlmICh0cy5hbGxvd0NsZWFudXAoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZyZWVNYW5hZ2VkVGV4dHVyZVNvdXJjZSh0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ1RleHR1cmVTb3VyY2VzLnB1c2godHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBsb2FkZWRUZXh0dXJlU291cmNlcyA9IHJlbWFpbmluZ1RleHR1cmVTb3VyY2VzO1xuXG4gICAgICAgIHRoaXMuX2NsZWFudXBMb29rdXBNYXAoKTtcbiAgICB9XG5cbiAgICBfZnJlZU1hbmFnZWRUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgaWYgKHRleHR1cmVTb3VyY2UuaXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRnJlZVRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRNZW1vcnlVc2FnZSgtdGV4dHVyZVNvdXJjZS53ICogdGV4dHVyZVNvdXJjZS5oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBiZSByZWxvYWRlZC5cbiAgICAgICAgdGV4dHVyZVNvdXJjZS5sb2FkaW5nU2luY2UgPSBudWxsO1xuICAgIH1cblxuICAgIF9jbGVhbnVwTG9va3VwTWFwKCkge1xuICAgICAgICAvLyBXZSBrZWVwIHRob3NlIHRoYXQgc3RpbGwgaGF2ZSB2YWx1ZSAoYXJlIGJlaW5nIGxvYWRlZCBvciBhbHJlYWR5IGxvYWRlZCwgb3IgYXJlIGxpa2VseSB0byBiZSByZXVzZWQpLlxuICAgICAgICB0aGlzLnRleHR1cmVTb3VyY2VIYXNobWFwLmZvckVhY2goKHRleHR1cmVTb3VyY2UsIGxvb2t1cElkKSA9PiB7XG4gICAgICAgICAgICBpZiAoISh0ZXh0dXJlU291cmNlLmlzTG9hZGVkKCkgfHwgdGV4dHVyZVNvdXJjZS5pc0xvYWRpbmcoKSkgJiYgIXRleHR1cmVTb3VyY2UuaXNVc2VkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVTb3VyY2VIYXNobWFwLmRlbGV0ZShsb29rdXBJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dGVybmFsbHkgZnJlZSB0ZXh0dXJlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gdGV4dHVyZVNvdXJjZVxuICAgICAqL1xuICAgIGZyZWVUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl91cGxvYWRlZFRleHR1cmVTb3VyY2VzLmluZGV4T2YodGV4dHVyZVNvdXJjZSk7XG4gICAgICAgIGNvbnN0IG1hbmFnZWQgPSAoaW5kZXggIT09IC0xKTtcblxuICAgICAgICBpZiAodGV4dHVyZVNvdXJjZS5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICBpZiAobWFuYWdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lbW9yeVVzYWdlKC10ZXh0dXJlU291cmNlLncgKiB0ZXh0dXJlU291cmNlLmgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZGVkVGV4dHVyZVNvdXJjZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUZyZWVUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdWxkIGJlIHJlbG9hZGVkLlxuICAgICAgICB0ZXh0dXJlU291cmNlLmxvYWRpbmdTaW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgX25hdGl2ZVVwbG9hZFRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFnZS5yZW5kZXJlci51cGxvYWRUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9uYXRpdmVGcmVlVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UucmVuZGVyZXIuZnJlZVRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSk7XG4gICAgICAgIHRleHR1cmVTb3VyY2UuY2xlYXJOYXRpdmVUZXh0dXJlKCk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlU291cmNlIHtcblxuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGxvYWRlciA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5pZCA9IFRleHR1cmVTb3VyY2UuaWQrKztcblxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuXG4gICAgICAgIHRoaXMuc3RhZ2UgPSBtYW5hZ2VyLnN0YWdlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgZW5hYmxlZCB0ZXh0dXJlcyAodGV4dHVyZXMgdGhhdCBhcmUgdXNlZCBieSB2aXNpYmxlIGVsZW1lbnRzKS5cbiAgICAgICAgICogQHR5cGUge1NldDxUZXh0dXJlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgYWN0aXZlIHRleHR1cmVzICh0ZXh0dXJlcyB0aGF0IGhhdmUgYXQgbGVhc3Qgb25lIGFjdGl2ZSBlbGVtZW50KS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVDb3VudCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmYWN0b3J5IGZvciB0aGUgc291cmNlIG9mIHRoaXMgdGV4dHVyZS5cbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpZXIgZm9yIHJldXNlLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb29rdXBJZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCwgdGhpcy5pcyBjYWxsZWQgd2hlbiB0aGUgdGV4dHVyZSBzb3VyY2UgaXMgbm8gbG9uZ2VyIGRpc3BsYXllZCAodGhpcy5jb21wb25lbnRzLnNpemUgYmVjb21lcyAwKS5cbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2FuY2VsQ2IgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkaW5nIHNpbmNlIHRpbWVzdGFtcCBpbiBtaWxsaXMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvYWRpbmdTaW5jZSA9IDA7XG5cbiAgICAgICAgdGhpcy53ID0gMDtcbiAgICAgICAgdGhpcy5oID0gMDtcblxuICAgICAgICB0aGlzLl9uYXRpdmVUZXh0dXJlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlbiB0aGlzLnRleHR1cmUgc291cmNlIGlzIG5ldmVyIGZyZWVkIGZyb20gbWVtb3J5IGR1cmluZyBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZXJtYW5lbnQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3ViLW9iamVjdCB3aXRoIHRleHR1cmUtc3BlY2lmaWMgcmVuZGVyaW5nIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBGb3IgaW1hZ2VzLCBjb250YWlucyB0aGUgc3JjIHByb3BlcnR5LCBmb3IgdGV4dHMsIGNvbnRhaW5zIGhhbmR5IHJlbmRlcmluZyBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVySW5mbyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlZCBmb3IgJ3JlbmRlclRvVGV4dHVyZScuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXNSZXN1bHRUZXh0dXJlID0gIXRoaXMubG9hZGVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250YWlucyB0aGUgbG9hZCBlcnJvciwgaWYgdGhlIHRleHR1cmUgc291cmNlIGNvdWxkIHByZXZpb3VzbHkgbm90IGJlIGxvYWRlZC5cbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWRFcnJvciA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICBIb2xkIGEgcmVmZXJlbmNlIHRvIHRoZSBqYXZhc2NyaXB0IHZhcmlhYmxlIHdoaWNoIGNvbnRhaW5zIHRoZSB0ZXh0dXJlLCB0aGlzIGlzIG5vdCByZXF1aXJlZCBmb3IgV2ViR0wgaW4gV2ViQnJvd3NlcnMgYnV0IGlzIHJlcXVpcmVkIGZvciBTcGFyayBydW50aW1lLlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW1hZ2VSZWYgPSBudWxsO1xuXG4gICAgfVxuXG4gICAgZ2V0IGxvYWRFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRFcnJvcjtcbiAgICB9XG5cbiAgICBhZGRUZXh0dXJlKHYpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRleHR1cmVzLmhhcyh2KSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlcy5hZGQodik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVUZXh0dXJlKHYpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5kZWxldGUodik7XG4gICAgfVxuXG4gICAgaW5jQWN0aXZlVGV4dHVyZUNvdW50KCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlQ291bnQrKztcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRleHR1cmVDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5iZWNvbWVzVXNlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVjQWN0aXZlVGV4dHVyZUNvdW50KCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlQ291bnQtLTtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRleHR1cmVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5iZWNvbWVzVW51c2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaXNSZXN1bHRUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNSZXN1bHRUZXh0dXJlO1xuICAgIH1cblxuICAgIHNldCBpc1Jlc3VsdFRleHR1cmUodikge1xuICAgICAgICB0aGlzLl9pc1Jlc3VsdFRleHR1cmUgPSB2O1xuICAgIH1cblxuICAgIGZvckVhY2hFbmFibGVkRWxlbWVudChjYikge1xuICAgICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG4gICAgICAgICAgICB0ZXh0dXJlLmVsZW1lbnRzLmZvckVhY2goY2IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYXNFbmFibGVkRWxlbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVzLnNpemUgPiAwO1xuICAgIH1cblxuICAgIGZvckVhY2hBY3RpdmVFbGVtZW50KGNiKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcbiAgICAgICAgICAgIHRleHR1cmUuZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldFJlbmRlcldpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53O1xuICAgIH1cblxuICAgIGdldFJlbmRlckhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaDtcbiAgICB9XG5cbiAgICBhbGxvd0NsZWFudXAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5wZXJtYW5lbnQgJiYgIXRoaXMuaXNVc2VkKCk7XG4gICAgfVxuXG4gICAgYmVjb21lc1VzZWQoKSB7XG4gICAgICAgIC8vIEV2ZW4gd2hpbGUgdGhlIHRleHR1cmUgaXMgYmVpbmcgbG9hZGVkLCBtYWtlIHN1cmUgaXQgaXMgb24gdGhlIGxvb2t1cCBtYXAgc28gdGhhdCBvdGhlcnMgY2FuIHJldXNlIGl0LlxuICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICB9XG5cbiAgICBiZWNvbWVzVW51c2VkKCkge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW5jZWxDYikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbENiKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgY2FsbGJhY2sgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbENiID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1NpbmNlID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzTG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9uYXRpdmVUZXh0dXJlO1xuICAgIH1cblxuICAgIGlzTG9hZGluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvYWRpbmdTaW5jZSA+IDApO1xuICAgIH1cblxuICAgIGlzRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2xvYWRFcnJvcjtcbiAgICB9XG5cbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHRoaXMuZnJlZSgpO1xuICAgICAgICBpZiAodGhpcy5pc1VzZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2FkKGZvcmNlU3luYyA9IGZhbHNlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIG1vbWVudCBvZiBsb2FkaW5nICh3aGVuIGEgdGV4dHVyZSBzb3VyY2UgYmVjb21lcyB1c2VkIGJ5IGFjdGl2ZSBlbGVtZW50cylcbiAgICAgICAgaWYgKHRoaXMuaXNSZXN1bHRUZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyBFbGVtZW50IHJlc3VsdCB0ZXh0dXJlIHNvdXJjZSwgZm9yIHdoaWNoIHRoZSBsb2FkaW5nIGlzIG1hbmFnZWQgYnkgdGhlIGNvcmUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX25hdGl2ZVRleHR1cmUgJiYgIXRoaXMuaXNMb2FkaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1NpbmNlID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbENiID0gdGhpcy5sb2FkZXIoKGVyciwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBsb2FkcyB0aGF0IGNvbWUgaW4gYWZ0ZXIgYSBjYW5jZWwuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgY2FsbGJhY2sgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxDYiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFuYWdlci5zdGFnZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhc3luYyBsb2FkIHdoZW4gc3RhZ2UgaXMgZGVzdHJveWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgdHhFcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGFnZS5pc1VwZGF0aW5nRnJhbWUoKSAmJiAhZm9yY2VTeW5jICYmIChvcHRpb25zLnRocm90dGxlICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlVGhyb3R0bGVyID0gdGhpcy5zdGFnZS50ZXh0dXJlVGhyb3R0bGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbENiID0gdGV4dHVyZVRocm90dGxlci5nZW5lcmljQ2FuY2VsQ2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVRocm90dGxlci5hZGQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xvYWRlZFNvdXJjZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzc0xvYWRlZFNvdXJjZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1NpbmNlID0gMDtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2Uob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgc2V0U291cmNlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy5zb3VyY2U7XG5cbiAgICAgICAgdGhpcy53ID0gc291cmNlLndpZHRoIHx8IChvcHRpb25zICYmIG9wdGlvbnMudykgfHwgMDtcbiAgICAgICAgdGhpcy5oID0gc291cmNlLmhlaWdodCB8fCAob3B0aW9ucyAmJiBvcHRpb25zLmgpIHx8IDA7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZW5kZXJJbmZvKSB7XG4gICAgICAgICAgICAvLyBBc3NpZ24gdG8gaWQgaW4gY2FjaGUgc28gdGhhdCBpdCBjYW4gYmUgcmV1c2VkLlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJJbmZvID0gb3B0aW9ucy5yZW5kZXJJbmZvO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wZXJtYW5lbnQgPSAhIW9wdGlvbnMucGVybWFuZW50O1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW1hZ2VSZWYpXG4gICAgICAgICAgICB0aGlzLl9pbWFnZVJlZiA9IG9wdGlvbnMuaW1hZ2VSZWY7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmxpcFRleHR1cmVZKSB7XG4gICAgICAgICAgICB0aGlzLl9mbGlwVGV4dHVyZVkgPSBvcHRpb25zLmZsaXBUZXh0dXJlWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsaXBUZXh0dXJlWSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzTmF0aXZlVGV4dHVyZShzb3VyY2UpKSB7XG4gICAgICAgICAgICAvLyBUZXh0dXJlIG1hbmFnZWQgYnkgY2FsbGVyLlxuICAgICAgICAgICAgdGhpcy5fbmF0aXZlVGV4dHVyZSA9IHNvdXJjZTtcblxuICAgICAgICAgICAgdGhpcy53ID0gdGhpcy53IHx8IHNvdXJjZS53O1xuICAgICAgICAgICAgdGhpcy5oID0gdGhpcy5oIHx8IHNvdXJjZS5oO1xuXG4gICAgICAgICAgICAvLyBXZWJHTFRleHR1cmUgb2JqZWN0cyBhcmUgYnkgZGVmYXVsdDtcbiAgICAgICAgICAgIHRoaXMucGVybWFuZW50ID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncGVybWFuZW50JykgPyBvcHRpb25zLnBlcm1hbmVudCA6IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIudXBsb2FkVGV4dHVyZVNvdXJjZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE11c3QgYmUgY2xlYXJlZCB3aGVuIHJlbG9hZCBpcyBzdWNjZXNmdWwuXG4gICAgICAgIHRoaXMuX2xvYWRFcnJvciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5vbkxvYWQoKTtcbiAgICB9XG5cbiAgICBpc1VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVUZXh0dXJlQ291bnQgPiAwO1xuICAgIH1cblxuICAgIG9uTG9hZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNVc2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm9uTG9hZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3JjZVJlbmRlclVwZGF0ZSgpIHtcbiAgICAgICAgLy8gVXNlcmxhbmQgc2hvdWxkIGNhbGwgdGhpcyBtZXRob2QgYWZ0ZXIgY2hhbmdpbmcgdGhlIG5hdGl2ZVRleHR1cmUgbWFudWFsbHkgb3V0c2lkZSBvZiB0aGUgZnJhbWV3b3JrXG4gICAgICAgIC8vICAodXNpbmcgdGV4W1N1Yl1JbWFnZTJkIGZvciBleGFtcGxlKS5cblxuICAgICAgICBpZiAodGhpcy5fbmF0aXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgLy8gQ2hhbmdlICd1cGRhdGUnIGZsYWcuIFRoaXMgaXMgY3VycmVudGx5IG5vdCB1c2VkIGJ5IHRoZSBmcmFtZXdvcmsgYnV0IGlzIGhhbmR5IGluIHVzZXJsYW5kLlxuICAgICAgICAgICAgdGhpcy5fbmF0aXZlVGV4dHVyZS51cGRhdGUgPSB0aGlzLnN0YWdlLmZyYW1lQ291bnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZm9yRWFjaEFjdGl2ZUVsZW1lbnQoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZm9yY2VSZW5kZXJVcGRhdGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBmb3JjZVVwZGF0ZVJlbmRlckNvb3JkcygpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoQWN0aXZlRWxlbWVudChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5fdXBkYXRlVGV4dHVyZUNvb3JkcygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXQgbmF0aXZlVGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZVRleHR1cmU7XG4gICAgfVxuXG4gICAgY2xlYXJOYXRpdmVUZXh0dXJlKCkge1xuICAgICAgICB0aGlzLl9uYXRpdmVUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgLy9hbHNvIGNsZWFyIHRoZSByZWZlcmVuY2UgdG8gdGhlIHRleHR1cmUgdmFyaWFibGUuXG4gICAgICAgIHRoaXMuX2ltYWdlUmVmID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciByZXN1bHQgdGV4dHVyZXMuXG4gICAgICovXG4gICAgcmVwbGFjZU5hdGl2ZVRleHR1cmUobmV3TmF0aXZlVGV4dHVyZSwgdywgaCkge1xuICAgICAgICBsZXQgcHJldk5hdGl2ZVRleHR1cmUgPSB0aGlzLl9uYXRpdmVUZXh0dXJlO1xuICAgICAgICAvLyBMb2FkZWQgYnkgY29yZS5cbiAgICAgICAgdGhpcy5fbmF0aXZlVGV4dHVyZSA9IG5ld05hdGl2ZVRleHR1cmU7XG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgICAgIHRoaXMuaCA9IGg7XG5cbiAgICAgICAgaWYgKCFwcmV2TmF0aXZlVGV4dHVyZSAmJiB0aGlzLl9uYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hBY3RpdmVFbGVtZW50KGVsZW1lbnQgPT4gZWxlbWVudC5vblRleHR1cmVTb3VyY2VMb2FkZWQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX25hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaEFjdGl2ZUVsZW1lbnQoZWxlbWVudCA9PiBlbGVtZW50Ll9zZXREaXNwbGF5ZWRUZXh0dXJlKG51bGwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpbWVuc2lvbnMgbXVzdCBiZSB1cGRhdGVkIGFsc28gb24gZW5hYmxlZCBlbGVtZW50cywgYXMgaXQgbWF5IGZvcmNlIGl0IHRvIGdvIHdpdGhpbiBib3VuZHMuXG4gICAgICAgIHRoaXMuZm9yRWFjaEVuYWJsZWRFbGVtZW50KGVsZW1lbnQgPT4gZWxlbWVudC5fdXBkYXRlRGltZW5zaW9ucygpKTtcblxuICAgICAgICAvLyBOb3RpY2UgdGhhdCB0aGUgc3ByaXRlIG1hcCBtdXN0IG5ldmVyIGNvbnRhaW4gcmVuZGVyIHRleHR1cmVzLlxuICAgIH1cblxuICAgIG9uRXJyb3IoZSkge1xuICAgICAgICB0aGlzLl9sb2FkRXJyb3IgPSBlO1xuICAgICAgICB0aGlzLmxvYWRpbmdTaW5jZSA9IDA7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tMaWdodG5pbmddIHRleHR1cmUgbG9hZCBlcnJvcicsIGUsIHRoaXMubG9va3VwSWQpO1xuICAgICAgICB0aGlzLmZvckVhY2hBY3RpdmVFbGVtZW50KGVsZW1lbnQgPT4gZWxlbWVudC5vblRleHR1cmVTb3VyY2VMb2FkRXJyb3IoZSkpO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5mcmVlVGV4dHVyZVNvdXJjZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9pc05hdGl2ZVRleHR1cmUoc291cmNlKSB7XG4gICAgICAgIGlmIChVdGlscy5pc05vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UuY29uc3RydWN0b3IubmFtZSA9PT0gXCJXZWJHTFRleHR1cmVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnV2ViR0xUZXh0dXJlJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UgaW5zdGFuY2VvZiBXZWJHTFRleHR1cmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG59XG5cblRleHR1cmVTb3VyY2UucHJvdG90eXBlLmlzVGV4dHVyZVNvdXJjZSA9IHRydWU7XG5cblRleHR1cmVTb3VyY2UuaWQgPSAxO1xuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4vVXRpbHMubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEFsbG93cyB0aHJvdHRsaW5nIG9mIGxvYWRpbmcgdGV4dHVyZSBzb3VyY2VzLCBrZWVwaW5nIHRoZSBhcHAgcmVzcG9uc2l2ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZVRocm90dGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG5cbiAgICAgICAgdGhpcy5nZW5lcmljQ2FuY2VsQ2IgPSAodGV4dHVyZVNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHRleHR1cmVTb3VyY2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3NvdXJjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIH1cblxuICAgIHByb2Nlc3NTb21lKCkge1xuICAgICAgICBpZiAodGhpcy5fc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzSXRlbSgpO1xuICAgICAgICAgICAgfSB3aGlsZSh0aGlzLl9zb3VyY2VzLmxlbmd0aCAmJiAoRGF0ZS5ub3coKSAtIHN0YXJ0IDwgVGV4dHVyZVRocm90dGxlci5NQVhfVVBMT0FEX1RJTUVfUEVSX0ZSQU1FKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcHJvY2Vzc0l0ZW0oKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMucG9wKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhLnBvcCgpO1xuICAgICAgICBpZiAoc291cmNlLmlzTG9hZGluZygpKSB7XG4gICAgICAgICAgICBzb3VyY2UucHJvY2Vzc0xvYWRlZFNvdXJjZShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZCh0ZXh0dXJlU291cmNlLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMucHVzaCh0ZXh0dXJlU291cmNlKTtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKGRhdGEpO1xuICAgIH1cblxuICAgIF9yZW1vdmUodGV4dHVyZVNvdXJjZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZih0ZXh0dXJlU291cmNlKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5UZXh0dXJlVGhyb3R0bGVyLk1BWF9VUExPQURfVElNRV9QRVJfRlJBTUUgPSAxMDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFV0aWxzIHtcblxuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICh2YWx1ZSAlIDEpID09PSAwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIHN0YXRpYyBjbG9uZSh2KSB7XG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodikgfHwgQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLmdldERlZXBDbG9uZSh2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvcHkgYnkgdmFsdWUuXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjbG9uZU9ialNoYWxsb3cob2JqKSB7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgbGV0IGNsb25lID0ge31cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbG9uZVtrZXlzW2ldXSA9IG9ialtrZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgc3RhdGljIG1lcmdlKG9iajEsIG9iajIpIHtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvYmoxW2tleXNbaV1dID0gb2JqMltrZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT09ICdvYmplY3QnKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNPYmplY3RMaXRlcmFsKHZhbHVlKXtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QXJyYXlJbmRleChpbmRleCwgYXJyKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5nZXRNb2R1bG9JbmRleChpbmRleCwgYXJyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE1vZHVsb0luZGV4KGluZGV4LCBsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIGluZGV4O1xuICAgICAgICB3aGlsZSAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBpbmRleCArPSBNYXRoLmNlaWwoLWluZGV4IC8gbGVuKSAqIGxlbjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IGluZGV4ICUgbGVuO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldERlZXBDbG9uZShvYmopIHtcbiAgICAgICAgbGV0IGksIGM7XG4gICAgICAgIGlmIChVdGlscy5pc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgICAgICAgIC8vIENvcHkgZnVuY3Rpb25zIGJ5IHJlZmVyZW5jZS5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgYyA9IFtdO1xuICAgICAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjW2tleXNbaV1dID0gVXRpbHMuZ2V0RGVlcENsb25lKG9ialtrZXlzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdChvYmopKSB7XG4gICAgICAgICAgICBjID0ge31cbiAgICAgICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY1trZXlzW2ldXSA9IFV0aWxzLmdldERlZXBDbG9uZShvYmpba2V5c1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGVxdWFsVmFsdWVzKHYxLCB2Mikge1xuICAgICAgICBpZiAoKHR5cGVvZiB2MSkgIT09ICh0eXBlb2YgdjIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodjEpKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYyKSAmJiBVdGlscy5lcXVhbE9iamVjdExpdGVyYWxzKHYxLCB2Mik7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2MSkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYyKSAmJiBVdGlscy5lcXVhbEFycmF5cyh2MSwgdjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHYxID09PSB2MjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBlcXVhbE9iamVjdExpdGVyYWxzKG9iajEsIG9iajIpIHtcbiAgICAgICAgbGV0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gICAgICAgIGxldCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICAgICAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0ga2V5czEubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrMSA9IGtleXMxW2ldO1xuICAgICAgICAgICAgY29uc3QgazIgPSBrZXlzMltpXTtcbiAgICAgICAgICAgIGlmIChrMSAhPT0gazIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHYxID0gb2JqMVtrMV07XG4gICAgICAgICAgICBjb25zdCB2MiA9IG9iajJbazJdO1xuXG4gICAgICAgICAgICBpZiAoIVV0aWxzLmVxdWFsVmFsdWVzKHYxLCB2MikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZXF1YWxBcnJheXModjEsIHYyKSB7XG4gICAgICAgIGlmICh2MS5sZW5ndGggIT09IHYyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdjEubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXF1YWxWYWx1ZXModjFbaV0sIHYyW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRUb0FycmF5KHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHN0YXRpYyBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaXRlcmF0b3JSZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghaXRlcmF0b3JSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlcmF0b3JSZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgaXRlcmF0b3JSZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNVY0NoYXIoY2hhcmNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJjb2RlID49IDY1ICYmIGNoYXJjb2RlIDw9IDkwO1xuICAgIH1cblxufVxuXG5VdGlscy5pc1dlYiA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSAmJiAodHlwZW9mIHNwYXJrc2NlbmUgPT09IFwidW5kZWZpbmVkXCIpO1xuVXRpbHMuaXNXUEUgPSBVdGlscy5pc1dlYiAmJiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV1BFXCIpICE9PSAtMSk7XG5VdGlscy5pc1NwYXJrID0gKHR5cGVvZiBzcGFya3NjZW5lICE9PSBcInVuZGVmaW5lZFwiKTtcblV0aWxzLmlzTm9kZSA9ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB8fCBVdGlscy5pc1NwYXJrO1xuVXRpbHMuaXNQUzQgPSBVdGlscy5pc1dlYiAmJiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiUGxheVN0YXRpb24gNFwiKSAhPT0gLTEpO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3JlQ29udGV4dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG5cbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyZWVPcmRlciA9IDA7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZSA9IHRoaXMuc3RhZ2UucmVuZGVyZXIuY3JlYXRlQ29yZVJlbmRlclN0YXRlKHRoaXMpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyRXhlYyA9IHRoaXMuc3RhZ2UucmVuZGVyZXIuY3JlYXRlQ29yZVJlbmRlckV4ZWN1dG9yKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlckV4ZWMuaW5pdCgpO1xuXG4gICAgICAgIHRoaXMuX3VzZWRNZW1vcnkgPSAwO1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlUG9vbCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVJZCA9IDE7XG5cbiAgICAgICAgdGhpcy5felNvcnRzID0gW107XG4gICAgfVxuXG4gICAgZ2V0IHVzZWRNZW1vcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VkTWVtb3J5O1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVQb29sLmZvckVhY2godGV4dHVyZSA9PiB0aGlzLl9mcmVlUmVuZGVyVGV4dHVyZSh0ZXh0dXJlKSk7XG4gICAgICAgIHRoaXMuX3VzZWRNZW1vcnkgPSAwO1xuICAgIH1cblxuICAgIGhhc1JlbmRlclVwZGF0ZXMoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucm9vdC5fcGFyZW50Ll9oYXNSZW5kZXJVcGRhdGVzO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLy8gQ2xlYXIgZmxhZyB0byBpZGVudGlmeSBpZiBhbnl0aGluZyBjaGFuZ2VzIGJlZm9yZSB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAgdGhpcy5yb290Ll9wYXJlbnQuX2hhc1JlbmRlclVwZGF0ZXMgPSAwO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgLy8gRHVlIHRvIHRoZSBib3VuZHNWaXNpYmlsaXR5IGZsYWcgZmVhdHVyZSAoYW5kIG9uQWZ0ZXJVcGRhdGUgaG9vayksIGl0IGlzIHBvc3NpYmxlIHRoYXQgb3RoZXIgZWxlbWVudHMgd2VyZVxuICAgICAgICAvLyBjaGFuZ2VkIGR1cmluZyB0aGUgdXBkYXRlIGxvb3AgKGZvciBleGFtcGxlIGR1ZSB0byB0aGUgdHhMb2FkZWQgZXZlbnQpLiBXZSBwcm9jZXNzIHRoZXNlIGNoYW5nZXMgaW1tZWRpYXRlbHlcbiAgICAgICAgLy8gKGJ1dCBub3QgcmVjdXJzaXZlbHkgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcykuXG4gICAgICAgIGlmICh0aGlzLnJvb3QuX2hhc1VwZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGVyZm9ybUZvcmNlZFpTb3J0cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENlcnRhaW4gRWxlbWVudENvcmUgaXRlbXMgbWF5IGJlIGZvcmNlZCB0byB6U29ydCB0byBzdHJpcCBvdXQgcmVmZXJlbmNlcyB0byBwcmV2ZW50IG1lbWxlYWtzLi5cbiAgICAgKi9cbiAgICBfcGVyZm9ybUZvcmNlZFpTb3J0cygpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX3pTb3J0cy5sZW5ndGg7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAvLyBGb3JjZWQgei1zb3J0cyAoRWxlbWVudENvcmUgbWF5IGZvcmNlIGEgei1zb3J0IGluIG9yZGVyIHRvIGZyZWUgbWVtb3J5L3ByZXZlbnQgbWVtb3J5IGxlYWtzKS5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5felNvcnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl96U29ydHNbaV0uelNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5felNvcnRzW2ldLnNvcnRaSW5kZXhlZENoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5felNvcnRzID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRyZWVPcmRlciA9IDA7XG5cbiAgICAgICAgdGhpcy5yb290LnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIF9yZW5kZXIoKSB7XG4gICAgICAgIC8vIE9idGFpbiBhIHNlcXVlbmNlIG9mIHRoZSBxdWFkIG9wZXJhdGlvbnMuXG4gICAgICAgIHRoaXMuX2ZpbGxSZW5kZXJTdGF0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YWdlLmdldE9wdGlvbigncmVhZFBpeGVsc0JlZm9yZURyYXcnKSkge1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuc3RhZ2UuZ2w7XG4gICAgICAgICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgcnVuIHRoZW0gd2l0aCB0aGUgcmVuZGVyIGV4ZWN1dG9yLlxuICAgICAgICB0aGlzLl9wZXJmb3JtUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgX2ZpbGxSZW5kZXJTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZS5yZXNldCgpO1xuICAgICAgICB0aGlzLnJvb3QucmVuZGVyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyU3RhdGUuZmluaXNoKCk7XG4gICAgfVxuXG4gICAgX3BlcmZvcm1SZW5kZXIoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyRXhlYy5leGVjdXRlKCk7XG4gICAgfVxuXG4gICAgX2FkZE1lbW9yeVVzYWdlKGRlbHRhKSB7XG4gICAgICAgIHRoaXMuX3VzZWRNZW1vcnkgKz0gZGVsdGE7XG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkTWVtb3J5VXNhZ2UoZGVsdGEpO1xuICAgIH1cblxuICAgIGFsbG9jYXRlUmVuZGVyVGV4dHVyZSh3LCBoKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcbiAgICAgICAgbGV0IHB3ID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZCh3ICogcHJlYykpO1xuICAgICAgICBsZXQgcGggPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGggKiBwcmVjKSk7XG5cbiAgICAgICAgLy8gU2VhcmNoIGxhc3QgaXRlbSBmaXJzdCwgc28gdGhhdCBsYXN0IHJlbGVhc2VkIHJlbmRlciB0ZXh0dXJlIGlzIHByZWZlcnJlZCAobWF5IGNhdXNlIG1lbW9yeSBjYWNoZSBiZW5lZml0cykuXG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9yZW5kZXJUZXh0dXJlUG9vbC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSBuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl9yZW5kZXJUZXh0dXJlUG9vbFtpXTtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmV1c2UgdGhlIHNhbWUgcmVuZGVyIHRleHR1cmVzIHdpdGhpbiB0aGUgc2FtZSBmcmFtZSBiZWNhdXNlIHRoYXQgd2lsbCBjcmVhdGUgZ3B1IHN0YWxscy5cbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLncgPT09IHB3ICYmIHRleHR1cmUuaCA9PT0gcGggJiYgKHRleHR1cmUudXBkYXRlICE9PSB0aGlzLnN0YWdlLmZyYW1lQ291bnRlcikpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmYgPSB0aGlzLnN0YWdlLmZyYW1lQ291bnRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlUG9vbC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fY3JlYXRlUmVuZGVyVGV4dHVyZSh3LCBoLCBwdywgcGgpO1xuICAgICAgICB0ZXh0dXJlLnByZWNpc2lvbiA9IHByZWM7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cblxuICAgIHJlbGVhc2VSZW5kZXJUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZVBvb2wucHVzaCh0ZXh0dXJlKTtcbiAgICB9XG5cbiAgICBmcmVlVW51c2VkUmVuZGVyVGV4dHVyZXMobWF4QWdlID0gNjApIHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgYWxsIHRleHR1cmVzIHRoYXQgYXJlIG5vIGxvbmdlciB1c2VkLlxuICAgICAgICAvLyBUaGlzIGNhY2hlIGlzIHNob3J0LWxpdmVkIGJlY2F1c2UgaXQgaXMgcmVhbGx5IGp1c3QgbWVhbnQgdG8gc3VwcGx5IHJ1bm5pbmcgc2hhZGVycyB0aGF0IGFyZVxuICAgICAgICAvLyB1cGRhdGVkIGR1cmluZyBhIG51bWJlciBvZiBmcmFtZXMuXG4gICAgICAgIGxldCBsaW1pdCA9IHRoaXMuc3RhZ2UuZnJhbWVDb3VudGVyIC0gbWF4QWdlO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVQb29sID0gdGhpcy5fcmVuZGVyVGV4dHVyZVBvb2wuZmlsdGVyKHRleHR1cmUgPT4ge1xuICAgICAgICAgICAgaWYgKHRleHR1cmUuZiA8PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZyZWVSZW5kZXJUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlUmVuZGVyVGV4dHVyZSh3LCBoLCBwdywgcGgpIHtcbiAgICAgICAgdGhpcy5fYWRkTWVtb3J5VXNhZ2UocHcgKiBwaCk7XG5cbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuc3RhZ2UucmVuZGVyZXIuY3JlYXRlUmVuZGVyVGV4dHVyZSh3LCBoLCBwdywgcGgpO1xuICAgICAgICB0ZXh0dXJlLmlkID0gdGhpcy5fcmVuZGVyVGV4dHVyZUlkKys7XG4gICAgICAgIHRleHR1cmUuZiA9IHRoaXMuc3RhZ2UuZnJhbWVDb3VudGVyO1xuICAgICAgICB0ZXh0dXJlLm93ID0gdztcbiAgICAgICAgdGV4dHVyZS5vaCA9IGg7XG4gICAgICAgIHRleHR1cmUudyA9IHB3O1xuICAgICAgICB0ZXh0dXJlLmggPSBwaDtcblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG5cbiAgICBfZnJlZVJlbmRlclRleHR1cmUobmF0aXZlVGV4dHVyZSkge1xuICAgICAgICB0aGlzLnN0YWdlLnJlbmRlcmVyLmZyZWVSZW5kZXJUZXh0dXJlKG5hdGl2ZVRleHR1cmUpO1xuICAgICAgICB0aGlzLl9hZGRNZW1vcnlVc2FnZSgtbmF0aXZlVGV4dHVyZS53ICogbmF0aXZlVGV4dHVyZS5oKTtcbiAgICB9XG5cbiAgICBjb3B5UmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlLCBuYXRpdmVUZXh0dXJlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UucmVuZGVyZXIuY29weVJlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZSwgbmF0aXZlVGV4dHVyZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZm9yY2VaU29ydChlbGVtZW50Q29yZSkge1xuICAgICAgICB0aGlzLl96U29ydHMucHVzaChlbGVtZW50Q29yZSk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3JlUXVhZExpc3Qge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG5cbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG5cbiAgICAgICAgdGhpcy5xdWFkVGV4dHVyZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnF1YWRFbGVtZW50cyA9IFtdO1xuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRUZXh0dXJlcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucXVhZFRleHR1cmVzID0gW107XG4gICAgICAgIHRoaXMucXVhZEVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZ2V0RWxlbWVudChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkRWxlbWVudHNbaW5kZXhdLl9lbGVtZW50O1xuICAgIH1cblxuICAgIGdldEVsZW1lbnRDb3JlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRFbGVtZW50c1tpbmRleF07XG4gICAgfVxuXG4gICAgZ2V0VGV4dHVyZShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkVGV4dHVyZXNbaW5kZXhdO1xuICAgIH1cblxuICAgIGdldFRleHR1cmVXaWR0aChpbmRleCkge1xuICAgICAgICBsZXQgbmF0aXZlVGV4dHVyZSA9IHRoaXMucXVhZFRleHR1cmVzW2luZGV4XTtcbiAgICAgICAgaWYgKG5hdGl2ZVRleHR1cmUudykge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHRleHR1cmU7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlVGV4dHVyZS53O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVhZEVsZW1lbnRzW2luZGV4XS5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZS53O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VGV4dHVyZUhlaWdodChpbmRleCkge1xuICAgICAgICBsZXQgbmF0aXZlVGV4dHVyZSA9IHRoaXMucXVhZFRleHR1cmVzW2luZGV4XTtcbiAgICAgICAgaWYgKG5hdGl2ZVRleHR1cmUuaCkge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHRleHR1cmU7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlVGV4dHVyZS5oO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVhZEVsZW1lbnRzW2luZGV4XS5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZS5oO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmVRdWFkT3BlcmF0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCwgc2hhZGVyLCBzaGFkZXJPd25lciwgcmVuZGVyVGV4dHVyZUluZm8sIHNjaXNzb3IsIGluZGV4KSB7XG5cbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xuICAgICAgICB0aGlzLnNoYWRlck93bmVyID0gc2hhZGVyT3duZXI7XG4gICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZUluZm8gPSByZW5kZXJUZXh0dXJlSW5mbztcbiAgICAgICAgdGhpcy5zY2lzc29yID0gc2Npc3NvcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICB9XG5cbiAgICBnZXQgcXVhZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN0eC5yZW5kZXJTdGF0ZS5xdWFkcztcbiAgICB9XG5cbiAgICBnZXRUZXh0dXJlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRzLmdldFRleHR1cmUodGhpcy5pbmRleCArIGluZGV4KTtcbiAgICB9XG5cbiAgICBnZXRFbGVtZW50Q29yZShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkcy5nZXRFbGVtZW50Q29yZSh0aGlzLmluZGV4ICsgaW5kZXgpO1xuICAgIH1cblxuICAgIGdldEVsZW1lbnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHMuZ2V0RWxlbWVudCh0aGlzLmluZGV4ICsgaW5kZXgpO1xuICAgIH1cblxuICAgIGdldEVsZW1lbnRXaWR0aChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50KGluZGV4KS5yZW5kZXJXaWR0aDtcbiAgICB9XG5cbiAgICBnZXRFbGVtZW50SGVpZ2h0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnQoaW5kZXgpLnJlbmRlckhlaWdodDtcbiAgICB9XG5cbiAgICBnZXRUZXh0dXJlV2lkdGgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHMuZ2V0VGV4dHVyZVdpZHRoKHRoaXMuaW5kZXggKyBpbmRleCk7XG4gICAgfVxuXG4gICAgZ2V0VGV4dHVyZUhlaWdodChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkcy5nZXRUZXh0dXJlSGVpZ2h0KHRoaXMuaW5kZXggKyBpbmRleCk7XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVyV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlclRleHR1cmVJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJUZXh0dXJlSW5mby53O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3R4LnN0YWdlLnc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRSZW5kZXJIZWlnaHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlclRleHR1cmVJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJUZXh0dXJlSW5mby5oO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3R4LnN0YWdlLmg7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZVJlbmRlckV4ZWN1dG9yIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcblxuICAgICAgICB0aGlzLnJlbmRlclN0YXRlID0gY3R4LnJlbmRlclN0YXRlO1xuXG4gICAgICAgIHRoaXMuZ2wgPSB0aGlzLmN0eC5zdGFnZS5nbDtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgIH1cblxuICAgIF9yZXNldCgpIHtcbiAgICAgICAgdGhpcy5fYmluZFJlbmRlclRleHR1cmUobnVsbCk7XG4gICAgICAgIHRoaXMuX3NldFNjaXNzb3IobnVsbCk7XG4gICAgICAgIHRoaXMuX2NsZWFyUmVuZGVyVGV4dHVyZSgpO1xuICAgIH1cblxuICAgIGV4ZWN1dGUoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG5cbiAgICAgICAgbGV0IHFvcHMgPSB0aGlzLnJlbmRlclN0YXRlLnF1YWRPcGVyYXRpb25zO1xuXG4gICAgICAgIGxldCBpID0gMCwgaiA9IDAsIG4gPSBxb3BzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzUXVhZE9wZXJhdGlvbihxb3BzW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wcm9jZXNzUXVhZE9wZXJhdGlvbihxdWFkT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmIChxdWFkT3BlcmF0aW9uLnJlbmRlclRleHR1cmVJbmZvICYmIHF1YWRPcGVyYXRpb24ucmVuZGVyVGV4dHVyZUluZm8uaWdub3JlKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgcXVhZCBvcGVyYXRpb25zIHdoZW4gd2UgYXJlICdyZS11c2luZycgYW5vdGhlciB0ZXh0dXJlIGFzIHRoZSByZW5kZXIgdGV4dHVyZSByZXN1bHQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXR1cFF1YWRPcGVyYXRpb24ocXVhZE9wZXJhdGlvbik7XG4gICAgICAgIHRoaXMuX2V4ZWNRdWFkT3BlcmF0aW9uKHF1YWRPcGVyYXRpb24pO1xuXG4gICAgfVxuXG4gICAgX3NldHVwUXVhZE9wZXJhdGlvbihxdWFkT3BlcmF0aW9uKSB7XG4gICAgfVxuXG4gICAgX2V4ZWNRdWFkT3BlcmF0aW9uKG9wKSB7XG4gICAgICAgIC8vIFNldCByZW5kZXIgdGV4dHVyZS5cbiAgICAgICAgbGV0IG5hdGl2ZVRleHR1cmUgPSBvcC5yZW5kZXJUZXh0dXJlSW5mbyA/IG9wLnJlbmRlclRleHR1cmVJbmZvLm5hdGl2ZVRleHR1cmUgOiBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUZXh0dXJlICE9PSBuYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9iaW5kUmVuZGVyVGV4dHVyZShuYXRpdmVUZXh0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5yZW5kZXJUZXh0dXJlSW5mbyAmJiAhb3AucmVuZGVyVGV4dHVyZUluZm8uY2xlYXJlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U2Npc3NvcihudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyUmVuZGVyVGV4dHVyZSgpO1xuICAgICAgICAgICAgb3AucmVuZGVyVGV4dHVyZUluZm8uY2xlYXJlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zZXRTY2lzc29yKG9wLnNjaXNzb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0U2Npc3NvcihvcC5zY2lzc29yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlclF1YWRPcGVyYXRpb24ob3ApO1xuICAgIH1cblxuICAgIF9yZW5kZXJRdWFkT3BlcmF0aW9uKG9wKSB7XG4gICAgfVxuXG4gICAgX2JpbmRSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZSA9IHJlbmRlclRleHR1cmU7XG4gICAgfVxuXG4gICAgX2NsZWFyUmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XG4gICAgfVxuXG4gICAgX3NldFNjaXNzb3IoYXJlYSkge1xuICAgIH1cblxufVxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3JlUmVuZGVyU3RhdGUge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuXG4gICAgICAgIHRoaXMuc3RhZ2UgPSBjdHguc3RhZ2U7XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0U2hhZGVyID0gdGhpcy5zdGFnZS5yZW5kZXJlci5nZXREZWZhdWx0U2hhZGVyKGN0eCk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IGN0eC5zdGFnZS5yZW5kZXJlcjtcblxuICAgICAgICB0aGlzLnF1YWRzID0gdGhpcy5yZW5kZXJlci5jcmVhdGVDb3JlUXVhZExpc3QoY3R4KTtcblxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mbyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fc2Npc3NvciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fc2hhZGVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zaGFkZXJPd25lciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fcmVhbFNoYWRlciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fY2hlY2sgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnF1YWRPcGVyYXRpb25zID0gW107XG5cbiAgICAgICAgdGhpcy5fdGV4dHVyaXplciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fdGV4dHVyaXplclRlbXBvcmFyeSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3F1YWRPcGVyYXRpb24gPSBudWxsO1xuXG4gICAgICAgIHRoaXMucXVhZHMucmVzZXQoKTtcblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlUZXh0dXJpemVycyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5faXNDYWNoaW5nVGV4dHVyaXplciA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHMucXVhZFRleHR1cmVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBzZXRTaGFkZXIoc2hhZGVyLCBvd25lcikge1xuICAgICAgICBpZiAodGhpcy5fc2hhZGVyT3duZXIgIT09IG93bmVyIHx8IHRoaXMuX3JlYWxTaGFkZXIgIT09IHNoYWRlcikge1xuICAgICAgICAgICAgLy8gU2FtZSBzaGFkZXIgb3duZXI6IGFjdGl2ZSBzaGFkZXIgaXMgYWxzbyB0aGUgc2FtZS5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgYW55IHNoYWRlciB1c2FnZSB0byBzYXZlIHBlcmZvcm1hbmNlLlxuXG4gICAgICAgICAgICB0aGlzLl9yZWFsU2hhZGVyID0gc2hhZGVyO1xuXG4gICAgICAgICAgICBpZiAoc2hhZGVyLnVzZURlZmF1bHQoKSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGVmYXVsdCBzaGFkZXIgd2hlbiBwb3NzaWJsZSB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHByb2dyYW0gY2hhbmdlcy5cbiAgICAgICAgICAgICAgICBzaGFkZXIgPSB0aGlzLmRlZmF1bHRTaGFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hhZGVyICE9PSBzaGFkZXIgfHwgdGhpcy5fc2hhZGVyT3duZXIgIT09IG93bmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hhZGVyID0gc2hhZGVyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRlck93bmVyID0gb3duZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHJlbmRlclRleHR1cmVJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyVGV4dHVyZUluZm87XG4gICAgfVxuXG4gICAgc2V0U2Npc3NvcihhcmVhKSB7XG4gICAgICAgIGlmICh0aGlzLl9zY2lzc29yICE9PSBhcmVhKSB7XG4gICAgICAgICAgICBpZiAoYXJlYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaXNzb3IgPSBhcmVhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2lzc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNjaXNzb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2lzc29yO1xuICAgIH1cblxuICAgIHNldFJlbmRlclRleHR1cmVJbmZvKHJlbmRlclRleHR1cmVJbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUZXh0dXJlSW5mbyAhPT0gcmVuZGVyVGV4dHVyZUluZm8pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvID0gcmVuZGVyVGV4dHVyZUluZm87XG4gICAgICAgICAgICB0aGlzLl9zY2lzc29yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRleHR1cml6ZXIgdG8gYmUgZHJhd24gZHVyaW5nIHN1YnNlcXVlbnQgYWRkUXVhZHMuXG4gICAgICogQHBhcmFtIHtFbGVtZW50VGV4dHVyaXplcn0gdGV4dHVyaXplclxuICAgICAqL1xuICAgIHNldFRleHR1cml6ZXIodGV4dHVyaXplciwgY2FjaGUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90ZXh0dXJpemVyID0gdGV4dHVyaXplcjtcbiAgICAgICAgdGhpcy5fY2FjaGVUZXh0dXJpemVyID0gY2FjaGU7XG4gICAgfVxuXG4gICAgc2V0IGlzQ2FjaGluZ1RleHR1cml6ZXIodikge1xuICAgICAgICB0aGlzLl9pc0NhY2hpbmdUZXh0dXJpemVyID0gdjtcbiAgICB9XG5cbiAgICBnZXQgaXNDYWNoaW5nVGV4dHVyaXplcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2FjaGluZ1RleHR1cml6ZXI7XG4gICAgfVxuXG4gICAgYWRkUXVhZChlbGVtZW50Q29yZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3F1YWRPcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVF1YWRPcGVyYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jaGVjayAmJiB0aGlzLl9oYXNDaGFuZ2VzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaFF1YWRPcGVyYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmF0aXZlVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJpemVyKSB7XG4gICAgICAgICAgICBuYXRpdmVUZXh0dXJlID0gdGhpcy5fdGV4dHVyaXplci5nZXRSZXN1bHRUZXh0dXJlKCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FjaGVUZXh0dXJpemVyKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIHJlbGVhc2UgdGhlIHRlbXBvcmFyeSB0ZXh0dXJlIGltbWVkaWF0ZWx5IGFmdGVyIGZpbmFsaXppbmcgdGhpcyBxdWFkIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wb3JhcnlUZXh0dXJpemVycy5wdXNoKHRoaXMuX3RleHR1cml6ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICBuYXRpdmVUZXh0dXJlID0gZWxlbWVudENvcmUuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UubmF0aXZlVGV4dHVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUZXh0dXJlSW5mbykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NoYWRlciA9PT0gdGhpcy5kZWZhdWx0U2hhZGVyICYmIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRleHR1cmUgbWlnaHQgYmUgcmV1c2FibGUgdW5kZXIgc29tZSBjb25kaXRpb25zLiBXZSB3aWxsIGNoZWNrIHRoZW0gaW4gRWxlbWVudENvcmUucmVuZGVyZXIuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8ubmF0aXZlVGV4dHVyZSA9IG5hdGl2ZVRleHR1cmU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8ub2Zmc2V0ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byByZXVzZSBhbm90aGVyIHRleHR1cmUgd2hlbiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHF1YWQuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8ubmF0aXZlVGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mby5lbXB0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5xdWFkcy5xdWFkVGV4dHVyZXMucHVzaChuYXRpdmVUZXh0dXJlKTtcbiAgICAgICAgdGhpcy5xdWFkcy5xdWFkRWxlbWVudHMucHVzaChlbGVtZW50Q29yZSk7XG5cbiAgICAgICAgdGhpcy5fcXVhZE9wZXJhdGlvbi5sZW5ndGgrKztcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZFF1YWQodGhpcywgdGhpcy5xdWFkcywgdGhpcy5sZW5ndGggLSAxKVxuICAgIH1cblxuICAgIGZpbmlzaGVkUmVuZGVyVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLm5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIHdhcyBvbmx5IG9uZSB0ZXh0dXJlIGRyYXduIGluIHRoaXMgcmVuZGVyIHRleHR1cmUuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gcmV1c2UgaXQgc28gdGhhdCB3ZSBjYW4gb3B0aW1pemUgb3V0IGFuIHVubmVjZXNzYXJ5IHJlbmRlciB0ZXh0dXJlIG9wZXJhdGlvbi5cbiAgICAgICAgICAgIC8vIChpdCBzaG91bGQgZXhhY3RseSBzcGFuIHRoaXMgcmVuZGVyIHRleHR1cmUpLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1JlbmRlclRleHR1cmVSZXVzYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8ubmF0aXZlVGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaXNSZW5kZXJUZXh0dXJlUmV1c2FibGUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLm9mZnNldDtcbiAgICAgICAgcmV0dXJuICh0aGlzLnF1YWRzLnF1YWRUZXh0dXJlc1tvZmZzZXRdLncgPT09IHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLncpICYmXG4gICAgICAgICAgICAodGhpcy5xdWFkcy5xdWFkVGV4dHVyZXNbb2Zmc2V0XS5oID09PSB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mby5oKSAmJlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5pc1JlbmRlclRleHR1cmVSZXVzYWJsZSh0aGlzLCB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mbylcbiAgICB9XG5cbiAgICBfaGFzQ2hhbmdlcygpIHtcbiAgICAgICAgbGV0IHEgPSB0aGlzLl9xdWFkT3BlcmF0aW9uO1xuICAgICAgICBpZiAodGhpcy5fc2hhZGVyICE9PSBxLnNoYWRlcikgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9zaGFkZXJPd25lciAhPT0gcS5zaGFkZXJPd25lcikgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUZXh0dXJlSW5mbyAhPT0gcS5yZW5kZXJUZXh0dXJlSW5mbykgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9zY2lzc29yICE9PSBxLnNjaXNzb3IpIHtcbiAgICAgICAgICAgIGlmICgodGhpcy5fc2Npc3NvclswXSAhPT0gcS5zY2lzc29yWzBdKSB8fCAodGhpcy5fc2Npc3NvclsxXSAhPT0gcS5zY2lzc29yWzFdKSB8fCAodGhpcy5fc2Npc3NvclsyXSAhPT0gcS5zY2lzc29yWzJdKSB8fCAodGhpcy5fc2Npc3NvclszXSAhPT0gcS5zY2lzc29yWzNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIF9maW5pc2hRdWFkT3BlcmF0aW9uKGNyZWF0ZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3F1YWRPcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9xdWFkT3BlcmF0aW9uLmxlbmd0aCB8fCB0aGlzLl9zaGFkZXIuYWRkRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcXVhZE9wZXJhdGlvbi5zY2lzc29yIHx8ICgodGhpcy5fcXVhZE9wZXJhdGlvbi5zY2lzc29yWzJdID4gMCkgJiYgKHRoaXMuX3F1YWRPcGVyYXRpb24uc2Npc3NvclszXSA+IDApKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZW1wdHkgY2xpcHBpbmcgcmVnaW9ucy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFkT3BlcmF0aW9ucy5wdXNoKHRoaXMuX3F1YWRPcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3RlbXBvcmFyeVRleHR1cml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fdGVtcG9yYXJ5VGV4dHVyaXplcnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBub3cgcmV1c2UgdGhlc2UgcmVuZGVyLXRvLXRleHR1cmVzIGluIHN1YnNlcXVlbnQgc3RhZ2VzLlxuICAgICAgICAgICAgICAgICAgICAvLyBIdWdlIHBlcmZvcm1hbmNlIGJlbmVmaXQgd2hlbiBmaWx0ZXJpbmcgKGZhc3QgYmx1cikuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBvcmFyeVRleHR1cml6ZXJzW2ldLnJlbGVhc2VSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBvcmFyeVRleHR1cml6ZXJzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3F1YWRPcGVyYXRpb24gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUXVhZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZVF1YWRPcGVyYXRpb24oKSB7XG4gICAgICAgIHRoaXMuX3F1YWRPcGVyYXRpb24gPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUNvcmVRdWFkT3BlcmF0aW9uKFxuICAgICAgICAgICAgdGhpcy5jdHgsXG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIsXG4gICAgICAgICAgICB0aGlzLl9zaGFkZXJPd25lcixcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLFxuICAgICAgICAgICAgdGhpcy5fc2Npc3NvcixcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2NoZWNrID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5fcXVhZE9wZXJhdGlvbikge1xuICAgICAgICAgICAgLy8gQWRkIHJlbWFpbmluZy5cbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaFF1YWRPcGVyYXRpb24oZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5maW5pc2hSZW5kZXJTdGF0ZSh0aGlzKTtcbiAgICB9XG5cbn1cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEZsZXhUYXJnZXQgZnJvbSBcIi4uLy4uL2ZsZXgvRmxleFRhcmdldC5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudENvcmUge1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgICB0aGlzLmN0eCA9IGVsZW1lbnQuc3RhZ2UuY3R4O1xuXG4gICAgICAgIC8vIFRoZSBtZW1vcnkgbGF5b3V0IG9mIHRoZSBpbnRlcm5hbCB2YXJpYWJsZXMgaXMgYWZmZWN0ZWQgYnkgdGhlaXIgcG9zaXRpb24gaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAvLyBJdCBib29zdHMgcGVyZm9ybWFuY2UgdG8gb3JkZXIgdGhlbSBieSB1c2FnZSBvZiBjcHUtaGVhdnkgZnVuY3Rpb25zIChyZW5kZXJTaW1wbGUgYW5kIHVwZGF0ZSkuXG5cbiAgICAgICAgdGhpcy5fcmVjYWxjID0gMDtcblxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX29uVXBkYXRlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9wUmVjYWxjID0gMDtcblxuICAgICAgICB0aGlzLl93b3JsZENvbnRleHQgPSBuZXcgRWxlbWVudENvcmVDb250ZXh0KCk7XG5cbiAgICAgICAgdGhpcy5faGFzVXBkYXRlcyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2xvY2FsQWxwaGEgPSAxO1xuXG4gICAgICAgIHRoaXMuX29uQWZ0ZXJDYWxjcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fb25BZnRlclVwZGF0ZSA9IG51bGw7XG5cbiAgICAgICAgLy8gQWxsIGxvY2FsIHRyYW5zbGF0aW9uL3RyYW5zZm9ybSB1cGRhdGVzOiBkaXJlY3RseSBwcm9wYWdhdGVkIGZyb20geC95L3cvaC9zY2FsZS93aGF0ZXZlci5cbiAgICAgICAgdGhpcy5fbG9jYWxQeCA9IDA7XG4gICAgICAgIHRoaXMuX2xvY2FsUHkgPSAwO1xuXG4gICAgICAgIHRoaXMuX2xvY2FsVGEgPSAxO1xuICAgICAgICB0aGlzLl9sb2NhbFRiID0gMDtcbiAgICAgICAgdGhpcy5fbG9jYWxUYyA9IDA7XG4gICAgICAgIHRoaXMuX2xvY2FsVGQgPSAxO1xuXG4gICAgICAgIHRoaXMuX2lzQ29tcGxleCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2RpbXNVbmtub3duID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fY2xpcHBpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBVc2VkIGJ5IGJvdGggdXBkYXRlIGFuZCByZW5kZXIuXG4gICAgICAgIHRoaXMuX3pTb3J0ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSBzb3VyY2UgdG8gYmUgZGlzcGxheWVkLlxuICAgICAgICAgKiBAdHlwZSB7VGV4dHVyZVNvdXJjZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3pDb250ZXh0VXNhZ2UgPSAwO1xuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9oYXNSZW5kZXJVcGRhdGVzID0gMDtcblxuICAgICAgICB0aGlzLl96SW5kZXhlZENoaWxkcmVuID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0ID0gdGhpcy5fd29ybGRDb250ZXh0O1xuXG4gICAgICAgIHRoaXMucmVuZGVyU3RhdGUgPSB0aGlzLmN0eC5yZW5kZXJTdGF0ZTtcblxuICAgICAgICB0aGlzLl9zY2lzc29yID0gbnVsbDtcblxuICAgICAgICAvLyBUaGUgYW5jZXN0b3IgRWxlbWVudENvcmUgdGhhdCBvd25zIHRoZSBpbmhlcml0ZWQgc2hhZGVyLiBOdWxsIGlmIG5vbmUgaXMgYWN0aXZlIChkZWZhdWx0IHNoYWRlcikuXG4gICAgICAgIHRoaXMuX3NoYWRlck93bmVyID0gbnVsbDtcblxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVRyZWVPcmRlciA9IDA7XG5cbiAgICAgICAgdGhpcy5fY29sb3JVbCA9IHRoaXMuX2NvbG9yVXIgPSB0aGlzLl9jb2xvckJsID0gdGhpcy5fY29sb3JCciA9IDB4RkZGRkZGRkY7XG5cbiAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgICB0aGlzLl93ID0gMDtcbiAgICAgICAgdGhpcy5faCA9IDA7XG5cbiAgICAgICAgdGhpcy5fb3B0RmxhZ3MgPSAwO1xuICAgICAgICB0aGlzLl9mdW5jWCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Z1bmNZID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZnVuY1cgPSBudWxsO1xuICAgICAgICB0aGlzLl9mdW5jSCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fc2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5fc2NhbGVZID0gMTtcbiAgICAgICAgdGhpcy5fcGl2b3RYID0gMC41O1xuICAgICAgICB0aGlzLl9waXZvdFkgPSAwLjU7XG4gICAgICAgIHRoaXMuX21vdW50WCA9IDA7XG4gICAgICAgIHRoaXMuX21vdW50WSA9IDA7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0gMDtcblxuICAgICAgICB0aGlzLl9hbHBoYSA9IDE7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3VseCA9IDA7XG4gICAgICAgIHRoaXMuX3VseSA9IDA7XG4gICAgICAgIHRoaXMuX2JyeCA9IDE7XG4gICAgICAgIHRoaXMuX2JyeSA9IDE7XG5cbiAgICAgICAgdGhpcy5fekluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fZm9yY2VaSW5kZXhDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3pQYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2lzUm9vdCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZmYgdHJ1ZSwgZHVyaW5nIHpTb3J0LCB0aGlzIGVsZW1lbnQgc2hvdWxkIGJlICdyZS1zb3J0ZWQnIGJlY2F1c2UgZWl0aGVyOlxuICAgICAgICAgKiAtIHpJbmRleCBkaWQgY2hhbmdcbiAgICAgICAgICogLSB6UGFyZW50IGRpZCBjaGFuZ2VcbiAgICAgICAgICogLSBlbGVtZW50IHdhcyBtb3ZlZCBpbiB0aGUgcmVuZGVyIHRyZWVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl96SW5kZXhSZXNvcnQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9zaGFkZXIgPSBudWxsO1xuXG4gICAgICAgIC8vIEVsZW1lbnQgaXMgcmVuZGVyZWQgb24gYW5vdGhlciB0ZXh0dXJlLlxuICAgICAgICB0aGlzLl9yZW5kZXJUb1RleHR1cmVFbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdGV4dHVyaXplciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fdXNlUmVuZGVyVG9UZXh0dXJlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fYm91bmRzTWFyZ2luID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9yZWNCb3VuZHNNYXJnaW4gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3dpdGhpbkJvdW5kc01hcmdpbiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9jbGlwYm94ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMuX3JlbmRlclNpbXBsZTtcblxuICAgICAgICB0aGlzLl9sYXlvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBvZmZzZXRYKCkge1xuICAgICAgICBpZiAodGhpcy5fZnVuY1gpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mdW5jWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQub3JpZ2luYWxYO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBvZmZzZXRYKHYpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzRnVuY3Rpb24odikpIHtcbiAgICAgICAgICAgIHRoaXMuZnVuY1ggPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZUZ1bmNYKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggKz0gKHYgLSB0aGlzLl9sYXlvdXQub3JpZ2luYWxYKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXQuc2V0T3JpZ2luYWxYV2l0aG91dFVwZGF0aW5nTGF5b3V0KHYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH1cblxuICAgIHNldCB4KHYpIHtcbiAgICAgICAgaWYgKHYgIT09IHRoaXMuX3gpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNsYXRlRGVsdGEodiAtIHRoaXMuX3gsIDApO1xuICAgICAgICAgICAgdGhpcy5feCA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZnVuY1goKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fb3B0RmxhZ3MgJiAxID8gdGhpcy5fZnVuY1ggOiBudWxsKTtcbiAgICB9XG5cbiAgICBzZXQgZnVuY1godikge1xuICAgICAgICBpZiAodGhpcy5fZnVuY1ggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdEZsYWdzIHw9IDE7XG4gICAgICAgICAgICB0aGlzLl9mdW5jWCA9IHY7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXQuc2V0T3JpZ2luYWxYV2l0aG91dFVwZGF0aW5nTGF5b3V0KDApO1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LmZvcmNlTGF5b3V0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJSZWNhbGNUcmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kaXNhYmxlRnVuY1goKSB7XG4gICAgICAgIHRoaXMuX29wdEZsYWdzID0gdGhpcy5fb3B0RmxhZ3MgJiAoMHhGRkZGIC0gMSk7XG4gICAgICAgIHRoaXMuX2Z1bmNYID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgb2Zmc2V0WSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Z1bmNZKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnVuY1k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0Lm9yaWdpbmFsWTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgb2Zmc2V0WSh2KSB7XG4gICAgICAgIGlmIChVdGlscy5pc0Z1bmN0aW9uKHYpKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bmNZID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVGdW5jWSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy55ICs9ICh2IC0gdGhpcy5fbGF5b3V0Lm9yaWdpbmFsWSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnNldE9yaWdpbmFsWVdpdGhvdXRVcGRhdGluZ0xheW91dCh2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9XG5cbiAgICBzZXQgeSh2KSB7XG4gICAgICAgIGlmICh2ICE9PSB0aGlzLl95KSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zbGF0ZURlbHRhKDAsIHYgLSB0aGlzLl95KTtcbiAgICAgICAgICAgIHRoaXMuX3kgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGZ1bmNZKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX29wdEZsYWdzICYgMiA/IHRoaXMuX2Z1bmNZIDogbnVsbCk7XG4gICAgfVxuXG4gICAgc2V0IGZ1bmNZKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Z1bmNZICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRGbGFncyB8PSAyO1xuICAgICAgICAgICAgdGhpcy5fZnVuY1kgPSB2O1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnNldE9yaWdpbmFsWVdpdGhvdXRVcGRhdGluZ0xheW91dCgwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5mb3JjZUxheW91dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyUmVjYWxjVHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGlzYWJsZUZ1bmNZKCkge1xuICAgICAgICB0aGlzLl9vcHRGbGFncyA9IHRoaXMuX29wdEZsYWdzICYgKDB4RkZGRiAtIDIpO1xuICAgICAgICB0aGlzLl9mdW5jWSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGZ1bmNXKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX29wdEZsYWdzICYgNCA/IHRoaXMuX2Z1bmNXIDogbnVsbCk7XG4gICAgfVxuXG4gICAgc2V0IGZ1bmNXKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Z1bmNXICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRGbGFncyB8PSA0O1xuICAgICAgICAgICAgdGhpcy5fZnVuY1cgPSB2O1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0Ll9vcmlnaW5hbFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5jaGFuZ2VkRGltZW5zaW9ucyh0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3cgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJSZWNhbGNUcmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2FibGVGdW5jVygpIHtcbiAgICAgICAgdGhpcy5fb3B0RmxhZ3MgPSB0aGlzLl9vcHRGbGFncyAmICgweEZGRkYgLSA0KTtcbiAgICAgICAgdGhpcy5fZnVuY1cgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBmdW5jSCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9vcHRGbGFncyAmIDggPyB0aGlzLl9mdW5jSCA6IG51bGwpO1xuICAgIH1cblxuICAgIHNldCBmdW5jSCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9mdW5jSCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fb3B0RmxhZ3MgfD0gODtcbiAgICAgICAgICAgIHRoaXMuX2Z1bmNIID0gdjtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dC5fb3JpZ2luYWxIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LmNoYW5nZWREaW1lbnNpb25zKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclJlY2FsY1RyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzYWJsZUZ1bmNIKCkge1xuICAgICAgICB0aGlzLl9vcHRGbGFncyA9IHRoaXMuX29wdEZsYWdzICYgKDB4RkZGRiAtIDgpO1xuICAgICAgICB0aGlzLl9mdW5jSCA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93O1xuICAgIH1cblxuICAgIGdldFJlbmRlcldpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQub3JpZ2luYWxXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oO1xuICAgIH1cblxuICAgIGdldFJlbmRlckhlaWdodCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0Lm9yaWdpbmFsSGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2g7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2NhbGVYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVYO1xuICAgIH1cblxuICAgIHNldCBzY2FsZVgodikge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGVYICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9zY2FsZVggPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzY2FsZVkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVk7XG4gICAgfVxuXG4gICAgc2V0IHNjYWxlWSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zY2FsZVkgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlWSA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVg7XG4gICAgfVxuXG4gICAgc2V0IHNjYWxlKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlWCAhPT0gdiB8fCB0aGlzLl9zY2FsZVkgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlWCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9zY2FsZVkgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBwaXZvdFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFg7XG4gICAgfVxuXG4gICAgc2V0IHBpdm90WCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9waXZvdFggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90WCA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WTtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RZKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bpdm90WSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fcGl2b3RZID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNsYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcGl2b3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFg7XG4gICAgfVxuXG4gICAgc2V0IHBpdm90KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bpdm90WCAhPT0gdiB8fCB0aGlzLl9waXZvdFkgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90WCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9waXZvdFkgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2xhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBtb3VudFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3VudFg7XG4gICAgfVxuXG4gICAgc2V0IG1vdW50WCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb3VudFggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdW50WCA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IG1vdW50WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdW50WTtcbiAgICB9XG5cbiAgICBzZXQgbW91bnRZKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vdW50WSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fbW91bnRZID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNsYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3VudFg7XG4gICAgfVxuXG4gICAgc2V0IG1vdW50KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vdW50WCAhPT0gdiB8fCB0aGlzLl9tb3VudFkgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdW50WCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9tb3VudFkgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2xhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCByb3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICAgIH1cblxuICAgIHNldCByb3RhdGlvbih2KSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fcm90YXRpb24gPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBhbHBoYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhO1xuICAgIH1cblxuICAgIHNldCBhbHBoYSh2KSB7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIHJvdW5kaW5nIGVycm9ycy5cbiAgICAgICAgdiA9ICh2ID4gMSA/IDEgOiAodiA8IDFlLTE0ID8gMCA6IHYpKTtcbiAgICAgICAgaWYgKHRoaXMuX2FscGhhICE9PSB2KSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuX2FscGhhO1xuICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxBbHBoYSgpO1xuICAgICAgICAgICAgaWYgKChwcmV2ID09PSAwKSAhPT0gKHYgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5fdXBkYXRlRW5hYmxlZEZsYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9XG5cbiAgICBzZXQgdmlzaWJsZSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmxlICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsQWxwaGEoKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuX3VwZGF0ZUVuYWJsZWRGbGFnKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LnNldFZpc2libGUodik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlTG9jYWxUcmFuc2Zvcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gMCAmJiB0aGlzLl9yb3RhdGlvbiAlICgyICogTWF0aC5QSSkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcm90YXRpb24gaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJlbmRlci4gVGhpcyBtZWFucyB3ZSBvbmx5IG5lZWQgdG8gdXNlIHNpbiBhbmQgY29zIHdoZW4gcm90YXRpb24gYWN0dWFsbHkgY2hhbmdlc1xuICAgICAgICAgICAgbGV0IF9zciA9IE1hdGguc2luKHRoaXMuX3JvdGF0aW9uKTtcbiAgICAgICAgICAgIGxldCBfY3IgPSBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuX3NldExvY2FsVHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgIF9jciAqIHRoaXMuX3NjYWxlWCxcbiAgICAgICAgICAgICAgICAtX3NyICogdGhpcy5fc2NhbGVZLFxuICAgICAgICAgICAgICAgIF9zciAqIHRoaXMuX3NjYWxlWCxcbiAgICAgICAgICAgICAgICBfY3IgKiB0aGlzLl9zY2FsZVlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRMb2NhbFRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2FsZVgsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHRoaXMuX3NjYWxlWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zbGF0ZSgpO1xuICAgIH07XG5cbiAgICBfdXBkYXRlTG9jYWxUcmFuc2xhdGUoKSB7XG4gICAgICAgIHRoaXMuX3JlY2FsY0xvY2FsVHJhbnNsYXRlKCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJSZWNhbGNUcmFuc2xhdGUoKTtcbiAgICB9O1xuXG4gICAgX3JlY2FsY0xvY2FsVHJhbnNsYXRlKCkge1xuICAgICAgICBsZXQgcGl2b3RYTXVsID0gdGhpcy5fcGl2b3RYICogdGhpcy5fdztcbiAgICAgICAgbGV0IHBpdm90WU11bCA9IHRoaXMuX3Bpdm90WSAqIHRoaXMuX2g7XG4gICAgICAgIGxldCBweCA9IHRoaXMuX3ggLSAocGl2b3RYTXVsICogdGhpcy5fbG9jYWxUYSArIHBpdm90WU11bCAqIHRoaXMuX2xvY2FsVGIpICsgcGl2b3RYTXVsO1xuICAgICAgICBsZXQgcHkgPSB0aGlzLl95IC0gKHBpdm90WE11bCAqIHRoaXMuX2xvY2FsVGMgKyBwaXZvdFlNdWwgKiB0aGlzLl9sb2NhbFRkKSArIHBpdm90WU11bDtcbiAgICAgICAgcHggLT0gdGhpcy5fbW91bnRYICogdGhpcy5fdztcbiAgICAgICAgcHkgLT0gdGhpcy5fbW91bnRZICogdGhpcy5faDtcbiAgICAgICAgdGhpcy5fbG9jYWxQeCA9IHB4O1xuICAgICAgICB0aGlzLl9sb2NhbFB5ID0gcHk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZUxvY2FsVHJhbnNsYXRlRGVsdGEoZHgsIGR5KSB7XG4gICAgICAgIHRoaXMuX2FkZExvY2FsVHJhbnNsYXRlKGR4LCBkeSk7XG4gICAgfTtcblxuICAgIF91cGRhdGVMb2NhbEFscGhhKCkge1xuICAgICAgICB0aGlzLl9zZXRMb2NhbEFscGhhKHRoaXMuX3Zpc2libGUgPyB0aGlzLl9hbHBoYSA6IDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICAgICAqIDA6IG5vIHVwZGF0ZXNcbiAgICAgKiAxOiByZS1pbnZva2Ugc2hhZGVyXG4gICAgICogMzogcmUtY3JlYXRlIHJlbmRlciB0ZXh0dXJlIGFuZCByZS1pbnZva2Ugc2hhZGVyXG4gICAgICovXG4gICAgc2V0SGFzUmVuZGVyVXBkYXRlcyh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3JsZENvbnRleHQuYWxwaGEpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBpZiAnd29ybGQgaW52aXNpYmxlJy4gUmVuZGVyIHVwZGF0ZXMgd2lsbCBiZSByZXNldCB0byAzIGZvciBldmVyeSBlbGVtZW50IHRoYXQgYmVjb21lcyB2aXNpYmxlLlxuICAgICAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICAgICAgcC5faGFzUmVuZGVyVXBkYXRlcyA9IE1hdGgubWF4KHR5cGUsIHAuX2hhc1JlbmRlclVwZGF0ZXMpO1xuICAgICAgICAgICAgd2hpbGUgKChwID0gcC5fcGFyZW50KSAmJiAocC5faGFzUmVuZGVyVXBkYXRlcyAhPT0gMykpIHtcbiAgICAgICAgICAgICAgICBwLl9oYXNSZW5kZXJVcGRhdGVzID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlXG4gICAgICogICAxOiBhbHBoYVxuICAgICAqICAgMjogdHJhbnNsYXRlXG4gICAgICogICA0OiB0cmFuc2Zvcm1cbiAgICAgKiAxMjg6IGJlY29tZXMgdmlzaWJsZVxuICAgICAqIDI1NjogZmxleCBsYXlvdXQgdXBkYXRlZFxuICAgICAqL1xuICAgIF9zZXRSZWNhbGModHlwZSkge1xuICAgICAgICB0aGlzLl9yZWNhbGMgfD0gdHlwZTtcblxuICAgICAgICB0aGlzLl9zZXRIYXNVcGRhdGVzKCk7XG5cbiAgICAgICAgLy8gQW55IGNoYW5nZXMgaW4gZGVzY2VuZGFudHMgc2hvdWxkIHRyaWdnZXIgdGV4dHVyZSB1cGRhdGVzLlxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuc2V0SGFzUmVuZGVyVXBkYXRlcygzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRIYXNVcGRhdGVzKCkge1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwICYmICFwLl9oYXNVcGRhdGVzKSB7XG4gICAgICAgICAgICBwLl9oYXNVcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHAgPSBwLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfVxuXG4gICAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ICE9PSB0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIGxldCBwcmV2SXNaQ29udGV4dCA9IHRoaXMuaXNaQ29udGV4dCgpO1xuICAgICAgICAgICAgbGV0IHByZXZQYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgICAgIC8vIE5vdGlmeSBmbGV4IGxheW91dCBlbmdpbmUuXG4gICAgICAgICAgICBpZiAodGhpcy5fbGF5b3V0IHx8IChwYXJlbnQgJiYgcGFyZW50LmlzRmxleENvbnRhaW5lcigpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LnNldFBhcmVudChwcmV2UGFyZW50LCBwYXJlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldlBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gZWxlbWVudHMgYXJlIGRlbGV0ZWQsIHRoZSByZW5kZXIgdGV4dHVyZSBtdXN0IGJlIHJlLXJlbmRlcmVkLlxuICAgICAgICAgICAgICAgIHByZXZQYXJlbnQuc2V0SGFzUmVuZGVyVXBkYXRlcygzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDEgKyAyICsgNCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBwYXJlbnQgdG8gcHJvcGFnYXRlIGhhc1VwZGF0ZXMgZmxhZy5cbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3NldEhhc1VwZGF0ZXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3pJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0WlBhcmVudChwYXJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFpQYXJlbnQocGFyZW50ID8gcGFyZW50LmZpbmRaQ29udGV4dCgpIDogbnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2SXNaQ29udGV4dCAhPT0gdGhpcy5pc1pDb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNaQ29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZVpDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGVaQ29udGV4dChwcmV2UGFyZW50LmZpbmRaQ29udGV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyZWUgb3JkZXIgZGlkIGNoYW5nZTogZXZlbiBpZiB6UGFyZW50IHN0YXlzIHRoZSBzYW1lLCB3ZSBtdXN0IHJlc29ydC5cbiAgICAgICAgICAgIHRoaXMuX3pJbmRleFJlc29ydCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5felBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3pQYXJlbnQuZW5hYmxlWlNvcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaGFkZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3U2hhZGVyT3duZXIgPSBwYXJlbnQgJiYgIXBhcmVudC5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCA/IHBhcmVudC5fc2hhZGVyT3duZXIgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTaGFkZXJPd25lciAhPT0gdGhpcy5fc2hhZGVyT3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTaGFkZXJPd25lclJlY3Vyc2l2ZShuZXdTaGFkZXJPd25lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGVuYWJsZVpTb3J0KGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl96U29ydCAmJiB0aGlzLl96Q29udGV4dFVzYWdlID4gMCkge1xuICAgICAgICAgICAgdGhpcy5felNvcnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gWlNvcnQgbXVzdCBiZSBkb25lLCBldmVuIGlmIHRoaXMgZWxlbWVudCBpcyBpbnZpc2libGUuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIHdoZW4gcmVtb3ZpbmcgZWxlbWVudCBmcm9tIGluYWN0aXZlIHJlbmRlciBicmFuY2hlcy5cbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5mb3JjZVpTb3J0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkQ2hpbGRBdChpbmRleCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jaGlsZHJlbikgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG4gICAgICAgIGNoaWxkLnNldFBhcmVudCh0aGlzKTtcbiAgICB9O1xuXG4gICAgc2V0Q2hpbGRBdChpbmRleCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jaGlsZHJlbikgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW5baW5kZXhdLnNldFBhcmVudChudWxsKTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW5baW5kZXhdID0gY2hpbGQ7XG4gICAgICAgIGNoaWxkLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG5cbiAgICByZW1vdmVDaGlsZEF0KGluZGV4KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgY2hpbGQuc2V0UGFyZW50KG51bGwpO1xuICAgIH07XG5cbiAgICByZW1vdmVDaGlsZHJlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLnNldFBhcmVudChudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKDApO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fekluZGV4ZWRDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4uc3BsaWNlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN5bmNDaGlsZHJlbihyZW1vdmVkLCBhZGRlZCwgb3JkZXIpIHtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBvcmRlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSByZW1vdmVkLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcmVtb3ZlZFtpXS5zZXRQYXJlbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhZGRlZC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGFkZGVkW2ldLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVDaGlsZChmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgbGV0IGMgPSB0aGlzLl9jaGlsZHJlbltmcm9tSW5kZXhdO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoZnJvbUluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKHRvSW5kZXgsIDAsIGMpO1xuXG4gICAgICAgIC8vIFRyZWUgb3JkZXIgY2hhbmdlZDogbXVzdCByZXNvcnQhO1xuICAgICAgICB0aGlzLl96SW5kZXhSZXNvcnQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5felBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5felBhcmVudC5lbmFibGVaU29ydCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldExvY2FsVHJhbnNmb3JtKGEsIGIsIGMsIGQpIHtcbiAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDQpO1xuICAgICAgICB0aGlzLl9sb2NhbFRhID0gYTtcbiAgICAgICAgdGhpcy5fbG9jYWxUYiA9IGI7XG4gICAgICAgIHRoaXMuX2xvY2FsVGMgPSBjO1xuICAgICAgICB0aGlzLl9sb2NhbFRkID0gZDtcblxuICAgICAgICAvLyBXZSBhbHNvIHJlZ2FyZCBuZWdhdGl2ZSBzY2FsaW5nIGFzIGEgY29tcGxleCBjYXNlLCBzbyB0aGF0IHdlIGNhbiBvcHRpbWl6ZSB0aGUgbm9uLWNvbXBsZXggY2FzZSBiZXR0ZXIuXG4gICAgICAgIHRoaXMuX2lzQ29tcGxleCA9IChiICE9PSAwKSB8fCAoYyAhPT0gMCkgfHwgKGEgPCAwKSB8fCAoZCA8IDApO1xuICAgIH07XG5cbiAgICBfYWRkTG9jYWxUcmFuc2xhdGUoZHgsIGR5KSB7XG4gICAgICAgIHRoaXMuX2xvY2FsUHggKz0gZHg7XG4gICAgICAgIHRoaXMuX2xvY2FsUHkgKz0gZHk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJSZWNhbGNUcmFuc2xhdGUoKTtcbiAgICB9XG5cbiAgICBfc2V0TG9jYWxBbHBoYShhKSB7XG4gICAgICAgIGlmICghdGhpcy5fd29ybGRDb250ZXh0LmFscGhhICYmICgodGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5fd29ybGRDb250ZXh0LmFscGhhKSAmJiBhKSkge1xuICAgICAgICAgICAgLy8gRWxlbWVudCBpcyBiZWNvbWluZyB2aXNpYmxlLiBXZSBuZWVkIHRvIGZvcmNlIHVwZGF0ZS5cbiAgICAgICAgICAgIHRoaXMuX3NldFJlY2FsYygxICsgMTI4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFJlY2FsYygxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhIDwgMWUtMTQpIHtcbiAgICAgICAgICAgIC8vIFRpbnkgcm91bmRpbmcgZXJyb3JzIG1heSBjYXVzZSBmYWlsaW5nIHZpc2liaWxpdHkgdGVzdHMuXG4gICAgICAgICAgICBhID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvY2FsQWxwaGEgPSBhO1xuICAgIH07XG5cbiAgICBzZXREaW1lbnNpb25zKHcsIGgsIGlzRXN0aW1hdGUgPSB0aGlzLl9kaW1zVW5rbm93bikge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVzdGltYXRpb24sIHRoZSB1cGRhdGUgbG9vcCBzaG91bGQgcGVyZm9ybSBkaWZmZXJlbnQgYm91bmQgY2hlY2tzLlxuICAgICAgICB0aGlzLl9kaW1zVW5rbm93biA9IGlzRXN0aW1hdGU7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQub3JpZ2luYWxXaWR0aCA9IHc7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQub3JpZ2luYWxIZWlnaHQgPSBoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3cgIT09IHcgfHwgdGhpcy5faCAhPT0gaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnModywgaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfdXBkYXRlRGltZW5zaW9ucyh3LCBoKSB7XG4gICAgICAgIGlmICh0aGlzLl93ICE9PSB3IHx8IHRoaXMuX2ggIT09IGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3cgPSB3O1xuICAgICAgICAgICAgdGhpcy5faCA9IGg7XG5cbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJSZWNhbGNUcmFuc2xhdGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cml6ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyLnJlbGVhc2VSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplci51cGRhdGVSZXN1bHRUZXh0dXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEdWUgdG8gd2lkdGgvaGVpZ2h0IGNoYW5nZTogdXBkYXRlIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VGV4dHVyZUNvb3Jkcyh1bHgsIHVseSwgYnJ4LCBicnkpIHtcbiAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKDMpO1xuXG4gICAgICAgIHRoaXMuX3VseCA9IHVseDtcbiAgICAgICAgdGhpcy5fdWx5ID0gdWx5O1xuICAgICAgICB0aGlzLl9icnggPSBicng7XG4gICAgICAgIHRoaXMuX2JyeSA9IGJyeTtcbiAgICB9O1xuXG4gICAgZ2V0IGRpc3BsYXllZFRleHR1cmVTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlO1xuICAgIH1cblxuICAgIHNldERpc3BsYXllZFRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSkge1xuICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXMoMyk7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UgPSB0ZXh0dXJlU291cmNlO1xuICAgIH07XG5cbiAgICBnZXQgaXNSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNSb290O1xuICAgIH1cblxuICAgIHNldEFzUm9vdCgpIHtcbiAgICAgICAgLy8gVXNlIHBhcmVudCBkdW1teS5cbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbmV3IEVsZW1lbnRDb3JlKHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICAgIC8vIEFmdGVyIHNldHRpbmcgcm9vdCwgbWFrZSBzdXJlIGl0J3MgdXBkYXRlZC5cbiAgICAgICAgdGhpcy5fcGFyZW50Ll9oYXNSZW5kZXJVcGRhdGVzID0gMztcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9oYXNVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgICAvLyBSb290IGlzLCBhbmQgd2lsbCBhbHdheXMgYmUsIHRoZSBwcmltYXJ5IHpDb250ZXh0LlxuICAgICAgICB0aGlzLl9pc1Jvb3QgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY3R4LnJvb3QgPSB0aGlzO1xuXG4gICAgICAgIC8vIFNldCBzY2lzc29yIGFyZWEgb2YgJ2Zha2UgcGFyZW50JyB0byBzdGFnZSdzIHZpZXdwb3J0LlxuICAgICAgICB0aGlzLl9wYXJlbnQuX3ZpZXdwb3J0ID0gWzAsIDAsIHRoaXMuY3R4LnN0YWdlLmNvb3Jkc1dpZHRoLCB0aGlzLmN0eC5zdGFnZS5jb29yZHNIZWlnaHRdO1xuICAgICAgICB0aGlzLl9wYXJlbnQuX3NjaXNzb3IgPSB0aGlzLl9wYXJlbnQuX3ZpZXdwb3J0O1xuXG4gICAgICAgIC8vIFdoZW4gcmVjQm91bmRzTWFyZ2luIGlzIG51bGwsIHRoZSBkZWZhdWx0cyBhcmUgdXNlZCAoMTAwIGZvciBhbGwgc2lkZXMpLlxuICAgICAgICB0aGlzLl9wYXJlbnQuX3JlY0JvdW5kc01hcmdpbiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDEgKyAyICsgNCk7XG4gICAgfTtcblxuICAgIGlzQW5jZXN0b3JPZihjKSB7XG4gICAgICAgIGxldCBwID0gYztcbiAgICAgICAgd2hpbGUgKHAgPSBwLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBpc1pDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2ZvcmNlWkluZGV4Q29udGV4dCB8fCB0aGlzLl9yZW5kZXJUb1RleHR1cmVFbmFibGVkIHx8IHRoaXMuX3pJbmRleCAhPT0gMCB8fCB0aGlzLl9pc1Jvb3QgfHwgIXRoaXMuX3BhcmVudCk7XG4gICAgfTtcblxuICAgIGZpbmRaQ29udGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaQ29udGV4dCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQuZmluZFpDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2V0WlBhcmVudChuZXdaUGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl96UGFyZW50ICE9PSBuZXdaUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5felBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl96SW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5felBhcmVudC5kZWNaQ29udGV4dFVzYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBmaWx0ZXIgb3V0IHRoaXMgaXRlbSB1cG9uIHRoZSBuZXh0IHJlc29ydC5cbiAgICAgICAgICAgICAgICB0aGlzLl96UGFyZW50LmVuYWJsZVpTb3J0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdaUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhZFpDb250ZXh0VXNhZ2UgPSAobmV3WlBhcmVudC5fekNvbnRleHRVc2FnZSA+IDApO1xuXG4gICAgICAgICAgICAgICAgLy8gQHByZTogbmV3IHBhcmVudCdzIGNoaWxkcmVuIGFycmF5IGhhcyBhbHJlYWR5IGJlZW4gbW9kaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdaUGFyZW50LmluY1pDb250ZXh0VXNhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3WlBhcmVudC5fekNvbnRleHRVc2FnZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYWRaQ29udGV4dFVzYWdlICYmICh0aGlzLl9wYXJlbnQgPT09IG5ld1pQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNoaWxkIHdhcyBhbHJlYWR5IGluIHRoZSBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGFkZCBkb3VibGUuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IGNoaWxkIHRvIGFycmF5LlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3WlBhcmVudC5fekluZGV4ZWRDaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3JkZXIgc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgICAgICAgICAgICAgICAgIG5ld1pQYXJlbnQuZW5hYmxlWlNvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3pQYXJlbnQgPSBuZXdaUGFyZW50O1xuXG4gICAgICAgICAgICAvLyBOZXdseSBhZGRlZCBlbGVtZW50IG11c3QgYmUgbWFya2VkIGZvciByZXNvcnQuXG4gICAgICAgICAgICB0aGlzLl96SW5kZXhSZXNvcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGluY1pDb250ZXh0VXNhZ2UoKSB7XG4gICAgICAgIHRoaXMuX3pDb250ZXh0VXNhZ2UrKztcbiAgICAgICAgaWYgKHRoaXMuX3pDb250ZXh0VXNhZ2UgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fekluZGV4ZWRDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIC8vIENvcHkuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fekluZGV4ZWRDaGlsZHJlbi5wdXNoKHRoaXMuX2NoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGx5LCBjaGlsZHJlbiBhcmUgYWxyZWFkeSBzb3J0ZWQgcHJvcGVybHkgKHRyZWUgb3JkZXIpLlxuICAgICAgICAgICAgICAgIHRoaXMuX3pTb3J0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVjWkNvbnRleHRVc2FnZSgpIHtcbiAgICAgICAgdGhpcy5fekNvbnRleHRVc2FnZS0tO1xuICAgICAgICBpZiAodGhpcy5fekNvbnRleHRVc2FnZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5felNvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4uc3BsaWNlKDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldCB6SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96SW5kZXg7XG4gICAgfVxuXG4gICAgc2V0IHpJbmRleCh6SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3pJbmRleCAhPT0gekluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXMoMSk7XG5cbiAgICAgICAgICAgIGxldCBuZXdaUGFyZW50ID0gdGhpcy5felBhcmVudDtcblxuICAgICAgICAgICAgbGV0IHByZXZJc1pDb250ZXh0ID0gdGhpcy5pc1pDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAoekluZGV4ID09PSAwICYmIHRoaXMuX3pJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgPT09IHRoaXMuX3pQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3pQYXJlbnQuZGVjWkNvbnRleHRVc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3WlBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHpJbmRleCAhPT0gMCAmJiB0aGlzLl96SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXdaUGFyZW50ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZpbmRaQ29udGV4dCgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobmV3WlBhcmVudCA9PT0gdGhpcy5felBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5felBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5felBhcmVudC5pbmNaQ29udGV4dFVzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl96UGFyZW50LmVuYWJsZVpTb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHpJbmRleCAhPT0gdGhpcy5fekluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pQYXJlbnQgJiYgdGhpcy5felBhcmVudC5fekNvbnRleHRVc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl96UGFyZW50LmVuYWJsZVpTb3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3WlBhcmVudCAhPT0gdGhpcy5felBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0WlBhcmVudChudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fekluZGV4ID0gekluZGV4O1xuXG4gICAgICAgICAgICBpZiAobmV3WlBhcmVudCAhPT0gdGhpcy5felBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0WlBhcmVudChuZXdaUGFyZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZJc1pDb250ZXh0ICE9PSB0aGlzLmlzWkNvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1pDb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlWkNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZVpDb250ZXh0KHRoaXMuX3BhcmVudC5maW5kWkNvbnRleHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCByZXNvcnQgaXMgZG9uZS5cbiAgICAgICAgICAgIHRoaXMuX3pJbmRleFJlc29ydCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5felBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3pQYXJlbnQuZW5hYmxlWlNvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXQgZm9yY2VaSW5kZXhDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yY2VaSW5kZXhDb250ZXh0O1xuICAgIH1cblxuICAgIHNldCBmb3JjZVpJbmRleENvbnRleHQodikge1xuICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXMoMSk7XG5cbiAgICAgICAgbGV0IHByZXZJc1pDb250ZXh0ID0gdGhpcy5pc1pDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuX2ZvcmNlWkluZGV4Q29udGV4dCA9IHY7XG5cbiAgICAgICAgaWYgKHByZXZJc1pDb250ZXh0ICE9PSB0aGlzLmlzWkNvbnRleHQoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzWkNvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZVpDb250ZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlWkNvbnRleHQodGhpcy5fcGFyZW50LmZpbmRaQ29udGV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBlbmFibGVaQ29udGV4dChwcmV2WkNvbnRleHQpIHtcbiAgICAgICAgaWYgKHByZXZaQ29udGV4dCAmJiBwcmV2WkNvbnRleHQuX3pDb250ZXh0VXNhZ2UgPiAwKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2ZlciBmcm9tIHVwcGVyIHogY29udGV4dCB0byB0aGlzIHogY29udGV4dC5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLl9nZXRaSW5kZXhlZERlc2NzKCk7XG4gICAgICAgICAgICByZXN1bHRzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FuY2VzdG9yT2YoYykgJiYgYy5fekluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuc2V0WlBhcmVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRaSW5kZXhlZERlc2NzKCkge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS5fZ2V0WkluZGV4ZWREZXNjc1JlYyhyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBfZ2V0WkluZGV4ZWREZXNjc1JlYyhyZXN1bHRzKSB7XG4gICAgICAgIGlmICh0aGlzLl96SW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jaGlsZHJlbiAmJiAhdGhpcy5pc1pDb250ZXh0KCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0uX2dldFpJbmRleGVkRGVzY3NSZWMocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNhYmxlWkNvbnRleHQoKSB7XG4gICAgICAgIC8vIFRyYW5zZmVyIGZyb20gdGhpcyB6IGNvbnRleHQgdG8gdXBwZXIgeiBjb250ZXh0LlxuICAgICAgICBpZiAodGhpcy5fekNvbnRleHRVc2FnZSA+IDApIHtcbiAgICAgICAgICAgIGxldCBuZXdaUGFyZW50ID0gdGhpcy5fcGFyZW50LmZpbmRaQ29udGV4dCgpO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB6LWluZGV4ZWQgY2hpbGRyZW4gYXJlIHVwIHRvIGRhdGUgKG9sZCBvbmVzIHJlbW92ZWQpLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3pTb3J0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0WkluZGV4ZWRDaGlsZHJlbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl96SW5kZXhlZENoaWxkcmVuLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIGlmIChjLl96SW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRaUGFyZW50KG5ld1pQYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldCBjb2xvclVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JVbDtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JVbChjb2xvcikge1xuICAgICAgICBpZiAodGhpcy5fY29sb3JVbCAhPT0gY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcyh0aGlzLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlID8gMyA6IDEpO1xuICAgICAgICAgICAgdGhpcy5fY29sb3JVbCA9IGNvbG9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yVXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvclVyO1xuICAgIH1cblxuICAgIHNldCBjb2xvclVyKGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvclVyICE9PSBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKHRoaXMuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UgPyAzIDogMSk7XG4gICAgICAgICAgICB0aGlzLl9jb2xvclVyID0gY29sb3I7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0IGNvbG9yQmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvckJsO1xuICAgIH1cblxuICAgIHNldCBjb2xvckJsKGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvckJsICE9PSBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKHRoaXMuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UgPyAzIDogMSk7XG4gICAgICAgICAgICB0aGlzLl9jb2xvckJsID0gY29sb3I7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0IGNvbG9yQnIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvckJyO1xuICAgIH1cblxuICAgIHNldCBjb2xvckJyKGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvckJyICE9PSBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKHRoaXMuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UgPyAzIDogMSk7XG4gICAgICAgICAgICB0aGlzLl9jb2xvckJyID0gY29sb3I7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBzZXQgb25VcGRhdGUoZikge1xuICAgICAgICB0aGlzLl9vblVwZGF0ZSA9IGY7XG4gICAgICAgIHRoaXMuX3NldFJlY2FsYyg3KTtcbiAgICB9XG5cbiAgICBzZXQgb25BZnRlclVwZGF0ZShmKSB7XG4gICAgICAgIHRoaXMuX29uQWZ0ZXJVcGRhdGUgPSBmO1xuICAgICAgICB0aGlzLl9zZXRSZWNhbGMoNyk7XG4gICAgfVxuXG4gICAgc2V0IG9uQWZ0ZXJDYWxjcyhmKSB7XG4gICAgICAgIHRoaXMuX29uQWZ0ZXJDYWxjcyA9IGY7XG4gICAgICAgIHRoaXMuX3NldFJlY2FsYyg3KTtcbiAgICB9XG5cbiAgICBnZXQgc2hhZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZGVyO1xuICAgIH1cblxuICAgIHNldCBzaGFkZXIodikge1xuICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXMoMSk7XG5cbiAgICAgICAgbGV0IHByZXZTaGFkZXIgPSB0aGlzLl9zaGFkZXI7XG4gICAgICAgIHRoaXMuX3NoYWRlciA9IHY7XG4gICAgICAgIGlmICghdiAmJiBwcmV2U2hhZGVyKSB7XG4gICAgICAgICAgICAvLyBEaXNhYmxlZCBzaGFkZXIuXG4gICAgICAgICAgICBsZXQgbmV3U2hhZGVyT3duZXIgPSAodGhpcy5fcGFyZW50ICYmICF0aGlzLl9wYXJlbnQuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQgPyB0aGlzLl9wYXJlbnQuX3NoYWRlck93bmVyIDogbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRTaGFkZXJPd25lclJlY3Vyc2l2ZShuZXdTaGFkZXJPd25lcik7XG4gICAgICAgIH0gZWxzZSBpZiAodikge1xuICAgICAgICAgICAgLy8gRW5hYmxlZCBzaGFkZXIuXG4gICAgICAgICAgICB0aGlzLl9zZXRTaGFkZXJPd25lclJlY3Vyc2l2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBhY3RpdmVTaGFkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkZXJPd25lciA/IHRoaXMuX3NoYWRlck93bmVyLnNoYWRlciA6IHRoaXMucmVuZGVyU3RhdGUuZGVmYXVsdFNoYWRlcjtcbiAgICB9XG5cbiAgICBnZXQgYWN0aXZlU2hhZGVyT3duZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkZXJPd25lcjtcbiAgICB9XG5cbiAgICBnZXQgY2xpcHBpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGlwcGluZztcbiAgICB9XG5cbiAgICBzZXQgY2xpcHBpbmcodikge1xuICAgICAgICBpZiAodGhpcy5fY2xpcHBpbmcgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBwaW5nID0gdjtcblxuICAgICAgICAgICAgLy8gRm9yY2UgdXBkYXRlIG9mIHNjaXNzb3IgYnkgdXBkYXRpbmcgdHJhbnNsYXRlLlxuICAgICAgICAgICAgLy8gQWxwaGEgbXVzdCBhbHNvIGJlIHVwZGF0ZWQgYmVjYXVzZSB0aGUgc2Npc3NvciBhcmVhIG1heSBoYXZlIGJlZW4gZW1wdHkuXG4gICAgICAgICAgICB0aGlzLl9zZXRSZWNhbGMoMSArIDIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGNsaXBib3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGlwYm94O1xuICAgIH1cblxuICAgIHNldCBjbGlwYm94KHYpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBvdXQtb2YtYm91bmRzIGVsZW1lbnQsIGFsbCBjaGlsZHJlbiB3aWxsIGFsc28gYmUgaWdub3JlZC5cbiAgICAgICAgLy8gSXQgd2lsbCBzYXZlIHVzIGZyb20gZXhlY3V0aW5nIHRoZSB1cGRhdGUvcmVuZGVyIGxvb3BzIGZvciB0aG9zZS5cbiAgICAgICAgLy8gVGhlIG9wdGltaXphdGlvbiB3aWxsIGJlIHVzZWQgaW1tZWRpYXRlbHkgZHVyaW5nIHRoZSBuZXh0IGZyYW1lLlxuICAgICAgICB0aGlzLl9jbGlwYm94ID0gdjtcbiAgICB9XG5cbiAgICBfc2V0U2hhZGVyT3duZXJSZWN1cnNpdmUoZWxlbWVudENvcmUpIHtcbiAgICAgICAgdGhpcy5fc2hhZGVyT3duZXIgPSBlbGVtZW50Q29yZTtcblxuICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4gJiYgIXRoaXMuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWMuX3NoYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBjLl9zZXRTaGFkZXJPd25lclJlY3Vyc2l2ZShlbGVtZW50Q29yZSk7XG4gICAgICAgICAgICAgICAgICAgIGMuX2hhc1JlbmRlclVwZGF0ZXMgPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfc2V0U2hhZGVyT3duZXJDaGlsZHJlblJlY3Vyc2l2ZShlbGVtZW50Q29yZSkge1xuICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWMuX3NoYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBjLl9zZXRTaGFkZXJPd25lclJlY3Vyc2l2ZShlbGVtZW50Q29yZSk7XG4gICAgICAgICAgICAgICAgICAgIGMuX2hhc1JlbmRlclVwZGF0ZXMgPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfaGFzUmVuZGVyQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckNvbnRleHQgIT09IHRoaXMuX3dvcmxkQ29udGV4dDtcbiAgICB9XG5cbiAgICBnZXQgcmVuZGVyQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckNvbnRleHQ7XG4gICAgfVxuXG4gICAgdXBkYXRlUmVuZGVyVG9UZXh0dXJlRW5hYmxlZCgpIHtcbiAgICAgICAgLy8gRW5mb3JjZSB0ZXh0dXJpemVyIGluaXRpYWxpc2F0aW9uLlxuICAgICAgICBsZXQgdiA9IHRoaXMudGV4dHVyaXplci5fZW5hYmxlZDtcblxuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlUmVuZGVyVG9UZXh0dXJlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlUmVuZGVyVG9UZXh0dXJlKCk7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyLnJlbGVhc2VSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZW5hYmxlUmVuZGVyVG9UZXh0dXJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIGxldCBwcmV2SXNaQ29udGV4dCA9IHRoaXMuaXNaQ29udGV4dCgpO1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUb1RleHR1cmVFbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dCA9IG5ldyBFbGVtZW50Q29yZUNvbnRleHQoKTtcblxuICAgICAgICAgICAgLy8gSWYgcmVuZGVyIHRvIHRleHR1cmUgaXMgYWN0aXZlLCBhIG5ldyBzaGFkZXIgY29udGV4dCBpcyBzdGFydGVkLlxuICAgICAgICAgICAgdGhpcy5fc2V0U2hhZGVyT3duZXJDaGlsZHJlblJlY3Vyc2l2ZShudWxsKTtcblxuICAgICAgICAgICAgaWYgKCFwcmV2SXNaQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbmRlciBjb250ZXh0IGZvcmNlcyB6IGNvbnRleHQuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVaQ29udGV4dCh0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZmluZFpDb250ZXh0KCkgOiBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKDMpO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcmVuZGVyIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkLlxuICAgICAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDcpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMuX3JlbmRlckFkdmFuY2VkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Rpc2FibGVSZW5kZXJUb1RleHR1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUb1RleHR1cmVFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUb1RleHR1cmVFbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFNoYWRlck93bmVyQ2hpbGRyZW5SZWN1cnNpdmUodGhpcy5fc2hhZGVyT3duZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0ID0gdGhpcy5fd29ybGRDb250ZXh0O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNaQ29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlWkNvbnRleHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHJlbmRlciBjb29yZGluYXRlcyBnZXQgdXBkYXRlZC5cbiAgICAgICAgICAgIHRoaXMuX3NldFJlY2FsYyg3KTtcblxuICAgICAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKDMpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMuX3JlbmRlclNpbXBsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzV2hpdGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fY29sb3JVbCA9PT0gMHhGRkZGRkZGRikgJiYgKHRoaXMuX2NvbG9yVXIgPT09IDB4RkZGRkZGRkYpICYmICh0aGlzLl9jb2xvckJsID09PSAweEZGRkZGRkZGKSAmJiAodGhpcy5fY29sb3JCciA9PT0gMHhGRkZGRkZGRik7XG4gICAgfVxuXG4gICAgaGFzU2ltcGxlVGV4Q29vcmRzKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3VseCA9PT0gMCkgJiYgKHRoaXMuX3VseSA9PT0gMCkgJiYgKHRoaXMuX2JyeCA9PT0gMSkgJiYgKHRoaXMuX2JyeSA9PT0gMSk7XG4gICAgfVxuXG4gICAgX3N0YXNoVGV4Q29vcmRzKCkge1xuICAgICAgICB0aGlzLl9zdGFzaGVkVGV4Q29vcmRzID0gW3RoaXMuX3VseCwgdGhpcy5fdWx5LCB0aGlzLl9icngsIHRoaXMuX2JyeV07XG4gICAgICAgIHRoaXMuX3VseCA9IDA7XG4gICAgICAgIHRoaXMuX3VseSA9IDA7XG4gICAgICAgIHRoaXMuX2JyeCA9IDE7XG4gICAgICAgIHRoaXMuX2JyeSA9IDE7XG4gICAgfVxuXG4gICAgX3Vuc3Rhc2hUZXhDb29yZHMoKSB7XG4gICAgICAgIHRoaXMuX3VseCA9IHRoaXMuX3N0YXNoZWRUZXhDb29yZHNbMF07XG4gICAgICAgIHRoaXMuX3VseSA9IHRoaXMuX3N0YXNoZWRUZXhDb29yZHNbMV07XG4gICAgICAgIHRoaXMuX2JyeCA9IHRoaXMuX3N0YXNoZWRUZXhDb29yZHNbMl07XG4gICAgICAgIHRoaXMuX2JyeSA9IHRoaXMuX3N0YXNoZWRUZXhDb29yZHNbM107XG4gICAgICAgIHRoaXMuX3N0YXNoZWRUZXhDb29yZHMgPSBudWxsO1xuICAgIH1cblxuICAgIF9zdGFzaENvbG9ycygpIHtcbiAgICAgICAgdGhpcy5fc3Rhc2hlZENvbG9ycyA9IFt0aGlzLl9jb2xvclVsLCB0aGlzLl9jb2xvclVyLCB0aGlzLl9jb2xvckJyLCB0aGlzLl9jb2xvckJsXTtcbiAgICAgICAgdGhpcy5fY29sb3JVbCA9IDB4RkZGRkZGRkY7XG4gICAgICAgIHRoaXMuX2NvbG9yVXIgPSAweEZGRkZGRkZGO1xuICAgICAgICB0aGlzLl9jb2xvckJyID0gMHhGRkZGRkZGRjtcbiAgICAgICAgdGhpcy5fY29sb3JCbCA9IDB4RkZGRkZGRkY7XG4gICAgfVxuXG4gICAgX3Vuc3Rhc2hDb2xvcnMoKSB7XG4gICAgICAgIHRoaXMuX2NvbG9yVWwgPSB0aGlzLl9zdGFzaGVkQ29sb3JzWzBdO1xuICAgICAgICB0aGlzLl9jb2xvclVyID0gdGhpcy5fc3Rhc2hlZENvbG9yc1sxXTtcbiAgICAgICAgdGhpcy5fY29sb3JCciA9IHRoaXMuX3N0YXNoZWRDb2xvcnNbMl07XG4gICAgICAgIHRoaXMuX2NvbG9yQmwgPSB0aGlzLl9zdGFzaGVkQ29sb3JzWzNdO1xuICAgICAgICB0aGlzLl9zdGFzaGVkQ29sb3JzID0gbnVsbDtcbiAgICB9XG5cbiAgICBpc1Zpc2libGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fbG9jYWxBbHBoYSA+IDFlLTE0KTtcbiAgICB9O1xuXG4gICAgZ2V0IG91dE9mQm91bmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3V0T2ZCb3VuZHM7XG4gICAgfVxuXG4gICAgc2V0IGJvdW5kc01hcmdpbih2KSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICBudWxsOiBpbmhlcml0IGZyb20gcGFyZW50LlxuICAgICAgICAgKiAgbnVtYmVyWzRdOiBzcGVjaWZpYyBtYXJnaW5zOiBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ib3VuZHNNYXJnaW4gPSB2ID8gdi5zbGljZSgpIDogbnVsbDtcblxuICAgICAgICAvLyBXZSBmb3JjZSByZWNhbGMgaW4gb3JkZXIgdG8gc2V0IGFsbCBib3VuZHNNYXJnaW4gcmVjdXJzaXZlbHkgZHVyaW5nIHRoZSBuZXh0IHVwZGF0ZS5cbiAgICAgICAgdGhpcy5fdHJpZ2dlclJlY2FsY1RyYW5zbGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCBib3VuZHNNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHNNYXJnaW47XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9yZWNhbGMgfD0gdGhpcy5fcGFyZW50Ll9wUmVjYWxjO1xuXG4gICAgICAgIGlmICh0aGlzLl9sYXlvdXQgJiYgdGhpcy5fbGF5b3V0LmlzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVjYWxjICYgMjU2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0LmxheW91dEZsZXhUcmVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKHRoaXMuX3JlY2FsYyAmIDIpICYmIHRoaXMuX29wdEZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVJlbGF0aXZlRGltRnVuY3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vblVwZGF0ZSkge1xuICAgICAgICAgICAgLy8gQmxvY2sgYWxsICd1cHdhcmRzJyB1cGRhdGVzIHdoZW4gY2hhbmdpbmcgdGhpbmdzIGluIHRoaXMgYnJhbmNoLlxuICAgICAgICAgICAgdGhpcy5faGFzVXBkYXRlcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9vblVwZGF0ZSh0aGlzLmVsZW1lbnQsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHcgPSB0aGlzLl9wYXJlbnQuX3dvcmxkQ29udGV4dDtcbiAgICAgICAgbGV0IHcgPSB0aGlzLl93b3JsZENvbnRleHQ7XG4gICAgICAgIGNvbnN0IHZpc2libGUgPSAocHcuYWxwaGEgJiYgdGhpcy5fbG9jYWxBbHBoYSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIG11c3QgdXBkYXRlIGlmOlxuICAgICAgICAgKiAtIGJyYW5jaCBjb250YWlucyB1cGRhdGVzIChldmVuIHdoZW4gaW52aXNpYmxlIGJlY2F1c2UgaXQgbWF5IGNvbnRhaW4gei1pbmRleGVkIGRlc2NlbmRhbnRzKVxuICAgICAgICAgKiAtIHRoZXJlIGFyZSAoaW5oZXJpdGVkKSB1cGRhdGVzIGFuZCB0aGlzIGJyYW5jaCBpcyB2aXNpYmxlXG4gICAgICAgICAqIC0gdGhpcyBicmFuY2ggYmVjb21lcyBpbnZpc2libGUgKGRlc2NzIG1heSBiZSB6LWluZGV4ZWQgc28gd2UgbXVzdCB1cGRhdGUgYWxsIGFscGhhIHZhbHVlcylcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLl9oYXNVcGRhdGVzIHx8ICh0aGlzLl9yZWNhbGMgJiYgdmlzaWJsZSkgfHwgKHcuYWxwaGEgJiYgIXZpc2libGUpKSB7XG4gICAgICAgICAgICBsZXQgcmVjYWxjID0gdGhpcy5fcmVjYWxjO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgd29ybGQgY29vcmRzL2FscGhhLlxuICAgICAgICAgICAgaWYgKHJlY2FsYyAmIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXcuYWxwaGEgJiYgdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCZWNvbWVzIHZpc2libGUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc1JlbmRlclVwZGF0ZXMgPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3LmFscGhhID0gcHcuYWxwaGEgKiB0aGlzLl9sb2NhbEFscGhhO1xuXG4gICAgICAgICAgICAgICAgaWYgKHcuYWxwaGEgPCAxZS0xNCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaW55IHJvdW5kaW5nIGVycm9ycyBtYXkgY2F1c2UgZmFpbGluZyB2aXNpYmlsaXR5IHRlc3RzLlxuICAgICAgICAgICAgICAgICAgICB3LmFscGhhID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZWNhbGMgJiA2KSB7XG4gICAgICAgICAgICAgICAgdy5weCA9IHB3LnB4ICsgdGhpcy5fbG9jYWxQeCAqIHB3LnRhO1xuICAgICAgICAgICAgICAgIHcucHkgPSBwdy5weSArIHRoaXMuX2xvY2FsUHkgKiBwdy50ZDtcbiAgICAgICAgICAgICAgICBpZiAocHcudGIgIT09IDApIHcucHggKz0gdGhpcy5fbG9jYWxQeSAqIHB3LnRiO1xuICAgICAgICAgICAgICAgIGlmIChwdy50YyAhPT0gMCkgdy5weSArPSB0aGlzLl9sb2NhbFB4ICogcHcudGM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZWNhbGMgJiA0KSB7XG4gICAgICAgICAgICAgICAgdy50YSA9IHRoaXMuX2xvY2FsVGEgKiBwdy50YTtcbiAgICAgICAgICAgICAgICB3LnRiID0gdGhpcy5fbG9jYWxUZCAqIHB3LnRiO1xuICAgICAgICAgICAgICAgIHcudGMgPSB0aGlzLl9sb2NhbFRhICogcHcudGM7XG4gICAgICAgICAgICAgICAgdy50ZCA9IHRoaXMuX2xvY2FsVGQgKiBwdy50ZDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0NvbXBsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdy50YSArPSB0aGlzLl9sb2NhbFRjICogcHcudGI7XG4gICAgICAgICAgICAgICAgICAgIHcudGIgKz0gdGhpcy5fbG9jYWxUYiAqIHB3LnRhO1xuICAgICAgICAgICAgICAgICAgICB3LnRjICs9IHRoaXMuX2xvY2FsVGMgKiBwdy50ZDtcbiAgICAgICAgICAgICAgICAgICAgdy50ZCArPSB0aGlzLl9sb2NhbFRiICogcHcudGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgcmVuZGVyIGNvb3Jkcy9hbHBoYS5cbiAgICAgICAgICAgIGNvbnN0IHByID0gdGhpcy5fcGFyZW50Ll9yZW5kZXJDb250ZXh0O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5faGFzUmVuZGVyQ29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdCA9IHRoaXMuX3JlbmRlckNvbnRleHQgPT09IHRoaXMuX3dvcmxkQ29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCByZW5kZXIgY29udGV4dCBidWlsZDogbWFrZSBzdXJlIHRoYXQgaXQgaXMgZnVsbHkgaW5pdGlhbGl6ZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHdlIGdldCBpbnRvIGJvdW5kcyBsYXRlciwgdGhlIHJlbmRlciBjb250ZXh0IHdvdWxkIG5vdCBiZSBpbml0aWFsaXplZCBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSBuZXcgRWxlbWVudENvcmVDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuX3JlbmRlckNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd29ybGQgY29vcmRzL2FscGhhLlxuICAgICAgICAgICAgICAgIGlmIChpbml0IHx8IChyZWNhbGMgJiAxKSkge1xuICAgICAgICAgICAgICAgICAgICByLmFscGhhID0gcHIuYWxwaGEgKiB0aGlzLl9sb2NhbEFscGhhO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmFscGhhIDwgMWUtMTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuYWxwaGEgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluaXQgfHwgKHJlY2FsYyAmIDYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHIucHggPSBwci5weCArIHRoaXMuX2xvY2FsUHggKiBwci50YTtcbiAgICAgICAgICAgICAgICAgICAgci5weSA9IHByLnB5ICsgdGhpcy5fbG9jYWxQeSAqIHByLnRkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHIudGIgIT09IDApIHIucHggKz0gdGhpcy5fbG9jYWxQeSAqIHByLnRiO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHIudGMgIT09IDApIHIucHkgKz0gdGhpcy5fbG9jYWxQeCAqIHByLnRjO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNldCB0aGUgcmVjYWxjIHRvZ2dsZSwgYmVjYXVzZSB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGF0IHRoZSBzY2lzc29yIGlzIHVwZGF0ZWQuXG4gICAgICAgICAgICAgICAgICAgIHJlY2FsYyB8PSAyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbml0IHx8IChyZWNhbGMgJiA0KSkge1xuICAgICAgICAgICAgICAgICAgICByLnRhID0gdGhpcy5fbG9jYWxUYSAqIHByLnRhO1xuICAgICAgICAgICAgICAgICAgICByLnRiID0gdGhpcy5fbG9jYWxUZCAqIHByLnRiO1xuICAgICAgICAgICAgICAgICAgICByLnRjID0gdGhpcy5fbG9jYWxUYSAqIHByLnRjO1xuICAgICAgICAgICAgICAgICAgICByLnRkID0gdGhpcy5fbG9jYWxUZCAqIHByLnRkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0NvbXBsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIudGEgKz0gdGhpcy5fbG9jYWxUYyAqIHByLnRiO1xuICAgICAgICAgICAgICAgICAgICAgICAgci50YiArPSB0aGlzLl9sb2NhbFRiICogcHIudGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnRjICs9IHRoaXMuX2xvY2FsVGMgKiBwci50ZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIudGQgKz0gdGhpcy5fbG9jYWxUYiAqIHByLnRjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0ID0gdGhpcy5fd29ybGRDb250ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jdHgudXBkYXRlVHJlZU9yZGVyID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnVwZGF0ZVRyZWVPcmRlciA9IHRoaXMuX3VwZGF0ZVRyZWVPcmRlciArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRyZWVPcmRlciA9IHRoaXMuY3R4LnVwZGF0ZVRyZWVPcmRlcisrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB3ZSBtdXN0IHVzZSBhICdyZW5kZXJUZXh0dXJlJy5cbiAgICAgICAgICAgIGNvbnN0IHVzZVJlbmRlclRvVGV4dHVyZSA9IHRoaXMuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQgJiYgdGhpcy5fdGV4dHVyaXplci5tdXN0UmVuZGVyVG9UZXh0dXJlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXNlUmVuZGVyVG9UZXh0dXJlICE9PSB1c2VSZW5kZXJUb1RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDb29yZHMgbXVzdCBiZSBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlY2FsYyB8PSAyICsgNDtcblxuICAgICAgICAgICAgICAgIC8vIFNjaXNzb3IgbWF5IGNoYW5nZTogZm9yY2UgdXBkYXRlLlxuICAgICAgICAgICAgICAgIHJlY2FsYyB8PSAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl91c2VSZW5kZXJUb1RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbXVzdCByZWxlYXNlIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyLnJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91c2VSZW5kZXJUb1RleHR1cmUgPSB1c2VSZW5kZXJUb1RleHR1cmU7XG5cbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9yZW5kZXJDb250ZXh0O1xuXG4gICAgICAgICAgICBjb25zdCBiYm94VyA9IHRoaXMuX2RpbXNVbmtub3duID8gMjA0OCA6IHRoaXMuX3c7XG4gICAgICAgICAgICBjb25zdCBiYm94SCA9IHRoaXMuX2RpbXNVbmtub3duID8gMjA0OCA6IHRoaXMuX2g7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBhIGJib3ggZm9yIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICAgIGxldCBzeCwgc3ksIGV4LCBleTtcbiAgICAgICAgICAgIGNvbnN0IHJDb21wbGV4ID0gKHIudGIgIT09IDApIHx8IChyLnRjICE9PSAwKSB8fCAoci50YSA8IDApIHx8IChyLnRkIDwgMCk7XG4gICAgICAgICAgICBpZiAockNvbXBsZXgpIHtcbiAgICAgICAgICAgICAgICBzeCA9IE1hdGgubWluKDAsIGJib3hXICogci50YSwgYmJveFcgKiByLnRhICsgYmJveEggKiByLnRiLCBiYm94SCAqIHIudGIpICsgci5weDtcbiAgICAgICAgICAgICAgICBleCA9IE1hdGgubWF4KDAsIGJib3hXICogci50YSwgYmJveFcgKiByLnRhICsgYmJveEggKiByLnRiLCBiYm94SCAqIHIudGIpICsgci5weDtcbiAgICAgICAgICAgICAgICBzeSA9IE1hdGgubWluKDAsIGJib3hXICogci50YywgYmJveFcgKiByLnRjICsgYmJveEggKiByLnRkLCBiYm94SCAqIHIudGQpICsgci5weTtcbiAgICAgICAgICAgICAgICBleSA9IE1hdGgubWF4KDAsIGJib3hXICogci50YywgYmJveFcgKiByLnRjICsgYmJveEggKiByLnRkLCBiYm94SCAqIHIudGQpICsgci5weTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ggPSByLnB4O1xuICAgICAgICAgICAgICAgIGV4ID0gci5weCArIHIudGEgKiBiYm94VztcbiAgICAgICAgICAgICAgICBzeSA9IHIucHk7XG4gICAgICAgICAgICAgICAgZXkgPSByLnB5ICsgci50ZCAqIGJib3hIO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZGltc1Vua25vd24gJiYgKHJDb21wbGV4IHx8IHRoaXMuX2xvY2FsVGEgPCAxIHx8IHRoaXMuX2xvY2FsVGIgPCAxKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBub24taWRlbnRpdHkgbWF0cml4LCB3ZSBtdXN0IGV4dGVuZCB0aGUgYmJveCBzbyB0aGF0IHdpdGhpbkJvdW5kcyBhbmRcbiAgICAgICAgICAgICAgICAvLyAgc2Npc3NvcnMgd2lsbCBpbmNsdWRlIHRoZSBjb21wbGV0ZSByYW5nZSBvZiAocG9zaXRpdmUpIGRpbWVuc2lvbnMgdXAgdG8gLGxoLlxuICAgICAgICAgICAgICAgIGNvbnN0IG54ID0gdGhpcy5feCAqIHByLnRhICsgdGhpcy5feSAqIHByLnRiICsgcHIucHg7XG4gICAgICAgICAgICAgICAgY29uc3QgbnkgPSB0aGlzLl94ICogcHIudGMgKyB0aGlzLl95ICogcHIudGQgKyBwci5weTtcbiAgICAgICAgICAgICAgICBpZiAobnggPCBzeCkgc3ggPSBueDtcbiAgICAgICAgICAgICAgICBpZiAobnkgPCBzeSkgc3kgPSBueTtcbiAgICAgICAgICAgICAgICBpZiAobnggPiBleCkgZXggPSBueDtcbiAgICAgICAgICAgICAgICBpZiAobnkgPiBleSkgZXkgPSBueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlY2FsYyAmIDYgfHwgIXRoaXMuX3NjaXNzb3IgLyogaW5pdGlhbCAqLykge1xuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHdlIG11c3QgJ2NsaXAnLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jbGlwcGluZyAmJiByLmlzU3F1YXJlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhcmVudCByZW5kZXJzIHRvIGEgdGV4dHVyZSwgaXQncyBzY2lzc29yIHNob3VsZCBiZSBpZ25vcmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5fcGFyZW50Ll91c2VSZW5kZXJUb1RleHR1cmUgPyB0aGlzLl9wYXJlbnQuX3ZpZXdwb3J0IDogdGhpcy5fcGFyZW50Ll9zY2lzc29yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVyZ2Ugc2Npc3NvciBhcmVhcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGx4ID0gTWF0aC5tYXgoYXJlYVswXSwgc3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbHkgPSBNYXRoLm1heChhcmVhWzFdLCBzeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2lzc29yID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGFyZWFbMl0gKyBhcmVhWzBdLCBleCkgLSBseCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihhcmVhWzNdICsgYXJlYVsxXSwgZXkpIC0gbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2lzc29yID0gW3N4LCBzeSwgZXggLSBzeCwgZXkgLSBzeV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBjbGlwcGluZzogcmV1c2UgcGFyZW50IHNjaXNzb3IuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjaXNzb3IgPSB0aGlzLl9wYXJlbnQuX3VzZVJlbmRlclRvVGV4dHVyZSA/IHRoaXMuX3BhcmVudC5fdmlld3BvcnQgOiB0aGlzLl9wYXJlbnQuX3NjaXNzb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG91dE9mQm91bmRzIG1hcmdpbi5cbiAgICAgICAgICAgIGlmICh0aGlzLl9ib3VuZHNNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNCb3VuZHNNYXJnaW4gPSB0aGlzLl9ib3VuZHNNYXJnaW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY0JvdW5kc01hcmdpbiA9IHRoaXMuX3BhcmVudC5fcmVjQm91bmRzTWFyZ2luO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fb25BZnRlckNhbGNzKSB7XG4gICAgICAgICAgICAgICAgLy8gQWZ0ZXIgY2FsY3MgbWF5IGNoYW5nZSByZW5kZXIgY29vcmRzLCBzY2lzc29yIGFuZC9vciByZWNCb3VuZHNNYXJnaW4uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQWZ0ZXJDYWxjcyh0aGlzLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIGJib3guXG4gICAgICAgICAgICAgICAgICAgIGlmIChyQ29tcGxleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ggPSBNYXRoLm1pbigwLCBiYm94VyAqIHIudGEsIGJib3hXICogci50YSArIGJib3hIICogci50YiwgYmJveEggKiByLnRiKSArIHIucHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBleCA9IE1hdGgubWF4KDAsIGJib3hXICogci50YSwgYmJveFcgKiByLnRhICsgYmJveEggKiByLnRiLCBiYm94SCAqIHIudGIpICsgci5weDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5ID0gTWF0aC5taW4oMCwgYmJveFcgKiByLnRjLCBiYm94VyAqIHIudGMgKyBiYm94SCAqIHIudGQsIGJib3hIICogci50ZCkgKyByLnB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXkgPSBNYXRoLm1heCgwLCBiYm94VyAqIHIudGMsIGJib3hXICogci50YyArIGJib3hIICogci50ZCwgYmJveEggKiByLnRkKSArIHIucHk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeCA9IHIucHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBleCA9IHIucHggKyByLnRhICogYmJveFc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeSA9IHIucHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleSA9IHIucHkgKyByLnRkICogYmJveEg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGltc1Vua25vd24gJiYgKHJDb21wbGV4IHx8IHRoaXMuX2xvY2FsVGEgPCAxIHx8IHRoaXMuX2xvY2FsVGIgPCAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbnggPSB0aGlzLl94ICogcHIudGEgKyB0aGlzLl95ICogcHIudGIgKyBwci5weDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG55ID0gdGhpcy5feCAqIHByLnRjICsgdGhpcy5feSAqIHByLnRkICsgcHIucHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnggPCBzeCkgc3ggPSBueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChueSA8IHN5KSBzeSA9IG55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG54ID4gZXgpIGV4ID0gbng7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnkgPiBleSkgZXkgPSBueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5fb3V0T2ZCb3VuZHMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBJbmhlcml0IHBhcmVudCBvdXQgb2YgYm91bmRzbmVzcy5cbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IDI7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2l0aGluQm91bmRzTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpdGhpbkJvdW5kc01hcmdpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuX2Rpc2FibGVXaXRoaW5Cb3VuZHNNYXJnaW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZWNhbGMgJiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY2hlY2sgaWYgZWxlbWVudCBpcyBvdXQtb2YtYm91bmRzIChhbGwgc2V0dGluZ3MgdGhhdCBhZmZlY3QgdGhpcyBzaG91bGQgZW5hYmxlIHJlY2FsYyBiaXQgMiBvciA0KS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2l0aGluTWFyZ2luID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPZmZzY3JlZW5zIGFyZSBhbHdheXMgcmVuZGVyZWQgYXMgbG9uZyBhcyB0aGUgcGFyZW50IGlzIHdpdGhpbiBib3VuZHMuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCB8fCAhdGhpcy5fdGV4dHVyaXplciB8fCAhdGhpcy5fdGV4dHVyaXplci5yZW5kZXJPZmZzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zY2lzc29yICYmICh0aGlzLl9zY2lzc29yWzJdIDw9IDAgfHwgdGhpcy5fc2Npc3NvclszXSA8PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5IHNjaXNzb3IgYXJlYS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBiYm94IHRvIGNoZWNrIG91dC1vZi1ib3VuZG5lc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLl9zY2lzc29yWzBdID4gZXgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLl9zY2lzc29yWzFdID4gZXkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzeCA+ICh0aGlzLl9zY2lzc29yWzBdICsgdGhpcy5fc2Npc3NvclsyXSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzeSA+ICh0aGlzLl9zY2lzc29yWzFdICsgdGhpcy5fc2Npc3NvclszXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX291dE9mQm91bmRzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3V0T2ZCb3VuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NsaXBwaW5nIHx8IHRoaXMuX3VzZVJlbmRlclRvVGV4dHVyZSB8fCAodGhpcy5fY2xpcGJveCAmJiAoYmJveFcgJiYgYmJveEgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXRoaW5NYXJnaW4gPSAodGhpcy5fb3V0T2ZCb3VuZHMgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aXRoaW5NYXJnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS10ZXN0LCBub3cgd2l0aCBtYXJnaW5zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWNCb3VuZHNNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aGluTWFyZ2luID0gISgoZXggPCB0aGlzLl9zY2lzc29yWzBdIC0gdGhpcy5fcmVjQm91bmRzTWFyZ2luWzJdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV5IDwgdGhpcy5fc2Npc3NvclsxXSAtIHRoaXMuX3JlY0JvdW5kc01hcmdpblszXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzeCA+IHRoaXMuX3NjaXNzb3JbMF0gKyB0aGlzLl9zY2lzc29yWzJdICsgdGhpcy5fcmVjQm91bmRzTWFyZ2luWzBdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN5ID4gdGhpcy5fc2Npc3NvclsxXSArIHRoaXMuX3NjaXNzb3JbM10gKyB0aGlzLl9yZWNCb3VuZHNNYXJnaW5bMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoaW5NYXJnaW4gPSAhKChleCA8IHRoaXMuX3NjaXNzb3JbMF0gLSAxMDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXkgPCB0aGlzLl9zY2lzc29yWzFdIC0gMTAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN4ID4gdGhpcy5fc2Npc3NvclswXSArIHRoaXMuX3NjaXNzb3JbMl0gKyAxMDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3kgPiB0aGlzLl9zY2lzc29yWzFdICsgdGhpcy5fc2Npc3NvclszXSArIDEwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2l0aGluTWFyZ2luICYmIHRoaXMuX291dE9mQm91bmRzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoaWxkcmVuIG11c3QgYmUgdmlzaXRlZCBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gZWxlbWVudHMgdGhhdCBhcmUgd2l0aGluIG1hcmdpbiwgc28gbXVzdCBiZSB2aXNpYmxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpdGhpbkJvdW5kc01hcmdpbiAhPT0gd2l0aGluTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93aXRoaW5Cb3VuZHNNYXJnaW4gPSB3aXRoaW5NYXJnaW47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl93aXRoaW5Cb3VuZHNNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSB1cGRhdGUgdGhpbmdzICh0eExvYWRlZCBldmVudHMpIGluIHRoZSBlbGVtZW50IGl0c2VsZiwgYnV0IGFsc28gaW4gZGVzY2VuZGFudHMgYW5kIGFuY2VzdG9ycy5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZXMgaW4gYW5jZXN0b3JzIHNob3VsZCBiZSBleGVjdXRlZCBkdXJpbmcgdGhlIG5leHQgY2FsbCBvZiB0aGUgc3RhZ2UgdXBkYXRlLiBCdXQgd2UgbXVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRha2UgY2FyZSB0aGF0IHRoZSBfcmVjYWxjIGFuZCBfaGFzVXBkYXRlcyBmbGFncyBhcmUgcHJvcGVybHkgcmVnaXN0ZXJlZC4gVGhhdCdzIHdoeSB3ZSBjbGVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvdGggYmVmb3JlIGVudGVyaW5nIHRoZSBjaGlsZHJlbiwgYW5kIHVzZSBfcFJlY2FsYyB0byB0cmFuc2ZlciBpbmhlcml0ZWQgdXBkYXRlcyBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gX3JlY2FsYyBkaXJlY3RseS5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZXMgaW4gZGVzY2VuZGFudHMgYXJlIGF1dG9tYXRpY2FsbHkgZXhlY3V0ZWQgd2l0aGluIHRoZSBjdXJyZW50IHVwZGF0ZSBsb29wLCB0aG91Z2ggd2UgbXVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRha2UgY2FyZSB0byBub3QgdXBkYXRlIHRoZSBoYXNVcGRhdGVzIGZsYWcgdW5uZWNlc3NhcmlseSBpbiBhbmNlc3RvcnMuIFdlIGFjaGlldmUgdGhpcyBieSBtYWtpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdXJlIHRoYXQgdGhlIGhhc1VwZGF0ZXMgZmxhZyBvZiB0aGlzIGVsZW1lbnQgaXMgdHVybmVkIG9uLCB3aGljaCBibG9ja3MgaXQgZm9yIGFuY2VzdG9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2FsYyA9IHRoaXMuX3JlY2FsYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWNhbGMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5fZW5hYmxlV2l0aGluQm91bmRzTWFyZ2luKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVjYWxjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZWxlbWVudCBuZWVkcyB0byBiZSByZS11cGRhdGVkIG5vdywgYmVjYXVzZSB3ZSB3YW50IHRoZSBkaW1lbnNpb25zIChhbmQgb3RoZXIgY2hhbmdlcykgdG8gYmUgdXBkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjYWxjID0gcmVjYWxjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuX2Rpc2FibGVXaXRoaW5Cb3VuZHNNYXJnaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZVJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIFNldCB2aWV3cG9ydCBuZWNlc3NhcnkgZm9yIGNoaWxkcmVuIHNjaXNzb3IgY2FsY3VsYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0WzJdID0gYmJveFc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0WzNdID0gYmJveEg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlld3BvcnQgPSBbMCwgMCwgYmJveFcsIGJib3hIXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgYml0cyB0aGF0IHNob3VsZCBub3QgYmUgY29waWVkIHRvIHRoZSBjaGlsZHJlbiAoY3VycmVudGx5IGFsbCBhcmUpLlxuICAgICAgICAgICAgdGhpcy5fcFJlY2FsYyA9ICh0aGlzLl9yZWNhbGMgJiAxMzUpO1xuXG4gICAgICAgICAgICAvLyBDbGVhciBmbGFncyBzbyB0aGF0IGZ1dHVyZSB1cGRhdGVzIGFyZSBwcm9wZXJseSBkZXRlY3RlZC5cbiAgICAgICAgICAgIHRoaXMuX3JlY2FsYyA9IDA7XG4gICAgICAgICAgICB0aGlzLl9oYXNVcGRhdGVzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vdXRPZkJvdW5kcyA8IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXNlUmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl93b3JsZENvbnRleHQuaXNJZGVudGl0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgd29ybGQgY29udGV4dCBpcyBhbHJlYWR5IGlkZW50aXR5OiB1c2UgdGhlIHdvcmxkIGNvbnRleHQgYXMgcmVuZGVyIGNvbnRleHQgdG8gcHJldmVudHMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmNlc3RvcnMgZnJvbSBoYXZpbmcgdG8gdXBkYXRlIHRoZSByZW5kZXIgY29udGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSB0aGlzLl93b3JsZENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcmlseSByZXBsYWNlIHRoZSByZW5kZXIgY29vcmQgYXR0cmlicyBieSB0aGUgaWRlbnRpdHkgbWF0cml4LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgdGhlIGNoaWxkcmVuIHRvIGNhbGN1bGF0ZSB0aGUgcmVuZGVyIGNvbnRleHQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0ID0gRWxlbWVudENvcmVDb250ZXh0LklERU5USVRZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91c2VSZW5kZXJUb1RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dCA9IHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbltpXS5faGFzVXBkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgbG9zZSB0aGUgJ2luaGVyaXRlZCcgdXBkYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS5fcmVjYWxjIHw9IHRoaXMuX3BSZWNhbGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0udXBkYXRlT3V0T2ZCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX29uQWZ0ZXJVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkFmdGVyVXBkYXRlKHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdHgudXBkYXRlVHJlZU9yZGVyID09PSAtMSB8fCB0aGlzLl91cGRhdGVUcmVlT3JkZXIgPj0gdGhpcy5jdHgudXBkYXRlVHJlZU9yZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbmV3IHRyZWUgb3JkZXIgZG9lcyBub3QgaW50ZXJmZXJlIHdpdGggdGhlIGN1cnJlbnQgKGdhcHMgYWxsb3dlZCkgdGhlcmUncyBubyBuZWVkIHRvIHRyYXZlcnNlIHRoZSBicmFuY2guXG4gICAgICAgICAgICAgICAgdGhpcy5jdHgudXBkYXRlVHJlZU9yZGVyID0gLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHJlZU9yZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYXBwbHlSZWxhdGl2ZURpbUZ1bmNzKCkge1xuICAgICAgICBpZiAodGhpcy5fb3B0RmxhZ3MgJiAxKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5fZnVuY1godGhpcy5fcGFyZW50LncpO1xuICAgICAgICAgICAgaWYgKHggIT09IHRoaXMuX3gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbFB4ICs9ICh4IC0gdGhpcy5feCk7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdEZsYWdzICYgMikge1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuX2Z1bmNZKHRoaXMuX3BhcmVudC5oKTtcbiAgICAgICAgICAgIGlmICh5ICE9PSB0aGlzLl95KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxQeSArPSAoeSAtIHRoaXMuX3kpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNoYW5nZWREaW1zID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9vcHRGbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLl9mdW5jVyh0aGlzLl9wYXJlbnQudyk7XG4gICAgICAgICAgICBpZiAodyAhPT0gdGhpcy5fdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3cgPSB3O1xuICAgICAgICAgICAgICAgIGNoYW5nZWREaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0RmxhZ3MgJiA4KSB7XG4gICAgICAgICAgICBjb25zdCBoID0gdGhpcy5fZnVuY0godGhpcy5fcGFyZW50LmgpO1xuICAgICAgICAgICAgaWYgKGggIT09IHRoaXMuX2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oID0gaDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRGltcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlZERpbXMpIHtcbiAgICAgICAgICAgIC8vIFJlY2FsYyBtb3VudCwgc2NhbGUgcG9zaXRpb24uXG4gICAgICAgICAgICB0aGlzLl9yZWNhbGNMb2NhbFRyYW5zbGF0ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQub25EaW1lbnNpb25zQ2hhbmdlZCh0aGlzLl93LCB0aGlzLl9oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZU91dE9mQm91bmRzKCkge1xuICAgICAgICAvLyBQcm9wYWdhdGUgb3V0T2ZCb3VuZHMgZmxhZyB0byBkZXNjZW5kYW50cyAobmVjZXNzYXJ5IGJlY2F1c2Ugb2Ygei1pbmRleGluZykuXG4gICAgICAgIC8vIEludmlzaWJsZSBlbGVtZW50cyBhcmUgbm90IGRyYXduIGFueXdheS4gV2hlbiBhbHBoYSBpcyB1cGRhdGVkLCBzbyB3aWxsIF9vdXRPZkJvdW5kcy5cbiAgICAgICAgaWYgKHRoaXMuX291dE9mQm91bmRzICE9PSAyICYmIHRoaXMuX3JlbmRlckNvbnRleHQuYWxwaGEgPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIEluaGVyaXQgcGFyZW50IG91dCBvZiBib3VuZHNuZXNzLlxuICAgICAgICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSAyO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fd2l0aGluQm91bmRzTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2l0aGluQm91bmRzTWFyZ2luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Ll9kaXNhYmxlV2l0aGluQm91bmRzTWFyZ2luKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLnVwZGF0ZU91dE9mQm91bmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlVHJlZU9yZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxBbHBoYSAmJiAodGhpcy5fb3V0T2ZCb3VuZHMgIT09IDIpKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUcmVlT3JkZXIgPSB0aGlzLmN0eC51cGRhdGVUcmVlT3JkZXIrKztcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0udXBkYXRlVHJlZU9yZGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3JlbmRlclNpbXBsZSgpIHtcbiAgICAgICAgdGhpcy5faGFzUmVuZGVyVXBkYXRlcyA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuX3pTb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRaSW5kZXhlZENoaWxkcmVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb3V0T2ZCb3VuZHMgPCAyICYmIHRoaXMuX3JlbmRlckNvbnRleHQuYWxwaGEpIHtcbiAgICAgICAgICAgIGxldCByZW5kZXJTdGF0ZSA9IHRoaXMucmVuZGVyU3RhdGU7XG5cbiAgICAgICAgICAgIGlmICgodGhpcy5fb3V0T2ZCb3VuZHMgPT09IDApICYmIHRoaXMuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRTaGFkZXIodGhpcy5hY3RpdmVTaGFkZXIsIHRoaXMuX3NoYWRlck93bmVyKTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRTY2lzc29yKHRoaXMuX3NjaXNzb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU3RhdGUuYWRkUXVhZCh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWxzbyBhZGQgY2hpbGRyZW4gdG8gdGhlIFZCTy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl96Q29udGV4dFVzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fekluZGV4ZWRDaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3pJbmRleGVkQ2hpbGRyZW5baV0ucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuW2ldLl96SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB6SW5kZXggaXMgc2V0LCB0aGlzIGl0ZW0gYWxyZWFkeSBiZWxvbmdzIHRvIGEgekluZGV4ZWRDaGlsZHJlbiBhcnJheSBpbiBvbmUgb2YgdGhlIGFuY2VzdG9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3JlbmRlckFkdmFuY2VkKCkge1xuICAgICAgICBjb25zdCBoYXNSZW5kZXJVcGRhdGVzID0gdGhpcy5faGFzUmVuZGVyVXBkYXRlcztcblxuICAgICAgICAvLyBXZSBtdXN0IGNsZWFyIHRoZSBoYXNSZW5kZXJVcGRhdGVzIGZsYWcgYmVmb3JlIHJlbmRlcmluZywgYmVjYXVzZSB1cGRhdGluZyByZXN1bHQgdGV4dHVyZXMgaW4gY29tYmluYXRpb25cbiAgICAgICAgLy8gd2l0aCB6LWluZGV4aW5nIG1heSB0cmlnZ2VyIHJlbmRlciB1cGRhdGVzIG9uIGEgcmVuZGVyIGJyYW5jaCB0aGF0IGlzICdoYWxmIGRvbmUnLlxuICAgICAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZSBmdWxsIHJlbmRlciBicmFuY2ggaXMgbWFya2VkIGZvciByZW5kZXIgdXBkYXRlcywgbm90IG9ubHkgaGFsZiAobGVhZGluZyB0byBmcmVlemUpLlxuICAgICAgICB0aGlzLl9oYXNSZW5kZXJVcGRhdGVzID0gMDtcblxuICAgICAgICBpZiAodGhpcy5felNvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFpJbmRleGVkQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vdXRPZkJvdW5kcyA8IDIgJiYgdGhpcy5fcmVuZGVyQ29udGV4dC5hbHBoYSkge1xuICAgICAgICAgICAgbGV0IHJlbmRlclN0YXRlID0gdGhpcy5yZW5kZXJTdGF0ZTtcblxuICAgICAgICAgICAgbGV0IG11c3RSZW5kZXJDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICBsZXQgcmVuZGVyVGV4dHVyZUluZm87XG4gICAgICAgICAgICBsZXQgcHJldlJlbmRlclRleHR1cmVJbmZvO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZVJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93ID09PSAwIHx8IHRoaXMuX2ggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoaXMgYnJhbmNoIGFuZCBkb24ndCBkcmF3IGFueXRoaW5nLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fdGV4dHVyaXplci5oYXNSZW5kZXJUZXh0dXJlKCkgfHwgKGhhc1JlbmRlclVwZGF0ZXMgPj0gMykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3dpdGNoIHRvIGRlZmF1bHQgc2hhZGVyIGZvciBidWlsZGluZyB1cCB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFNoYWRlcihyZW5kZXJTdGF0ZS5kZWZhdWx0U2hhZGVyLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBwcmV2UmVuZGVyVGV4dHVyZUluZm8gPSByZW5kZXJTdGF0ZS5yZW5kZXJUZXh0dXJlSW5mbztcblxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZVRleHR1cmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsICAvLyBTZXQgYnkgQ29yZVJlbmRlclN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdzogdGhpcy5fdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGg6IHRoaXMuX2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJpemVyLmhhc1Jlc3VsdFRleHR1cmUoKSB8fCAoIXJlbmRlclN0YXRlLmlzQ2FjaGluZ1RleHR1cml6ZXIgJiYgKGhhc1JlbmRlclVwZGF0ZXMgPCAzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogV2UgZG9uJ3QgYWx3YXlzIGNhY2hlIHJlbmRlciB0ZXh0dXJlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgcnVsZSBpcywgdGhhdCBjYWNoaW5nIGZvciBhIHNwZWNpZmljIHJlbmRlciB0ZXh0dXJlIGlzIG9ubHkgZW5hYmxlZCBpZjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIC0gVGhlcmUgaXMgYSByZXN1bHQgdGV4dHVyZSB0byBiZSB1cGRhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogLSBUaGVyZSB3ZXJlIG5vIHJlbmRlciB1cGRhdGVzIC13aXRoaW4gdGhlIGNvbnRlbnRzLSBzaW5jZSBsYXN0IGZyYW1lIChFbGVtZW50Q29yZS5oYXNSZW5kZXJVcGRhdGVzIDwgMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIC0gQU5EIHRoZXJlIGFyZSBubyBhbmNlc3RvcnMgdGhhdCBhcmUgYmVpbmcgY2FjaGVkIGR1cmluZyB0aGlzIGZyYW1lIChDb3JlUmVuZGVyU3RhdGUuaXNDYWNoaW5nVGV4dHVyaXplcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICAgSWYgYW4gYW5jZXN0b3IgaXMgY2FjaGVkIGFueXdheSwgaXQncyBwcm9iYWJseSBub3QgbmVjZXNzYXJ5IHRvIGtlZXAgZGVlcGVyIGNhY2hlcy4gSWYgdGhlIHRvcCBsZXZlbCBpcyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICogICBjaGFuZ2Ugd2hpbGUgYSBsb3dlciBvbmUgaXMgbm90LCB0aGF0IGxvd2VyIGxldmVsIHdpbGwgYmUgY2FjaGVkIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSW4gY2FzZSBvZiB0aGUgZmFzdCBibHVyIGVsZW1lbnQsIHRoaXMgcHJldmVudHMgaGF2aW5nIHRvIGNhY2hlIGFsbCBibHVyIGxldmVscyBhbmQgc3RhZ2VzLCBzYXZpbmcgYSBodWdlIGFtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICogb2YgR1BVIG1lbW9yeSFcbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBFc3BlY2lhbGx5IHdoZW4gdXNpbmcgbXVsdGlwbGUgc3RhY2tlZCBsYXllcnMgb2YgdGhlIHNhbWUgZGltZW5zaW9ucyB0aGF0IGFyZSBSVFQgdGhpcyB3aWxsIGhhdmUgYSB2ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBub3RpY2FibGUgZWZmZWN0IG9uIHBlcmZvcm1hbmNlIGFzIGxlc3MgcmVuZGVyIHRleHR1cmVzIG5lZWQgdG8gYmUgYWxsb2NhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlSW5mby5jYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5pc0NhY2hpbmdUZXh0dXJpemVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdGV4dHVyaXplci5oYXNSZXN1bHRUZXh0dXJlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBhbHJlYWR5IHJlbGVhc2UgdGhlIGN1cnJlbnQgdGV4dHVyZSB0byB0aGUgcG9vbCwgYXMgaXQgd2lsbCBiZSByZWJ1aWxkIGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgbXVsdGlwbGUgbGF5ZXJzIG9mICdmaWx0ZXJpbmcnLCB0aGlzIG1heSBzYXZlIHVzIGZyb20gaGF2aW5nIHRvIGNyZWF0ZSBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICByZW5kZXItdG8tdGV4dHVyZSBsYXllci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGljZSB0aGF0IHdlIGRvbid0IGRvIHRoaXMgd2hlbiB0aGVyZSBpcyBhIHJlc3VsdCB0ZXh0dXJlLCBhcyBhbnkgb3RoZXIgZWxlbWVudCBtYXkgcmVseSBvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHRoYXQgcmVzdWx0IHRleHR1cmUgYmVpbmcgZmlsbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplci5yZWxlYXNlUmVuZGVyVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0UmVuZGVyVGV4dHVyZUluZm8ocmVuZGVyVGV4dHVyZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRTY2lzc29yKG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgciA9IHRoaXMuX3JlbmRlckNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhbiBpZGVudGl0eSBjb250ZXh0IGZvciBkcmF3aW5nIHRoZSBkaXNwbGF5ZWQgdGV4dHVyZSB0byB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0ID0gRWxlbWVudENvcmVDb250ZXh0LklERU5USVRZO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZGlzcGxheWVkIHRleHR1cmUgc291cmNlIGluIGxvY2FsIGNvb3JkaW5hdGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZS5hZGRRdWFkKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0ID0gcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG11c3RSZW5kZXJDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLl9vdXRPZkJvdW5kcyA9PT0gMCkgJiYgdGhpcy5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRTaGFkZXIodGhpcy5hY3RpdmVTaGFkZXIsIHRoaXMuX3NoYWRlck93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0U2Npc3Nvcih0aGlzLl9zY2lzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZS5hZGRRdWFkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWxzbyBhZGQgY2hpbGRyZW4gdG8gdGhlIFZCTy5cbiAgICAgICAgICAgIGlmIChtdXN0UmVuZGVyQ2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fekNvbnRleHRVc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl96SW5kZXhlZENoaWxkcmVuW2ldLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbltpXS5fekluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgekluZGV4IGlzIHNldCwgdGhpcyBpdGVtIGFscmVhZHkgYmVsb25ncyB0byBhIHpJbmRleGVkQ2hpbGRyZW4gYXJyYXkgaW4gb25lIG9mIHRoZSBhbmNlc3RvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0ucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VSZW5kZXJUb1RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlUmVzdWx0VGV4dHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChtdXN0UmVuZGVyQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluaXNoZWQgcmVmcmVzaGluZyByZW5kZXJUZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5maW5pc2hlZFJlbmRlclRleHR1cmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3RoaW5nIHdhcyByZW5kZXJlZCwgd2Ugc3RvcmUgYSBmbGFnIGluIHRoZSB0ZXh0dXJpemVyIGFuZCBwcmV2ZW50IHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIC8vICByZW5kZXItdG8tdGV4dHVyZSBhbmQgZmlsdGVyaW5nLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyLmVtcHR5ID0gcmVuZGVyVGV4dHVyZUluZm8uZW1wdHk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlclRleHR1cmVJbmZvLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBpZ25vcmUgZW1wdHkgcmVuZGVyIHRleHR1cmVzIGFuZCBkbyBub3QgZHJhdyB0aGUgZmluYWwgcXVhZC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjbGVhbnMgdXAgbWVtb3J5IGFuZCBlbmZvcmNlcyB0aGF0IHRoZSByZXN1bHQgdGV4dHVyZSBpcyBhbHNvIGNsZWFyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyLnJlbGVhc2VSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVuZGVyVGV4dHVyZUluZm8ubmF0aXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmF0aXZlVGV4dHVyZSBpcyBzZXQsIHdlIGNhbiByZXVzZSB0aGF0IGRpcmVjdGx5IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgcmVuZGVyIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyLnJldXNlVGV4dHVyZUFzUmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlSW5mby5uYXRpdmVUZXh0dXJlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZUluZm8uaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJpemVyLnJlbmRlclRleHR1cmVSZXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWFkIG9wZXJhdGlvbnMgbXVzdCBiZSB3cml0dGVuIHRvIGEgcmVuZGVyIHRleHR1cmUgYWN0dWFsbHkgb3duZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplci5yZWxlYXNlUmVuZGVyVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCBjcmVhdGUgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZUluZm8ubmF0aXZlVGV4dHVyZSA9IHRoaXMuX3RleHR1cml6ZXIuZ2V0UmVuZGVyVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgcGFyZW50J3MgcmVuZGVyIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFJlbmRlclRleHR1cmVJbmZvKHByZXZSZW5kZXJUZXh0dXJlSW5mbyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0VGV4dHVyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJpemVyLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRUZXh0dXJlID0gdGhpcy5fdGV4dHVyaXplci5nZXRSZXN1bHRUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVSZXN1bHRUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0VGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvZ2dpbmcgdGhlIHVwZGF0ZSBmcmFtZSBjYW4gYmUgaGFuZHkgZm9yIHVzZXJsYW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFRleHR1cmUudXBkYXRlID0gcmVuZGVyU3RhdGUuc3RhZ2UuZnJhbWVDb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyaXplci51cGRhdGVSZXN1bHRUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RleHR1cml6ZXIucmVuZGVyT2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgcmVzdWx0IHRleHR1cmUgdG8gdGhlIGFjdHVhbCByZW5kZXIgdGFyZ2V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0U2hhZGVyKHRoaXMuYWN0aXZlU2hhZGVyLCB0aGlzLl9zaGFkZXJPd25lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRTY2lzc29yKHRoaXMuX3NjaXNzb3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyByZW5kZXIgdGV4dHVyZSBpbmZvIGlzIHNldCwgdGhlIGNhY2hlIGNhbiBiZSByZXVzZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9ICFyZW5kZXJUZXh0dXJlSW5mbyB8fCByZW5kZXJUZXh0dXJlSW5mby5jYWNoZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0VGV4dHVyaXplcih0aGlzLl90ZXh0dXJpemVyLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFzaFRleENvb3JkcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJpemVyLmNvbG9yaXplKSB0aGlzLl9zdGFzaENvbG9ycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZS5hZGRRdWFkKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJpemVyLmNvbG9yaXplKSB0aGlzLl91bnN0YXNoQ29sb3JzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bnN0YXNoVGV4Q29vcmRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRUZXh0dXJpemVyKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyVGV4dHVyZUluZm8gJiYgcmVuZGVyVGV4dHVyZUluZm8uY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBzaWJsaW5ncyB0byBjYWNoZS5cbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5pc0NhY2hpbmdUZXh0dXJpemVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgelNvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96U29ydDtcbiAgICB9XG5cbiAgICBzb3J0WkluZGV4ZWRDaGlsZHJlbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIHdhbnQgdG8gYXZvaWQgcmVzb3J0aW5nIGV2ZXJ5dGhpbmcuIEluc3RlYWQsIHdlIGRvIGEgc2luZ2xlIHBhc3Mgb2YgdGhlIGZ1bGwgYXJyYXk6XG4gICAgICAgICAqIC0gZmlsdGVyaW5nIG91dCBlbGVtZW50cyB3aXRoIGEgZGlmZmVyZW50IHpQYXJlbnQgdGhhbiB0aGlzICh3ZXJlIHJlbW92ZWQpXG4gICAgICAgICAqIC0gZmlsdGVyaW5nIG91dCwgYnV0IGFsc28gZ2F0aGVyaW5nIChpbiBhIHRlbXBvcmFyeSBhcnJheSkgdGhlIGVsZW1lbnRzIHRoYXQgaGF2ZSB6SW5kZXhSZXNvcnQgZmxhZ1xuICAgICAgICAgKiAtIHRoZW4sIGZpbmFsbHksIHdlIG1lcmdlLXNvcnQgYm90aCB0aGUgbmV3IGFycmF5IGFuZCB0aGUgJ29sZCcgb25lXG4gICAgICAgICAqIC0gZWxlbWVudCBtYXkgaGF2ZSBiZWVuIGFkZGVkICdkb3VibGUnLCBzbyB3aGVuIG1lcmdlLXNvcnRpbmcgYWxzbyBjaGVjayBmb3IgZG91Ymxlcy5cbiAgICAgICAgICogLSBpZiB0aGUgb2xkIG9uZSBpcyBsYXJnZXIgKGluIHNpemUpIHRoYW4gaXQgc2hvdWxkIGJlLCBzcGxpY2Ugb2ZmIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICAgKi9cblxuICAgICAgICBjb25zdCBuID0gdGhpcy5fekluZGV4ZWRDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBwdHIgPSAwO1xuICAgICAgICBjb25zdCBhID0gdGhpcy5fekluZGV4ZWRDaGlsZHJlbjtcblxuICAgICAgICAvLyBOb3RpY2UgdGhhdCBpdGVtcyBtYXkgb2NjdXIgbXVsdGlwbGUgdGltZXMgZHVlIHRvIHotaW5kZXggY2hhbmdpbmcuXG4gICAgICAgIGNvbnN0IGIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhW2ldLl96UGFyZW50ID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0uX3pJbmRleFJlc29ydCkge1xuICAgICAgICAgICAgICAgICAgICBiLnB1c2goYVtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB0ciAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYVtwdHJdID0gYVtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwdHIrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtID0gYi5sZW5ndGg7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgICAgIGJbal0uX3pJbmRleFJlc29ydCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiLnNvcnQoRWxlbWVudENvcmUuc29ydFpJbmRleGVkQ2hpbGRyZW4pO1xuICAgICAgICAgICAgY29uc3QgbiA9IHB0cjtcbiAgICAgICAgICAgIGlmICghbikge1xuICAgICAgICAgICAgICAgIHB0ciA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgYVtwdHIrK10gPSBiW2orK107XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoaiA8IG0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoID4gcHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNsaWNlIG9sZCAodW5uZWNlc3NhcnkpIHBhcnQgb2ZmIGFycmF5LlxuICAgICAgICAgICAgICAgICAgICBhLnNwbGljZShwdHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2Utc29ydCBhcnJheXM7XG4gICAgICAgICAgICAgICAgcHRyID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlUmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gKGFbaV0uX3pJbmRleCA9PT0gYltqXS5fekluZGV4ID8gYVtpXS5fdXBkYXRlVHJlZU9yZGVyIC0gYltqXS5fdXBkYXRlVHJlZU9yZGVyIDogYVtpXS5fekluZGV4IC0gYltqXS5fekluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGQgPSB2ID4gMCA/IGJbaisrXSA6IGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHRyID09PSAwIHx8IChtZXJnZVJlc3VsdFtwdHIgLSAxXSAhPT0gYWRkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VSZXN1bHRbcHRyKytdID0gYWRkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZCA9IGJbaisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHRyID09PSAwIHx8IChtZXJnZVJlc3VsdFtwdHIgLSAxXSAhPT0gYWRkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZVJlc3VsdFtwdHIrK10gPSBhZGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaiA8IG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaiA+PSBtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkID0gYVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdHIgPT09IDAgfHwgKG1lcmdlUmVzdWx0W3B0ciAtIDFdICE9PSBhZGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlUmVzdWx0W3B0cisrXSA9IGFkZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpIDwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fekluZGV4ZWRDaGlsZHJlbiA9IG1lcmdlUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGEubGVuZ3RoID4gcHRyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2xpY2Ugb2xkICh1bm5lY2Vzc2FyeSkgcGFydCBvZmYgYXJyYXkuXG4gICAgICAgICAgICAgICAgYS5zcGxpY2UocHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3pTb3J0ID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGdldCBsb2NhbFRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxUYTtcbiAgICB9O1xuXG4gICAgZ2V0IGxvY2FsVGIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFRiO1xuICAgIH07XG5cbiAgICBnZXQgbG9jYWxUYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsVGM7XG4gICAgfTtcblxuICAgIGdldCBsb2NhbFRkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxUZDtcbiAgICB9O1xuXG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgIH1cblxuICAgIGdldCByZW5kZXJVcGRhdGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzUmVuZGVyVXBkYXRlcztcbiAgICB9XG5cbiAgICBnZXQgdGV4dHVyaXplcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJpemVyKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyID0gbmV3IEVsZW1lbnRUZXh0dXJpemVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJpemVyO1xuICAgIH1cblxuICAgIGdldENvcm5lclBvaW50cygpIHtcbiAgICAgICAgbGV0IHcgPSB0aGlzLl93b3JsZENvbnRleHQ7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHcucHgsXG4gICAgICAgICAgICB3LnB5LFxuICAgICAgICAgICAgdy5weCArIHRoaXMuX3cgKiB3LnRhLFxuICAgICAgICAgICAgdy5weSArIHRoaXMuX3cgKiB3LnRjLFxuICAgICAgICAgICAgdy5weCArIHRoaXMuX3cgKiB3LnRhICsgdGhpcy5faCAqIHcudGIsXG4gICAgICAgICAgICB3LnB5ICsgdGhpcy5fdyAqIHcudGMgKyB0aGlzLl9oICogdy50ZCxcbiAgICAgICAgICAgIHcucHggKyB0aGlzLl9oICogdy50YixcbiAgICAgICAgICAgIHcucHkgKyB0aGlzLl9oICogdy50ZFxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICBnZXRSZW5kZXJUZXh0dXJlQ29vcmRzKHJlbFgsIHJlbFkpIHtcbiAgICAgICAgbGV0IHIgPSB0aGlzLl9yZW5kZXJDb250ZXh0O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgci5weCArIHIudGEgKiByZWxYICsgci50YiAqIHJlbFksXG4gICAgICAgICAgICByLnB5ICsgci50YyAqIHJlbFggKyByLnRkICogcmVsWVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGdldEFic29sdXRlQ29vcmRzKHJlbFgsIHJlbFkpIHtcbiAgICAgICAgbGV0IHcgPSB0aGlzLl9yZW5kZXJDb250ZXh0O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdy5weCArIHcudGEgKiByZWxYICsgdy50YiAqIHJlbFksXG4gICAgICAgICAgICB3LnB5ICsgdy50YyAqIHJlbFggKyB3LnRkICogcmVsWVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGNvbGxlY3RBdENvb3JkKHgsIHksIGNoaWxkcmVuKSB7XG4gICAgICAgIC8vIHJldHVybiB3aGVuIGJyYW5jaCBpcyBoaWRkZW5cbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlckNvbnRleHQuYWxwaGEgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluQm91bmQoeCwgeSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2lzc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5TY2lzc29yKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLmNvbGxlY3RBdENvb3JkKHgsIHksIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5zb3J0KEVsZW1lbnRDb3JlLnNvcnRaSW5kZXhlZENoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBpbkJvdW5kKHR4LCB0eSkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRDb3JuZXJQb2ludHMoKTtcbiAgICAgICAgcmV0dXJuIHR4ID4gY1swXSAmJiB0eCA8IGNbMl0gJiYgdHkgPiBjWzFdICYmIHR5IDwgY1s3XTtcbiAgICB9XG5cbiAgICBpblNjaXNzb3IoKSB7XG4gICAgICAgIGNvbnN0IHNjID0gdGhpcy5fc2Npc3NvcjtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q29ybmVyUG9pbnRzKCk7XG5cbiAgICAgICAgcmV0dXJuIGNbMl0gPj0gc2NbMF0gJiYgY1swXSA8PSBzY1swXSArIHNjWzJdICYmIGNbN10gPj0gc2NbMV0gJiYgY1sxXSA8PSBzY1sxXSArIHNjWzNdO1xuICAgIH1cblxuICAgIGdldCBsYXlvdXQoKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUxheW91dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0O1xuICAgIH1cblxuICAgIGdldCBmbGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0ID8gdGhpcy5fbGF5b3V0LmZsZXggOiBudWxsO1xuICAgIH1cblxuICAgIHNldCBmbGV4KHYpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQuZmxleCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGZsZXhJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0ID8gdGhpcy5fbGF5b3V0LmZsZXhJdGVtIDogbnVsbDtcbiAgICB9XG5cbiAgICBzZXQgZmxleEl0ZW0odikge1xuICAgICAgICB0aGlzLmxheW91dC5mbGV4SXRlbSA9IHY7XG4gICAgfVxuXG4gICAgaXNGbGV4SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fbGF5b3V0ICYmIHRoaXMuX2xheW91dC5pc0ZsZXhJdGVtRW5hYmxlZCgpO1xuICAgIH1cblxuICAgIGlzRmxleENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fbGF5b3V0ICYmIHRoaXMuX2xheW91dC5pc0ZsZXhFbmFibGVkKCk7XG4gICAgfVxuXG4gICAgZW5hYmxlRmxleExheW91dCgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlTGF5b3V0KCk7XG4gICAgfVxuXG4gICAgX2Vuc3VyZUxheW91dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dCA9IG5ldyBGbGV4VGFyZ2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzYWJsZUZsZXhMYXlvdXQoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJSZWNhbGNUcmFuc2xhdGUoKTtcbiAgICB9XG5cbiAgICBoYXNGbGV4TGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2xheW91dCAmJiB0aGlzLl9sYXlvdXQuaXNFbmFibGVkKCkpO1xuICAgIH1cblxuICAgIHNldExheW91dCh4LCB5LCB3LCBoKSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnModywgaCk7XG4gICAgfVxuXG4gICAgdHJpZ2dlckxheW91dCgpIHtcbiAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDI1Nik7XG4gICAgfVxuXG4gICAgX3RyaWdnZXJSZWNhbGNUcmFuc2xhdGUoKSB7XG4gICAgICAgIHRoaXMuX3NldFJlY2FsYygyKTtcbiAgICB9XG5cbn1cblxuY2xhc3MgRWxlbWVudENvcmVDb250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFscGhhID0gMTtcblxuICAgICAgICB0aGlzLnB4ID0gMDtcbiAgICAgICAgdGhpcy5weSA9IDA7XG5cbiAgICAgICAgdGhpcy50YSA9IDE7XG4gICAgICAgIHRoaXMudGIgPSAwO1xuICAgICAgICB0aGlzLnRjID0gMDtcbiAgICAgICAgdGhpcy50ZCA9IDE7XG4gICAgfVxuXG4gICAgaXNJZGVudGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGEgPT09IDEgJiZcbiAgICAgICAgICAgIHRoaXMucHggPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMucHkgPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMudGEgPT09IDEgJiZcbiAgICAgICAgICAgIHRoaXMudGIgPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMudGMgPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMudGQgPT09IDE7XG4gICAgfVxuXG4gICAgaXNTcXVhcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRiID09PSAwICYmIHRoaXMudGMgPT09IDA7XG4gICAgfVxuXG59XG5cbkVsZW1lbnRDb3JlQ29udGV4dC5JREVOVElUWSA9IG5ldyBFbGVtZW50Q29yZUNvbnRleHQoKTtcbkVsZW1lbnRDb3JlLnNvcnRaSW5kZXhlZENoaWxkcmVuID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuX3pJbmRleCA9PT0gYi5fekluZGV4ID8gYS5fdXBkYXRlVHJlZU9yZGVyIC0gYi5fdXBkYXRlVHJlZU9yZGVyIDogYS5fekluZGV4IC0gYi5fekluZGV4KTtcbn07XG5cbmltcG9ydCBFbGVtZW50VGV4dHVyaXplciBmcm9tIFwiLi9FbGVtZW50VGV4dHVyaXplci5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vVXRpbHMubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVGV4dHVyZVNvdXJjZSBmcm9tICcuLi9UZXh0dXJlU291cmNlLm1qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnRUZXh0dXJpemVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRDb3JlKSB7XG5cbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRDb3JlLmVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2NvcmUgPSBlbGVtZW50Q29yZTtcblxuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuX2NvcmUuY3R4O1xuXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXp5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvbG9yaXplID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZVJldXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlck9mZnNjcmVlbiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuZW1wdHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgZW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfVxuXG4gICAgc2V0IGVuYWJsZWQodikge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdjtcbiAgICAgICAgdGhpcy5fY29yZS51cGRhdGVSZW5kZXJUb1RleHR1cmVFbmFibGVkKCk7XG4gICAgfVxuXG4gICAgZ2V0IHJlbmRlck9mZnNjcmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlck9mZnNjcmVlbjtcbiAgICB9XG5cbiAgICBzZXQgcmVuZGVyT2Zmc2NyZWVuKHYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyT2Zmc2NyZWVuID0gdjtcbiAgICAgICAgdGhpcy5fY29yZS5zZXRIYXNSZW5kZXJVcGRhdGVzKDEpO1xuXG4gICAgICAgIC8vIFRoaXMgZW5mb3JjZXMgcmVjaGVja2luZyB0aGUgJ3dpdGhpbiBib3VuZHMnLlxuICAgICAgICB0aGlzLl9jb3JlLl9zZXRSZWNhbGMoNik7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JpemU7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yaXplKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yaXplICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xvcml6ZSA9IHY7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgYWZmZWN0cyB0aGUgZmluYWxseSBkcmF3biBxdWFkLlxuICAgICAgICAgICAgdGhpcy5fY29yZS5zZXRIYXNSZW5kZXJVcGRhdGVzKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFRleHR1cmVTb3VyY2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZSA9IG5ldyBUZXh0dXJlU291cmNlKHRoaXMuX2VsZW1lbnQuc3RhZ2UudGV4dHVyZU1hbmFnZXIpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXN1bHRUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2U7XG4gICAgfVxuXG4gICAgaGFzUmVzdWx0VGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZTtcbiAgICB9XG5cbiAgICByZXN1bHRUZXh0dXJlSW5Vc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlICYmIHRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2UuaGFzRW5hYmxlZEVsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlUmVzdWx0VGV4dHVyZSgpIHtcbiAgICAgICAgbGV0IHJlc3VsdFRleHR1cmUgPSB0aGlzLmdldFJlc3VsdFRleHR1cmUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlLm5hdGl2ZVRleHR1cmUgIT09IHJlc3VsdFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgdyA9IHJlc3VsdFRleHR1cmUgPyByZXN1bHRUZXh0dXJlLncgOiAwO1xuICAgICAgICAgICAgICAgIGxldCBoID0gcmVzdWx0VGV4dHVyZSA/IHJlc3VsdFRleHR1cmUuaCA6IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZS5yZXBsYWNlTmF0aXZlVGV4dHVyZShyZXN1bHRUZXh0dXJlLCB3LCBoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGV4dHVyZSB3aWxsIGJlIHVwZGF0ZWQ6IGFsbCBlbGVtZW50cyB1c2luZyB0aGUgc291cmNlIG5lZWQgdG8gYmUgdXBkYXRlZCBhcyB3ZWxsLlxuICAgICAgICAgICAgdGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZS5mb3JFYWNoRW5hYmxlZEVsZW1lbnQoZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY29yZS5zZXRIYXNSZW5kZXJVcGRhdGVzKDMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdXN0UmVuZGVyVG9UZXh0dXJlKCkge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBtdXN0IHJlYWxseSByZW5kZXIgYXMgdGV4dHVyZS5cbiAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQgJiYgIXRoaXMubGF6eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZW5hYmxlZCAmJiB0aGlzLmxhenkgJiYgdGhpcy5fY29yZS5faGFzUmVuZGVyVXBkYXRlcyA8IDMpIHtcbiAgICAgICAgICAgIC8vIFN0YXRpYy1vbmx5OiBpZiByZW5kZXJUb1RleHR1cmUgZGlkIG5vdCBuZWVkIHRvIHVwZGF0ZSBkdXJpbmcgbGFzdCBkcmF3biBmcmFtZSwgZ2VuZXJhdGUgaXQgYXMgYSBjYWNoZS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLnJlbGVhc2UoKTtcbiAgICB9XG5cbiAgICBnZXQgcmVuZGVyVGV4dHVyZVJldXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclRleHR1cmVSZXVzZWQ7XG4gICAgfVxuXG4gICAgcmVsZWFzZSgpIHtcbiAgICAgICAgdGhpcy5yZWxlYXNlUmVuZGVyVGV4dHVyZSgpO1xuICAgIH1cblxuICAgIHJlbGVhc2VSZW5kZXJUZXh0dXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJUZXh0dXJlUmV1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHgucmVsZWFzZVJlbmRlclRleHR1cmUodGhpcy5fcmVuZGVyVGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVSZXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzdWx0VGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV1c2VzIHRoZSBzcGVjaWZpZWQgdGV4dHVyZSBhcyB0aGUgcmVuZGVyIHRleHR1cmUgKGluIGFuY2VzdG9yKS5cbiAgICByZXVzZVRleHR1cmVBc1JlbmRlclRleHR1cmUobmF0aXZlVGV4dHVyZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGV4dHVyZSAhPT0gbmF0aXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlUmVuZGVyVGV4dHVyZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZSA9IG5hdGl2ZVRleHR1cmU7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlUmV1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhc1JlbmRlclRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3JlbmRlclRleHR1cmU7XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVyVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlID0gdGhpcy5jdHguYWxsb2NhdGVSZW5kZXJUZXh0dXJlKHRoaXMuX2NvcmUuX3csIHRoaXMuX2NvcmUuX2gpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZVJldXNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUZXh0dXJlO1xuICAgIH1cblxuICAgIGdldFJlc3VsdFRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUZXh0dXJlO1xuICAgIH1cblxufVxuXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLypcbiogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbipcbiogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiovXG5cbmltcG9ydCB7IExhdW5jaCB9IGZyb20gJ0BsaWdodG5pbmdqcy9zZGsnO1xuXG5pbXBvcnQgeyBBcHAgfSBmcm9tICcuLi9zcmMvQXBwJztcbmltcG9ydCB7IGFwcERhdGEsIGFwcFNldHRpbmdzLCBwbGF0Zm9ybVNldHRpbmdzIH0gZnJvbSAnLi4vc3JjL3NldHRpbmdzJztcblxuLy8gbGF1bmNoIHRoZSBhcHBsaWNhdGlvbiB3aXRoIGN1c3RvbSBzZXR0aW5nc1xuY29uc3QgYXBwID0gTGF1bmNoKEFwcCwgYXBwU2V0dGluZ3MsIHBsYXRmb3JtU2V0dGluZ3MsIGFwcERhdGEpO1xuXG4vLyBhcHBlbmQgdGhlIGNhbnZhcyB0byB0aGUgZG9tXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFwcC5zdGFnZS5nZXRDYW52YXMoKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=